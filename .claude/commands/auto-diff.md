---
description: 代码变更自动化分析流水线 - 获取变更 → 影响分析 → 补充注释 → 生成测试 → 验证
argument-hint: [可选：指定要分析的文件/目录，默认为所有变更]
---

# 🔄 代码变更自动化分析流水线

> **核心原则**: 代码改动后自动分析影响域、补充文档、生成测试、验证功能

## 分析目标

$ARGUMENTS (留空则分析所有变更)

---

## ⚡ 执行模式：全链路自动化

**一条命令完成完整的 Code-to-Test 流水线**：

1. ✅ **获取变更** - 执行 git diff，收集变更详情
2. ✅ **影响分析** - 分析改动被哪些组件引用，输出风险报告
3. ✅ **补充注释** - 调用 SubText 子代理，添加高价值注释
4. ✅ **生成测试** - 调用 Test 子代理，编写测试用例
5. ✅ **运行验证** - 执行测试，验证功能正常

---

## 🔴 执行前强制读取

### 1. 子代理定义
- `subagent/subtext.md` - SubText 子代理协议（注释规范）
- `subagent/Test.md` - Test 子代理协议（测试规范）

### 2. 项目规范
- `Rules/RulesReadMe.md` - 项目通用规则
- `Rules/CORE_PRINCIPLES.md` - 核心原则
- `CLAUDE.md` - 项目架构文档

### 3. 技能系统
- `skills/test-driven-development/SKILL.md` - TDD 实践
- `skills/documentation/SKILL.md` - 文档编写规范

---

## 📋 执行流程

### Phase 1: 获取变更 (git diff)

```bash
# 获取所有未暂存的变更
git diff

# 如果指定了文件，只分析该文件
git diff -- [文件路径]
```

**收集信息**:
- 变更类型（新增/修改/删除）
- 变更文件列表
- 变更行数统计
- 变更代码片段

---

### Phase 2: 影响域分析 (Impact Analysis)

**核心任务**: 智能体实地分析代码，确定变更会影响哪些上层组件。

#### 分析维度

```
影响分析 = {
  直接引用: 哪些文件直接 import/引用了变更的代码
  间接调用: 哪些函数调用了变更的函数
  数据依赖: 哪些数据结构受变更影响
  配置关联: 哪些配置项与变更相关
}
```

#### 分析方法

1. **符号分析** - 查找变更的类/函数/变量被哪些文件引用
2. **依赖分析** - 分析模块间的依赖关系
3. **调用链追踪** - 从变更点向上游追溯调用链
4. **测试覆盖分析** - 查找相关测试文件

#### 风险评估矩阵

| 变更影响范围 | 风险等级 | 建议操作 |
|-------------|---------|---------|
| 仅本文件 | 🟢 低 | 直接提交 |
| 同模块文件 | 🟡 中 | 检查模块内调用 |
| 跨模块引用 | 🟠 高 | 全面回归测试 |
| 核心基础设施 | 🔴 极高 | 需详细评审 |

---

### Phase 3: 输出影响报告

**输出格式**:

```
═══════════════════════════════════════════════════════════════
📊 代码变更影响分析报告
═══════════════════════════════════════════════════════════════

📁 变更文件: [文件列表]
📝 变更类型: [新增/修改/删除]
📏 变更行数: +N/-M 行

🔍 影响域分析
├── 直接影响 (需要同步修改):
│   ├── [文件A] - 原因: 直接引用了变更的XXX
│   └── [文件B] - 原因: 调用了变更的YYY函数
│
├── 间接影响 (可能受影响):
│   ├── [文件C] - 原因: 数据流可能经过变更点
│   └── [文件D] - 原因: 配置会间接影响变更逻辑
│
└── 测试影响 (需要更新测试):
    ├── [测试文件X] - 原因: 测试用例覆盖变更逻辑
    └── [测试文件Y] - 原因: Mock/Stub 需要更新

⚠️ 高风险提示:
- 改动 [具体变更] 可能导致 [具体影响]
- 建议: [修复/测试/评审建议]
```

---

### Phase 4: 自动补充注释 (SubText)

**调用 SubText 子代理**：

对于变更涉及的每个文件，执行：

1. **分析变更上下文**
   - 关联的 PRD/TDD/FD 编号
   - 业务规则变更点
   - 设计决策变化

2. **添加变更相关注释**
   - 文件头变更记录
   - 函数变更说明
   - 关键逻辑变更原因

**执行命令**:
```
/subtext [变更文件路径]
```

---

### Phase 5: 自动生成测试 (Test)

**调用 Test 子代理**：

对于变更涉及的每个文件，执行：

1. **分析测试需求**
   - 从变更提取验收标准
   - 识别边界条件变化
   - 确定测试覆盖范围

2. **生成测试用例**
   - 单元测试（核心逻辑）
   - 集成测试（交互路径）
   - 边界测试（异常情况）

**执行命令**:
```
/test [源文件路径]
```

---

### Phase 6: 运行测试验证

```bash
# 运行单元测试
./gradlew test --tests "[测试类名]"

# 或运行特定测试方法
./gradlew test --tests "[测试类名].[测试方法名]"
```

**验证标准**:
- ✅ 所有新增测试通过
- ✅ 相关回归测试通过
- ✅ 边界条件测试覆盖

---

## 📝 示例用法

```
/auto-diff                                    # 分析所有变更
/auto-diff data/src/main/kotlin/xxx.kt       # 只分析指定文件
/auto-diff --no-test                         # 只分析，不生成测试
/auto-diff --no-comment                      # 只分析，不补充注释
```

---

## ✅ 执行完成标准

```
═══════════════════════════════════════════════════════════════
🎉 代码变更自动化流水线执行完成
═══════════════════════════════════════════════════════════════

📊 变更统计:
   • 分析文件: N 个
   • 新增注释: M 处
   • 新增测试: K 个用例

📋 影响报告:
   • 高风险: N 项 (已标记)
   • 中风险: M 项 (需关注)
   • 低风险: K 项 (已忽略)

🧪 测试结果:
   • 通过: XX 个
   • 失败: YY 个
   • 跳过: ZZ 个

💡 建议:
   • [具体建议1]
   • [具体建议2]
```

---

## 🚫 绝对禁止

1. **禁止跳过影响分析** - 必须完整分析变更影响
2. **禁止脱离文档** - 注释和测试必须关联 PRD/TDD/FD
3. **禁止忽略风险** - 高风险变更必须明确标记
4. **禁止只分析不验证** - 必须运行测试确认功能正常
