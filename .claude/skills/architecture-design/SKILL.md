---
name: architecture-design
description: 架构设计技能 - 设计分层架构、模块划分、技术选型、数据流设计。在项目启动、功能模块设计或需要重构时使用。
---

# 架构设计

## 激活时机

当满足以下条件时自动激活此技能：
- 新项目启动需要设计架构
- 新功能模块需要设计
- 现有架构需要重构
- 技术选型需要决策
- 系统扩展性评估

## 设计流程

### 1. 需求分析
```
- 理解业务需求
- 识别功能边界
- 分析非功能需求（性能、安全、可用性）
```

### 2. 架构决策
```
- 选择架构模式（分层、微服务、事件驱动等）
- 技术栈选型
- 数据存储方案
```

### 3. 模块设计
```
- 模块划分
- 接口定义
- 依赖关系设计
```

### 4. 数据流设计
```
- 请求/响应流程
- 数据流转路径
- 错误处理策略
```

## 分层架构模式

### 标准四层架构

```
┌─────────────────────────────────────┐
│         表现层 (Presentation)        │
│  - 路由 / 视图 / API 网关            │
│  - 请求解析、响应格式化              │
│  - 输入验证                          │
└───────────────┬─────────────────────┘
                ↓
┌─────────────────────────────────────┐
│         业务层 (Business)            │
│  - 业务逻辑                          │
│  - 流程编排                          │
│  - 业务规则验证                      │
└───────────────┬─────────────────────┘
                ↓
┌─────────────────────────────────────┐
│         数据访问层 (Data Access)     │
│  - 数据库操作                        │
│  - 外部服务调用                      │
│  - 缓存管理                          │
└───────────────┬─────────────────────┘
                ↓
┌─────────────────────────────────────┐
│         基础设施层 (Infrastructure)  │
│  - 数据库、缓存、消息队列            │
│  - 第三方服务                        │
└─────────────────────────────────────┘
```

### 关注点分离原则

| 层级 | 职责 | 不应包含 |
|------|------|----------|
| **表现层** | 路由、视图、请求处理 | 业务逻辑、数据库操作 |
| **业务层** | 业务规则、流程编排 | HTTP、数据库细节 |
| **数据访问层** | 数据操作抽象 | 业务规则、HTTP响应 |
| **基础设施** | 底层服务实现 | 业务逻辑 |

## 架构模式选择

### 分层架构 (Layered)
```
适用场景：
✅ 传统 Web 应用
✅ 中小型项目
✅ 团队熟悉度高

优点：
- 结构清晰
- 易于理解和维护
- 便于测试

缺点：
- 层间传递可能有性能损耗
- 可能过度设计
```

### 微服务架构 (Microservices)
```
适用场景：
✅ 大型复杂系统
✅ 需要独立部署
✅ 多团队协作

优点：
- 独立部署扩展
- 技术栈灵活
- 故障隔离

缺点：
- 分布式复杂度高
- 运维成本高
- 数据一致性挑战
```

### 事件驱动架构 (Event-Driven)
```
适用场景：
✅ 异步处理场景
✅ 高并发系统
✅ 松耦合需求

优点：
- 高度解耦
- 易于扩展
- 异步处理

缺点：
- 调试复杂
- 最终一致性
- 消息顺序问题
```

## 设计原则

### SOLID 原则

| 原则 | 说明 | 示例 |
|------|------|------|
| **S** 单一职责 | 类只做一件事 | UserService 只处理用户逻辑 |
| **O** 开闭原则 | 对扩展开放，对修改关闭 | 通过接口扩展，不修改原有代码 |
| **L** 里氏替换 | 子类可替换父类 | 子类不改变父类行为 |
| **I** 接口隔离 | 接口小而专 | 拆分大接口为多个小接口 |
| **D** 依赖倒置 | 依赖抽象不依赖具体 | 依赖接口不依赖实现 |

### DRY 原则
```
Don't Repeat Yourself - 避免重复

❌ 重复代码：
function getUserEmail(id) { database.query("SELECT email FROM users...") }
function getUserName(id) { database.query("SELECT name FROM users...") }

✅ 提取复用：
function getUser(id, fields) { database.query(`SELECT ${fields} FROM users...`) }
```

### KISS 原则
```
Keep It Simple, Stupid - 保持简单

优先选择：
- 简单的数据结构 > 复杂的设计模式
- 直接的解决方案 > 过度抽象
- 显式代码 > 隐式魔法
```

## 目录结构设计

### 后端项目标准结构
```
project/
├── src/
│   ├── controllers/      # 请求处理
│   ├── services/         # 业务逻辑
│   ├── repositories/     # 数据访问
│   ├── routes/           # 路由定义
│   ├── middleware/       # 中间件
│   ├── types/            # 类型定义
│   ├── utils/            # 工具函数
│   ├── config/           # 配置
│   └── tests/            # 测试
├── docs/                 # 文档
└── scripts/              # 脚本
```

### 前端项目标准结构
```
project/
├── src/
│   ├── components/       # 通用组件
│   ├── pages/            # 页面组件
│   ├── hooks/            # 自定义 Hooks
│   ├── services/         # API 服务
│   ├── store/            # 状态管理
│   ├── types/            # 类型定义
│   ├── utils/            # 工具函数
│   ├── styles/           # 样式文件
│   └── tests/            # 测试
├── public/               # 静态资源
└── docs/                 # 文档
```

## 技术选型考虑因素

### 评估维度
```
1. 团队熟悉度 - 学习成本
2. 社区活跃度 - 长期维护
3. 生态成熟度 - 库和工具支持
4. 性能表现 - 是否满足需求
5. 开发效率 - 开发体验
6. 运维成本 - 部署、监控
```

### 决策记录模板
```markdown
## 技术选型：[技术名称]

### 背景
[需要解决什么问题]

### 选项
| 方案 | 优点 | 缺点 | 评分 |
|------|------|------|------|
| A    | ...  | ...  | 8/10 |
| B    | ...  | ...  | 6/10 |

### 决策
选择方案 A，理由：
1. 团队已有经验
2. 社区活跃
3. 性能满足需求

### 风险与缓解
- 风险：...
- 缓解措施：...
```

## 相关资源

- `resources/layered-architecture.md` - 分层架构详解
- `resources/design-patterns.md` - 设计模式参考
- `resources/data-flow.md` - 数据流设计

---

**技能状态**: 完成 ✅
**适用阶段**: 项目启动、功能设计、架构重构
