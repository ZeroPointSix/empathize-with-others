# 项目开发规范

本文档定义了 Empathy AI 项目的完整开发规范，所有开发者必须严格遵守。

---

## 一、代码风格与命名规范

### 1.1 命名约定
| 类型 | 规则 | 示例 |
|------|------|------|
| **包名** | 全小写，用点分隔 | `com.empathy.ai.presentation.viewmodel` |
| **类名** | 大驼峰 (PascalCase) | `AiAdvisorChatViewModel` |
| **函数名** | 小驼峰 (camelCase) | `sendMessage()`, `getUserProfile()` |
| **变量名** | 小驼峰 (camelCase) | `val chatMessages: List<...>` |
| **常量** | 全大写，下划线分隔 | `const val MAX_RETRY_COUNT = 3` |
| **枚举** | 大驼峰，属性全大写 | `enum class State { IDLE, LOADING, ERROR }` |

### 1.2 文件结构规范
```
// 导入分组顺序（必须严格遵守）
1. Kotlin 标准库
2. 第三方库（按字母顺序）
3. AndroidX 库
4. Jetpack Compose 库
5. 项目内部模块（按模块依赖顺序）
6. 当前包的类

// 示例
package com.empathy.ai.presentation.viewmodel

import kotlin.coroutines.CoroutineContext
import kotlinx.coroutines.flow.MutableStateFlow
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.empathy.ai.domain.usecase.SendMessageUseCase
import com.empathy.ai.presentation.ui.screen.chat.ChatScreenState
```

### 1.3 可组合函数命名
- **组件**：使用名词或名词短语 `UserAvatar()`, `ChatBubble()`
- **布局**：使用 `Root/Container/Scaffold` 后缀 `ChatScreenRoot()`, `SettingsContainer()`
- **事件处理**：使用 `on` 前缀 `onMessageSend()`, `onRetryClick()`

---

## 二、架构分层规范

### 2.1 Clean Architecture 分层
```
presentation/     # UI 层（Activity, ViewModel, Composable）
domain/           # 业务逻辑层（UseCase, Repository Interface, Entity）
data/             # 数据层（Repository Impl, Database, Network, DI）
app/              # Application 层（App 配置, Hilt Setup）
```

### 2.2 模块依赖规则
- **presentation** 依赖 **domain** 和 **data**
- **domain** 不依赖任何其他模块（核心业务逻辑）
- **data** 依赖 **domain**
- **禁止** presentation 直接依赖 data

### 2.3 Repository 接口位置
- **接口定义**：`domain/src/main/kotlin/.../repository/`
- **实现位置**：`data/src/main/kotlin/.../repository/`
- **使用方式**：通过 Hilt 注入，在 ViewModel/UseCase 中使用接口

---

## 三、状态管理规范

### 3.1 Compose 状态管理
```kotlin
// ✅ 正确：状态提升
@Composable
fun ChatScreen(
    uiState: ChatUiState,
    onMessageSend: (String) -> Unit
) { ... }

// ❌ 错误：状态未提升，导致测试困难
@Composable
fun ChatScreen() {
    val uiState = remember { mutableStateOf(...) }
    ...
}
```

### 3.2 状态持久化选择
| 场景 | 方案 | 说明 |
|------|------|------|
| 屏幕旋转 | `remember` | 仅内存存储 |
| 进程重建 | `rememberSaveable` | 状态序列化保存 |
| 跨会话持久化 | DataStore/SharedPreferences | 长期保存 |
| 业务数据 | Room 数据库 | 结构化数据存储 |

### 3.3 ViewModel 规范
```kotlin
// ✅ 正确：UiState 数据类 + StateFlow
data class ChatUiState(
    val messages: List<Message> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
)

class ChatViewModel @Inject constructor(
    private val sendMessageUseCase: SendMessageUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(ChatUiState())
    val uiState: StateFlow<ChatUiState> = _uiState.asStateFlow()

    fun sendMessage(content: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            // 业务逻辑
        }
    }
}
```

---

## 四、协程与异步处理规范

### 4.1 协程作用域使用
| 作用域 | 使用场景 | 禁止场景 |
|--------|----------|----------|
| `viewModelScope` | ViewModel 中的业务操作 | 长时间后台任务 |
| `rememberCoroutineScope()` | Composable 中的一次性操作 | 需要跟随 ViewModel 生命周期的操作 |
| `GlobalScope` | **禁止使用** | 所有场景 |
| `lifecycleScope` | Activity/Fragment 中的生命周期感知操作 | - |

### 4.2 异常处理规范
```kotlin
// ✅ 正确：使用 runCatching 或 try-catch
viewModelScope.launch {
    try {
        val result = sendMessageUseCase.execute(content)
        _uiState.update { it.copy(messages = result) }
    } catch (e: NetworkException) {
        _uiState.update { it.copy(error = "网络错误，请重试") }
    } catch (e: Exception) {
        _uiState.update { it.copy(error = "未知错误: ${e.message}") }
    }
}

// ❌ 错误：吞掉所有异常
viewModelScope.launch {
    sendMessageUseCase.execute(content)
}
```

### 4.3 取消机制
```kotlin
// ✅ 正确：使用 withTimeoutOrNull
viewModelScope.launch {
    val result = withTimeoutOrNull(5000L) {
        sendMessageUseCase.execute(content)
    } ?: throw TimeoutCancellationException("请求超时")
}

// ❌ 错误：硬编码超时
viewModelScope.launch {
    delay(5000) // 不推荐
}
```

---

## 五、数据库规范 (Room)

### 5.1 Migration 规范
```kotlin
// ✅ 正确：每次迁移必须增加版本号和测试
val MIGRATION_14_15 = object : Migration(14, 15) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL("""
            ALTER TABLE BrainTagEntity
            ADD COLUMN createdAt INTEGER NOT NULL DEFAULT 0
        """.trimIndent())
    }
}

// ❌ 错误：不测试迁移
val MIGRATION_14_15 = object : Migration(14, 15) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // 无操作或随意修改
    }
}
```

### 5.2 Entity 设计规则
- **主键**：必须有稳定的 ID（推荐 UUID 或自增 Long）
- **NotNull 约束**：与迁移策略一致，避免新增列无默认值
- **索引**：对频繁查询的列添加索引
- **关系**：使用 `@Embedded` 和 `@Relation` 避免复杂关联查询

---

## 六、UI 开发规范 (Jetpack Compose)

### 6.1 可组合函数参数
```kotlin
// ✅ 正确：使用 @Stable 类型，明确不可变
@Composable
fun UserAvatar(
    avatarUrl: String,
    userName: String,
    size: AvatarSize = AvatarSize.Medium,
    onClick: () -> Unit = {}
) { ... }

// ❌ 错误：使用任意类型，缺乏稳定性保证
@Composable
fun UserAvatar(
    avatarUrl: Any?,  // 类型不明确
    userName: String,
    modifier: Modifier = Modifier
) { ... }
```

### 6.2 性能优化规则
| 优化项 | 规范 | 原因 |
|--------|------|------|
| **Key** | LazyColumn/LazyRow 必须提供稳定的 key | 避免重组错乱 |
| **Stable 注解** | 对复杂参数类型添加 @Stable/@Immutable | 帮助 Compose 优化重组 |
| **内联函数** | 简单 lambda 参数使用内联 | 减少运行时开销 |
| **避免嵌套** | 避免深层嵌套的 Column/Row | 影响测量性能 |

### 6.3 Scaffold 使用规范
```kotlin
// ✅ 正确：使用 Scaffold 处理标准布局
@Composable
fun MainScreen(
    onNavigateToSettings: () -> Unit
) {
    Scaffold(
        topBar = {
            TopAppBar(title = { Text("主页") })
        },
        floatingActionButton = {
            FloatingActionButton(onClick = onNavigateToSettings) {
                Icon(Icons.Default.Settings, contentDescription = "设置")
            }
        }
    ) { paddingValues ->
        // 内容使用 paddingValues
        Column(modifier = Modifier.padding(paddingValues)) {
            // ...
        }
    }
}
```

---

## 七、Git 工作流规范

### 7.1 提交规范
| 类型 | 前缀 | 说明 |
|------|------|------|
| feat | 新功能 | `feat: 添加AI军师对话功能` |
| fix | 修复 Bug | `fix: 修复悬浮球双击显示问题` |
| docs | 文档更新 | `docs: 更新README` |
| refactor | 重构代码 | `refactor: 重构ChatViewModel状态管理` |
| test | 测试相关 | `test: 添加ChatViewModel单元测试` |
| chore | 构建/工具 | `chore: 更新Gradle版本` |

### 7.2 分支策略
- **main**: 生产环境代码（受保护）
- **develop**: 开发环境代码
- **feature/xxx**: 功能分支
- **bugfix/xxx**: Bug 修复分支
- **hotfix/xxx**: 紧急修复分支

### 7.3 Commit Message 格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

示例：
```
fix(AiAdvisorChatViewModel): 修复消息重复发送问题

在快速点击发送按钮时，由于协程未完成导致消息被发送两次。
通过添加发送状态锁来防止重复提交。

Closes #BUG-00044
```

---

## 八、测试要求规范

### 8.1 测试覆盖率目标
| 模块 | 最低覆盖率 | 建议覆盖率 |
|------|-----------|-----------|
| domain | 80% | 90% |
| data | 70% | 80% |
| presentation | 60% | 70% |

### 8.2 单元测试规范
```kotlin
// ✅ 正确：使用 given-when-then 结构
class SendMessageUseCaseTest {

    @Test
    fun `当发送消息成功时应该更新对话列表`() = runTest {
        // given
        val repository = FakeMessageRepository()
        val useCase = SendMessageUseCase(repository)

        // when
        useCase.execute("Hello")

        // then
        assertEquals(1, repository.getMessages().size)
    }
}
```

### 8.3 ViewModel 测试规范
```kotlin
// ✅ 正确：使用 runTest + Turbine
class ChatViewModelTest {

    @Test
    fun `发送消息后状态应该更新`() = runTest {
        // given
        val viewModel = ChatViewModel(sendMessageUseCase)

        // when
        viewModel.sendMessage("Hello")

        // then
        viewModel.uiState.test {
            val state = awaitItem()
            assertTrue(state.isLoading)
        }
    }
}
```

---

## 九、调试与日志规范

### 9.1 日志级别使用
| 级别 | 使用场景 | 示例 |
|------|----------|------|
| **ERROR** | 应用崩溃、关键功能失败 | `Logger.e("AI响应解析失败", e)` |
| **WARN** | 可恢复的错误、异常情况 | `Logger.w("网络请求超时，使用缓存")` |
| **INFO** | 重要业务状态变化 | `Logger.i("用户登录成功")` |
| **DEBUG** | 开发调试信息 | `Logger.d("消息发送: $content")` |
| **VERBOSE** | 详细调试信息 | `Logger.v("状态更新: $oldState -> $newState")` |

### 9.2 调试流程规范
1. **复现**：准确记录复现步骤和环境
2. **收集信息**：日志、堆栈、截图/视频
3. **形成假设**：基于证据推理可能原因
4. **验证修复**：确认修复有效且无副作用
5. **记录文档**：更新 BUG 文档和检查清单

### 9.3 禁止的调试方式
- ❌ 使用 `println` 替代 Logger
- ❌ 在生产代码中硬编码调试逻辑
- ❌ 忽略异常或吞掉堆栈信息

---

## 十、性能优化规范

### 10.1 优化优先级
```
P0 (立即处理): 应用崩溃、ANR、内存泄漏
P1 (本周处理): 明显卡顿、启动慢（>3s）
P2 (排期处理): 次要性能问题
P3 (有空处理): 代码层面的优化机会
```

### 10.2 性能测量工具
| 场景 | 工具 |
|------|------|
| **UI 性能** | Compose Compiler Metrics, Layout Inspector |
| **内存** | Android Profiler, LeakCanary |
| **网络** | Network Profiler |
| **启动** | ADB shell am start -W |

### 10.3 常见优化规则
| 场景 | 优化方案 |
|------|----------|
| **列表滚动卡顿** | 使用 LazyColumn/LazyRow，确保 Item 稳定 |
| **图片加载** | 使用 Coil/Glide，设置合适的 placeholder |
| **网络请求** | 批量请求、请求缓存、Gzip 压缩 |
| **数据库查询** | 添加索引、使用 Room @Transaction |

---

## 十一、代码审查检查清单

### 11.1 必查项
- [ ] 根本原因分析是否充分
- [ ] 测试覆盖是否完整
- [ ] 是否有副作用评估
- [ ] 修复范围是否合理
- [ ] 代码风格是否符合规范

### 11.2 危险信号
- ⚠️ 无测试或测试不充分
- ⚠️ 修复方案与问题不匹配
- ⚠️ 修改范围过大
- ⚠️ 可能遗漏相似问题

### 11.3 审查后必须
- [ ] 运行单元测试
- [ ] 运行集成测试
- [ ] 检查是否有 lint 警告
- [ ] 验证编译通过

---

## 十二、重构规范

### 12.1 重构流程
1. **确保测试覆盖**：重构前必须有测试
2. **小步前进**：每次只重构一个关注点
3. **频繁提交**：每个小步骤都提交
4. **验证测试**：每次修改后运行测试
5. **文档更新**：同步更新相关文档

### 12.2 禁止的重构
- ❌ 未经测试的大规模重构
- ❌ 重构时修改功能和修复 Bug 同时进行
- ❌ 跳过代码审查直接提交重构代码

---

## 十三、Bug 修复规范

### 13.1 Bug 分析要求
每个 BUG 文档必须包含：
- [ ] 问题描述（什么情况下发生）
- [ ] 根本原因分析（为什么发生）
- [ ] 解决方案（如何修复）
- [ ] 验证方法（如何确认修复）
- [ ] 预防措施（如何避免再次发生）
- [ ] 相关问题（是否有类似问题）

### 13.2 修复后检查
- [ ] 原问题是否解决
- [ ] 是否引入新问题
- [ ] 相关功能是否正常
- [ ] 性能是否有影响

---

## 十四、组件复用系统规范

基于对项目140+ UI组件、27个Domain工具类、5个Data工具类、26个ViewModel的深度分析，补充以下规范：

### 14.1 组件分层架构（原子-分子-有机体-模板）

项目组件按复杂度分为四级：

| 层级 | 组件示例 | 复用级别 | 规范要求 |
|------|----------|----------|----------|
| **原子组件** | `IosButton`, `IosTextField`, `AvatarView` | 最高 | 基础UI单元，无业务逻辑 |
| **分子组件** | `IosSearchBar`, `ModernPersonaTab`, `SmartFolderCard` | 高 | 组合原子组件，有简单交互 |
| **有机体组件** | `FactStreamCard`, `CategoryCard`, `EmotionTimelineView` | 中 | 复杂业务逻辑，独立功能单元 |
| **模板组件** | `AiAdvisorChatScreen`, `ContactDetailScreen` | 低 | 页面级组合，特定场景使用 |

### 14.2 现有可复用组件清单

#### 14.2.1 UI组件分类目录
```
presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/
├── animation/              # 3个动画组件
│   ├── AnimatedContent.kt
│   ├── LoadingAnimation.kt
│   └── TransitionAnimation.kt
├── dialog/                 # 8个对话框组件
│   ├── IosAlertDialog.kt
│   ├── IosActionSheet.kt
│   ├── LoadingDialog.kt
│   └── ... (共8个)
├── state/                  # 6个状态展示组件
│   ├── LoadingSkeleton.kt
│   ├── ErrorView.kt
│   ├── ErrorStateView.kt
│   ├── EmptyView.kt
│   ├── EmptyStateView.kt
│   └── FriendlyErrorCard.kt
├── input/                  # 3个输入组件
│   ├── IosTextField.kt
│   ├── SearchBar.kt
│   └── ModernSearchBar.kt
├── ios/                    # 16个iOS风格组件
│   ├── IosButton.kt
│   ├── IosSwitch.kt
│   ├── IosPicker.kt
│   └── ... (共16个)
├── contact/                # 联系人相关
│   └── ContactListItem.kt
├── message/                # 消息气泡
│   ├── MessageBubble.kt
│   └── AiMessageBlock.kt
├── tag/                    # 标签组件
│   ├── MacaronTagChip.kt
│   └── TagChip.kt
├── timeline/               # 8个时间线组件
│   ├── EmotionTimelineView.kt
│   ├── TimelineCard.kt
│   └── ... (共8个)
├── factstream/             # 8个事实流组件
│   ├── FactStreamCard.kt
│   ├── FactCard.kt
│   └── ... (共8个)
├── persona/                # 5个人格组件
│   ├── ModernPersonaTab.kt
│   ├── SmartFolderCard.kt
│   └── ... (共5个)
├── overview/               # 4个总览卡片
│   ├── DataStatisticsCard.kt
│   ├── OverviewCard.kt
│   └── ... (共4个)
└── vault/                  # 4个数据仓库组件
    ├── DataSourceGrid.kt
    ├── DataStatisticsCard.kt
    └── ... (共4个)
```

#### 14.2.2 Domain层工具类（27个）
```kotlin
domain/src/main/kotlin/com/empathy/ai/domain/util/
├── AI处理类
│   ├── AiSummaryProcessor.kt        # AI总结处理器
│   ├── AiSummaryResponseParser.kt   # AI响应解析器
│   ├── PromptBuilder.kt             # 提示词构建器
│   └── PromptTemplates.kt           # 提示词模板
├── 验证类
│   ├── ContentValidator.kt          # 内容验证器
│   ├── PromptValidator.kt           # 提示词验证器
│   └── UserProfileValidator.kt      # 用户画像验证器
├── 上下文构建类
│   ├── ContextBuilder.kt            # 上下文构建器
│   ├── ConversationContextBuilder.kt # 对话上下文构建器
│   └── UserProfileContextBuilder.kt  # 用户画像上下文构建器
├── 日期时间类
│   └── DateUtils.kt                 # 日期工具
└── 日志与性能类
    ├── Logger.kt                    # 日志接口
    ├── PerformanceMetrics.kt        # 性能指标
    └── MemoryConstants.kt           # 内存常量
```

#### 14.2.3 Data层工具类（5个）
```kotlin
data/src/main/kotlin/com/empathy/ai/data/util/
├── AiResponseCleaner.kt        # AI响应清洗
├── AndroidLogger.kt            # Android日志实现
├── ApiErrorHandler.kt          # API错误处理器
├── BlockUpdateManager.kt       # 块更新管理器
└── DebugLogger.kt              # 调试日志
```

### 14.3 组件复用检查清单

在创建新组件前，必须检查以下事项：

#### 14.3.1 是否存在可复用的原子组件？
```kotlin
// ✅ 正确：复用现有原子组件
@Composable
fun CustomButton(
    text: String,
    onClick: () -> Unit
) {
    IosButton(                          // 复用iOS风格按钮
        text = text,
        onClick = onClick
    )
}

// ❌ 错误：重复创建相似组件
@Composable
fun CustomButton(
    text: String,
    onClick: () -> Unit
) {
    Button(
        shape = RoundedCornerShape(12.dp),
        colors = ButtonDefaults.buttonColors(...),
        // ... 重复实现
    )
}
```

#### 14.3.2 是否可以组合现有分子组件？
```kotlin
// ✅ 正确：组合搜索组件
@Composable
fun ContactSearchBar(
    query: String,
    onQueryChange: (String) -> Unit,
    onClear: () -> Unit
) {
    ModernSearchBar(                    // 复用搜索栏
        query = query,
        onQueryChange = onQueryChange,
        onClear = onClear,
        placeholder = "搜索联系人"
    )
}
```

#### 14.3.3 是否可以继承或扩展有机体组件？
```kotlin
// ✅ 正确：扩展时间线组件
@Composable
fun EmotionTimelineView(
    emotions: List<Emotion>,
    modifier: Modifier = Modifier
) {
    TimelineCard(                       // 复用时间线卡片
        title = "情感历程",
        items = emotions.map { it to it.timestamp }
    ) {
        // 扩展特定内容
    }
}
```

### 14.4 组件创建规范

#### 14.4.1 组件命名规则
| 组件类型 | 命名规则 | 示例 |
|----------|----------|------|
| 原子组件 | `功能名 + 类型后缀` | `IosButton`, `AvatarView` |
| 分子组件 | `功能名 + 描述词` | `ModernSearchBar`, `SmartFolderCard` |
| 有机体组件 | `功能名 + 领域词` | `FactStreamCard`, `CategoryCard` |
| 屏幕组件 | `领域名 + Screen` | `AiAdvisorChatScreen`, `ContactDetailScreen` |

#### 14.4.2 组件参数规范
```kotlin
// ✅ 正确：清晰的参数定义
@Composable
fun IosSearchBar(
    query: String,
    onQueryChange: (String) -> Unit,
    onClear: () -> Unit,
    placeholder: String = "搜索",
    modifier: Modifier = Modifier
) { ... }

// ❌ 错误：参数不明确或过多
@Composable
fun SearchBar(
    query: Any?,                    // 类型不明确
    onChange: (Any?) -> Unit,       // 参数名不明确
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    visible: Boolean = true,
    // ... 更多参数
) { ... }
```

#### 14.4.3 组件文件位置规范
```
// 组件文件必须放在对应分类目录下

// 原子组件
component/ios/IosButton.kt          ✅ 正确
component/animation/Loading.kt      ✅ 正确

// 分子组件
component/persona/SmartFolderCard.kt ✅ 正确

// 有机体组件
component/factstream/FactCard.kt    ✅ 正确

// 禁止：随意放置
presentation/ui/SearchBar.kt        ❌ 错误
presentation/viewmodel/CustomButton.kt ❌ 错误
```

### 14.5 工具类复用规范

#### 14.5.1 Domain工具类使用规则
```kotlin
// ✅ 正确：使用Domain层工具类
class MyUseCase {
    fun execute(prompt: String): Result<Summary> {
        // 使用验证器
        val validationResult = PromptValidator.validate(prompt)
        if (!validationResult.isValid) {
            return Result.failure(validationResult.error!!)
        }
        
        // 使用构建器
        val builtPrompt = PromptBuilder.build(prompt)
        // ...
    }
}

// ❌ 错误：在UseCase中重复实现验证逻辑
class MyUseCase {
    fun execute(prompt: String): Result<Summary> {
        if (prompt.isBlank()) {          // 重复实现
            return Result.failure(IllegalArgumentException("Prompt cannot be blank"))
        }
        if (prompt.length < 10) {        // 重复实现
            return Result.failure(IllegalArgumentException("Prompt too short"))
        }
        // ...
    }
}
```

#### 14.5.2 Data工具类使用规则
```kotlin
// ✅ 正确：使用统一日志
class NetworkRepository {
    private val logger = AndroidLogger
    
    fun fetchData() {
        logger.d("Fetching data from API")
        // ...
        logger.e("Network error: ${e.message}", e)
    }
}

// ❌ 错误：直接使用println
class NetworkRepository {
    fun fetchData() {
        println("Fetching data from API")  // 禁止
        // ...
    }
}
```

### 14.6 ViewModel复用规范

#### 14.6.1 BaseViewModel使用规则
```kotlin
// ✅ 正确：继承BaseViewModel
class ContactListViewModel @Inject constructor(
    private val getContactsUseCase: GetContactsUseCase
) : BaseViewModel<ContactListUiState, ContactListEvent>(
    initialState = ContactListUiState()
) {
    
    fun loadContacts() {
        launch {
            // 使用基类的状态管理
            updateState { it.copy(isLoading = true) }
            // ...
        }
    }
}

// ❌ 错误：直接实现ViewModel
class ContactListViewModel @Inject constructor(
    private val getContactsUseCase: GetContactsUseCase
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ContactListUiState())
    val uiState: StateFlow<ContactListUiState> = _uiState.asStateFlow()
    
    // 缺少基类提供的通用功能
}
```

#### 14.6.2 ViewModel状态管理规范
```kotlin
// 状态分类
sealed class UiState {
    data class Idle(val message: String? = null) : UiState()
    data class Loading(val progress: Float? = null) : UiState()
    data class Success<T>(val data: T) : UiState()
    data class Error(val message: String, val cause: Throwable? = null) : UiState()
}

// 事件分类
sealed class UiEvent {
    data class ShowToast(val message: String) : UiEvent()
    data class Navigate(val route: String) : UiEvent()
    data object Dismiss : UiEvent()
}
```

### 14.7 组件依赖关系规范

#### 14.7.1 允许的依赖方向
```
原子组件 → 无依赖（独立）
分子组件 → 原子组件
有机体组件 → 原子组件 + 分子组件
屏幕组件 → 有机体组件 + 分子组件 + ViewModel
ViewModel → UseCase
UseCase → Repository接口 + Domain工具类
Repository实现 → Repository接口 + Data工具类 + Database + Network
```

#### 14.7.2 禁止的依赖方向
```
❌ 屏幕组件直接依赖原子组件（应通过有机体组件）
❌ ViewModel直接依赖Data工具类（应通过Domain工具类）
❌ Domain层依赖Data层
❌ Presentation层直接依赖Repository实现（应通过UseCase）
```

### 14.8 组件重复模式识别与规范

#### 14.8.1 已发现的重复组件
| 重复组件 | 位置 | 建议处理 |
|----------|------|----------|
| 加载骨架屏 | `LoadingSkeleton.kt` × 3 | 统一为 `StateLoadingView` |
| 错误视图 | `ErrorView.kt`, `ErrorStateView.kt`, `FriendlyErrorCard.kt` | 合并为 `UnifiedErrorView` |
| 空状态 | `EmptyView.kt`, `EmptyStateView.kt` | 合并为 `UnifiedEmptyView` |
| iOS弹窗 | `IOSAlertDialog.kt` × 2 | 统一为 `IosAlertDialog` |
| 日志 | `Logger.kt`, `AndroidLogger.kt`, `DebugLogger.kt` | 统一为 `Logger` 接口 |

#### 14.8.2 组件合并规范
```kotlin
// ✅ 正确：合并相似组件
// 合并前
@Composable
fun ErrorView(message: String, onRetry: () -> Unit) { ... }
@Composable
fun ErrorStateView(state: ErrorState) { ... }
@Composable
fun FriendlyErrorCard(error: Throwable) { ... }

// 合并后（统一组件）
@Composable
fun UnifiedErrorView(
    error: ErrorDisplay,
    modifier: Modifier = Modifier,
    onRetry: (() -> Unit)? = null
) { ... }

// 使用方
@Composable
fun MyScreen() {
    UnifiedErrorView(
        error = ErrorDisplay.Message("出错了"),
        onRetry = { /* 重试逻辑 */ }
    )
}
```

### 14.9 新组件贡献指南

#### 14.9.1 创建新组件的流程
1. **检查复用**：在对应分类目录搜索是否存在相似组件
2. **分类定位**：确定组件所属层级（原子/分子/有机体/模板）
3. **命名规范**：遵循组件命名规则
4. **参数设计**：使用@Stable类型，参数不超过5个核心参数
5. **文档注释**：添加KDoc注释，说明用途和参数
6. **单元测试**：为组件编写基础测试

#### 14.9.2 组件KDoc模板
```kotlin
/**
 * [组件名称] - [一句话描述功能]
 *
 * [详细描述组件的用途、使用场景和注意事项]
 *
 * @param [参数名] [参数描述] ([默认值/可选值])
 * @param [参数名] [参数描述] ([默认值/可选值])
 * @return [返回值描述]
 *
 * @example
 * ```kotlin
 * [使用示例代码]
 * ```
 */
@Composable
fun ComponentName(...) { ... }
```

---

## 十五、思维链与MCP配置规范

### 15.1 MCP服务器配置
```json
// .kiro/settings/mcp.json
{
  "mcpServers": {
    "context7": {
      "command": "npx",
      "args": ["-y", "@upstash/context7-mcp"],
      "disabled": false,
      "description": "用于实时查询项目文档和API参考"
    },
    "sequentialthinking": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-sequential-thinking"],
      "disabled": false,
      "description": "用于复杂问题的分步思考和推理"
    }
  }
}
```

### 15.2 思维链使用场景
| 场景 | 工具 | 使用方式 |
|------|------|----------|
| 复杂Bug分析 | sequentialthinking | 分步推理根本原因 |
| 架构设计决策 | sequentialthinking | 分步评估方案优劣 |
| 文档查询 | context7 | 实时查询API文档 |
| 性能优化 | sequentialthinking | 分步定位瓶颈 |

---

**文档版本**: v2.0
**最后更新**: 2026-01-09
