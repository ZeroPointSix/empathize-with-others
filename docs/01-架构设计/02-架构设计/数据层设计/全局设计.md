---
标题: 数据层全局设计
版本: v2.0
创建日期: 2025-12-08
最后更新: 2025-12-08
更新人: AI Assistant
状态: 活跃
标签: [数据层设计, 全局设计, 架构]
相关文档: [开发规范.md, 本地存储.md, 网络访问.md, 外部服务.md]
---

# 数据层全局设计

---

## 📋 设计概述

数据层负责数据的获取与持久化，是连接业务逻辑和外部数据源的桥梁。采用三板块设计：本地记忆系统、远程通信系统、安全配置系统。

---

## 🏗️ 架构总览

```
┌─────────────────────────────────────────┐
│           Data Layer                    │
│  (数据获取与持久化)                     │
├─────────────────────────────────────────┤
│         本地记忆系统                        │
│  - Room Database                        │
│  - 文件存储                             │
│  - 数据转换                             │
├─────────────────────────────────────────┤
│         远程通信系统                        │
│  - Retrofit HTTP Client                  │
│  - API 接口定义                         │
│  - DTO 数据传输对象                      │
├─────────────────────────────────────────┤
│         安全配置系统                        │
│  - EncryptedSharedPreferences           │
│  - 配置管理                             │
│  - 密钥存储                             │
└─────────────────────────────────────────┘
```

---

## 📦 第一板块：本地记忆系统 (Local Persistence)

**负责：** 存储结构化的业务数据（人、标签）。

### 任务 1：构建数据库基础 (Room Entities & DAOs)

**目的**：将 Domain 层的业务对象持久化到 SQLite，并支持响应式查询（Flow）。

**方法**：
1. 定义 `ContactProfileEntity` 和 `BrainTagEntity`（表结构）
2. 编写 `RoomTypeConverters`（解决 Map/Enum 存储问题）
3. 编写 `ContactDao` 和 `BrainTagDao`（定义 SQL 操作）
4. 配置 `AppDatabase`（挂载表和转换器）

**AI 解释/指令**：
> 告诉 AI：Entity 必须是 Domain Model 的扁平化映射（Map转String，Enum转String）。DAO 的读取操作必须返回 `Flow` 以支持 MVVM 的实时刷新。写入操作统一使用 `OnConflictStrategy.REPLACE` 实现 Upsert。

---

## 🌐 第二板块：远程通信系统 (Remote Networking)

**负责：** 连接云端 AI 大脑（OpenAI/DeepSeek）。

### 任务 2：构建网络通信基础 (Retrofit & DTOs)

**目的**：建立一个支持 **BYOK (动态 URL)** 的 HTTP 客户端，用于发送 Prompt 和接收 AI 回复。

**方法**：
1. 定义 **DTO (Data Transfer Objects)**：`ChatRequestDto`, `ChatResponseDto`, `MessageDto`。这些是专门用于 JSON 序列化的类，**严禁**复用 Domain Model
2. 定义 **API 接口**：`OpenAiApi`。使用 `@Url` 注解实现动态 BaseUrl 替换

**AI 解释/指令**：
> 告诉 AI：DTO 类必须与 Domain Model 严格隔离。API 接口必须支持通过参数动态传入 URL（因为用户可能切换 AI 服务商）。

---

## 🔐 第三板块：安全配置系统 (Secure Configuration)

**负责：** 管理敏感钥匙（Key）和全局开关。

### 任务 3：构建安全存储 (EncryptedSharedPreferences)

**目的**：提供一个"保险箱"，安全地存储用户的 API Key，防止手机被 Root 后泄露。

**方法**：
1. 在 Hilt 模块中提供 `EncryptedSharedPreferences` 的单例实例
2. 实现 `SettingsRepositoryImpl`，封装 Key 的读写逻辑

**AI 解释/指令**：
> 告诉 AI：不要使用普通的 `SharedPreferences`。必须使用 Jetpack Security 库创建加密实例。Key 的读写操作应该是挂起函数 (`suspend`)，虽然 SP 操作很快，但在协程中处理 IO 是最佳实践。

---

## 🔧 第四板块：总装与交付 (Assembly & Delivery)

**负责：**将上面三个板块封装起来，对外提供符合 Domain 接口规范的服务。

### 任务 4：依赖注入配置 (Hilt Modules)

**目的**：初始化所有单例（Database, Retrofit, OkHttpClient, EncryptedPrefs），并告诉 App 如何找到它们。

**方法**：
1. 创建 `DatabaseModule`：提供 Room 实例和 DAOs
2. 创建 `NetworkModule`：提供配置好 Gson 的 Retrofit 和配置好超时/Log 的 OkHttpClient
3. 创建 `RepositoryModule`：将 `Impl` 类绑定到 Domain 层的 `Interface` 上

**AI 解释/指令**：
> 告诉 AI：所有 Network 组件必须是 `@Singleton`。OkHttpClient 必须配置 `connectTimeout` (建议 30s，AI 响应慢) 和 `loggingInterceptor` (仅 Debug 模式开启)。

### 任务 5：仓库实现落地 (Repository Implementation)

**目的**：编写"胶水代码"，协调 Local 和 Remote 数据源，完成数据清洗和转换。

**方法**：
1. `Contact/BrainTagRepositoryImpl`：负责 Entity <-> Domain Model 的转换
2. `AiRepositoryImpl`：负责从 Settings 拿 Key -> 拼装 DTO -> 调 API -> 解析结果 -> 返回 Domain Model

**AI 解释/指令**：
> 告诉 AI：Repository 是数据层的唯一出口。严禁将 Entity 或 DTO 暴露给 Domain 层，必须在内部进行 `map { it.toDomain() }` 转换。对于 AI 请求，如果发生网络异常，需要捕获并抛出业务层能理解的异常。

---

## 📊 数据流架构

### 1. 数据读取流程

```
UI/ViewModel
    ↓ (调用 Repository)
Repository Implementation
    ↓ (选择数据源)
┌─────────────┬─────────────┐
│ Local Data  │ Remote Data │
│ (Room)     │ (Network)   │
└─────────────┴─────────────┘
    ↓ (数据转换)
Domain Model
    ↓ (返回)
UI/ViewModel
```

### 2. 数据写入流程

```
UI/ViewModel
    ↓ (调用 Repository)
Repository Implementation
    ↓ (数据验证)
Domain Model
    ↓ (转换)
Entity/DTO
    ↓ (持久化/传输)
Local Storage/Remote API
```

---

## 🔗 组件依赖关系

```
Repository Implementation
├── Local Storage
│   ├── Room Database
│   ├── DAOs
│   └── Type Converters
├── Remote Communication
│   ├── Retrofit Client
│   ├── API Interfaces
│   └── DTOs
├── Security Configuration
│   ├── Encrypted Preferences
│   └── Settings Repository
└── Data Mappers
    ├── Entity → Domain
    └── Domain → Entity
```

---

## 📝 技术选型

### 本地存储
- **Room**: 2.6.1 - SQLite 抽象层
- **SQLite**: 原生数据库
- **Type Converters**: 自定义类型转换

### 网络通信
- **Retrofit**: 2.11.0 - HTTP 客户端
- **OkHttp**: 4.12.0 - 网络底层
- **Gson**: 2.10.1 - JSON 序列化

### 安全存储
- **EncryptedSharedPreferences**: 1.1.0-alpha06
- **Android Keystore**: 硬件级加密

### 依赖注入
- **Hilt**: 2.52 - 依赖注入框架
- **Kotlin Coroutines**: 1.9.0 - 异步处理

---

## 🎯 性能优化策略

### 1. 数据库优化
- **索引设计**: 为查询频繁的字段建立索引
- **分页加载**: 大数据集使用分页查询
- **缓存策略**: 热点数据内存缓存

### 2. 网络优化
- **连接池**: 复用 HTTP 连接
- **缓存机制**: 响应数据适当缓存
- **超时控制**: 合理设置连接和读取超时

### 3. 内存优化
- **对象池**: 复用频繁创建的对象
- **弱引用**: 避免内存泄漏
- **及时释放**: 不再使用的资源及时释放

---

## 🔒 安全设计

### 1. 数据加密
- **API Key**: 使用 EncryptedSharedPreferences 存储
- **敏感数据**: 数据库字段加密存储
- **传输安全**: HTTPS + 证书验证

### 2. 访问控制
- **权限最小化**: 只申请必要的权限
- **数据脱敏**: 敏感信息本地脱敏
- **审计日志**: 关键操作记录日志

---

## 📋 总结

我们需要干的事情就是构建 **三套引擎（数据库、网络、保险箱）**，然后通过 **一套总线（Hilt + Repository）** 把它们连接到之前写好的业务层上。

### 建议执行路径

1. **先做板块一 (本地)** → 再做 **板块四 (DI配置)** → 跑通本地数据的单元测试
2. **然后做板块二 (网络)** → 再做 **板块三 (安全)** → 跑通 AI 调用的逻辑

---

## 🔄 开发流程

### 第一阶段：基础搭建
1. 配置依赖注入模块
2. 创建数据库实体和 DAO
3. 实现基础 Repository

### 第二阶段：功能实现
1. 实现网络通信模块
2. 实现安全配置模块
3. 完善数据转换逻辑

### 第三阶段：集成测试
1. 单元测试各个组件
2. 集成测试数据流
3. 性能测试和优化

---

## 📊 质量保证

### 代码质量
- **静态分析**: 使用 Detekt 检查代码质量
- **代码审查**: 所有变更需要代码审查
- **测试覆盖**: 核心逻辑 100% 测试覆盖

### 性能监控
- **数据库性能**: 监控查询耗时
- **网络性能**: 监控请求响应时间
- **内存使用**: 监控内存占用情况

---

**最后更新**: 2025-12-08  
**维护者**: 数据访问层团队  
**版本**: v2.0