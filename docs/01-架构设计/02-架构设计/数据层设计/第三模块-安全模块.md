好的，我们现在深入讨论 **模块三：安全配置系统 (Secure Configuration)**。

对于后台开发者来说，你可以把它理解为 **“端侧的 Secret Manager”** 或者 **“加密的 .env 文件”**。

在 Android 端，这部分的设计至关重要，因为 APK 反编译极其容易，手机 Root 后文件系统也是透明的。如果直接用明文存 API Key，相当于把你的钱包扔在大街上。

我们从 **技术选型**、**实现逻辑** 和 **Hilt 组装** 三个层面来解构这个模块。

-----

### 1\. 技术选型：硬件级加密 (The Vault)

我们不使用普通的 `SharedPreferences`（它只是一个 XML 文件），而是使用 Google 官方的 **Jetpack Security (EncryptedSharedPreferences)**。

#### 核心机制

  * **主密钥 (Master Key)**:
      * 生成于 Android 的 **Keystore 系统**中。
      * 存储在 **TEE (可信执行环境)** 或 **StrongBox (专用安全芯片)** 中。即使是 Root 权限或操作系统本身也无法把这个主密钥“拷出来”，只能请求它进行加解密操作。
  * **数据加密**:
      * **Key (键名)**: 使用 `AES256_SIV` 加密。黑客连你存的键叫 "api\_key" 还是 "password" 都看不到。
      * **Value (键值)**: 使用 `AES256_GCM` 加密。这是目前民用最高级别的对称加密标准。

-----

### 2\. 仓库实现逻辑 (SettingsRepositoryImpl)

**位置**：`data/repository/SettingsRepositoryImpl.kt`

这是业务层访问配置的唯一入口。虽然 `SharedPreferences` 的 API 很简单（get/put），但我们在实现时需要遵循 Clean Architecture 的规范。

#### 核心设计点：

1.  **挂起函数 (Suspend Functions)**:
      * 虽然读取 SP 通常很快（毫秒级），但**写入**（加密 + 磁盘IO）可能会慢。
      * **设计决策**：Domain 层接口定义为 `suspend`，迫使调用方（ViewModel/UseCase）必须在协程中调用，绝对不阻塞 UI 主线程。
2.  **配置项清单**:
      * **`apiKey`**: 用户输入的 SK-xxxx。
      * **`aiProvider`**: 用户选的服务商（"OpenAI" 或 "DeepSeek"）。这也决定了网络层拼接哪个 URL。
      * **`userPromptName`** (可选): 用户设定的“我的名字”（用于隐私脱敏字典）。

#### 伪代码逻辑 (C++ 风格类比):

```cpp
class SettingsRepositoryImpl : public SettingsRepository {
private:
    // 注入的是经过包装的加密实例，用法和普通 Map 一样
    SharedPreferences* m_securePrefs; 

public:
    // 读取：解密是透明的，自动完成
    virtual string getApiKey() {
        return m_securePrefs->getString("enc_api_key", NULL);
    }

    // 写入：加密也是透明的
    // commit() 是同步写入(阻塞)，apply() 是异步写入(非阻塞)
    // 在 suspend 函数中，我们通常用 edit().putString(...).apply()
    virtual void saveApiKey(string key) {
        auto editor = m_securePrefs->edit();
        editor->putString("enc_api_key", key);
        editor->apply(); 
    }
};
```

-----

### 3\. 总装逻辑 (DI / Hilt Module)

**位置**：`di/DataModule.kt`

这是最容易出错的地方。我们需要在这里创建那个复杂的加密实例，并把它作为单例提供给全 App 使用。

#### 核心配置步骤：

1.  **创建主密钥 (MasterKey)**:

    ```kotlin
    val masterKey = MasterKey.Builder(context)
        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
        .build()
    ```

2.  **创建加密 SP 实例**:

    ```kotlin
    val encryptedPrefs = EncryptedSharedPreferences.create(
        context,
        "secret_shared_prefs", // 文件名：secret_shared_prefs.xml
        masterKey, // 传入主密钥
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
    ```

3.  **提供注入**:

      * 使用 `@Provides` 和 `@Singleton` 注解，确保整个 App 生命周期内只创建一次加密实例（创建成本较高）。

-----

### 4\. 总结：这一步我们要干嘛？

我们要在 **Data Layer** 完成以下两件事，就能把这个模块搞定：

1.  **Task 8 (实现仓库)**: 写 `SettingsRepositoryImpl`，把读写逻辑封装好。
2.  **Task 10 (配置 DI)**: 在 `DataModule` 里写那段创建 `MasterKey` 和 `EncryptedSharedPreferences` 的代码。
