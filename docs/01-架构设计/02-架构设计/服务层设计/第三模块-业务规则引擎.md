# 第三模块:业务规则引擎

## 概述

业务规则引擎负责管理和执行应用中的各种业务规则,包括隐私脱敏、安全检查、策略匹配等。本模块基于现有的标签系统(BrainTag)设计一个简化但可扩展的规则引擎。

---

## 规则系统架构

### 整体架构图

```
┌─────────────────────────────────────────┐
│         UseCase层 (业务编排)            │
│  AnalyzeChatUseCase / CheckDraftUseCase │
└────────────────┬────────────────────────┘
                 │ 调用
                 ↓
┌─────────────────────────────────────────┐
│      规则引擎层 (Rule Engine)           │
│  ┌─────────────┐    ┌─────────────┐   │
│  │PrivacyEngine│    │SafetyChecker│   │
│  │  隐私脱敏   │    │  安全检查    │   │
│  └─────────────┘    └─────────────┘   │
└────────────────┬────────────────────────┘
                 │ 读取规则
                 ↓
┌─────────────────────────────────────────┐
│       规则存储层 (Repository)           │
│  BrainTagRepository / PrivacyRepository │
└─────────────────────────────────────────┘
```

---

## 基于标签的规则定义

### 标签类型系统

我们的规则系统基于`BrainTag`实现,每个标签代表一条规则:

```kotlin
data class BrainTag(
    val id: Long = 0,
    val contactId: String,     // 规则适用的联系人
    val type: TagType,         // 规则类型
    val content: String,       // 规则内容
    val priority: Int = 0,     // 优先级(预留)
    val createdAt: Long = System.currentTimeMillis()
)

enum class TagType {
    RISK_RED,       // 风险规则(红色警告)
    STRATEGY_GREEN  // 策略规则(绿色建议)
}
```

### 规则分类

**风险规则(RISK_RED)**:
- 用途:标记需要避免的内容
- 示例:"不要催促"、"不要提前任"、"避免讨论工作"
- 触发:输入内容匹配时阻止或警告

**策略规则(STRATEGY_GREEN)**:
- 用途:提供积极的行为建议
- 示例:"多夸他衣品好"、"耐心倾听"、"聊钓鱼话题"
- 触发:在分析时作为正面引导

---

## 隐私脱敏引擎

### PrivacyEngine实现

```kotlin
/**
 * 隐私脱敏引擎
 *
 * 职责: 在数据发送给AI前进行脱敏处理
 */
object PrivacyEngine {
    /**
     * 对单条文本进行脱敏
     *
     * @param rawText 原始文本
     * @param privacyMapping 隐私映射规则
     * @return 脱敏后的文本
     */
    fun mask(rawText: String, privacyMapping: Map<String, String>): String {
        var maskedText = rawText
        
        privacyMapping.forEach { (original, mask) ->
            maskedText = maskedText.replace(original, mask, ignoreCase = true)
        }
        
        return maskedText
    }

    /**
     * 对文本列表进行批量脱敏
     *
     * @param rawTexts 原始文本列表
     * @param privacyMapping 隐私映射规则
     * @return 脱敏后的文本列表
     */
    fun maskBatch(rawTexts: List<String>, privacyMapping: Map<String, String>): List<String> {
        return rawTexts.map { mask(it, privacyMapping) }
    }
}
```

### 使用示例

```kotlin
class AnalyzeChatUseCase @Inject constructor(
    private val privacyRepository: PrivacyRepository
) {
    suspend fun invoke(...): Result<AnalysisResult> {
        // 1. 获取隐私映射规则
        val privacyMapping = privacyRepository.getPrivacyMapping()
            .getOrElse { emptyMap() }
        
        // 示例规则:
        // {
        //   "张三" -> "[NAME_01]",
        //   "13812345678" -> "[PHONE_01]",
        //   "北京市朝阳区" -> "[ADDR_01]"
        // }
        
        // 2. 脱敏处理
        val rawContext = listOf(
            "张三最近在北京市朝阳区买了房",
            "他的电话是13812345678"
        )
        
        val maskedContext = PrivacyEngine.maskBatch(rawContext, privacyMapping)
        
        // 结果:
        // [
        //   "[NAME_01]最近在[ADDR_01]买了房",
        //   "他的电话是[PHONE_01]"
        // ]
        
        // 3. 发送给AI
        return aiRepository.analyze(maskedContext)
    }
}
```

---

## 安全检查引擎

### 两层检查架构

```
用户输入草稿
     ↓
┌──────────────┐
│ Layer 1:     │
│ 本地关键词匹配│  ← 快速,离线
└──────────────┘
     ↓
  命中雷区?
     ├─ 是 → 立即警告
     └─ 否 → 继续
          ↓
     ┌──────────────┐
     │ Layer 2:     │
     │ AI语义检查   │  ← 深度,联网
     └──────────────┘
          ↓
       返回结果
```

### 本地关键词匹配

```kotlin
/**
 * 本地快速检查
 */
private fun performLocalCheck(
    draft: String,
    redTags: List<BrainTag>
): SafetyCheckResult {
    val triggeredTags = mutableListOf<String>()
    
    // 简单的子串匹配
    redTags.forEach { tag ->
        if (draft.contains(tag.content, ignoreCase = true)) {
            triggeredTags.add(tag.content)
        }
    }
    
    return if (triggeredTags.isNotEmpty()) {
        SafetyCheckResult(
            isSafe = false,
            triggeredRisks = triggeredTags,
            suggestion = "检测到敏感内容: ${triggeredTags.joinToString(", ")}"
        )
    } else {
        SafetyCheckResult(isSafe = true)
    }
}
```

**优点**:
- 速度快(毫秒级)
- 不消耗API额度
- 离线可用

**缺点**:
- 只能检测直接匹配
- 无法识别语义相似的表达

---

### AI语义检查

```kotlin
/**
 * AI深度检查(可选)
 */
private suspend fun performDeepCheck(
    draft: String,
    redTags: List<BrainTag>
): SafetyCheckResult {
    // 1. 脱敏
    val privacyMapping = privacyRepository.getPrivacyMapping().getOrElse { emptyMap() }
    val maskedDraft = PrivacyEngine.mask(draft, privacyMapping)
    
    // 2. 提取规则内容
    val riskRules = redTags.map { it.content }
    
    // 3. 调用AI进行语义分析
    // AI会理解"催"、"赶紧"、"快点"都属于"催促"的语义
    val result = aiRepository.checkDraftSafety(maskedDraft, riskRules).getOrThrow()
    
    return result
}
```

**优点**:
- 语义理解能力强
- 可以检测同义表达
- 准确率高

**缺点**:
- 需要网络请求
- 消耗API额度
- 响应较慢(1-2秒)

---

### 完整的CheckDraftUseCase

```kotlin
class CheckDraftUseCase @Inject constructor(
    private val brainTagRepository: BrainTagRepository,
    private val privacyRepository: PrivacyRepository,
    private val aiRepository: AiRepository
) {
    suspend operator fun invoke(
        contactId: String,
        draftSnapshot: String,
        enableDeepCheck: Boolean = false
    ): Result<SafetyCheckResult> {
        return try {
            // 1. 加载雷区规则
            val redTags = brainTagRepository.getTagsForContact(contactId)
                .first()
                .filter { it.type == TagType.RISK_RED }

            if (redTags.isEmpty()) {
                return Result.success(SafetyCheckResult(isSafe = true))
            }

            // 2. Layer 1: 本地关键词检查
            val localResult = performLocalCheck(draftSnapshot, redTags)
            if (!localResult.isSafe) {
                return Result.success(localResult)
            }

            // 3. Layer 2: AI语义检查(可选)
            if (enableDeepCheck) {
                val deepResult = performDeepCheck(draftSnapshot, redTags)
                return Result.success(deepResult)
            }

            Result.success(SafetyCheckResult(isSafe = true))
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

---

## 规则匹配策略

### 策略1:精确匹配

```kotlin
fun exactMatch(text: String, rule: String): Boolean {
    return text.equals(rule, ignoreCase = true)
}
```

**使用场景**:特定词汇检测
**示例**:"前任" 只匹配 "前任",不匹配 "前任公司"

---

### 策略2:子串匹配

```kotlin
fun substringMatch(text: String, rule: String): Boolean {
    return text.contains(rule, ignoreCase = true)
}
```

**使用场景**:关键词检测
**示例**:"催促" 匹配 "不要催我"、"你别催了"

---

### 策略3:正则匹配

```kotlin
fun regexMatch(text: String, pattern: String): Boolean {
    return Regex(pattern, RegexOption.IGNORE_CASE).containsMatchIn(text)
}
```

**使用场景**:模式检测
**示例**:`\d{11}` 匹配手机号

---

### 策略4:语义匹配(AI)

```kotlin
suspend fun semanticMatch(text: String, rule: String): Boolean {
    val result = aiRepository.checkSemanticSimilarity(text, rule).getOrNull()
    return result?.similarity ?: 0.0 > 0.7
}
```

**使用场景**:同义表达检测
**示例**:"催促" 语义匹配 "赶紧"、"快点"、"别磨蹭"

---

## 规则优先级设计

### 优先级定义

```kotlin
data class BrainTag(
    val id: Long = 0,
    val contactId: String,
    val type: TagType,
    val content: String,
    val priority: Int = 0  // 优先级: 数字越大优先级越高
)

enum class Priority {
    LOW(0),      // 低优先级
    MEDIUM(50),  // 中优先级
    HIGH(100)    // 高优先级
}
```

### 优先级应用

```kotlin
/**
 * 按优先级执行规则检查
 */
private fun checkWithPriority(
    text: String,
    rules: List<BrainTag>
): SafetyCheckResult {
    // 按优先级排序(高优先级先检查)
    val sortedRules = rules.sortedByDescending { it.priority }
    
    for (rule in sortedRules) {
        if (text.contains(rule.content, ignoreCase = true)) {
            return SafetyCheckResult(
                isSafe = false,
                triggeredRisks = listOf(rule.content),
                suggestion = "触发${getPriorityLabel(rule.priority)}规则: ${rule.content}"
            )
        }
    }
    
    return SafetyCheckResult(isSafe = true)
}

private fun getPriorityLabel(priority: Int): String = when {
    priority >= 100 -> "高优先级"
    priority >= 50 -> "中优先级"
    else -> "低优先级"
}
```

---

## 规则引擎可扩展设计

### 策略模式实现

```kotlin
/**
 * 规则匹配策略接口
 */
interface RuleMatchStrategy {
    fun match(text: String, rule: String): Boolean
}

/**
 * 子串匹配策略
 */
class SubstringMatchStrategy : RuleMatchStrategy {
    override fun match(text: String, rule: String): Boolean {
        return text.contains(rule, ignoreCase = true)
    }
}

/**
 * 正则匹配策略
 */
class RegexMatchStrategy : RuleMatchStrategy {
    override fun match(text: String, rule: String): Boolean {
        return try {
            Regex(rule, RegexOption.IGNORE_CASE).containsMatchIn(text)
        } catch (e: Exception) {
            false
        }
    }
}

/**
 * 可配置的规则引擎
 */
class ConfigurableRuleEngine(
    private val strategy: RuleMatchStrategy = SubstringMatchStrategy()
) {
    fun checkText(text: String, rules: List<String>): List<String> {
        return rules.filter { rule ->
            strategy.match(text, rule)
        }
    }
}
```

### 使用示例

```kotlin
// 使用子串匹配
val engine1 = ConfigurableRuleEngine(SubstringMatchStrategy())
val result1 = engine1.checkText("不要催我", listOf("催"))

// 使用正则匹配
val engine2 = ConfigurableRuleEngine(RegexMatchStrategy())
val result2 = engine2.checkText("电话13812345678", listOf("\\d{11}"))
```

---

## 规则持久化方案

### 当前方案:基于Room

```kotlin
@Entity(tableName = "brain_tags")
data class BrainTagEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    
    @ColumnInfo(name = "contact_id", index = true)
    val contactId: String,
    
    @ColumnInfo(name = "tag_type")
    val type: String,  // RISK_RED / STRATEGY_GREEN
    
    @ColumnInfo(name = "content")
    val content: String,
    
    @ColumnInfo(name = "priority")
    val priority: Int = 0,
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long = System.currentTimeMillis()
)
```

### 