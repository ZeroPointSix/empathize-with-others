
### 第一步：环境配置 (Dependencies)
**相当于：** 在 Linux 服务器上安装 MySQL 和 Python 的 `SQLAlchemy` / `PyMySQL` 库。

* **你需要干什么：**
    打开 `app/build.gradle.kts`，填入库的引用。
* **核心库：**
    1.  **Room Runtime:** 数据库核心运行时。
    2.  **Room KSP (Compiler):** 编译器。Android 的 Room 是在编译时生成 SQL 代码的，所以需要这个。
    3.  **Room KTX:** 让 Room 支持 Kotlin 的协程 (`suspend`) 和流 (`Flow`)。
    4.  **Gson:** 用于把 `Map` 序列化成 JSON 字符串存入数据库。

---

### 第二步：定义表结构 (Entities)
**相当于：** 编写 SQL 的 `CREATE TABLE` 语句。

* **你需要干什么：**
    在 `data/local/entity` 下创建两个 Kotlin Data Class，并打上 `@Entity` 注解。

* **具体细节：**
    1.  **`ContactProfileEntity` (联系人表):**
        * **表名:** `profiles`
        * **主键:** `id` (String, 不自增，因为 ID 可能来自外部或 UUID)。
        * **字段:** `name`, `target_goal`, `context_depth`。
        * **特殊处理:** `facts` 字段在 Domain 层是 Map，在这里定义为 **`String`** (命名为 `facts_json`)。
    2.  **`BrainTagEntity` (标签表):**
        * **表名:** `brain_tags`
        * **主键:** `id` (Long, **自增** `autoGenerate = true`)。
        * **外键/索引:** `contact_id`。必须加 `@ColumnInfo(index = true)`，因为查询标签几乎都是 `WHERE contact_id = ?`。
        * **特殊处理:** `type` (Enum) 在这里定义为 **`String`**。


### 第三步：造翻译器 (Type Converters)

**设计目标**：
SQLite 很笨，只认识 `Int`, `String` 等基本类型。你的 `facts: Map<String, String>` 和 `type: TagType` (枚举) 它都不认识。
我们需要一个“翻译官”，在数据存入前打包成 String，取出来后解包回对象。

**实现策略**：
我们不搞复杂的，直接用 **Gson** 做序列化。虽然 Moshi 更快，但 Gson 在处理这种简单 Map 时代码最少。

**核心逻辑设计**：
我们需要创建一个单例类 `RoomTypeConverters`，里面放四个翻译函数：

1.  **Map ↔ JSON String** (用于 `ContactProfile.facts`)
    * **入库 (To DB)**：`Gson().toJson(map)`。
        * *效果*：`{"hobby": "fishing"}` -> `"{\"hobby\": \"fishing\"}"`
    * **出库 (From DB)**：`Gson().fromJson(json, typeToken)`。
        * *注意*：这里涉及泛型擦除，需要用 `TypeToken` 告诉 Gson 这是一个 `Map<String, String>`。

2.  **Enum ↔ String** (用于 `BrainTag.type`)
    * **入库**：`enum.name` (例如 `"RISK_RED"`)。
    * **出库**：`TagType.valueOf(string)`。
    * *容错设计*：如果数据库里存了旧版本的枚举值（代码里删了），为了不 Crash，可以用 `try-catch` 返回一个默认值（如 `STRATEGY_GREEN`）。

---

### 第四步：写 SQL (Define DAOs)

**设计目标**：
这是你写 SQL 的地方。对于后台开发者，这就像写 Mapper。
核心原则是：**“查询要响应式 (Reactive)，写入要简单粗暴 (Upsert)”**。

**1. `ContactDao` (联系人操作)**
* **`getAllProfiles(): Flow<List<ContactProfileEntity>>`**
    * *设计意图*：注意返回的是 **Flow**。这意味着这不仅仅是一次查询，而是一个**“长连接管道”**。只要任何地方改了这张表，这个管道会自动吐出最新数据。这是 MVVM 架构 UI 自动刷新的根本动力。
* **`insertOrUpdate(entity)`**
    * *SQL 策略*：`@Insert(onConflict = OnConflictStrategy.REPLACE)`。
    * *设计意图*：我们不需要单独写 `update`。只要 ID 一样，Room 就认为是同一条数据，直接覆盖旧的。这大大简化了上层逻辑。

**2. `BrainTagDao` (标签操作)**
* **`getTagsByContactId(contactId: String): Flow<List<BrainTagEntity>>`**
    * *设计意图*：同样用 Flow。当你在“数据喂养”页面加了个标签，聊天页面的分析卡片应该能立即感知到。
* **`deleteTag(id: Long)`**
    * *设计意图*：简单的物理删除。

---

### 第五步：总装与落地 (Database & Repository Impl)

这是把所有零件组装起来，并真正对外提供服务的阶段。

**1. 建库 (`AppDatabase`)**
* 这是一个配置类。
* **挂载**：把 `Step 2` 的两个 Entity 和 `Step 3` 的 Converter 挂上去。
* **版本控制**：`version = 1`。MVP 阶段如果改了表结构，直接卸载重装 APP 即可，暂时不需要写 Migration 脚本。

**2. 接口落地 (`RepositoryImpl`) —— 最关键的胶水层**
这是连接 Domain 层（纯 Kotlin）和 Data 层（Android/SQL）的桥梁。

**`ContactRepositoryImpl` 的具体工作流：**

* **实现 `saveProfile(domainProfile)`：**
    1.  **拆包**：拿到 Domain 层的 `ContactProfile`。
    2.  **转换**：调用 Converter 把 `facts` Map 变成 String。
    3.  **封装**：New 一个 `ContactProfileEntity`。
    4.  **落地**：调用 `dao.insertOrUpdate(entity)`。

* **实现 `getAllProfiles()`：**
    1.  **对接管道**：调用 `dao.getAllProfiles()` 拿到 `Flow<List<Entity>>`。
    2.  **数据清洗**：使用 `.map { list -> ... }` 操作符。
    3.  **还原**：遍历 List，把每个 Entity 里的 JSON String 还原成 Map，重新组装成 Domain 层的 `ContactProfile`。
    4.  **交付**：最终吐出 `Flow<List<ContactProfile>>` 给 UseCase。
