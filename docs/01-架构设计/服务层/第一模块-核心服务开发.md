# 第一模块:核心服务开发

## 概述

本模块将教你如何从零到一开发一个标准的UseCase。我们将采用**五步开发法**,并通过完整示例展示每一步的具体实现。

---

## UseCase 五步开发法

### 第一步:明确业务场景

**目标**:搞清楚这个UseCase要解决什么问题,对应用户的什么操作。

**思考清单**:
1. 用户在什么场景下触发这个功能?
2. 用户期望得到什么结果?
3. 需要加载哪些数据?
4. 需要调用哪些Repository?

**示例 - AnalyzeChatUseCase**:
```
场景: 用户在聊天界面点击悬浮窗的[帮我分析]按钮
输入: 当前联系人ID + 屏幕抓取的聊天记录
输出: AI生成的策略建议
依赖: ContactRepository, BrainTagRepository, PrivacyRepository, AiRepository
```

---

### 第二步:定义接口签名

**目标**:确定UseCase的输入参数和返回值。

**设计原则**:
- **参数简洁**:只接收必要的参数(通常是ID和简单数据)
- **返回Result**:统一使用`Result<T>`封装成功/失败
- **使用suspend**:支持协程,避免阻塞

**标准模板**:
```kotlin
class XxxUseCase @Inject constructor(
    private val repository1: Repository1,
    private val repository2: Repository2
) {
    /**
     * 执行[业务描述]
     *
     * @param param1 参数1说明
     * @param param2 参数2说明
     * @return 业务结果
     */
    suspend operator fun invoke(
        param1: String,
        param2: List<String>
    ): Result<OutputType> {
        TODO("待实现")
    }
}
```

**示例 - AnalyzeChatUseCase**:
```kotlin
class AnalyzeChatUseCase @Inject constructor(
    private val contactRepository: ContactRepository,
    private val brainTagRepository: BrainTagRepository,
    private val privacyRepository: PrivacyRepository,
    private val aiRepository: AiRepository,
    private val settingsRepository: SettingsRepository
) {
    suspend operator fun invoke(
        contactId: String,
        rawScreenContext: List<String>
    ): Result<AnalysisResult> {
        TODO("待实现")
    }
}
```

---

### 第三步:实现业务流程

**目标**:按照标准流程编写业务逻辑。

**标准流程**:
```
1. 前置检查 (配置检查、参数验证)
   ↓
2. 数据加载 (并行加载无依赖的数据)
   ↓
3. 数据清洗 (去重、排序、转换)
   ↓
4. 业务处理 (调用核心逻辑、AI分析)
   ↓
5. 结果返回 (封装为Result)
```

**完整示例 - AnalyzeChatUseCase**:
```kotlin
suspend operator fun invoke(
    contactId: String,
    rawScreenContext: List<String>
): Result<AnalysisResult> {
    return try {
        // 步骤1: 前置检查
        val apiKey = settingsRepository.getApiKey().getOrNull()
        if (apiKey.isNullOrBlank()) {
            return Result.failure(IllegalStateException("未配置 API Key"))
        }

        // 步骤2: 数据加载
        val profile = contactRepository.getProfile(contactId).getOrNull()
            ?: return Result.failure(IllegalStateException("未找到联系人: $contactId"))

        val brainTags = brainTagRepository.getTagsForContact(contactId).first()
        val privacyMapping = privacyRepository.getPrivacyMapping().getOrElse { emptyMap() }

        // 步骤3: 数据清洗
        val cleanedContext = rawScreenContext
            .distinct()
            .takeLast(profile.contextDepth)

        // 步骤4: 业务处理
        val maskedContext = PrivacyEngine.maskBatch(cleanedContext, privacyMapping)
        val prompt = buildPrompt(
            targetGoal = profile.targetGoal,
            facts = profile.facts,
            redTags = brainTags.filter { it.type == TagType.RISK_RED },
            greenTags = brainTags.filter { it.type == TagType.STRATEGY_GREEN },
            conversationHistory = maskedContext
        )
        val systemInstruction = buildSystemInstruction()
        val analysisResult = aiRepository.analyzeChat(prompt, systemInstruction).getOrThrow()

        // 步骤5: 结果返回
        Result.success(analysisResult)

    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

---

### 第四步:抽取辅助方法

**目标**:将复杂逻辑拆分为小的私有方法,提高可读性。

**原则**:
- 单个方法不超过30行
- 方法名语义化(动词开头)
- 按调用顺序排列

**示例**:
```kotlin
private fun buildPrompt(
    targetGoal: String,
    facts: Map<String, String>,
    redTags: List<BrainTag>,
    greenTags: List<BrainTag>,
    conversationHistory: List<String>
): String {
    return buildString {
        appendLine("【攻略目标】")
        appendLine(targetGoal)
        appendLine()

        if (facts.isNotEmpty()) {
            appendLine("【已知信息】")
            facts.forEach { (key, value) ->
                appendLine("- $key: $value")
            }
            appendLine()
        }

        if (redTags.isNotEmpty()) {
            appendLine("【雷区警告】")
            redTags.forEach { tag ->
                appendLine("- ${tag.content}")
            }
            appendLine()
        }

        if (greenTags.isNotEmpty()) {
            appendLine("【策略建议】")
            greenTags.forEach { tag ->
                appendLine("- ${tag.content}")
            }
            appendLine()
        }

        appendLine("【聊天记录】")
        conversationHistory.forEach { message ->
            appendLine(message)
        }
    }
}

private fun buildSystemInstruction(): String {
    return """
        你是一个专业的社交沟通顾问。
        
        请基于提供的信息,分析当前聊天情况,并给出:
        1. 对方当前的情绪和潜在意图
        2. 可能存在的风险点
        3. 具体的回复建议
        
        注意事项:
        - 严格遵守雷区警告
        - 优先使用策略建议
        - 回复要真诚自然
    """.trimIndent()
}
```

---

### 第五步:编写单元测试

**目标**:验证UseCase的各种场景(成功、失败、边界)。

**测试结构**:
```kotlin
class AnalyzeChatUseCaseTest {
    
    private lateinit var contactRepository: ContactRepository
    private lateinit var brainTagRepository: BrainTagRepository
    private lateinit var aiRepository: AiRepository
    private lateinit var useCase: AnalyzeChatUseCase
    
    @Before
    fun setup() {
        contactRepository = mockk()
        brainTagRepository = mockk()
        aiRepository = mockk()
        
        useCase = AnalyzeChatUseCase(
            contactRepository = contactRepository,
            brainTagRepository = brainTagRepository,
            aiRepository = aiRepository
        )
    }
    
    @Test
    fun `成功场景 - 应返回分析结果`() = runTest {
        val mockProfile = ContactProfile(
            id = "contact_123",
            name = "张三",
            targetGoal = "追求对方",
            facts = mapOf("爱好" to "钓鱼"),
            contextDepth = 10
        )
        
        coEvery { contactRepository.getProfile("contact_123") } returns Result.success(mockProfile)
        coEvery { aiRepository.analyzeChat(any(), any()) } returns Result.success(mockResult)
        
        val result = useCase.invoke("contact_123", listOf("你好", "最近怎么样"))
        
        assertTrue(result.isSuccess)
    }
}
```

---

## 业务逻辑封装最佳实践

### 1. 单一职责

每个UseCase只做一件事:

```kotlin
// 正确示例
class AnalyzeChatUseCase
class CheckDraftUseCase
class FeedTextUseCase

// 错误示例 - 职责混乱
class ChatUseCase {
    fun analyze() { }
    fun checkDraft() { }
    fun sendMessage() { }
}
```

### 2. 数据转换集中

```kotlin
// 正确 - UseCase内部转换
suspend fun invoke(...): Result<AnalysisResult> {
    val rawData = repository.getData()
    val transformed = transformData(rawData)
    return Result.success(transformed)
}
```

### 3. 防御式编程

```kotlin
suspend fun invoke(contactId: String, text: String): Result<Unit> {
    if (contactId.isBlank()) {
        return Result.failure(IllegalArgumentException("联系人ID不能为空"))
    }
    
    if (text.length > 5000) {
        return Result.failure(IllegalArgumentException("文本长度不能超过5000字符"))
    }
    
    return processText(contactId, text)
}
```

### 4. 早返回模式

```kotlin
suspend fun invoke(...): Result<Data> {
    val apiKey = getApiKey()
    if (apiKey == null) {
        return Result.failure(IllegalStateException("未配置Key"))
    }
    
    val profile = getProfile()
    if (profile == null) {
        return Result.failure(IllegalStateException("未找到画像"))
    }
    
    return processData(apiKey, profile)
}
```

---

## 协程与事务管理

### 挂起函数使用

**所有IO操作必须是suspend函数**:

```kotlin
// 正确
suspend fun invoke(...): Result<Data> {
    val data = repository.loadData()
    return Result.success(data)
}

// 错误 - 会阻塞主线程
fun invoke(...): Result<Data> {
    val data = repository.loadDataBlocking()
    return Result.success(data)
}
```

### 协程作用域

**在UseCase中不要创建新的协程**:

```kotlin
// 正确 - 直接调用suspend函数
suspend fun invoke(...): Result<Data> {
    val data1 = repository1.getData()
    val data2 = repository2.getData()
    return Result.success(combine(data1, data2))
}

// 错误 - 不要在UseCase中launch
suspend fun invoke(...): Result<Data> {
    CoroutineScope(Dispatchers.IO).launch {
        repository.getData()
    }
}
```

### 并行调用优化

**使用async进行并行加载**:

```kotlin
suspend fun invoke(...): Result<Data> = coroutineScope {
    val deferredProfile = async { contactRepository.getProfile(id) }
    val deferredTags = async { brainTagRepository.getTags(id) }
    
    val profile = deferredProfile.await().getOrThrow()
    val tags = deferredTags.await().getOrThrow()
    
    Result.success(combine(profile, tags))
}
```

---

## 完整开发示例

以下是一个完整的UseCase实现示例:

```kotlin
/**
 * 草稿安全检查用例
 *
 * 触发场景: 用户点击[帮我检查]按钮
 * 功能: 检查草稿是否触发雷区标签
 */
class CheckDraftUseCase @Inject constructor(
    private val brainTagRepository: BrainTagRepository,
    private val privacyRepository: PrivacyRepository,
    private val aiRepository: AiRepository
) {
    /**
     * 执行草稿检查
     *
     * @param contactId 目标联系人ID
     * @param draftSnapshot 草稿快照
     * @param enableDeepCheck 是否启用AI深度检查
     * @return 安全检查结果
     */
    suspend operator fun invoke(
        contactId: String,
        draftSnapshot: String,
        enableDeepCheck: Boolean = false
    ): Result<SafetyCheckResult> {
        return try {
            validateInput(contactId, draftSnapshot)
            
            val redTags = loadRedTags(contactId)
            
            if (redTags.isEmpty()) {
                return Result.success(SafetyCheckResult(isSafe = true))
            }
            
            val localCheckResult = performLocalCheck(draftSnapshot, redTags)
            if (!localCheckResult.isSafe) {
                return Result.success(localCheckResult)
            }
            
            if (enableDeepCheck) {
                val deepCheckResult = performDeepCheck(draftSnapshot, redTags)
                return Result.success(deepCheckResult)
            }
            
            Result.success(SafetyCheckResult(isSafe = true))
            
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private fun validateInput(contactId: String, draft: String) {
        require(contactId.isNotBlank()) { "联系人ID不能为空" }
        require(draft.isNotBlank()) { "草稿内容不能为空" }
    }
    
    private suspend fun loadRedTags(contactId: String): List<BrainTag> {
        return brainTagRepository.getTagsForContact(contactId)
            .first()
            .filter { it.type == TagType.RISK_RED }
    }
    
    private fun performLocalCheck(
        draft: String,
        redTags: List<BrainTag>
    ): SafetyCheckResult {
        val triggeredTags = mutableListOf<String>()
        
        redTags.forEach { tag ->
            if (draft.contains(tag.content, ignoreCase = true)) {
                triggeredTags.add(tag.content)
            }
        }
        
        return if (triggeredTags.isNotEmpty()) {
            SafetyCheckResult(
                isSafe = false,
                triggeredRisks = triggeredTags,
                suggestion = "检测到敏感内容: ${triggeredTags.joinToString(", ")}"
            )
        } else {
            SafetyCheckResult(isSafe = true)
        }
    }
    
    private suspend fun performDeepCheck(
        draft: String,
        redTags: List<BrainTag>
    ): SafetyCheckResult {
        val privacyMapping = privacyRepository.getPrivacyMapping().getOrElse { emptyMap() }
        val maskedDraft = PrivacyEngine.mask(draft, privacyMapping)
        val riskRules = redTags.map { it.content }
        
        return aiRepository.checkDraftSafety(maskedDraft, riskRules).getOrThrow()
    }
}
```

---

## 总结

UseCase开发的核心要点:

1. **五步开发法**:明确场景 → 定义接口 → 实现流程 → 抽取方法 → 编写测试
2. **标准结构**:前置检查 → 数据加载 → 数据清洗 → 业务处理 → 结果返回
3. **设计原则**:单一职责、早返回、防御式编程
4. **协程使用**:所有IO操作都是suspend,不要创建新协程
5. **测试覆盖**:成功场景、失败场景、边界场景

掌握这些原则,你就能编写出高质量的UseCase代码。