---
date_modified: 2025-12-03 20:25:00
---

# 项目架构实施指南 v2.0：共情 AI 助手

|**项目名称**|**版本**|**状态**|**架构模式**|
|---|---|---|---|
|Empathy AI Assistant|v2.0|**Ready for Dev**|Clean Architecture + MVVM|

---

## 1. 核心设计哲学 (Core Philosophy)

本项目是一款**Native Android 辅助工具**，设计必须严格遵循以下原则：

1. **零后端 (Zero-Backend):** 应用本身不维护服务器，无用户账户体系。
    
2. **BYOK (Bring Your Own Key):** 所有的 AI 能力通过用户自备的 API Key（OpenAI/Google/DeepSeek）直连第三方。
    
3. **隐私绝对优先 (Privacy First):** * 敏感数据（聊天记录）必须在本地脱敏后才能发送给 AI。
    
    - Key 必须通过硬件级加密存储。
        
4. **无感接入 (Passive & Active):** 通过悬浮窗和无障碍服务 (Accessibility) 与宿主 App (微信/QQ) 交互，不修改宿主 App 源码。
    

---

## 2. 总体架构设计 (High-Level Architecture)

采用 **Clean Architecture** (整洁架构) 分层，结合 **Hilt** 依赖注入。

### 2.1 技术栈选型 (Tech Stack)

- **语言:** Kotlin
    
- **UI:** Jetpack Compose (用于 App 内部及悬浮窗内容)
    
- **核心服务:** AccessibilityService (屏幕读取), LifecycleService (悬浮窗宿主)
    
- **数据存储:** Room (SQLite), EncryptedSharedPreferences (安全存储)
    
- **网络:** Retrofit 2 + OkHttp (支持动态 BaseURL)
    
- **多模态处理:** FFmpegKit-Android (音视频提取)
    

### 2.2 模块与目录结构 (Project Structure)

建议工程目录严格按照以下结构建立：

Plaintext

```
com.empathy.ai
├── app                 // Application入口, Hilt配置
├── data                // [数据层] 负责数据的获取与持久化
│   ├── local           // Room Database, DAO, EncryptedPrefs
│   ├── remote          // Retrofit Service (含动态URL支持)
│   ├── media           // FFmpeg/MediaCodec 封装实现
│   ├── repository      // Repository 接口的实现类
│   └── model           // Data Entities (DTOs)
│
├── domain              // [领域层] 纯业务逻辑 (无 Android 依赖)
│   ├── model           // 核心业务实体 (Profile, Strategy)
│   ├── repository      // Repository 接口定义
│   ├── usecase         // 核心业务流 (e.g., AnalyzeChatUseCase)
│   └── service         // 领域服务接口
│
├── presentation        // [表现层] UI 与 交互
│   ├── service         // Android Service (Accessibility, FloatingWindow)
│   ├── ui              // Compose Screens (Settings, AnalysisCard)
│   ├── viewmodel       // HiltViewModel (状态管理)
│   └── theme           // Compose Theme
│
└── di                  // Hilt 模块 (NetworkModule, DatabaseModule)
```

---

## 3. 关键模块详细设计 (Detailed Design)

### 3.1 表现层：悬浮窗与 Compose 结合

挑战： Compose 通常依赖 Activity，但悬浮窗需在 Service 中运行。

解决方案： 使用 ComposeView 桥接 WindowManager，并手动管理生命周期。

- **类：** `FloatingWindowService` (继承 `LifecycleService`)
    
- **核心逻辑：**
    
    1. 创建 `ComposeView(context)`。
        
    2. 调用 `setViewCompositionStrategy(DisposeOnViewTreeLifecycleDestroyed)` 防止内存泄漏。
        
    3. `windowManager.addView(composeView, layoutParams)`。
        

### 3.2 抓取层：屏幕内容获取 (The Fetcher)

挑战： 如何获取屏幕外（历史）聊天记录？

类： ScreenFetcher (AccessibilityService)

算法流程 (滚动抓取)：

1. **扫描：** 遍历当前窗口节点，提取所有 `TextView` 内容及坐标。
    
2. **判断：** 若抓取条数 < 设定深度 (e.g., 10条)，寻找可滚动节点 (List/Recycler)。
    
3. **动作：** 执行 `ACTION_SCROLL_BACKWARD` (向下滑动查看旧消息)。
    
4. **去重：** 再次扫描，根据 `text + boundsInScreen` 进行去重合并。
    
5. **循环：** 直至满足条数或无法滚动。
    

### 3.3 数据层：BYOK 动态网络架构

挑战： 用户可能使用不同的 AI 服务商（OpenAI, DeepSeek 等），BaseURL 不固定。

类： AiProviderManager

实现：

- Retrofit 接口定义中使用 `@Url` 注解。
    
- Repository 根据用户配置，动态注入 `baseUrl` 和 `Header (Authorization)`。
    

### 3.4 服务层：业务逻辑编排

**定位**: 服务层位于Domain Layer，是连接表现层和数据层的核心枢纽，封装了应用的业务逻辑和业务规则。

**核心组件**:

| 组件 | 职责 | 示例 |
|------|------|------|
| **UseCase** | 封装单个业务流程 | AnalyzeChatUseCase |
| **Service** | 提供可复用的领域能力 | PrivacyEngine |

**架构特点**:
- ✅ 严格遵循Clean Architecture依赖规则
- ✅ 使用Result<T>统一错误处理
- ✅ 所有IO操作都是suspend函数
- ✅ 依赖Repository接口而非实现

**已实现组件**:
- ✅ **AnalyzeChatUseCase** - 分析聊天场景，生成策略建议
- ✅ **CheckDraftUseCase** - 检查草稿是否触发雷区标签
- ✅ **FeedTextUseCase** - 喂养文本到联系人画像
- ✅ **PrivacyEngine** - 隐私脱敏引擎

**详细文档**:
- [服务层完整设计](./服务层/README.md) - 文档导航与快速开始
- [服务层全局设计](./服务层/服务层全局设计.md) - 架构定位与设计原则
- [服务层开发规范](./服务层/服务层开发规范.md) - 命名与代码组织规范
- [第一模块-核心服务开发](./服务层/第一模块-核心服务开发.md) - UseCase五步开发法
- [第二模块-服务编排](./服务层/第二模块-服务编排.md) - 多Repository协调模式
- [第三模块-业务规则引擎](./服务层/第三模块-业务规则引擎.md) - 规则系统与隐私引擎

### 3.5 媒体层：多模态数据喂养 (新增)

挑战： 处理用户导入的 MP4/MP3，提取纯文本或关键帧。

类： MediaProcessor

实现：

- 集成 `FFmpegKit-Android`。
    
- **音频提取：** `ffmpeg -i input.mp4 -vn -acodec libmp3lame output.mp3` -> 传给 Whisper API。
    
- **关键帧提取：** `ffmpeg -i input.mp4 -vf fps=1/5 frame_%03d.jpg` (每5秒截一帧) -> 传给 Vision API。
    

---

## 4. 安全与隐私架构 (Security & Privacy)

### 4.1 数据脱敏 (Masking)

原则： 原始聊天记录绝不允许直接离开设备。

强制调用链：

所有发送给 AI 的请求，必须经过 PrivacyEngine 处理。建议在 UseCase 层强制执行：

Kotlin

```
// AnalyzeChatUseCase.kt
suspend operator fun invoke(rawText: String): AnalysisResult {
    // 1. 本地脱敏 (核心安全栅栏)
    val maskedText = privacyEngine.mask(rawText, loadPrivacyDict())
    
    // 2. 仅发送脱敏后的文本
    val remoteResult = aiRepository.analyze(maskedText)
    
    // 3. (可选) 本地还原显示
    return remoteResult
}
```

### 4.2 密钥存储

- **严禁**使用普通 `SharedPreferences`。
    
- **必须**使用 Jetpack Security 的 `EncryptedSharedPreferences`。
    

---

## 5. 数据库模型 (Database Schema)

使用 Room 定义本地知识库。

Kotlin

```
// 1. 联系人画像
@Entity(tableName = "profiles")
data class ContactProfile(
    @PrimaryKey val id: String, 
    val name: String, 
    val targetGoal: String, // 长期目标
    val contextDepth: Int = 10 
)

// 2. 策略与雷区 (RAG 核心)
@Entity(tableName = "brain_tags", indices = [Index(value = ["contactId", "type"])])
data class BrainTag(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    val contactId: String,
    val type: String, // "RED"(雷区), "GREEN"(策略)
    val content: String, // e.g., "不喜欢被问薪资"
    val source: String // "MANUAL" or "AI_AUTO"
)
```

---

## 6. 开发路线图 (Roadmap)

|**阶段**|**周期**|**核心任务**|**交付物**|
|---|---|---|---|
|**Phase 1: 骨架**|Week 1|构建 MVVM 结构、FloatingWindowService、基础 Accessibility|能显示的悬浮窗、能抓取当前屏文字的 Log|
|**Phase 2: 大脑**|Week 2|Room 数据库、Settings 页、EncryptedPrefs、FFmpeg 集成|支持配置保存、支持视频/音频转文字流程|
|**Phase 3: 连接**|Week 3|Retrofit 动态 URL、PrivacyEngine 脱敏逻辑、OpenAI/DeepSeek 联调|点击分析 -> 抓取 -> 脱敏 -> AI请求 -> 弹窗结果|
|**Phase 4: 优化**|Week 4|**滚动抓取算法**优化、UI 动画、自动填充文本逻辑|完整的 MVP v2.0|
