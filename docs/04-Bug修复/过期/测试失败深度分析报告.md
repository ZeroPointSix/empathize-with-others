# 测试失败深度分析报告

## 概述

本报告详细分析了 4 个失败测试的根本原因、技术细节和调试建议。

## 测试失败汇总

| # | 测试类 | 测试方法 | 失败率 | 严重程度 | 根本原因类别 |
|---|--------|---------|--------|---------|------------|
| 1 | CheckDraftUseCaseTest | deep check - AI call failure should fallback to local check | 100% | 高 | 业务逻辑不匹配 |
| 2 | BrainTagViewModelPropertyTest | property10SearchResultsShouldOnlyContainMatchingTags | 100% | 高 | 协程调度时序 |
| 3 | ContactListViewModelPropertyTest | property 7 - clearing search should restore all contacts | 100% | 中 | Looper/协程环境 |
| 4 | ContactListViewModelTest | addContact should show error when save fails | 新发现 | 中 | 协程异常处理 |

---

## 测试 1：CheckDraftUseCaseTest - AI 降级逻辑

### 失败信息
```
CheckDraftUseCaseTest > deep check - AI call failure should fallback to local check FAILED
    java.lang.AssertionError at CheckDraftUseCaseTest.kt:261
```

### 测试代码分析

**测试期望**：
```kotlin
// 测试期望：当 AI 调用失败时，应该降级到本地检查
// 本地检查应该检测到 "借钱" 关键词，返回危险结果

val draft = "我想借点钱应急"  // 包含 "借钱" 关键词
coEvery {
    aiRepository.checkDraftSafety(any(), any())
} returns Result.failure(Exception("网络错误"))

// 期望结果：
assertFalse(checkResult.isSafe)  // 应该不安全
assertEquals(1, checkResult.triggeredRisks.size)  // 应该有 1 个触发的风险
assertTrue(checkResult.triggeredRisks.contains("借钱"))  // 应该包含 "借钱"
```

**实际实现**：
```kotlin
// CheckDraftUseCase.kt 的实际逻辑

// 1. 先执行本地检查
val triggeredTags = mutableListOf<String>()
redTags.forEach { tag ->
    if (draftSnapshot.contains(tag.content, ignoreCase = true)) {
        triggeredTags.add(tag.content)
    }
}

// 2. 如果本地匹配命中，立即返回危险
if (triggeredTags.isNotEmpty()) {
    return Result.success(
        SafetyCheckResult(
            isSafe = false,
            triggeredRisks = triggeredTags,
            suggestion = "检测到敏感内容: ${triggeredTags.joinToString(", ")}"
        )
    )
}

// 3. 只有本地检查通过后，才会执行 AI 检查
if (enableDeepCheck) {
    // ... AI 检查逻辑
    return deepCheckResult.fold(
        onSuccess = { Result.success(it) },
        onFailure = { 
            // 降级：AI 失败时返回本地检查结果（安全）
            Result.success(SafetyCheckResult(isSafe = true))
        }
    )
}
```

### 问题根源

**核心矛盾**：测试期望与实际实现的逻辑流程不一致

1. **测试期望的流程**：
   ```
   本地检查（未命中） → AI 检查（失败） → 降级到本地检查（命中）
   ```

2. **实际实现的流程**：
   ```
   本地检查（命中） → 立即返回危险 → 不执行 AI 检查
   ```

**关键发现**：
- 当草稿包含 "借钱" 关键词时，本地检查会立即命中并返回
- 代码永远不会执行到 AI 检查的降级逻辑
- 测试用例设计的场景在实际代码中不可能发生

### 失败原因

测试断言失败的具体位置（第 261 行）可能是以下之一：

1. `assertFalse(checkResult.isSafe)` - 如果实际返回了 `isSafe = true`
2. `assertEquals(1, checkResult.triggeredRisks.size)` - 如果触发的风险数量不是 1
3. `assertTrue(checkResult.triggeredRisks.contains("借钱"))` - 如果没有包含 "借钱"

**最可能的情况**：测试实际上通过了本地检查，但测试的断言或 Mock 配置有问题。

### 调试建议

#### 方案 1：修改测试用例（推荐）

将测试改为验证实际的降级场景：

```kotlin
@Test
fun `deep check - AI call failure should fallback to safe when no local match`() = runTest {
    // Given: 草稿不包含本地关键词
    val redTags = listOf(
        BrainTag(
            id = 1,
            contactId = "contact_1",
            content = "借钱",  // 本地关键词
            type = TagType.RISK_RED
        )
    )
    coEvery { brainTagRepository.getTagsForContact("contact_1") } returns flowOf(redTags)
    coEvery { privacyRepository.getPrivacyMapping() } returns Result.success(emptyMap())

    // 草稿不包含 "借钱"，但可能有语义风险
    val draft = "能不能帮我一个忙，我需要一些资金周转"
    
    // AI 检查失败
    coEvery {
        aiRepository.checkDraftSafety(any(), any())
    } returns Result.failure(Exception("网络错误"))

    // When
    val result = useCase(
        contactId = "contact_1",
        draftSnapshot = draft,
        enableDeepCheck = true
    )

    // Then - 应该降级到安全（因为本地检查未命中）
    assertTrue(result.isSuccess)
    val checkResult = result.getOrNull()!!
    assertTrue(checkResult.isSafe)  // 降级返回安全
}
```

#### 方案 2：修改实现逻辑

如果测试的期望是正确的，需要修改 `CheckDraftUseCase` 的实现：

```kotlin
suspend operator fun invoke(
    contactId: String,
    draftSnapshot: String,
    enableDeepCheck: Boolean = false
): Result<SafetyCheckResult> {
    return try {
        val redTags = brainTagRepository.getTagsForContact(contactId)
            .first()
            .filter { it.type == TagType.RISK_RED }

        if (redTags.isEmpty()) {
            return Result.success(SafetyCheckResult(isSafe = true))
        }

        // 先执行本地检查，但不立即返回
        val localTriggeredTags = mutableListOf<String>()
        redTags.forEach { tag ->
            if (draftSnapshot.contains(tag.content, ignoreCase = true)) {
                localTriggeredTags.add(tag.content)
            }
        }

        // 如果启用深度检查，尝试 AI 检查
        if (enableDeepCheck) {
            val privacyMapping = privacyRepository.getPrivacyMapping().getOrElse { emptyMap() }
            val maskedDraft = PrivacyEngine.mask(draftSnapshot, privacyMapping)
            val riskRules = redTags.map { it.content }
            
            val deepCheckResult = aiRepository.checkDraftSafety(maskedDraft, riskRules)
            
            return deepCheckResult.fold(
                onSuccess = { Result.success(it) },
                onFailure = { 
                    // 降级：返回本地检查结果
                    if (localTriggeredTags.isNotEmpty()) {
                        Result.success(
                            SafetyCheckResult(
                                isSafe = false,
                                triggeredRisks = localTriggeredTags,
                                suggestion = "检测到敏感内容: ${localTriggeredTags.joinToString(", ")}"
                            )
                        )
                    } else {
                        Result.success(SafetyCheckResult(isSafe = true))
                    }
                }
            )
        }

        // 未启用深度检查，返回本地检查结果
        if (localTriggeredTags.isNotEmpty()) {
            Result.success(
                SafetyCheckResult(
                    isSafe = false,
                    triggeredRisks = localTriggeredTags,
                    suggestion = "检测到敏感内容: ${localTriggeredTags.joinToString(", ")}"
                )
            )
        } else {
            Result.success(SafetyCheckResult(isSafe = true))
        }
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

#### 方案 3：添加调试日志

在测试中添加详细的调试输出：

```kotlin
@Test
fun `deep check - AI call failure should fallback to local check`() = runTest {
    // ... setup code ...

    // When
    val result = useCase(
        contactId = "contact_1",
        draftSnapshot = draft,
        enableDeepCheck = true
    )

    // Debug output
    println("Result isSuccess: ${result.isSuccess}")
    println("Result value: ${result.getOrNull()}")
    println("Result exception: ${result.exceptionOrNull()}")
    
    val checkResult = result.getOrNull()!!
    println("isSafe: ${checkResult.isSafe}")
    println("triggeredRisks: ${checkResult.triggeredRisks}")
    println("suggestion: ${checkResult.suggestion}")

    // Then - 应该被本地检查捕获为危险
    assertTrue(result.isSuccess)
    assertFalse(checkResult.isSafe)
    assertEquals(1, checkResult.triggeredRisks.size)
    assertTrue(checkResult.triggeredRisks.contains("借钱"))
}
```

### 推荐行动

1. **立即行动**：添加调试日志，确定实际返回值
2. **短期修复**：根据调试结果，选择方案 1 或方案 2
3. **长期改进**：明确降级策略的业务需求，更新设计文档

---


## 测试 2：BrainTagViewModelPropertyTest - 搜索过滤

### 失败信息
```
BrainTagViewModelPropertyTest > property10SearchResultsShouldOnlyContainMatchingTags FAILED
    java.lang.AssertionError at BrainTagViewModelPropertyTest.kt:302
```

### 测试代码分析

**测试逻辑**：
```kotlin
checkAll(iterations = 100,
    Arb.brainTagList(5..15),  // 生成 5-15 个标签
    Arb.string(1..10, Codepoint.alphanumeric())  // 生成 1-10 字符的查询
) { tags, query ->
    // Given: 准备标签列表
    val tagsFlow = MutableStateFlow(tags)
    coEvery { getBrainTagsUseCase("") } returns tagsFlow

    val viewModel = BrainTagViewModel(...)
    runCurrent()
    advanceUntilIdle()

    // When: 激活搜索并输入查询
    viewModel.onEvent(
        BrainTagUiEvent.ManageSearch(active = true, query = query)
    )
    advanceUntilIdle()

    // Then: 验证搜索结果
    val results = searchState.results
    results.forEach { tag ->
        assertTrue(
            tag.content.contains(query, ignoreCase = true),
            "搜索结果中的标签 '${tag.content}' 应该包含查询文本 '$query'"
        )
    }
}
```

### 问题根源

#### 1. 协程调度时序问题

**ViewModel 的搜索实现**：
```kotlin
private fun manageSearch(active: Boolean, query: String?) {
    if (active) {
        val searchQuery = query ?: _uiState.value.searchState.query
        _uiState.update {
            it.copy(
                searchState = it.searchState.copy(
                    isActive = true,
                    query = searchQuery
                )
            )
        }
        
        // 更新搜索 Flow（会触发防抖搜索）
        searchQueryFlow.value = searchQuery  // ← 异步触发
    }
}

// 搜索防抖设置
searchQueryFlow
    .debounce(300)  // ← 300ms 延迟
    .distinctUntilChanged()
    .onEach { query ->
        withContext(Dispatchers.Default) {  // ← 后台线程
            if (query.isNotBlank()) {
                performSearch(query)  // ← 实际搜索
            }
        }
    }
    .launchIn(viewModelScope)
```

**时序问题**：
1. 测试调用 `viewModel.onEvent(ManageSearch(...))`
2. `searchQueryFlow.value = searchQuery` 触发 Flow
3. 测试调用 `advanceUntilIdle()`
4. **但是**：`debounce(300)` 需要 300ms 延迟
5. **但是**：`withContext(Dispatchers.Default)` 在不同的调度器上
6. 测试立即检查结果，但搜索可能还未完成

#### 2. 测试数据生成问题

**标签内容生成**：
```kotlin
private fun Arb.Companion.brainTagList(size: IntRange = 1..10): Arb<List<BrainTag>> = arbitrary {
    val count = Arb.int(size).bind()
    
    (1..count).map { index ->
        BrainTag(
            id = index.toLong(),
            contactId = Arb.uuid().bind().toString(),
            content = "Tag_$index",  // ← 固定格式：Tag_1, Tag_2, ...
            type = Arb.tagType().bind(),
            source = "MANUAL"
        )
    }
}
```

**查询生成**：
```kotlin
Arb.string(1..10, Codepoint.alphanumeric())  // ← 随机字母数字字符串
```

**匹配问题**：
- 标签内容：`Tag_1`, `Tag_2`, `Tag_3`, ...
- 查询可能是：`abc`, `xyz`, `123`, ...
- 大部分随机查询不会匹配任何标签
- 当查询不匹配时，`results` 应该为空
- 但如果搜索未完成，`results` 可能包含旧数据或所有标签

#### 3. 第 302 行的具体断言

查看代码，第 302 行可能是：
```kotlin
results.forEach { tag ->
    assertTrue(
        tag.content.contains(query, ignoreCase = true),
        "搜索结果中的标签 '${tag.content}' 应该包含查询文本 '$query'"  // ← 第 302 行
    )
}
```

**失败场景**：
- 查询：`"abc"`
- 标签：`Tag_1`, `Tag_2`, `Tag_3`
- 期望结果：空列表（没有匹配）
- 实际结果：`[Tag_1, Tag_2, Tag_3]`（搜索未执行，显示所有标签）
- 断言失败：`Tag_1` 不包含 `"abc"`

### 调试建议

#### 方案 1：修复测试的协程调度（推荐）

```kotlin
@Test
fun property10SearchResultsShouldOnlyContainMatchingTags() = testScope.runTest {
    checkAll(iterations = 100,
        Arb.brainTagList(5..15),
        Arb.string(1..10, Codepoint.alphanumeric())
    ) { tags, query ->
        // Given: 准备标签列表
        val tagsFlow = MutableStateFlow(tags)
        coEvery { getBrainTagsUseCase("") } returns tagsFlow

        val viewModel = BrainTagViewModel(
            getBrainTagsUseCase,
            saveBrainTagUseCase,
            deleteBrainTagUseCase
        )
        
        runCurrent()
        advanceUntilIdle()

        // When: 激活搜索并输入查询
        viewModel.onEvent(
            BrainTagUiEvent.ManageSearch(
                active = true,
                query = query
            )
        )
        
        // ← 关键：等待防抖延迟
        advanceTimeBy(301)  // 超过 300ms 防抖
        advanceUntilIdle()  // 等待所有协程完成

        // Then: 验证搜索状态
        val searchState = viewModel.uiState.value.searchState
        
        // 添加调试输出
        if (searchState.results.isNotEmpty()) {
            println("Query: '$query'")
            println("Tags: ${tags.map { it.content }}")
            println("Results: ${searchState.results.map { it.content }}")
        }
        
        assertTrue(searchState.isActive, "搜索应该被激活")
        assertEquals(query, searchState.query, "搜索查询应该匹配输入")

        // Then: 验证搜索结果
        val results = searchState.results
        results.forEach { tag ->
            assertTrue(
                tag.content.contains(query, ignoreCase = true),
                """
                搜索结果验证失败:
                - 查询: '$query'
                - 标签: '${tag.content}'
                - 所有标签: ${tags.map { it.content }}
                - 搜索结果: ${results.map { it.content }}
                """.trimIndent()
            )
        }

        // 验证所有匹配的标签都在结果中
        val expectedMatches = tags.filter { tag ->
            tag.content.contains(query, ignoreCase = true)
        }
        assertEquals(
            expectedMatches.size,
            results.size,
            "搜索结果数量应该等于匹配的标签数量"
        )
    }
}
```

#### 方案 2：改进测试数据生成

确保查询能够匹配标签：

```kotlin
@Test
fun property10SearchResultsShouldOnlyContainMatchingTags() = testScope.runTest {
    checkAll(iterations = 100, Arb.brainTagList(5..15)) { tags ->
        // 跳过空列表
        if (tags.isEmpty()) return@checkAll
        
        // 从现有标签中选择一个，提取部分内容作为查询
        val randomTag = tags.random()
        val query = randomTag.content.take(3)  // 取前 3 个字符
        
        // Given: 准备标签列表
        val tagsFlow = MutableStateFlow(tags)
        coEvery { getBrainTagsUseCase("") } returns tagsFlow

        val viewModel = BrainTagViewModel(...)
        runCurrent()
        advanceUntilIdle()

        // When: 激活搜索
        viewModel.onEvent(
            BrainTagUiEvent.ManageSearch(active = true, query = query)
        )
        advanceTimeBy(301)
        advanceUntilIdle()

        // Then: 至少应该匹配一个标签（我们选择的那个）
        val results = viewModel.uiState.value.searchState.results
        assertTrue(
            results.isNotEmpty(),
            "应该至少匹配一个标签"
        )
        assertTrue(
            results.any { it.id == randomTag.id },
            "应该包含我们选择的标签"
        )
        
        // 验证所有结果都匹配查询
        results.forEach { tag ->
            assertTrue(
                tag.content.contains(query, ignoreCase = true),
                "标签 '${tag.content}' 应该包含查询 '$query'"
            )
        }
    }
}
```

#### 方案 3：使用 UnconfinedTestDispatcher

```kotlin
@OptIn(ExperimentalCoroutinesApi::class)
class BrainTagViewModelPropertyTest {
    // 使用 UnconfinedTestDispatcher 立即执行协程
    private val testDispatcher = UnconfinedTestDispatcher()
    private val testScope = TestScope(testDispatcher)

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
        // ...
    }
    
    // 测试中不需要 advanceTimeBy，协程会立即执行
}
```

**注意**：`UnconfinedTestDispatcher` 会立即执行协程，但可能跳过防抖逻辑。

### 推荐行动

1. **立即行动**：添加 `advanceTimeBy(301)` 等待防抖
2. **短期修复**：添加详细的调试输出，确认时序问题
3. **中期改进**：改进测试数据生成，确保有匹配的标签
4. **长期优化**：考虑将防抖逻辑提取为可测试的组件

---


## 测试 3：ContactListViewModelPropertyTest - Looper 错误

### 失败信息
```
ContactListViewModelPropertyTest > property 7 - clearing search should restore all contacts FAILED
    kotlinx.coroutines.CoroutinesInternalError at DispatchedTask.kt:132
        Caused by: java.lang.IllegalStateException at MainDispatchers.kt:111
            Caused by: java.lang.RuntimeException at Looper.java:-1
```

### 错误堆栈分析

这是一个典型的 Android Looper 相关错误，发生在协程测试环境中。

**错误链**：
1. `RuntimeException at Looper.java` - Android Looper 异常
2. `IllegalStateException at MainDispatchers.kt:111` - Main dispatcher 状态异常
3. `CoroutinesInternalError at DispatchedTask.kt:132` - 协程内部错误

### 问题根源

#### 1. Looper 错误的常见原因

在 Android 单元测试中，`Looper` 错误通常由以下原因引起：

**原因 A：尝试访问 Android 主线程**
```kotlin
// 某些代码尝试在主线程上执行
Dispatchers.Main  // ← 在单元测试中可能不可用
```

**原因 B：测试环境未正确设置 Main dispatcher**
```kotlin
// 测试类中缺少或配置错误
@Before
fun setup() {
    Dispatchers.setMain(testDispatcher)  // ← 必须设置
}
```

**原因 C：使用了 Android 特定的 API**
```kotlin
// 例如：Handler, Looper, MessageQueue 等
Handler(Looper.getMainLooper())  // ← 在单元测试中不可用
```

#### 2. 当前测试的配置

```kotlin
@OptIn(ExperimentalCoroutinesApi::class)
class ContactListViewModelPropertyTest {
    // 使用 UnconfinedTestDispatcher
    private val testDispatcher = UnconfinedTestDispatcher()

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)  // ← 已正确设置
        // ...
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()  // ← 已正确清理
    }
}
```

配置看起来是正确的，但仍然出现 Looper 错误。

#### 3. 测试代码分析

```kotlin
@Test
fun `property 7 - clearing search should restore all contacts`() = runTest {
    checkAll(iterations = 100, Arb.contactList(3..10)) { contacts ->
        // Given: 准备测试数据
        coEvery { getAllContactsUseCase() } returns flowOf(contacts)

        val viewModel = ContactListViewModel(
            getAllContactsUseCase,
            deleteContactUseCase,
            saveProfileUseCase
        )
        advanceUntilIdle()  // ← 可能在这里触发 Looper 错误

        // ... 测试逻辑 ...
    }
}
```

#### 4. 可能的触发点

**ContactListViewModel 的初始化**：
```kotlin
@HiltViewModel
class ContactListViewModel @Inject constructor(
    private val getAllContactsUseCase: GetAllContactsUseCase,
    // ...
) : ViewModel() {

    init {
        // ViewModel 创建时自动加载数据
        loadContacts()  // ← 可能触发协程
        setupSearchDebounce()  // ← 设置防抖
    }
    
    private fun setupSearchDebounce() {
        searchQueryFlow
            .debounce(300)
            .distinctUntilChanged()
            .onEach { query ->
                withContext(Dispatchers.Default) {  // ← 切换调度器
                    // ...
                }
            }
            .launchIn(viewModelScope)  // ← 在 viewModelScope 中启动
    }
}
```

**问题**：
- `viewModelScope` 默认使用 `Dispatchers.Main.immediate`
- 在测试环境中，如果 Main dispatcher 配置不当，可能触发 Looper 错误
- `runTest` 创建的 TestScope 与 `viewModelScope` 可能不兼容

### 调试建议

#### 方案 1：使用 StandardTestDispatcher（推荐）

```kotlin
@OptIn(ExperimentalCoroutinesApi::class)
class ContactListViewModelPropertyTest {
    // 改用 StandardTestDispatcher
    private val testDispatcher = StandardTestDispatcher()

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
        // ...
    }

    @Test
    fun `property 7 - clearing search should restore all contacts`() = runTest {
        checkAll(iterations = 100, Arb.contactList(3..10)) { contacts ->
            // Given
            coEvery { getAllContactsUseCase() } returns flowOf(contacts)

            val viewModel = ContactListViewModel(
                getAllContactsUseCase,
                deleteContactUseCase,
                saveProfileUseCase
            )
            
            // 使用 testScheduler 推进时间
            testScheduler.advanceUntilIdle()

            // 验证初始状态
            assertEquals(contacts.size, viewModel.uiState.value.contacts.size)

            // When: 激活搜索
            viewModel.onEvent(ContactListUiEvent.ManageSearch(active = true, query = "test"))
            testScheduler.advanceTimeBy(301)  // 等待防抖
            testScheduler.advanceUntilIdle()

            // Then: 搜索应该激活
            assertTrue(viewModel.uiState.value.searchState.isActive)

            // When: 关闭搜索
            viewModel.onEvent(ContactListUiEvent.ManageSearch(active = false))
            testScheduler.advanceUntilIdle()

            // Then: 验证结果
            assertFalse(viewModel.uiState.value.searchState.isActive)
            assertEquals("", viewModel.uiState.value.searchState.query)
            assertEquals(contacts.size, viewModel.uiState.value.displayContacts.size)
        }
    }
}
```

#### 方案 2：隔离 ViewModel 创建

```kotlin
@Test
fun `property 7 - clearing search should restore all contacts`() = runTest {
    checkAll(iterations = 100, Arb.contactList(3..10)) { contacts ->
        // 在 runTest 的作用域内创建 ViewModel
        val viewModel = runBlocking(testDispatcher) {
            coEvery { getAllContactsUseCase() } returns flowOf(contacts)
            
            ContactListViewModel(
                getAllContactsUseCase,
                deleteContactUseCase,
                saveProfileUseCase
            )
        }
        
        advanceUntilIdle()
        
        // ... 测试逻辑 ...
    }
}
```

#### 方案 3：使用 TestCoroutineScope（旧 API）

```kotlin
@OptIn(ExperimentalCoroutinesApi::class)
class ContactListViewModelPropertyTest {
    private val testDispatcher = StandardTestDispatcher()
    private val testScope = TestScope(testDispatcher)

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
        // ...
    }

    @Test
    fun `property 7 - clearing search should restore all contacts`() {
        // 不使用 runTest，直接在 testScope 中运行
        testScope.runTest {
            checkAll(iterations = 100, Arb.contactList(3..10)) { contacts ->
                // ... 测试逻辑 ...
            }
        }
    }
}
```

#### 方案 4：检查 ViewModel 依赖

确保 ViewModel 不依赖 Android 特定的组件：

```kotlin
// 检查 ContactListViewModel 及其依赖
// 确保没有使用：
// - Handler
// - Looper
// - MessageQueue
// - 任何需要 Android Context 的组件
```

#### 方案 5：添加 Robolectric（如果必要）

如果 ViewModel 确实需要 Android 组件：

```kotlin
// build.gradle.kts
testImplementation("org.robolectric:robolectric:4.11.1")

// 测试类
@RunWith(RobolectricTestRunner::class)
@Config(sdk = [28])
class ContactListViewModelPropertyTest {
    // ... 测试代码 ...
}
```

### 推荐行动

1. **立即行动**：将 `UnconfinedTestDispatcher` 改为 `StandardTestDispatcher`
2. **短期修复**：添加 try-catch 捕获异常，打印详细堆栈
3. **中期改进**：检查 ViewModel 及其依赖，移除 Android 特定代码
4. **长期优化**：考虑使用依赖注入提供可测试的 Dispatcher

### 特别注意

**Release 构建失败，Debug 构建可能通过**：
- 这表明问题可能与构建配置或优化有关
- Release 构建可能使用不同的协程调度策略
- 建议在两种构建类型下都进行测试

---


## 测试 4：ContactListViewModelTest - 协程异常处理

### 失败信息
```
ContactListViewModelTest > addContact should show error when save fails FAILED
    kotlinx.coroutines.test.UncaughtExceptionsBeforeTest at ContactListViewModelTest.kt:113
```

### 错误分析

`UncaughtExceptionsBeforeTest` 是 kotlinx-coroutines-test 库特有的错误，表示在测试开始前有未捕获的协程异常。

### 问题根源

#### 1. 协程异常传播

在协程测试中，未捕获的异常会被收集并在测试结束时报告：

```kotlin
@Test
fun `addContact should show error when save fails`() = runTest {
    // Given
    coEvery { saveProfileUseCase(any()) } returns Result.failure(Exception("保存失败"))

    val viewModel = ContactListViewModel(...)
    
    // When
    viewModel.onEvent(ContactListUiEvent.AddContact(...))
    advanceUntilIdle()

    // Then
    // 如果 ViewModel 中有未捕获的异常，测试会失败
}
```

#### 2. 可能的异常来源

**ViewModel 初始化时的异常**：
```kotlin
init {
    loadContacts()  // ← 如果这里抛出异常
    setupSearchDebounce()
}

private fun loadContacts() {
    viewModelScope.launch {
        try {
            getAllContactsUseCase().collect { contacts ->
                _uiState.update { it.copy(contacts = contacts) }
            }
        } catch (e: Exception) {
            // 如果没有 catch，异常会传播
            _uiState.update { it.copy(error = e.message) }
        }
    }
}
```

**事件处理中的异常**：
```kotlin
private fun addContact() {
    viewModelScope.launch {
        // 如果这里抛出异常且未捕获
        val result = saveProfileUseCase(profile)
        result.onFailure { error ->
            _uiState.update { it.copy(error = error.message) }
        }
    }
}
```

#### 3. 测试环境的异常处理

在 `runTest` 中，所有协程异常都会被收集：

```kotlin
runTest {
    // 任何在这个作用域内启动的协程
    // 如果抛出未捕获的异常
    // 都会导致测试失败
    
    val viewModel = ContactListViewModel(...)  // ← 可能在 init 中抛出异常
    advanceUntilIdle()  // ← 等待所有协程完成，收集异常
}
```

### 调试建议

#### 方案 1：添加异常捕获（推荐）

确保 ViewModel 中所有协程都有异常处理：

```kotlin
private fun loadContacts() {
    viewModelScope.launch {
        try {
            _uiState.update { it.copy(isLoading = true, error = null) }
            
            getAllContactsUseCase().collect { contacts ->
                _uiState.update { 
                    it.copy(
                        isLoading = false,
                        contacts = contacts
                    )
                }
            }
        } catch (e: Exception) {
            // 捕获所有异常
            _uiState.update { 
                it.copy(
                    isLoading = false,
                    error = e.message ?: "加载联系人失败"
                )
            }
        }
    }
}

private fun addContact() {
    viewModelScope.launch {
        try {
            _uiState.update { it.copy(isLoading = true, error = null) }
            
            val profile = createProfileFromState()
            val result = saveProfileUseCase(profile)
            
            result.onSuccess {
                _uiState.update { 
                    it.copy(
                        isLoading = false,
                        // 清空输入等
                    )
                }
            }.onFailure { error ->
                _uiState.update { 
                    it.copy(
                        isLoading = false,
                        error = error.message ?: "保存失败"
                    )
                }
            }
        } catch (e: Exception) {
            // 捕获意外异常
            _uiState.update { 
                it.copy(
                    isLoading = false,
                    error = e.message ?: "操作失败"
                )
            }
        }
    }
}
```

#### 方案 2：使用 CoroutineExceptionHandler

```kotlin
@HiltViewModel
class ContactListViewModel @Inject constructor(
    private val getAllContactsUseCase: GetAllContactsUseCase,
    // ...
) : ViewModel() {

    // 定义异常处理器
    private val exceptionHandler = CoroutineExceptionHandler { _, exception ->
        _uiState.update { 
            it.copy(
                isLoading = false,
                error = exception.message ?: "未知错误"
            )
        }
    }

    // 使用自定义的 scope
    private val customScope = ViewModel Scope + exceptionHandler

    private fun loadContacts() {
        customScope.launch {
            // 即使抛出异常，也会被 exceptionHandler 捕获
            getAllContactsUseCase().collect { contacts ->
                _uiState.update { it.copy(contacts = contacts) }
            }
        }
    }
}
```

#### 方案 3：修改测试以处理异常

```kotlin
@Test
fun `addContact should show error when save fails`() = runTest {
    // Given
    val exception = Exception("保存失败")
    coEvery { saveProfileUseCase(any()) } returns Result.failure(exception)

    // 创建 ViewModel 前设置异常处理
    val exceptionHandler = CoroutineExceptionHandler { _, throwable ->
        println("Caught exception: ${throwable.message}")
    }

    val viewModel = ContactListViewModel(...)
    
    // 等待初始化完成
    advanceUntilIdle()

    // When
    viewModel.onEvent(ContactListUiEvent.AddContact(...))
    advanceUntilIdle()

    // Then
    assertNotNull(viewModel.uiState.value.error)
    assertTrue(viewModel.uiState.value.error!!.contains("保存失败"))
}
```

#### 方案 4：检查 Mock 配置

确保 Mock 对象正确配置：

```kotlin
@Before
fun setup() {
    getAllContactsUseCase = mockk()
    deleteContactUseCase = mockk()
    saveProfileUseCase = mockk()
    
    // 设置默认行为，避免未配置的调用抛出异常
    coEvery { getAllContactsUseCase() } returns flowOf(emptyList())
    coEvery { deleteContactUseCase(any()) } returns Result.success(Unit)
    coEvery { saveProfileUseCase(any()) } returns Result.success(Unit)
}

@Test
fun `addContact should show error when save fails`() = runTest {
    // 覆盖默认行为
    coEvery { saveProfileUseCase(any()) } returns Result.failure(Exception("保存失败"))
    
    // ... 测试逻辑 ...
}
```

#### 方案 5：添加详细的调试日志

```kotlin
@Test
fun `addContact should show error when save fails`() = runTest {
    println("=== Test Start ===")
    
    try {
        // Given
        coEvery { getAllContactsUseCase() } returns flowOf(emptyList())
        coEvery { saveProfileUseCase(any()) } returns Result.failure(Exception("保存失败"))
        
        println("Creating ViewModel...")
        val viewModel = ContactListViewModel(
            getAllContactsUseCase,
            deleteContactUseCase,
            saveProfileUseCase
        )
        
        println("Advancing until idle...")
        advanceUntilIdle()
        
        println("Initial state: ${viewModel.uiState.value}")
        
        // When
        println("Triggering AddContact event...")
        viewModel.onEvent(ContactListUiEvent.AddContact(...))
        
        println("Advancing until idle...")
        advanceUntilIdle()
        
        println("Final state: ${viewModel.uiState.value}")
        
        // Then
        assertNotNull(viewModel.uiState.value.error)
        
        println("=== Test End ===")
    } catch (e: Exception) {
        println("=== Test Failed ===")
        println("Exception: ${e.message}")
        e.printStackTrace()
        throw e
    }
}
```

### 推荐行动

1. **立即行动**：添加详细的调试日志，找出异常来源
2. **短期修复**：在 ViewModel 的所有协程中添加 try-catch
3. **中期改进**：使用 CoroutineExceptionHandler 统一处理异常
4. **长期优化**：建立统一的错误处理机制

---

## 总结与建议

### 测试失败的共同模式

1. **协程调度时序问题**（测试 2, 3）
   - 防抖延迟未等待
   - 不同 Dispatcher 之间的切换
   - TestScope 与 ViewModelScope 的不兼容

2. **测试期望与实现不匹配**（测试 1）
   - 测试假设的业务流程与实际实现不一致
   - 需要明确业务需求和降级策略

3. **异常处理不完善**（测试 4）
   - 协程中的异常未被捕获
   - 测试环境对异常更敏感

### 优先级建议

| 优先级 | 测试 | 预计修复时间 | 影响范围 |
|--------|------|------------|---------|
| P0 | 测试 1 | 1-2 小时 | 核心业务逻辑 |
| P0 | 测试 2 | 2-3 小时 | 搜索功能 |
| P1 | 测试 3 | 3-4 小时 | 测试基础设施 |
| P1 | 测试 4 | 1-2 小时 | 错误处理 |

### 通用调试策略

1. **添加详细日志**
   ```kotlin
   println("State before: ${viewModel.uiState.value}")
   println("Event: $event")
   println("State after: ${viewModel.uiState.value}")
   ```

2. **隔离问题**
   - 创建最小可复现的测试用例
   - 逐步添加复杂性，找出失败点

3. **验证假设**
   - 使用断点调试
   - 检查 Mock 对象的调用次数和参数

4. **查看测试报告**
   ```bash
   # 查看详细的测试报告
   open app/build/reports/tests/testDebugUnitTest/index.html
   ```

### 长期改进建议

1. **建立测试最佳实践文档**
   - 协程测试的标准模式
   - Mock 配置的最佳实践
   - 常见问题和解决方案

2. **改进测试基础设施**
   - 创建测试工具类
   - 统一的测试 Dispatcher 配置
   - 可复用的测试数据生成器

3. **增强错误处理**
   - 统一的异常处理机制
   - 更好的错误消息
   - 降级策略的明确定义

4. **持续集成优化**
   - 在 CI 中运行测试
   - 测试失败时的自动通知
   - 测试覆盖率报告

---

## 附录：快速参考

### 协程测试常用 API

```kotlin
// 创建测试调度器
val testDispatcher = StandardTestDispatcher()
val testDispatcher = UnconfinedTestDispatcher()

// 设置 Main dispatcher
Dispatchers.setMain(testDispatcher)
Dispatchers.resetMain()

// 推进时间
testScheduler.advanceTimeBy(100)
testScheduler.advanceUntilIdle()
runCurrent()

// 运行测试
runTest { /* 测试代码 */ }
testScope.runTest { /* 测试代码 */ }
```

### Mock 配置模板

```kotlin
@Before
fun setup() {
    // 创建 Mock
    repository = mockk()
    
    // 设置默认行为
    coEvery { repository.getData() } returns flowOf(emptyList())
    coEvery { repository.saveData(any()) } returns Result.success(Unit)
    
    // 设置 relaxed mock（自动返回默认值）
    repository = mockk(relaxed = true)
}
```

### 调试检查清单

- [ ] 是否正确设置了 `Dispatchers.setMain()`？
- [ ] 是否等待了足够的时间（`advanceTimeBy`）？
- [ ] 是否等待了所有协程完成（`advanceUntilIdle`）？
- [ ] Mock 对象是否正确配置？
- [ ] 是否有未捕获的异常？
- [ ] 测试期望是否与实现一致？
- [ ] 是否添加了调试日志？
- [ ] 是否查看了详细的测试报告？

