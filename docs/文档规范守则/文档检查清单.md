# æ–‡æ¡£æ£€æŸ¥æ¸…å•

**ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-12-08  
**æœ€åæ›´æ–°**: 2025-12-08  
**æ›´æ–°äºº**: AI Assistant  
**çŠ¶æ€**: æ´»è·ƒ  
**é€‚ç”¨å›¢é˜Ÿ**: 5äººä»¥ä¸‹å°å›¢é˜Ÿ  
**å¼€å‘å‘¨æœŸ**: 1å‘¨è¿­ä»£  

---

## ğŸ“‹ æ£€æŸ¥æ¸…å•æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†è½»é‡çº§ã€é«˜æ•ˆçš„æ–‡æ¡£è´¨é‡æ£€æŸ¥æ¸…å•ï¼Œä¸“ä¸ºå°å›¢é˜Ÿã€å¿«é€Ÿè¿­ä»£ã€Markdown+Gitå·¥å…·é“¾è®¾è®¡ï¼Œç¡®ä¿3åˆ†é’Ÿå†…å®Œæˆæ–‡æ¡£è´¨é‡æ£€æŸ¥ã€‚

### æ£€æŸ¥ç›®æ ‡

1. **å¿«é€Ÿè¯„ä¼°**ï¼š3åˆ†é’Ÿå†…å®Œæˆæ–‡æ¡£è´¨é‡æ£€æŸ¥
2. **æ ‡å‡†åŒ–æ£€æŸ¥**ï¼šç»Ÿä¸€çš„æ£€æŸ¥æ ‡å‡†å’Œæµç¨‹
3. **è‡ªåŠ¨åŒ–ä¼˜å…ˆ**ï¼šåˆ©ç”¨å·¥å…·å‡å°‘äººå·¥æ£€æŸ¥å·¥ä½œé‡
4. **æŒç»­æ”¹è¿›**ï¼šåŸºäºæ£€æŸ¥ç»“æœæŒç»­ä¼˜åŒ–æ–‡æ¡£è´¨é‡

---

## âš¡ 3åˆ†é’Ÿå¿«é€Ÿæ£€æŸ¥æµç¨‹

### ç¬¬1åˆ†é’Ÿï¼šè‡ªåŠ¨åŒ–æ£€æŸ¥

è¿è¡Œè‡ªåŠ¨åŒ–è„šæœ¬è¿›è¡ŒåŸºç¡€æ£€æŸ¥ï¼š

```bash
#!/bin/bash
# 3åˆ†é’Ÿæ–‡æ¡£è´¨é‡æ£€æŸ¥è„šæœ¬

echo "å¼€å§‹3åˆ†é’Ÿæ–‡æ¡£è´¨é‡æ£€æŸ¥..."

# 1. Markdownæ ¼å¼æ£€æŸ¥ï¼ˆ20ç§’ï¼‰
echo "1. æ£€æŸ¥Markdownæ ¼å¼..."
START_TIME=$(date +%s)
find docs -name "*.md" -exec markdownlint {} \;
FORMAT_ERRORS=$?
FORMAT_TIME=$(date +%s)
FORMAT_DURATION=$((FORMAT_TIME - START_TIME))

# 2. é“¾æ¥æœ‰æ•ˆæ€§æ£€æŸ¥ï¼ˆ30ç§’ï¼‰
echo "2. æ£€æŸ¥é“¾æ¥æœ‰æ•ˆæ€§..."
START_TIME=$(date +%s)
find docs -name "*.md" -exec markdown-link-check {} \;
LINK_ERRORS=$?
LINK_TIME=$(date +%s)
LINK_DURATION=$((LINK_TIME - START_TIME))

# 3. å…ƒä¿¡æ¯å®Œæ•´æ€§æ£€æŸ¥ï¼ˆ20ç§’ï¼‰
echo "3. æ£€æŸ¥å…ƒä¿¡æ¯å®Œæ•´æ€§..."
START_TIME=$(date +%s)
python scripts/check-metadata.py docs/ > /tmp/metadata_check.txt
METADATA_ERRORS=$?
METADATA_TIME=$(date +%s)
METADATA_DURATION=$((METADATA_TIME - START_TIME))

# 4. ç”Ÿæˆå¿«é€ŸæŠ¥å‘Šï¼ˆ50ç§’ï¼‰
echo "4. ç”Ÿæˆå¿«é€ŸæŠ¥å‘Š..."
START_TIME=$(date +%s)
python scripts/generate-quick-report.py $FORMAT_ERRORS $LINK_ERRORS $METADATA_ERRORS > /tmp/quality_report.txt
REPORT_TIME=$(date +%s)
REPORT_DURATION=$((REPORT_TIME - START_TIME))

# è¾“å‡ºæ£€æŸ¥ç»“æœ
TOTAL_DURATION=$((REPORT_TIME - $(date +%s)))
echo "âœ… æ£€æŸ¥å®Œæˆï¼Œæ€»ç”¨æ—¶ï¼š${TOTAL_DURATION}ç§’"
echo "  - æ ¼å¼æ£€æŸ¥ï¼š${FORMAT_DURATION}ç§’ï¼Œé”™è¯¯æ•°ï¼š$FORMAT_ERRORS"
echo "  - é“¾æ¥æ£€æŸ¥ï¼š${LINK_DURATION}ç§’ï¼Œé”™è¯¯æ•°ï¼š$LINK_ERRORS"
echo "  - å…ƒä¿¡æ¯æ£€æŸ¥ï¼š${METADATA_DURATION}ç§’ï¼Œé”™è¯¯æ•°ï¼š$METADATA_ERRORS"
echo "  - æŠ¥å‘Šç”Ÿæˆï¼š${REPORT_DURATION}ç§’"

# æ˜¾ç¤ºå¿«é€Ÿè¯„åˆ†
python scripts/calculate-quick-score.sh /tmp/quality_report.txt
```

### ç¬¬2åˆ†é’Ÿï¼šå†…å®¹å¿«é€Ÿè¯„ä¼°

äººå·¥å¿«é€Ÿæµè§ˆæ–‡æ¡£å†…å®¹ï¼Œè¿›è¡Œä»¥ä¸‹è¯„ä¼°ï¼š

#### å†…å®¹å®Œæ•´æ€§æ£€æŸ¥ï¼ˆ30ç§’ï¼‰

| æ£€æŸ¥é¡¹ | æ£€æŸ¥æ ‡å‡† | é€šè¿‡/ä¸é€šè¿‡ |
|---------|----------|-------------|
| æ–‡æ¡£æ¦‚è¿° | åŒ…å«èƒŒæ™¯ã€ç›®æ ‡ã€èŒƒå›´ | [ ] |
| æ ¸å¿ƒç« èŠ‚ | åŒ…å«ä¸»è¦å†…å®¹å’Œå®ç°ç»†èŠ‚ | [ ] |
| ç¤ºä¾‹ä»£ç  | åŒ…å«å¯è¿è¡Œçš„ä»£ç ç¤ºä¾‹ | [ ] |
| ç›¸å…³é“¾æ¥ | åŒ…å«ç›¸å…³æ–‡æ¡£å’Œèµ„æºé“¾æ¥ | [ ] |
| æ€»ç»“ä¿¡æ¯ | åŒ…å«è¦ç‚¹å›é¡¾å’Œç»éªŒæ€»ç»“ | [ ] |

#### é€»è¾‘æ¸…æ™°æ€§æ£€æŸ¥ï¼ˆ30ç§’ï¼‰

| æ£€æŸ¥é¡¹ | æ£€æŸ¥æ ‡å‡† | é€šè¿‡/ä¸é€šè¿‡ |
|---------|----------|-------------|
| ç»“æ„åˆç† | ç« èŠ‚ç»„ç»‡åˆç†ï¼Œå±‚æ¬¡æ¸…æ™° | [ ] |
| é€»è¾‘è¿è´¯ | å†…å®¹å‰åå‘¼åº”ï¼Œæ— çŸ›ç›¾ | [ ] |
| é‡ç‚¹çªå‡º | é‡è¦ä¿¡æ¯æ˜ç¡®æ ‡è¯†ï¼Œæ˜“äºæŸ¥æ‰¾ | [ ] |
| è¡¨è¾¾æ¸…æ™° | è¯­è¨€ç®€æ´ï¼Œæœ¯è¯­ä¸€è‡´ | [ ] |

#### æŠ€æœ¯å‡†ç¡®æ€§æ£€æŸ¥ï¼ˆ30ç§’ï¼‰

| æ£€æŸ¥é¡¹ | æ£€æŸ¥æ ‡å‡† | é€šè¿‡/ä¸é€šè¿‡ |
|---------|----------|-------------|
| æŠ€æœ¯æè¿° | æŠ€æœ¯å†…å®¹æè¿°å‡†ç¡®æ— è¯¯ | [ ] |
| ç¤ºä¾‹ä»£ç  | ç¤ºä¾‹ä»£ç å¯æ­£å¸¸è¿è¡Œ | [ ] |
| æ•°æ®é…ç½® | é…ç½®å‚æ•°å’Œæ•°æ®å‡†ç¡® | [ ] |
| ç‰ˆæœ¬ä¿¡æ¯ | ç‰ˆæœ¬å·å’Œæ—¥æœŸæ­£ç¡® | [ ] |

### ç¬¬3åˆ†é’Ÿï¼šè¯„åˆ†å’Œè®°å½•ï¼ˆ30ç§’ï¼‰

æ ¹æ®æ£€æŸ¥ç»“æœè®¡ç®—è´¨é‡è¯„åˆ†å¹¶è®°å½•ï¼š

```python
#!/usr/bin/env python3
import sys
import json
from datetime import datetime

def quick_quality_check():
    """å¿«é€Ÿè´¨é‡æ£€æŸ¥å’Œè¯„åˆ†"""
    # è¯»å–æ£€æŸ¥ç»“æœ
    with open('/tmp/quality_report.txt', 'r') as f:
        report_data = f.read().strip()
    
    # è§£æé”™è¯¯æ•°é‡
    format_errors = int(sys.argv[1]) if len(sys.argv) > 1 else 0
    link_errors = int(sys.argv[2]) if len(sys.argv) > 2 else 0
    metadata_errors = int(sys.argv[3]) if len(sys.argv) > 3 else 0
    
    # è®¡ç®—å„ç»´åº¦å¾—åˆ†
    format_score = max(0.0, 1.5 - (format_errors * 0.3))
    link_score = max(0.0, 0.75 - (link_errors * 0.15))
    metadata_score = max(0.0, 0.5 - (metadata_errors * 0.3))
    
    # äººå·¥è¯„ä¼°åˆ†æ•°ï¼ˆå‡è®¾ï¼‰
    content_score = 1.0  # å†…å®¹å®Œæ•´æ€§
    logic_score = 0.8   # é€»è¾‘æ¸…æ™°æ€§
    tech_score = 0.9    # æŠ€æœ¯å‡†ç¡®æ€§
    
    # è®¡ç®—æ€»åˆ†
    total_score = (format_score * 0.3 + 
                  content_score * 0.25 + 
                  logic_score * 0.2 + 
                  link_score * 0.15 + 
                  metadata_score * 0.1)
    
    # ç¡®å®šç­‰çº§
    if total_score >= 4.5:
        grade = "ä¼˜ç§€"
    elif total_score >= 4.0:
        grade = "è‰¯å¥½"
    elif total_score >= 3.5:
        grade = "åˆæ ¼"
    elif total_score >= 3.0:
        grade = "éœ€æ”¹è¿›"
    else:
        grade = "ä¸åˆæ ¼"
    
    # ç”Ÿæˆæ£€æŸ¥ç»“æœ
    result = {
        'timestamp': datetime.now().isoformat(),
        'auto_check': {
            'format_errors': format_errors,
            'link_errors': link_errors,
            'metadata_errors': metadata_errors
        },
        'manual_assessment': {
            'content_score': content_score,
            'logic_score': logic_score,
            'tech_score': tech_score
        },
        'scores': {
            'format_score': round(format_score, 2),
            'content_score': content_score,
            'logic_score': logic_score,
            'tech_score': tech_score,
            'link_score': round(link_score, 2),
            'metadata_score': round(metadata_score, 2),
            'total_score': round(total_score, 2)
        },
        'grade': grade,
        'recommendations': generate_recommendations(total_score, format_errors, link_errors, metadata_errors)
    }
    
    # è¾“å‡ºç»“æœ
    print(json.dumps(result, ensure_ascii=False, indent=2))
    return result

def generate_recommendations(total_score, format_errors, link_errors, metadata_errors):
    """ç”Ÿæˆæ”¹è¿›å»ºè®®"""
    recommendations = []
    
    if total_score < 3.5:
        recommendations.append("æ–‡æ¡£è´¨é‡ä¸åˆæ ¼ï¼Œå»ºè®®é‡å†™å¹¶ä½¿ç”¨æ¨¡æ¿")
    
    if format_errors > 0:
        recommendations.append("ä¿®å¤Markdownæ ¼å¼é”™è¯¯ï¼Œä½¿ç”¨æ ¼å¼åŒ–å·¥å…·")
    
    if link_errors > 0:
        recommendations.append("ä¿®å¤å¤±æ•ˆé“¾æ¥ï¼Œä½¿ç”¨é“¾æ¥æ£€æŸ¥å·¥å…·")
    
    if metadata_errors > 0:
        recommendations.append("è¡¥å……ç¼ºå¤±çš„å…ƒä¿¡æ¯å­—æ®µ")
    
    if total_score < 4.0:
        recommendations.append("æå‡å†…å®¹å®Œæ•´æ€§å’Œé€»è¾‘æ¸…æ™°æ€§")
    
    return recommendations

if __name__ == '__main__':
    result = quick_quality_check()
    
    # ä¿å­˜æ£€æŸ¥è®°å½•
    with open('docs/metrics/quality-checks.json', 'a') as f:
        # è¯»å–ç°æœ‰è®°å½•
        try:
            existing_data = json.load(f)
        except:
            existing_data = []
        
        existing_data.append(result)
        json.dump(existing_data, f, ensure_ascii=False, indent=2)
    
    print(f"âœ… è´¨é‡æ£€æŸ¥å®Œæˆï¼Œè¯„åˆ†ï¼š{result['scores']['total_score']}ï¼Œç­‰çº§ï¼š{result['grade']}")
```

---

## ğŸ“Š è¯¦ç»†æ£€æŸ¥æ ‡å‡†

### æ ¼å¼è§„èŒƒæ€§æ£€æŸ¥

#### Markdownè¯­æ³•æ£€æŸ¥

| æ£€æŸ¥é¡¹ | æ£€æŸ¥æ–¹æ³• | é€šè¿‡æ ‡å‡† | å¸¸è§é—®é¢˜ |
|---------|----------|----------|----------|
| æ ‡é¢˜å±‚çº§ | æ£€æŸ¥#å·æ•°é‡å’Œå±‚çº§ | å±‚çº§æ­£ç¡®ï¼Œæ— è·³çº§ | æ ‡é¢˜å±‚çº§æ··ä¹± |
| åˆ—è¡¨æ ¼å¼ | æ£€æŸ¥-ã€*ã€æ•°å­—ä½¿ç”¨ | æ ¼å¼æ­£ç¡®ï¼Œå¯¹é½æ•´é½ | æ ¼å¼ä¸ä¸€è‡´ |
| ä»£ç å— | æ£€æŸ¥```è¯­è¨€æ ‡è¯† | è¯­è¨€æ ‡è¯†æ­£ç¡®ï¼Œè¯­æ³•é«˜äº® | ç¼ºå°‘è¯­è¨€æ ‡è¯† |
| è¡¨æ ¼æ ¼å¼ | æ£€æŸ¥è¡¨æ ¼å¯¹é½å’Œè¡¨å¤´ | æ ¼å¼æ­£ç¡®ï¼Œæ˜“è¯» | è¡¨æ ¼æ··ä¹± |
| å›¾ç‰‡é“¾æ¥ | æ£€æŸ¥å›¾ç‰‡è·¯å¾„å’Œaltæ–‡æœ¬ | è·¯å¾„æ­£ç¡®ï¼Œaltæ–‡æœ¬å®Œæ•´ | å›¾ç‰‡å¤±æ•ˆï¼Œç¼ºå°‘alt |

#### é“¾æ¥æœ‰æ•ˆæ€§æ£€æŸ¥

| æ£€æŸ¥é¡¹ | æ£€æŸ¥æ–¹æ³• | é€šè¿‡æ ‡å‡† | å¸¸è§é—®é¢˜ |
|---------|----------|----------|----------|
| å†…éƒ¨é“¾æ¥ | æ£€æŸ¥ç›¸å¯¹è·¯å¾„æœ‰æ•ˆæ€§ | è·¯å¾„æ­£ç¡®ï¼Œæ–‡ä»¶å­˜åœ¨ | ç›¸å¯¹è·¯å¾„é”™è¯¯ |
| å¤–éƒ¨é“¾æ¥ | æ£€æŸ¥HTTPçŠ¶æ€ç  | 200çŠ¶æ€ç ï¼Œå†…å®¹å¯è®¿é—® | 404é”™è¯¯ï¼Œé“¾æ¥å¤±æ•ˆ |
| é”šç‚¹é“¾æ¥ | æ£€æŸ¥é¡µé¢å†…è·³è½¬ | é”šç‚¹æ­£ç¡®ï¼Œè·³è½¬æœ‰æ•ˆ | é”šç‚¹é”™è¯¯ |
| èµ„æºé“¾æ¥ | æ£€æŸ¥æ–‡æ¡£èµ„æºé“¾æ¥ | èµ„æºå¯è®¿é—®ï¼Œè·¯å¾„æ­£ç¡® | èµ„æºå¤±æ•ˆ |

### å†…å®¹å®Œæ•´æ€§æ£€æŸ¥

| æ£€æŸ¥é¡¹ | æ£€æŸ¥æ–¹æ³• | é€šè¿‡æ ‡å‡† | å¸¸è§é—®é¢˜ |
|---------|----------|----------|----------|
| æ–‡æ¡£æ¦‚è¿° | æ£€æŸ¥æ˜¯å¦åŒ…å«èƒŒæ™¯ã€ç›®æ ‡ | åŒ…å«å®Œæ•´æ¦‚è¿°ä¿¡æ¯ | ç¼ºå°‘æ¦‚è¿°æˆ–ç›®æ ‡ |
| æ ¸å¿ƒç« èŠ‚ | æ£€æŸ¥ä¸»è¦å†…å®¹ç« èŠ‚ | åŒ…å«æ‰€æœ‰å¿…è¦ç« èŠ‚ | ç¼ºå°‘é‡è¦ç« èŠ‚ |
| ç¤ºä¾‹ä»£ç  | æ£€æŸ¥ä»£ç ç¤ºä¾‹å®Œæ•´æ€§ | åŒ…å«å¯è¿è¡Œç¤ºä¾‹ | ç¤ºä¾‹ä¸å®Œæ•´æˆ–é”™è¯¯ |
| ç›¸å…³é“¾æ¥ | æ£€æŸ¥å‚è€ƒæ–‡æ¡£é“¾æ¥ | åŒ…å«ç›¸å…³æ–‡æ¡£é“¾æ¥ | ç¼ºå°‘é‡è¦å‚è€ƒé“¾æ¥ |
| æ€»ç»“ä¿¡æ¯ | æ£€æŸ¥æ€»ç»“å’Œç»éªŒ | åŒ…å«è¦ç‚¹æ€»ç»“ | ç¼ºå°‘æ€»ç»“ä¿¡æ¯ |

### é€»è¾‘æ¸…æ™°æ€§æ£€æŸ¥

| æ£€æŸ¥é¡¹ | æ£€æŸ¥æ–¹æ³• | é€šè¿‡æ ‡å‡† | å¸¸è§é—®é¢˜ |
|---------|----------|----------|----------|
| ç»“æ„åˆç† | æ£€æŸ¥ç« èŠ‚ç»„ç»‡é€»è¾‘ | ç»“æ„æ¸…æ™°ï¼Œå±‚æ¬¡åˆç† | ç»“æ„æ··ä¹±ï¼Œé€»è¾‘ä¸æ¸… |
| å†…å®¹è¿è´¯ | æ£€æŸ¥å†…å®¹å‰åä¸€è‡´æ€§ | å†…å®¹å‰åå‘¼åº”ï¼Œæ— çŸ›ç›¾ | å†…å®¹çŸ›ç›¾ï¼Œé€»è¾‘è·³è·ƒ |
| é‡ç‚¹çªå‡º | æ£€æŸ¥é‡è¦ä¿¡æ¯æ ‡è¯† | é‡ç‚¹ä¿¡æ¯æ˜ç¡®æ ‡è¯† | é‡ç‚¹ä¸çªå‡ºï¼ŒæŸ¥æ‰¾å›°éš¾ |
| è¡¨è¾¾æ¸…æ™° | æ£€æŸ¥è¯­è¨€è¡¨è¾¾ | è¯­è¨€ç®€æ´ï¼Œæœ¯è¯­ä¸€è‡´ | è¡¨è¾¾ä¸æ¸…ï¼Œæœ¯è¯­æ··ä¹± |

### æŠ€æœ¯å‡†ç¡®æ€§æ£€æŸ¥

| æ£€æŸ¥é¡¹ | æ£€æŸ¥æ–¹æ³• | é€šè¿‡æ ‡å‡† | å¸¸è§é—®é¢˜ |
|---------|----------|----------|----------|
| æŠ€æœ¯æè¿° | æ£€æŸ¥æŠ€æœ¯å†…å®¹å‡†ç¡®æ€§ | æŠ€æœ¯æè¿°å‡†ç¡®æ— è¯¯ | æŠ€æœ¯æè¿°é”™è¯¯æˆ–è¿‡æ—¶ |
| ç¤ºä¾‹ä»£ç  | æ£€æŸ¥ä»£ç å¯è¿è¡Œæ€§ | ç¤ºä¾‹ä»£ç å¯æ­£å¸¸è¿è¡Œ | ç¤ºä¾‹ä»£ç æœ‰é”™è¯¯ |
| æ•°æ®é…ç½® | æ£€æŸ¥é…ç½®å‚æ•°å‡†ç¡®æ€§ | é…ç½®å‚æ•°æ­£ç¡®æ— è¯¯ | é…ç½®å‚æ•°é”™è¯¯æˆ–ä¸å®Œæ•´ |
| ç‰ˆæœ¬ä¿¡æ¯ | æ£€æŸ¥ç‰ˆæœ¬å’Œæ—¥æœŸä¿¡æ¯ | ç‰ˆæœ¬ä¿¡æ¯å‡†ç¡®ä¸€è‡´ | ç‰ˆæœ¬ä¿¡æ¯é”™è¯¯æˆ–ç¼ºå¤± |

---

## ğŸ› ï¸ æ£€æŸ¥å·¥å…·å’Œè„šæœ¬

### è‡ªåŠ¨åŒ–æ£€æŸ¥è„šæœ¬

#### check-metadata.py

```python
#!/usr/bin/env python3
import os
import re
import yaml
from datetime import datetime

def check_metadata(directory):
    """æ£€æŸ¥æ–‡æ¡£å…ƒä¿¡æ¯å®Œæ•´æ€§"""
    results = []
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith('.md'):
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # æå–YAMLå‰ç½®å†…å®¹
                    metadata = extract_metadata(content)
                    missing_fields = []
                    
                    # æ£€æŸ¥å¿…è¦å­—æ®µ
                    required_fields = ['ç‰ˆæœ¬', 'åˆ›å»ºæ—¥æœŸ', 'æœ€åæ›´æ–°', 'æ›´æ–°äºº']
                    for field in required_fields:
                        if field not in metadata:
                            missing_fields.append(field)
                    
                    # æ£€æŸ¥å¯é€‰å­—æ®µ
                    optional_fields = ['çŠ¶æ€', 'æ ‡ç­¾', 'ç›¸å…³æ–‡æ¡£']
                    for field in optional_fields:
                        if field in metadata and not metadata[field]:
                            missing_fields.append(f"{field}(å€¼ä¸ºç©º)")
                    
                    if missing_fields:
                        result = {
                            'file': file_path,
                            'status': 'error',
                            'missing_fields': missing_fields,
                            'message': f"ç¼ºå¤±å¿…è¦å­—æ®µï¼š{', '.join(missing_fields)}"
                        }
                    else:
                        result = {
                            'file': file_path,
                            'status': 'success',
                            'message': 'å…ƒä¿¡æ¯å®Œæ•´'
                        }
                    results.append(result)
                    
                except Exception as e:
                    results.append({
                        'file': file_path,
                        'status': 'error',
                        'error': str(e),
                        'message': f"è¯»å–æ–‡ä»¶å¤±è´¥ï¼š{str(e)}"
                    })
    
    return results

def extract_metadata(content):
    """ä»æ–‡æ¡£å†…å®¹æå–å…ƒä¿¡æ¯"""
    metadata = {}
    
    # æå–YAMLå‰ç½®å†…å®¹
    if content.startswith('---'):
        try:
            yaml_content = content.split('---')[1].split('---')[0]
            metadata = yaml.safe_load(yaml_content)
        except:
            pass
    
    return metadata

if __name__ == '__main__':
    import sys
    directory = sys.argv[1] if len(sys.argv) > 1 else 'docs/'
    
    results = check_metadata(directory)
    
    # è¾“å‡ºæ£€æŸ¥ç»“æœ
    error_count = sum(1 for r in results if r['status'] == 'error')
    print(f"METADATA_CHECK:{error_count}")
    
    # è¾“å‡ºè¯¦ç»†ç»“æœ
    for result in results:
        if result['status'] == 'error':
            print(f"ERROR:{result['file']} - {result['message']}")
```

#### generate-quick-report.py

```python
#!/usr/bin/env python3
import sys
import json
from datetime import datetime

def generate_quick_report(format_errors, link_errors, metadata_errors):
    """ç”Ÿæˆå¿«é€Ÿè´¨é‡æŠ¥å‘Š"""
    report = {
        'timestamp': datetime.now().isoformat(),
        'summary': {
            'total_errors': format_errors + link_errors + metadata_errors,
            'format_errors': format_errors,
            'link_errors': link_errors,
            'metadata_errors': metadata_errors
        }
    }
    
    # ç”Ÿæˆæ”¹è¿›å»ºè®®
    recommendations = []
    
    if format_errors > 0:
        recommendations.append("ä¿®å¤Markdownæ ¼å¼é”™è¯¯")
    
    if link_errors > 0:
        recommendations.append("ä¿®å¤å¤±æ•ˆé“¾æ¥")
    
    if metadata_errors > 0:
        recommendations.append("è¡¥å……ç¼ºå¤±çš„å…ƒä¿¡æ¯")
    
    if format_errors == 0 and link_errors == 0 and metadata_errors == 0:
        recommendations.append("æ–‡æ¡£è´¨é‡è‰¯å¥½ï¼Œä¿æŒå½“å‰æ°´å¹³")
    
    report['recommendations'] = recommendations
    
    return report

if __name__ == '__main__':
    format_errors = int(sys.argv[1]) if len(sys.argv) > 1 else 0
    link_errors = int(sys.argv[2]) if len(sys.argv) > 2 else 0
    metadata_errors = int(sys.argv[3]) if len(sys.argv) > 3 else 0
    
    report = generate_quick_report(format_errors, link_errors, metadata_errors)
    print(json.dumps(report, ensure_ascii=False, indent=2))
```

#### calculate-quick-score.sh

```bash
#!/bin/bash
# è®¡ç®—å¿«é€Ÿè´¨é‡è¯„åˆ†

# è¯»å–è´¨é‡æŠ¥å‘Š
REPORT_FILE="/tmp/quality_report.txt"
if [ ! -f "$REPORT_FILE" ]; then
    echo "âŒ è´¨é‡æŠ¥å‘Šæ–‡ä»¶ä¸å­˜åœ¨"
    exit 1
fi

# æå–è¯„åˆ†æ•°æ®
FORMAT_SCORE=$(python -c "
import json
import sys
try:
    with open('$REPORT_FILE', 'r') as f:
        data = json.load(f)
        print(data['scores']['format_score'])
except:
    print(0.0)
")

echo "âœ… å¿«é€Ÿè´¨é‡è¯„åˆ†å®Œæˆï¼š$FORMAT_SCORE"
```

---

## ğŸ“ˆ è´¨é‡è¶‹åŠ¿è·Ÿè¸ª

### è´¨é‡å†å²è®°å½•

åˆ›å»º`docs/metrics/quality-history.json`è®°å½•å†å²æ£€æŸ¥ç»“æœï¼š

```json
[
  {
    "timestamp": "2025-12-08T07:30:00Z",
    "file": "docs/åŠŸèƒ½è®¾è®¡/æ–°åŠŸèƒ½è®¾è®¡.md",
    "auto_check": {
      "format_errors": 0,
      "link_errors": 1,
      "metadata_errors": 0
    },
    "manual_assessment": {
      "content_score": 1.0,
      "logic_score": 0.8,
      "tech_score": 0.9
    },
    "scores": {
      "format_score": 1.5,
      "content_score": 1.0,
      "logic_score": 0.8,
      "tech_score": 0.9,
      "link_score": 0.6,
      "metadata_score": 0.5,
      "total_score": 3.85
    },
    "grade": "åˆæ ¼",
    "recommendations": [
      "ä¿®å¤å¤±æ•ˆé“¾æ¥",
      "æå‡å†…å®¹å®Œæ•´æ€§"
    ]
  }
]
```

### è´¨é‡è¶‹åŠ¿åˆ†æ

```python
#!/usr/bin/env python3
import json
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

def analyze_quality_trend():
    """åˆ†ææ–‡æ¡£è´¨é‡è¶‹åŠ¿"""
    # è¯»å–å†å²æ•°æ®
    with open('docs/metrics/quality-history.json', 'r') as f:
        data = json.load(f)
    
    # æå–æ•°æ®
    dates = [datetime.fromisoformat(item['timestamp']) for item in data]
    scores = [item['scores']['total_score'] for item in data]
    
    # ç»˜åˆ¶è¶‹åŠ¿å›¾
    plt.figure(figsize=(12, 6))
    plt.plot(dates, scores, marker='o-', linewidth=2)
    plt.title('æ–‡æ¡£è´¨é‡è¶‹åŠ¿ï¼ˆæœ€è¿‘30å¤©ï¼‰')
    plt.xlabel('æ—¥æœŸ')
    plt.ylabel('è´¨é‡è¯„åˆ†')
    plt.grid(True, alpha=0.3)
    
    # æ·»åŠ ç›®æ ‡çº¿
    plt.axhline(y=4.0, color='r', linestyle='--', alpha=0.7, label='åˆæ ¼çº¿')
    plt.axhline(y=4.5, color='orange', linestyle='--', alpha=0.7, label='è‰¯å¥½çº¿')
    
    # ä¿å­˜å›¾è¡¨
    plt.savefig('docs/metrics/quality-trend.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    # ç”Ÿæˆè¶‹åŠ¿åˆ†æ
    recent_scores = scores[-10:]  # æœ€è¿‘10æ¬¡æ£€æŸ¥
    avg_score = sum(recent_scores) / len(recent_scores)
    
    trend_analysis = {
        'timestamp': datetime.now().isoformat(),
        'period': 'æœ€è¿‘30å¤©',
        'average_score': round(avg_score, 2),
        'score_count': len(recent_scores),
        'trend': 'stable' if avg_score >= 4.0 else 'improving' if avg_score >= 3.5 else 'declining'
    }
    
    # ä¿å­˜åˆ†æç»“æœ
    with open('docs/metrics/quality-trend-analysis.json', 'w') as f:
        json.dump(trend_analysis, f, ensure_ascii=False, indent=2)
    
    print("âœ… è´¨é‡è¶‹åŠ¿åˆ†æå®Œæˆ")

if __name__ == '__main__':
    analyze_quality_trend()
```

---

## ğŸ¯ æ£€æŸ¥ç»“æœå¤„ç†

### é—®é¢˜åˆ†ç±»å’Œä¼˜å…ˆçº§

| é—®é¢˜ç±»å‹ | ä¸¥é‡ç¨‹åº¦ | å¤„ç†ä¼˜å…ˆçº§ | å¤„ç†æ—¶é™ | å…¸å‹åœºæ™¯ |
|---------|----------|----------|----------|
| æ ¼å¼é”™è¯¯ | é«˜ | P1 | 24å°æ—¶å†… | å½±å“æ–‡æ¡£å¯è¯»æ€§ |
| é“¾æ¥å¤±æ•ˆ | ä¸­ | P2 | 1å‘¨å†… | å½±å“æ–‡æ¡£å®Œæ•´æ€§ |
| å†…å®¹ç¼ºå¤± | é«˜ | P1 | 24å°æ—¶å†… | å½±å“æ–‡æ¡£ä»·å€¼ |
| é€»è¾‘æ··ä¹± | ä¸­ | P2 | 1å‘¨å†… | å½±å“æ–‡æ¡£ç†è§£æ€§ |
| æŠ€æœ¯é”™è¯¯ | é«˜ | P1 | 24å°æ—¶å†… | å½±å“æ–‡æ¡£å‡†ç¡®æ€§ |

### æ”¹è¿›è·Ÿè¸ª

åˆ›å»º`docs/metrics/improvement-tracking.json`è·Ÿè¸ªæ”¹è¿›æƒ…å†µï¼š

```json
{
  "improvements": [
    {
      "id": "IMP-001",
      "timestamp": "2025-12-08T07:30:00Z",
      "issue_type": "format_errors",
      "description": "ä¿®å¤æ ‡é¢˜å±‚çº§æ··ä¹±é—®é¢˜",
      "action": "ä½¿ç”¨æ¨¡æ¿å’Œæ ¼å¼æ£€æŸ¥å·¥å…·",
      "status": "completed",
      "impact": "æå‡äº†æ–‡æ¡£æ ¼å¼è§„èŒƒæ€§"
    },
    {
      "id": "IMP-002",
      "timestamp": "2025-12-08T07:30:00Z",
      "issue_type": "link_errors",
      "description": "ä¿®å¤å¤±æ•ˆé“¾æ¥é—®é¢˜",
      "action": "å»ºç«‹å®šæœŸé“¾æ¥æ£€æŸ¥æœºåˆ¶",
      "status": "in_progress",
      "impact": "æå‡äº†æ–‡æ¡£é“¾æ¥æœ‰æ•ˆæ€§"
    }
  ]
}
```

---

## ğŸ“ è”ç³»å’Œæ”¯æŒ

**è´¨é‡è´Ÿè´£äºº**: [è´¨é‡è´Ÿè´£äººå§“å]  
**æŠ€æœ¯æ”¯æŒ**: [æŠ€æœ¯æ”¯æŒè”ç³»æ–¹å¼]  
**é—®é¢˜åé¦ˆ**: [åé¦ˆæ¸ é“]  

---

**åˆ›å»ºæ—¥æœŸ**: 2025-12-08  
**æœ€åæ›´æ–°**: 2025-12-08  
**æ›´æ–°äºº**: AI Assistant  
**ä¸‹æ¬¡å®¡æŸ¥**: 2025-12-15  
**é€‚ç”¨èŒƒå›´**: å…¨å›¢é˜Ÿæ–‡æ¡£  
**å®æ–½æ—¶é—´**: 2025-12-08å¼€å§‹