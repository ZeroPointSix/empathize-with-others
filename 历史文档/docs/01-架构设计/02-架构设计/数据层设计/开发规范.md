---
æ ‡é¢˜: æ•°æ®å±‚å¼€å‘è§„èŒƒ
ç‰ˆæœ¬: v2.0
åˆ›å»ºæ—¥æœŸ: 2025-12-08
æœ€åæ›´æ–°: 2025-12-08
æ›´æ–°äºº: AI Assistant
çŠ¶æ€: æ´»è·ƒ
æ ‡ç­¾: [æ•°æ®å±‚è®¾è®¡, å¼€å‘è§„èŒƒ, ç¼–ç æ ‡å‡†]
ç›¸å…³æ–‡æ¡£: [å…¨å±€è®¾è®¡.md, æœ¬åœ°å­˜å‚¨.md, ç½‘ç»œè®¿é—®.md]
---

# æ•°æ®å±‚å¼€å‘è§„èŒƒ

---

## ğŸ“‹ é€šç”¨åŸåˆ™ (General Principles)

### 1. å‘½åè§„èŒƒ
- **æ–‡ä»¶å‘½å**ï¼š`PascalCase` (å¤§é©¼å³°)ï¼Œä¾‹å¦‚ `ContactProfileEntity.kt`
- **è¡¨å/åˆ—å**ï¼š`snake_case` (ä¸‹åˆ’çº¿)ï¼Œä¾‹å¦‚ `contact_id`
- **Kotlin å±æ€§**ï¼š`camelCase` (å°é©¼å³°)ï¼Œä¾‹å¦‚ `contactId`

### 2. ç©ºå®‰å…¨
- æ•°æ®åº“å­—æ®µå°½é‡è®¾ä¸º `NOT NULL` (å³ Kotlin ä¸­ä¸å¸¦ `?` çš„ç±»å‹)ï¼Œé™¤éä¸šåŠ¡å…è®¸ä¸ºç©º

### 3. ç±»å‹å®‰å…¨
- ä¼˜å…ˆä½¿ç”¨ sealed class æ›¿ä»£æšä¸¾
- ä½¿ç”¨ Result<T> åŒ…è£…å¯èƒ½å¤±è´¥çš„æ“ä½œ
- é¿å…ä½¿ç”¨ !! å¼ºåˆ¶è§£åŒ…

---

## ğŸ“¦ Step 1: ç¯å¢ƒé…ç½®è§„èŒƒ (Dependencies)

åœ¨ `build.gradle.kts` ä¸­ï¼Œæˆ‘ä»¬éµå¾ª **"åˆ†ç»„ç®¡ç†"** çš„åŸåˆ™ï¼Œä¸æŠŠåº“æ‰”å¾—åˆ°å¤„éƒ½æ˜¯ã€‚

### è§„èŒƒè¦æ±‚
- å¿…é¡»æ˜ç¡®ç‰ˆæœ¬å·å˜é‡ï¼ˆå¦‚ `val roomVersion = "2.6.1"`ï¼‰ï¼Œæ–¹ä¾¿ç»Ÿä¸€å‡çº§
- åŒç±»åº“æ”¾åœ¨ä¸€èµ·ï¼ˆRoom åŠå…¶ KSP ç¼–è¯‘å™¨ï¼‰
- æ³¨é‡Šæ¸…æ™°

### ç¤ºä¾‹é…ç½®
```kotlin
dependencies {
    // === Local Storage (Room) ===
    val roomVersion = "2.6.1"
    implementation("androidx.room:room-runtime:$roomVersion")
    implementation("androidx.room:room-ktx:$roomVersion") // æ”¯æŒ Coroutines/Flow
    ksp("androidx.room:room-compiler:$roomVersion")       // ç¼–è¯‘å™¨

    // === Serialization (Gson) ===
    implementation("com.google.gson:gson:2.10.1")
    
    // === Security (EncryptedSharedPreferences) ===
    implementation("androidx.security:security-crypto:1.1.0-alpha06")
    
    // === Network (Retrofit) ===
    val retrofitVersion = "2.11.0"
    implementation("com.squareup.retrofit2:retrofit:$retrofitVersion")
    implementation("com.squareup.retrofit2:converter-gson:$retrofitVersion")
}
```

---

## ğŸ—ï¸ Step 2: å®ä½“ç±»è§„èŒƒ (Entities)

è¿™æ˜¯ SQL è¡¨ç»“æ„çš„å®šä¹‰å¤„ã€‚

### è§„èŒƒ Aï¼šå‘½ååç¼€
- æ‰€æœ‰æ•°æ®åº“å¯¹è±¡å¿…é¡»ä»¥ **`Entity`** ç»“å°¾ï¼Œä»¥åŒºåˆ† Domain å±‚çš„ Model
- *ä¾‹ï¼š* `ContactProfileEntity` (DB) vs `ContactProfile` (Domain)

### è§„èŒƒ Bï¼šè¡¨åæ˜ å°„
- `tableName` å¿…é¡»æ˜¯å¤æ•°ã€ä¸‹åˆ’çº¿é£æ ¼
- *ä¾‹ï¼š* `@Entity(tableName = "contact_profiles")`

### è§„èŒƒ Cï¼šä¸»é”®ä¸åˆ—å
- å¿…é¡»æ˜¾å¼æŒ‡å®š `@ColumnInfo(name = "xxx")`ã€‚è¿™èƒ½è®©ä½ çš„ Kotlin å˜é‡åï¼ˆcamelCaseï¼‰å’Œæ•°æ®åº“åˆ—åï¼ˆsnake_caseï¼‰è§£è€¦
- *å¥½å¤„ï¼š* ä»¥åä½ é‡æ„ä»£ç æ”¹å˜é‡åï¼Œä¸ä¼šå¯¼è‡´æ•°æ®åº“æ•°æ®ä¸¢å¤±

### ç¤ºä¾‹å®ä½“
```kotlin
@Entity(tableName = "brain_tags") // SQL è¡¨å
data class BrainTagEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0, // é»˜è®¤å€¼è®¾ä¸º 0ï¼Œæ’å…¥æ—¶ Room ä¼šè‡ªåŠ¨ç”Ÿæˆ

    @ColumnInfo(name = "contact_id", index = true) // SQL åˆ—å + ç´¢å¼•
    val contactId: String,

    @ColumnInfo(name = "tag_type") // æ˜ å°„: tagType -> tag_type
    val type: String,
    
    @ColumnInfo(name = "content")
    val content: String,
    
    @ColumnInfo(name = "source")
    val source: String = "MANUAL",
    
    @ColumnInfo(name = "confidence")
    val confidence: Float = 1.0f,
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long = System.currentTimeMillis()
)
```

---

## ğŸ”„ Step 3: ç¿»è¯‘å™¨è§„èŒƒ (Type Converters)

è§£å†³ Gson åºåˆ—åŒ–çš„åœ°æ–¹ã€‚

### è§„èŒƒ Aï¼šç©ºå®‰å…¨å¤„ç†
- æ•°æ®åº“è¯»å‡ºæ¥çš„å­—ç¬¦ä¸²å¯èƒ½æ˜¯ `null`ï¼ˆè™½ç„¶æˆ‘ä»¬è®¾äº† Not Nullï¼Œä½†è¦é˜²ä¸‡ä¸€ï¼‰ã€‚ä»£ç å¿…é¡»å¤„ç† `String?` å¹¶è¿”å›éç©ºçš„ `Map`

### è§„èŒƒ Bï¼šæ³›å‹å¤„ç†
- ä½¿ç”¨ Gson çš„ `TypeToken` æ—¶ï¼Œå¿…é¡»å†™æ¸…æ¥šæ³›å‹ç±»å‹

### ç¤ºä¾‹è½¬æ¢å™¨
```kotlin
class RoomTypeConverters {
    private val gson = Gson()
    
    @TypeConverter
    fun fromStringMap(value: String?): Map<String, String> {
        if (value.isNullOrEmpty()) return emptyMap() // é˜²å¾¡æ€§ç¼–ç¨‹
        return try {
            val type = object : TypeToken<Map<String, String>>() {}.type
            gson.fromJson(value, type) ?: emptyMap()
        } catch (e: Exception) {
            emptyMap()
        }
    }
    
    @TypeConverter
    fun toStringMap(value: Map<String, String>?): String {
        if (value == null) return "{}"
        return try {
            gson.toJson(value)
        } catch (e: Exception) {
            "{}"
        }
    }
    
    @TypeConverter
    fun fromTagType(value: TagType): String = value.name
    
    @TypeConverter
    fun toTagType(value: String): TagType {
        return try {
            TagType.valueOf(value)
        } catch (e: Exception) {
            TagType.STRATEGY_GREEN // é»˜è®¤å€¼
        }
    }
}
```

---

## ğŸ” Step 4: DAO è§„èŒƒ (Data Access Objects)

è¿™æ˜¯å†™ SQL çš„åœ°æ–¹ã€‚

### è§„èŒƒ Aï¼šå‡½æ•°å‘½å
- **æŸ¥è¯¢**ï¼š`get...` æˆ– `find...`
- **æ’å…¥/æ›´æ–°**ï¼š`insertOrUpdate...` (Upsert)
- **åˆ é™¤**ï¼š`delete...`

### è§„èŒƒ Bï¼šè¿”å›å€¼ç±»å‹
- **ä¸€æ¬¡æ€§æ“ä½œ (IO)**ï¼šå¿…é¡»æŒ‚èµ· `suspend fun`ã€‚é€‚ç”¨äº Insert/Delete/Update
- **æµå¼æŸ¥è¯¢ (Stream)**ï¼šå¿…é¡»è¿”å› `Flow<T>`ï¼Œ**ä¸åŠ ** `suspend`ã€‚é€‚ç”¨äº `getAll...`

### è§„èŒƒ Cï¼šå†²çªç­–ç•¥
- é»˜è®¤ä½¿ç”¨ `onConflict = OnConflictStrategy.REPLACE` å®ç°"è¦†ç›–æ›´æ–°"

### ç¤ºä¾‹ DAO
```kotlin
@Dao
interface ContactDao {
    // è¯»æµ (æ—  suspend)
    @Query("SELECT * FROM contact_profiles ORDER BY name ASC")
    fun getAllProfiles(): Flow<List<ContactProfileEntity>>

    // å•ä¸ªæŸ¥è¯¢ (æœ‰ suspend)
    @Query("SELECT * FROM contact_profiles WHERE id = :id")
    suspend fun getProfileById(id: String): ContactProfileEntity?

    // æœç´¢æŸ¥è¯¢ (æœ‰ suspend)
    @Query("SELECT * FROM contact_profiles WHERE name LIKE '%' || :query || '%' ORDER BY name ASC")
    suspend fun searchProfiles(query: String): List<ContactProfileEntity>

    // å†™æ“ä½œ (æœ‰ suspend)
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertProfile(entity: ContactProfileEntity): Long

    @Update
    suspend fun updateProfile(entity: ContactProfileEntity): Int

    @Delete
    suspend fun deleteProfile(id: String): Int
    
    // æ‰¹é‡æ“ä½œ
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertProfiles(entities: List<ContactProfileEntity>): List<Long>
}
```

---

## ğŸ”§ Step 5: ä»“åº“å®ç°è§„èŒƒ (Repository Impl)

è¿™æ˜¯æœ€å…³é”®çš„é€»è¾‘å±‚ã€‚

### è§„èŒƒ Aï¼šæ˜ å°„å‡½æ•° (Mappers)
- **ç¦æ­¢**åœ¨ Repository ç±»å¤–éƒ¨æš´éœ² Entity
- å¿…é¡»ç¼–å†™ç§æœ‰çš„æ‰©å±•å‡½æ•° `toDomain()` å’Œ `toEntity()` æ¥å¤„ç†æ•°æ®è½¬æ¢
- *ä½ç½®ï¼š* ç›´æ¥å†™åœ¨ `ContactRepositoryImpl.kt` æ–‡ä»¶çš„åº•éƒ¨

### è§„èŒƒ Bï¼šæ„é€ å‡½æ•°æ³¨å…¥
- å¿…é¡»ä½¿ç”¨ `@Inject` æ³¨å…¥ DAOï¼Œè€Œä¸æ˜¯è‡ªå·± `database.dao()`

### è§„èŒƒ Cï¼šæ•°æ®æ¸…æ´—
- å¦‚æœæ•°æ®åº“å­˜çš„æ˜¯ JSON Stringï¼Œå¿…é¡»åœ¨è¿™é‡Œè½¬æˆ Mapï¼Œç»å¯¹ä¸èƒ½æŠŠ String å”®ç»™ Domain å±‚

### ç¤ºä¾‹ Repository
```kotlin
class ContactRepositoryImpl @Inject constructor(
    private val contactDao: ContactDao,
    private val brainTagDao: BrainTagDao
) : ContactRepository {

    override fun getAllProfiles(): Flow<List<ContactProfile>> {
        return contactDao.getAllProfiles().map { entities ->
            entities.map { it.toDomain() }
        }
    }

    override suspend fun getProfile(id: String): Result<ContactProfile?> {
        return try {
            val entity = contactDao.getProfileById(id)
            if (entity != null) {
                Result.success(entity.toDomain())
            } else {
                Result.success(null)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    override suspend fun saveProfile(profile: ContactProfile): Result<Unit> {
        return try {
            val entity = profile.toEntity()
            contactDao.insertProfile(entity)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    override suspend fun updateContactFacts(
        contactId: String, 
        newFacts: Map<String, String>
    ): Result<Unit> {
        return try {
            val currentProfile = contactDao.getProfileById(contactId)
                ?: return Result.failure(IllegalArgumentException("Contact not found"))
            
            val updatedFacts = currentProfile.facts.toMutableMap()
            updatedFacts.putAll(newFacts)
            
            val updatedEntity = currentProfile.copy(facts = updatedFacts.toJsonString())
            contactDao.updateProfile(updatedEntity)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    // --- Private Mappers (å†™åœ¨æ–‡ä»¶åº•éƒ¨) ---
    private fun ContactProfileEntity.toDomain(): ContactProfile {
        return ContactProfile(
            id = this.id,
            name = this.name,
            targetGoal = this.targetGoal,
            contextDepth = this.contextDepth,
            facts = Gson().fromJson(this.facts) ?: emptyMap()
        )
    }

    private fun ContactProfile.toEntity(): ContactProfileEntity {
        return ContactProfileEntity(
            id = this.id,
            name = this.name,
            targetGoal = this.targetGoal,
            contextDepth = this.contextDepth,
            facts = Gson().toJson(this.facts)
        )
    }
}
```

---

## ğŸŒ Step 6: ç½‘ç»œæ¨¡å—è§„èŒƒ

### API æ¥å£è§„èŒƒ
```kotlin
interface AiApiService {
    @POST
    @Url
    suspend fun analyzeChat(
        @Url url: String,
        @Body request: ChatRequestDto,
        @HeaderMap headers: Map<String, String>
    ): Response<ChatResponseDto>
    
    @POST
    @Url
    suspend fun checkDraftSafety(
        @Url url: String,
        @Body request: SafetyCheckRequestDto,
        @HeaderMap headers: Map<String, String>
    ): Response<SafetyCheckResponseDto>
}
```

### DTO è§„èŒƒ
```kotlin
data class ChatRequestDto(
    @SerializedName("model")
    val model: String,
    
    @SerializedName("messages")
    val messages: List<MessageDto>,
    
    @SerializedName("temperature")
    val temperature: Float = 0.7f,
    
    @SerializedName("max_tokens")
    val maxTokens: Int = 1000
)

data class MessageDto(
    @SerializedName("role")
    val role: String,
    
    @SerializedName("content")
    val content: String
)
```

---

## ğŸ” Step 7: å®‰å…¨å­˜å‚¨è§„èŒƒ

### EncryptedSharedPreferences
```kotlin
class SecurePreferences @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val masterKeyAlias = MasterKeys.get(context).masterKeyAlias
    
    private val sharedPreferences = EncryptedSharedPreferences.create(
        context,
        "secure_prefs",
        masterKeyAlias,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefKeyPaddingScheme.NONE
    )

    suspend fun getApiKey(): Result<String?> {
        return try {
            withContext(Dispatchers.IO) {
                val key = sharedPreferences.getString("api_key", null)
                Result.success(key)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun saveApiKey(key: String): Result<Unit> {
        return try {
            withContext(Dispatchers.IO) {
                sharedPreferences.edit()
                    .putString("api_key", key)
                    .apply()
            }
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

---

## ğŸ§ª Step 8: ä¾èµ–æ³¨å…¥æ¨¡å—è§„èŒƒ

### DatabaseModule
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    @Provides
    @Singleton
    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "empathy_ai.db"
        )
        .addTypeConverters(RoomTypeConverters())
        .fallbackToDestructiveMigration()
        .build()
    }
    
    @Provides
    fun provideContactDao(database: AppDatabase): ContactDao = database.contactDao()
    
    @Provides
    fun provideBrainTagDao(database: AppDatabase): BrainTagDao = database.brainTagDao()
}
```

### NetworkModule
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideGson(): Gson = GsonBuilder()
        .setLenient()
        .create()
    
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .writeTimeout(30, TimeUnit.SECONDS)
        .addInterceptor(HttpLoggingInterceptor().apply {
            level = if (BuildConfig.DEBUG) {
                HttpLoggingInterceptor.Level.BODY
            } else {
                HttpLoggingInterceptor.Level.NONE
            }
        })
        .build()
    
    @Provides
    @Singleton
    fun provideRetrofit(
        okHttpClient: OkHttpClient,
        gson: Gson
    ): Retrofit = Retrofit.Builder()
        .client(okHttpClient)
        .addConverterFactory(GsonConverterFactory.create(gson))
        .baseUrl("https://api.example.com/") // é»˜è®¤å€¼ï¼Œä¼šè¢«åŠ¨æ€è¦†ç›–
        .build()
    
    @Provides
    @Singleton
    fun provideAiApiService(retrofit: Retrofit): AiApiService = retrofit.create(AiApiService::class.java)
}
```

---

## ğŸ“Š é”™è¯¯å¤„ç†è§„èŒƒ

### ç»Ÿä¸€å¼‚å¸¸å¤„ç†
```kotlin
sealed class DataException(message: String, cause: Throwable? = null) : Exception(message, cause) {
    class NetworkError(message: String, cause: Throwable? = null) : DataException(message, cause)
    class DatabaseError(message: String, cause: Throwable? = null) : DataException(message, cause)
    class ValidationError(message: String) : DataException(message)
    class SecurityError(message: String, cause: Throwable? = null) : DataException(message, cause)
}

// åœ¨ Repository ä¸­ä½¿ç”¨
override suspend fun getProfile(id: String): Result<ContactProfile?> {
    return try {
        val entity = contactDao.getProfileById(id)
        Result.success(entity?.toDomain())
    } catch (e: SQLiteException) {
        Result.failure(DataException.DatabaseError("Database error: ${e.message}", e))
    } catch (e: Exception) {
        Result.failure(DataException.NetworkError("Unexpected error: ${e.message}", e))
    }
}
```

---

## ğŸ§ª æµ‹è¯•è§„èŒƒ

### å•å…ƒæµ‹è¯•
```kotlin
@Test
fun `getProfile should return domain model when entity exists`() = runTest {
    // Given
    val entity = ContactProfileEntity(id = "1", name = "Test")
    coEvery { contactDao.getProfileById("1") } returns entity
    
    // When
    val result = repository.getProfile("1")
    
    // Then
    assertTrue(result.isSuccess)
    assertEquals("Test", result.getOrNull()?.name)
}
```

### é›†æˆæµ‹è¯•
```kotlin
@Test
fun `save and retrieve profile should work end to end`() = runTest {
    // Given
    val profile = ContactProfile(id = "1", name = "Test")
    
    // When
    val saveResult = repository.saveProfile(profile)
    val getResult = repository.getProfile("1")
    
    // Then
    assertTrue(saveResult.isSuccess)
    assertTrue(getResult.isSuccess)
    assertEquals("Test", getResult.getOrNull()?.name)
}
```

---

## ğŸ“ ä»£ç å®¡æŸ¥æ¸…å•

### å¿…é¡»æ£€æŸ¥é¡¹
- [ ] æ‰€æœ‰ Entity éƒ½æœ‰æ­£ç¡®çš„è¡¨åå’Œåˆ—åæ˜ å°„
- [ ] æ‰€æœ‰ DAO æ–¹æ³•éƒ½æœ‰æ­£ç¡®çš„ suspend/Flow æ ‡è®°
- [ ] æ‰€æœ‰ç½‘ç»œè¯·æ±‚éƒ½æœ‰é”™è¯¯å¤„ç†
- [ ] æ‰€æœ‰æ•æ„Ÿæ•°æ®éƒ½ä½¿ç”¨åŠ å¯†å­˜å‚¨
- [ ] æ‰€æœ‰æ•°æ®è½¬æ¢éƒ½æœ‰ç©ºå®‰å…¨å¤„ç†
- [ ] æ‰€æœ‰ Repository æ–¹æ³•éƒ½è¿”å› Result<T>

### æ¨èæ£€æŸ¥é¡¹
- [ ] æ•°æ®åº“æŸ¥è¯¢æ˜¯å¦ä½¿ç”¨äº†ç´¢å¼•ä¼˜åŒ–
- [ ] ç½‘ç»œè¯·æ±‚æ˜¯å¦è®¾ç½®äº†åˆç†çš„è¶…æ—¶
- [ ] æ˜¯å¦é¿å…äº†åœ¨ä¸»çº¿ç¨‹è¿›è¡Œæ•°æ®åº“æ“ä½œ
- [ ] æ˜¯å¦æ­£ç¡®å¤„ç†äº†å¹¶å‘è®¿é—®

---

**æœ€åæ›´æ–°**: 2025-12-08  
**ç»´æŠ¤è€…**: æ•°æ®è®¿é—®å±‚å›¢é˜Ÿ  
**ç‰ˆæœ¬**: v2.0