

### 第一板块：本地记忆系统 (Local Persistence)
**负责：** 存储结构化的业务数据（人、标签）。

#### 任务 1：构建数据库基础 (Room Entities & DAOs)
* **目的**：将 Domain 层的业务对象持久化到 SQLite，并支持响应式查询（Flow）。
* **方法**：
    1.  定义 `ContactProfileEntity` 和 `BrainTagEntity`（表结构）。
    2.  编写 `RoomTypeConverters`（解决 Map/Enum 存储问题）。
    3.  编写 `ContactDao` 和 `BrainTagDao`（定义 SQL 操作）。
    4.  配置 `AppDatabase`（挂载表和转换器）。
* **AI 解释/指令**：
    > 告诉 AI：Entity 必须是 Domain Model 的扁平化映射（Map转String，Enum转String）。DAO 的读取操作必须返回 `Flow` 以支持 MVVM 的实时刷新。写入操作统一使用 `OnConflictStrategy.REPLACE` 实现 Upsert。

---

### 第二板块：远程通信系统 (Remote Networking)
**负责：** 连接云端 AI 大脑（OpenAI/DeepSeek）。

#### 任务 2：构建网络通信基础 (Retrofit & DTOs)
* **目的**：建立一个支持 **BYOK (动态 URL)** 的 HTTP 客户端，用于发送 Prompt 和接收 AI 回复。
* **方法**：
    1.  定义 **DTO (Data Transfer Objects)**：`ChatRequestDto`, `ChatResponseDto`, `MessageDto`。这些是专门用于 JSON 序列化的类，**严禁**复用 Domain Model。
    2.  定义 **API 接口**：`OpenAiApi`。使用 `@Url` 注解实现动态 BaseUrl 替换。
* **AI 解释/指令**：
    > 告诉 AI：DTO 类必须与 Domain Model 严格隔离。API 接口必须支持通过参数动态传入 URL（因为用户可能切换 AI 服务商）。

---

### 第三板块：安全配置系统 (Secure Configuration)
**负责：** 管理敏感钥匙（Key）和全局开关。

#### 任务 3：构建安全存储 (EncryptedSharedPreferences)
* **目的**：提供一个“保险箱”，安全地存储用户的 API Key，防止手机被 Root 后泄露。
* **方法**：
    1.  在 Hilt 模块中提供 `EncryptedSharedPreferences` 的单例实例。
    2.  实现 `SettingsRepositoryImpl`，封装 Key 的读写逻辑。
* **AI 解释/指令**：
    > 告诉 AI：不要使用普通的 `SharedPreferences`。必须使用 Jetpack Security 库创建加密实例。Key 的读写操作应该是挂起函数 (`suspend`)，虽然 SP 操作很快，但在协程中处理 IO 是最佳实践。

---

### 第四板块：总装与交付 (Assembly & Delivery)
**负责**：将上面三个板块封装起来，对外提供符合 Domain 接口规范的服务。

#### 任务 4：依赖注入配置 (Hilt Modules)
* **目的**：初始化所有单例（Database, Retrofit, OkHttpClient, EncryptedPrefs），并告诉 App 如何找到它们。
* **方法**：
    1.  创建 `DatabaseModule`：提供 Room 实例和 DAOs。
    2.  创建 `NetworkModule`：提供配置好 Gson 的 Retrofit 和配置好超时/Log 的 OkHttpClient。
    3.  创建 `RepositoryModule`：将 `Impl` 类绑定到 Domain 层的 `Interface` 上。
* **AI 解释/指令**：
    > 告诉 AI：所有 Network 组件必须是 `@Singleton`。OkHttpClient 必须配置 `connectTimeout` (建议 30s，AI 响应慢) 和 `loggingInterceptor` (仅 Debug 模式开启)。

#### 任务 5：仓库实现落地 (Repository Implementation)
* **目的**：编写“胶水代码”，协调 Local 和 Remote 数据源，完成数据清洗和转换。
* **方法**：
    1.  `Contact/BrainTagRepositoryImpl`：负责 Entity <-> Domain Model 的转换。
    2.  `AiRepositoryImpl`：负责从 Settings 拿 Key -> 拼装 DTO -> 调 API -> 解析结果 -> 返回 Domain Model。
* **AI 解释/指令**：
    > 告诉 AI：Repository 是数据层的唯一出口。严禁将 Entity 或 DTO 暴露给 Domain 层，必须在内部进行 `map { it.toDomain() }` 转换。对于 AI 请求，如果发生网络异常，需要捕获并抛出业务层能理解的异常。

---

### 总结

我们需要干的事情就是构建 **三套引擎（数据库、网络、保险箱）**，然后通过 **一套总线（Hilt + Repository）** 把它们连接到之前写好的业务层上。

**建议执行路径**：
先做 **板块一 (本地)** -> 再做 **板块四 (DI配置)** -> 跑通本地数据的单元测试。
然后做 **板块二 (网络)** -> 再做 **板块三 (安全)** -> 跑通 AI 调用的逻辑。

