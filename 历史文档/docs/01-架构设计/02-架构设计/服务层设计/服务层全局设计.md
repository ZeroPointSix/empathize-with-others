# 服务层全局设计

## 概述

服务层(Service Layer)在Clean Architecture中位于**领域层(Domain Layer)**,是连接表现层(Presentation)和数据层(Data)的核心枢纽。它封装了应用的业务逻辑和业务规则,对外提供高内聚、低耦合的业务能力。

### 服务层的定位

在我们的Empathy AI项目中,服务层的职责可以用一个类比来理解:

> **数据层**是"仓库管理员" - 负责存取货物(CRUD、网络请求)  
> **服务层**是"业务经理" - 负责决策和编排(什么时候取什么货、如何组合、如何校验)  
> **表现层**是"前台接待" - 负责与用户交互(展示、收集输入)

---

## 架构分层图

```
┌─────────────────────────────────────────────┐
│          Presentation Layer                 │
│         (ViewModel / Composable)            │
└──────────────────┬──────────────────────────┘
                   │ 调用
                   ↓
┌─────────────────────────────────────────────┐
│          Service Layer (Domain)             │
│  ┌──────────────┐  ┌──────────────┐        │
│  │   UseCase    │  │   Service    │        │
│  │  业务编排     │  │  领域服务     │        │
│  └──────────────┘  └──────────────┘        │
│           │ 调用多个Repository              │
└───────────┼─────────────────────────────────┘
            │
            ↓
┌─────────────────────────────────────────────┐
│          Data Layer                         │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐   │
│  │ Contact  │ │ BrainTag │ │    AI    │   │
│  │Repository│ │Repository│ │Repository│   │
│  └──────────┘ └──────────┘ └──────────┘   │
└─────────────────────────────────────────────┘
```

---

## 核心组件对比

服务层包含两种核心组件:**UseCase** 和 **Service**。它们的区别和使用场景如下:

| 维度 | UseCase (用例) | Service (领域服务) |
|------|---------------|-------------------|
| **职责** | 编排单个业务流程 | 提供可复用的领域能力 |
| **生命周期** | 一次性执行 | 无状态单例 |
| **依赖** | 依赖多个Repository和Service | 通常不依赖Repository |
| **示例** | `AnalyzeChatUseCase` - 分析聊天 | `PrivacyEngine` - 脱敏引擎 |
| **调用方** | ViewModel | UseCase |
| **命名规范** | `XxxUseCase` | `XxxEngine` / `XxxService` |

### UseCase(用例)

**设计目标**:封装一个完整的业务流程,对应用户的一个操作意图。

**典型结构**:
```kotlin
class AnalyzeChatUseCase @Inject constructor(
    private val contactRepository: ContactRepository,
    private val brainTagRepository: BrainTagRepository,
    private val privacyRepository: PrivacyRepository,
    private val aiRepository: AiRepository
) {
    suspend operator fun invoke(
        contactId: String,
        rawContext: List<String>
    ): Result<AnalysisResult> {
        // 1. 加载数据
        // 2. 数据清洗
        // 3. 脱敏处理
        // 4. 调用AI
        // 5. 返回结果
    }
}
```

**关键特征**:
- 使用`operator fun invoke`使其可以像函数一样调用
- 返回`Result<T>`封装成功/失败状态
- 所有业务逻辑都是`suspend`函数(支持协程)

### Service(领域服务)

**设计目标**:提供跨多个UseCase的可复用能力,通常是无状态的纯函数。

**典型结构**:
```kotlin
object PrivacyEngine {
    fun mask(rawText: String, privacyMapping: Map<String, String>): String {
        var maskedText = rawText
        privacyMapping.forEach { (original, mask) ->
            maskedText = maskedText.replace(original, mask, ignoreCase = true)
        }
        return maskedText
    }
}
```

**关键特征**:
- 通常使用`object`声明为单例
- 纯函数(无副作用、无状态)
- 不直接依赖Repository(数据由UseCase传入)

---

## 服务层三大板块

我们将服务层的设计分为三个模块,逐步构建完整的业务能力:

### 板块一:核心服务开发

**负责**:单个UseCase的标准开发流程。

**核心内容**:
- UseCase五步开发法
- 业务逻辑封装原则
- Suspend函数与协程使用
- 完整开发示例

**输出物**:掌握如何从零到一编写一个标准UseCase。

---

### 板块二:服务编排

**负责**:多个数据源的协调与数据流转。

**核心内容**:
- 多Repository并行/串行调用
- 数据清洗与转换模式
- Flow响应式数据流
- 典型编排场景

**输出物**:掌握如何高效协调多个Repository,处理复杂的数据流。

---

### 板块三:业务规则引擎

**负责**:可扩展的规则定义与执行。

**核心内容**:
- 基于BrainTag的规则定义
- 规则匹配与执行引擎
- 与PrivacyEngine/SafetyCheck集成
- 可扩展设计

**输出物**:掌握如何构建灵活的业务规则系统。

---

## 核心设计原则

### 1. 依赖倒置原则(DIP)

服务层依赖的是Repository **接口**,而不是实现。这使得:
- 业务逻辑与技术实现解耦
- 可以轻松替换数据源(从Room换到Realm)
- 单元测试时可以Mock Repository

```kotlin
// ✅ 正确:依赖接口
class AnalyzeChatUseCase @Inject constructor(
    private val contactRepository: ContactRepository  // 接口
)

// ❌ 错误:依赖实现
class AnalyzeChatUseCase @Inject constructor(
    private val contactRepository: ContactRepositoryImpl  // 实现类
)
```

### 2. 单一职责原则(SRP)

每个UseCase只负责一个业务流程,不要在一个UseCase里塞入多个不相关的功能。

```kotlin
// ✅ 正确:单一职责
class AnalyzeChatUseCase  // 只负责分析聊天
class CheckDraftUseCase   // 只负责检查草稿

// ❌ 错误:职责混乱
class ChatUseCase {       // 什么都干
    fun analyze() { }
    fun checkDraft() { }
    fun sendMessage() { }
}
```

### 3. 错误边界原则

服务层必须捕获并转换数据层的异常,返回统一的`Result`类型。

```kotlin
suspend fun invoke(...): Result<AnalysisResult> {
    return try {
        // 业务逻辑
        Result.success(data)
    } catch (e: Exception) {
        // 转换为业务层能理解的错误
        Result.failure(e)
    }
}
```

**禁止**:让数据层的异常(如`HttpException`)直接抛到表现层。

### 4. 数据不可变原则

从Repository获取的Domain Model在服务层中应该是不可变的(使用`data class`的`copy`方法)。

```kotlin
// ✅ 正确:不修改原对象
val updatedProfile = profile.copy(
    facts = profile.facts + newFacts
)

// ❌ 错误:直接修改
profile.facts.putAll(newFacts)  // 如果facts是可变Map
```

### 5. 并发安全原则

使用Kotlin协程的结构化并发,避免线程安全问题。

```kotlin
// ✅ 正确:使用协程
suspend fun loadData() {
    val profile = contactRepository.getProfile(id).getOrThrow()
    val tags = brainTagRepository.getTagsForContact(id).first()
}

// ❌ 错误:使用线程
fun loadData() {
    Thread {
        // 回调地狱...
    }.start()
}
```

---

## 服务层与数据层的边界

### 数据层职责(Data Layer)
- **CRUD操作**:增删改查数据库
- **网络请求**:调用远程API
- **数据持久化**:存储到本地
- **DTO转换**:Entity/DTO ↔ Domain Model

### 服务层职责(Service Layer)
- **业务逻辑**:判断、计算、决策
- **流程编排**:协调多个Repository
- **数据校验**:业务规则检查
- **异常处理**:转换技术异常为业务异常

### 交互规则

1. **单向依赖**:服务层依赖数据层,数据层不能依赖服务层
2. **接口隔离**:服务层只能通过Repository接口调用数据层
3. **数据转换**:数据层负责Entity↔Model转换,服务层只处理Domain Model
4. **异常隔离**:数据层的技术异常不能穿透到服务层

---

## 典型业务流程示例

以`AnalyzeChatUseCase`为例,展示服务层的完整工作流:

```
用户点击[帮我分析]
       ↓
ViewModel调用UseCase
       ↓
┌──────────────────────────────────────┐
│  AnalyzeChatUseCase                  │
│                                      │
│  1. 从ContactRepository加载画像       │
│  2. 从BrainTagRepository加载标签      │
│  3. 从PrivacyRepository加载脱敏规则   │
│  4. 使用PrivacyEngine脱敏上下文       │
│  5. 组装Prompt                       │
│  6. 调用AiRepository分析             │
│  7. 返回Result<AnalysisResult>       │
└──────────────────────────────────────┘
       ↓
ViewModel更新UI状态
```

**关键点**:
- UseCase协调了4个Repository
- 使用了1个领域服务(PrivacyEngine)
- 所有操作都是异步的(suspend)
- 返回统一的Result类型

---

## 总结

服务层是Clean Architecture的核心,它通过以下方式实现业务逻辑与技术细节的解耦:

1. **UseCase封装业务流程** - 对应用户的每一个操作意图
2. **Service提供可复用能力** - 跨UseCase的通用逻辑
3. **依赖Repository接口** - 而不是具体实现
4. **返回Result类型** - 统一的错误处理
5. **使用协程** - 异步操作的标准方案

**执行路径建议**:
先掌握**板块一(核心服务开发)** → 理解**板块二(服务编排)** → 最后学习**板块三(业务规则引擎)**。

每个板块都有详细的开发指南和示例代码,帮助你从零到一构建高质量的服务层。