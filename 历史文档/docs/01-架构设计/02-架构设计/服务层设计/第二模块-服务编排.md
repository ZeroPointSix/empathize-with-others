# 第二模块:服务编排

## 概述

服务编排(Service Orchestration)是UseCase的核心能力之一。当一个业务流程需要协调多个Repository时,如何高效、正确地组织这些调用,是本模块要解决的问题。

---

## 多Repository协调模式

### 模式一:串行调用(Serial Execution)

**使用场景**:后续调用依赖前面调用的结果

**特点**:
- 调用顺序严格
- 数据有依赖关系
- 执行时间 = 各调用时间之和

**示例**:
```kotlin
suspend fun invoke(contactId: String): Result<AnalysisResult> {
    return try {
        // 第1步:加载联系人画像
        val profile = contactRepository.getProfile(contactId).getOrThrow()
        
        // 第2步:根据画像的contextDepth加载相应数量的标签
        val tags = brainTagRepository.getTagsForContact(contactId)
            .first()
            .take(profile.contextDepth)
        
        // 第3步:使用画像和标签调用AI
        val result = aiRepository.analyze(
            profile = profile,
            tags = tags
        ).getOrThrow()
        
        Result.success(result)
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

**执行时序**:
```
获取画像(200ms)
     ↓
获取标签(150ms)
     ↓
AI分析(2000ms)
     ↓
总耗时: 2350ms
```

---

### 模式二:并行调用(Parallel Execution)

**使用场景**:多个调用之间无依赖关系

**特点**:
- 同时发起多个请求
- 等待所有结果返回
- 执行时间 = max(各调用时间)

**示例**:
```kotlin
suspend fun invoke(contactId: String): Result<AnalysisResult> = coroutineScope {
    return@coroutineScope try {
        // 并行加载三个数据源
        val profileDeferred = async { contactRepository.getProfile(contactId) }
        val tagsDeferred = async { brainTagRepository.getTagsForContact(contactId).first() }
        val privacyDeferred = async { privacyRepository.getPrivacyMapping() }
        
        // 等待所有结果
        val profile = profileDeferred.await().getOrThrow()
        val tags = tagsDeferred.await().getOrThrow()
        val privacyMapping = privacyDeferred.await().getOrElse { emptyMap() }
        
        // 使用结果进行后续处理
        val result = processData(profile, tags, privacyMapping)
        
        Result.success(result)
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

**执行时序**:
```
获取画像(200ms) ────┐
获取标签(150ms) ────┤ 并行执行
获取隐私(100ms) ────┘
                   ↓
               处理数据(50ms)
                   ↓
            总耗时: 250ms
```

**性能对比**:
- 串行调用:200 + 150 + 100 = 450ms
- 并行调用:max(200, 150, 100) + 50 = 250ms
- **提升**:约45%

---

### 模式三:混合编排(Hybrid Orchestration)

**使用场景**:部分调用可并行,部分必须串行

**示例 - AnalyzeChatUseCase完整流程**:
```kotlin
suspend fun invoke(
    contactId: String,
    rawContext: List<String>
): Result<AnalysisResult> = coroutineScope {
    return@coroutineScope try {
        // 阶段1: 前置检查(串行)
        val apiKey = settingsRepository.getApiKey().getOrNull()
        if (apiKey.isNullOrBlank()) {
            return@coroutineScope Result.failure(IllegalStateException("未配置API Key"))
        }
        
        // 阶段2: 并行加载基础数据
        val profileDeferred = async { contactRepository.getProfile(contactId) }
        val tagsDeferred = async { brainTagRepository.getTagsForContact(contactId).first() }
        val privacyDeferred = async { privacyRepository.getPrivacyMapping() }
        
        val profile = profileDeferred.await().getOrThrow()
        val tags = tagsDeferred.await().getOrThrow()
        val privacyMapping = privacyDeferred.await().getOrElse { emptyMap() }
        
        // 阶段3: 数据清洗(串行)
        val cleanedContext = rawContext
            .distinct()
            .takeLast(profile.contextDepth)
        
        val maskedContext = PrivacyEngine.maskBatch(cleanedContext, privacyMapping)
        
        // 阶段4: AI分析(串行,依赖前面所有结果)
        val prompt = buildPrompt(profile, tags, maskedContext)
        val result = aiRepository.analyzeChat(prompt, systemInstruction).getOrThrow()
        
        Result.success(result)
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

**执行流程图**:
```
检查API Key
     ↓
┌────────────────┐
│  并行加载数据   │
│  - 画像        │
│  - 标签        │
│  - 隐私规则    │
└────────────────┘
     ↓
数据清洗 + 脱敏
     ↓
组装Prompt
     ↓
AI分析
```

---

## 数据流转与转换

### 数据流转原则

**原则1:单向数据流**

数据应该从Repository流向UseCase,再流向ViewModel,不能反向:

```kotlin
// 正确流向
Repository → UseCase → ViewModel → UI

// 错误 - 不要让数据反向流动
UI → UseCase → Repository → UseCase → UI
```

**原则2:数据不可变**

从Repository获取的数据在UseCase中不应被修改:

```kotlin
// 正确 - 使用copy创建新对象
val updatedProfile = profile.copy(
    facts = profile.facts + newFacts
)

// 错误 - 直接修改原对象
profile.facts.putAll(newFacts)
```

---

### 数据转换模式

**模式1:Repository层转换**

Entity ↔ Domain Model的转换在Repository内部完成:

```kotlin
class ContactRepositoryImpl @Inject constructor(
    private val dao: ContactDao
) : ContactRepository {
    
    override fun getAllProfiles(): Flow<List<ContactProfile>> {
        return dao.getAllProfiles().map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    private fun ContactProfileEntity.toDomain(): ContactProfile {
        return ContactProfile(
            id = this.id,
            name = this.name,
            facts = Gson().fromJson(this.factsJson, typeToken)
        )
    }
}
```

**模式2:UseCase层转换**

业务逻辑相关的转换在UseCase中完成:

```kotlin
class AnalyzeChatUseCase @Inject constructor(...) {
    
    suspend fun invoke(...): Result<AnalysisResult> {
        val tags = brainTagRepository.getTagsForContact(id).first()
        
        // 按类型分组 - 业务逻辑转换
        val redTags = tags.filter { it.type == TagType.RISK_RED }
        val greenTags = tags.filter { it.type == TagType.STRATEGY_GREEN }
        
        // 转换为Prompt格式 - 业务逻辑转换
        val promptText = buildPrompt(redTags, greenTags)
        
        return aiRepository.analyze(promptText)
    }
}
```

---

### 数据清洗策略

**策略1:去重**

```kotlin
val uniqueMessages = rawMessages.distinct()

val uniqueByKey = rawMessages.distinctBy { it.id }
```

**策略2:过滤**

```kotlin
val validMessages = rawMessages.filter { it.content.isNotBlank() }

val recentMessages = rawMessages.filter { 
    it.timestamp > cutoffTime 
}
```

**策略3:排序与截取**

```kotlin
val latestMessages = rawMessages
    .sortedByDescending { it.timestamp }
    .take(profile.contextDepth)

val oldestFirst = rawMessages
    .sortedBy { it.timestamp }
    .takeLast(10)
```

**策略4:映射转换**

```kotlin
val maskedMessages = rawMessages.map { message ->
    PrivacyEngine.mask(message.content, privacyMapping)
}

val formatted = rawMessages.map { message ->
    "${message.sender}: ${message.content}"
}
```

**组合使用**:
```kotlin
val processedContext = rawScreenContext
    .filter { it.isNotBlank() }           // 过滤空白
    .distinct()                           // 去重
    .takeLast(profile.contextDepth)       // 截取最近N条
    .map { PrivacyEngine.mask(it, mapping) }  // 脱敏
```

---

## Flow响应式数据流

### Flow基础概念

**Flow vs Suspend**:

```kotlin
// Suspend函数 - 一次性调用,返回单个结果
suspend fun getProfile(id: String): Result<ContactProfile>

// Flow - 持续监听,返回数据流
fun getAllProfiles(): Flow<List<ContactProfile>>
```

**使用场景对比**:

| 场景 | 使用Suspend | 使用Flow |
|------|------------|----------|
| 一次性查询 | ✅ | ❌ |
| 实时监听数据变化 | ❌ | ✅ |
| 在UseCase中 | ✅ 常用 | ⚠️ 少用 |
| 在ViewModel中 | ✅ 调用 | ✅ 收集 |

---

### 在UseCase中使用Flow

**方式1:转为一次性数据**

```kotlin
class AnalyzeChatUseCase @Inject constructor(
    private val brainTagRepository: BrainTagRepository
) {
    suspend fun invoke(contactId: String): Result<AnalysisResult> {
        // 使用first()获取Flow的第一个值
        val tags = brainTagRepository.getTagsForContact(contactId).first()
        
        // 后续使用tags进行业务处理
        return processWithTags(tags)
    }
}
```

**方式2:返回Flow给ViewModel**

```kotlin
class ObserveProfileUseCase @Inject constructor(
    private val contactRepository: ContactRepository
) {
    // 注意:这里不是suspend函数
    operator fun invoke(contactId: String): Flow<ContactProfile?> {
        return contactRepository.getProfile(contactId)
            .map { result -> result.getOrNull() }
    }
}
```

**ViewModel中收集Flow**:
```kotlin
class ProfileViewModel @Inject constructor(
    private val observeProfileUseCase: ObserveProfileUseCase
) : ViewModel() {
    
    private val _profileState = MutableStateFlow<ProfileState>(ProfileState.Loading)
    val profileState: StateFlow<ProfileState> = _profileState
    
    fun loadProfile(contactId: String) {
        viewModelScope.launch {
            observeProfileUseCase(contactId).collect { profile ->
                _profileState.value = if (profile != null) {
                    ProfileState.Success(profile)
                } else {
                    ProfileState.Error("未找到联系人")
                }
            }
        }
    }
}
```

---

### Flow操作符使用

**map - 转换数据**:
```kotlin
fun getFormattedProfiles(): Flow<List<String>> {
    return contactRepository.getAllProfiles()
        .map { profiles ->
            profiles.map { "${it.name} (${it.facts.size}条信息)" }
        }
}
```

**filter - 过滤数据**:
```kotlin
fun getActiveProfiles(): Flow<List<ContactProfile>> {
    return contactRepository.getAllProfiles()
        .map { profiles ->
            profiles.filter { it.facts.isNotEmpty() }
        }
}
```

**combine - 合并多个Flow**:
```kotlin
fun getCombinedData(contactId: String): Flow<CombinedData> {
    val profileFlow = contactRepository.getProfile(contactId)
    val tagsFlow = brainTagRepository.getTagsForContact(contactId)
    
    return combine(profileFlow, tagsFlow) { profile, tags ->
        CombinedData(
            profile = profile.getOrNull(),
            tags = tags
        )
    }
}
```

---

## 典型编排场景示例

### 场景1:数据预加载

**需求**:在用户进入详情页前,预加载所有需要的数据

```kotlin
class PreloadContactDataUseCase @Inject constructor(
    private val contactRepository: ContactRepository,
    private val brainTagRepository: BrainTagRepository,
    private val privacyRepository: PrivacyRepository
) {
    data class PreloadedData(
        val profile: ContactProfile,
        val tags: List<BrainTag>,
        val privacyMapping: Map<String, String>
    )
    
    suspend operator fun invoke(contactId: String): Result<PreloadedData> = coroutineScope {
        return@coroutineScope try {
            // 并行加载所有数据
            val profileDeferred = async { contactRepository.getProfile(contactId) }
            val tagsDeferred = async { brainTagRepository.getTagsForContact(contactId).first() }
            val privacyDeferred = async { privacyRepository.getPrivacyMapping() }
            
            // 等待并验证结果
            val profile = profileDeferred.await().getOrThrow()
            val tags = tagsDeferred.await().getOrThrow()
            val privacyMapping = privacyDeferred.await().getOrElse { emptyMap() }
            
            Result.success(PreloadedData(profile, tags, privacyMapping))
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

---

### 场景2:分步校验

**需求**:多层校验,任何一层失败立即返回

```kotlin
class ValidateAndSaveUseCase @Inject constructor(
    private val contactRepository: ContactRepository,
    private val brainTagRepository: BrainTagRepository
) {
    suspend operator fun invoke(
        contactId: String,
        newFact: Pair<String, String>
    ): Result<Unit> {
        return try {
            // 第1层:格式校验
            validateFormat(newFact)
            
            // 第2层:业务规则校验
            val profile = contactRepository.getProfile(contactId).getOrThrow()
            if (profile.facts.size >= 50) {
                return Result.failure(IllegalStateException("事实数量已达上限"))
            }
            