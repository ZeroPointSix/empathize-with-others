
### 通用原则 (General Principles)

1.  **文件命名**：`PascalCase` (大驼峰)，例如 `ContactProfileEntity.kt`。
2.  **表名/列名**：`snake_case` (下划线)，例如 `contact_id`。这是数据库的标准。
3.  **Kotlin 属性**：`camelCase` (小驼峰)，例如 `contactId`。
4.  **空安全**：数据库字段尽量设为 `NOT NULL` (即 Kotlin 中不带 `?` 的类型)，除非业务允许为空。

-----

### Step 1: 环境配置规范 (Dependencies)

在 `build.gradle.kts` 中，我们遵循 **"分组管理"** 的原则，不把库扔得到处都是。

  * **规范**：
      * 必须明确版本号变量（如 `val roomVersion = "2.6.1"`），方便统一升级。
      * 同类库放在一起（Room 及其 KSP 编译器）。
      * 注释清晰。

<!-- end list -->

```kotlin
// 示例规范
dependencies {
    // === Local Storage (Room) ===
    val roomVersion = "2.6.1"
    implementation("androidx.room:room-runtime:$roomVersion")
    implementation("androidx.room:room-ktx:$roomVersion") // 支持 Coroutines/Flow
    ksp("androidx.room:room-compiler:$roomVersion")       // 编译器

    // === Serialization (Gson) ===
    implementation("com.google.gson:gson:2.10.1")
}
```

-----

### Step 2: 实体类规范 (Entities)

这是 SQL 表结构的定义处。

  * **规范 A：命名后缀**

      * 所有数据库对象必须以 **`Entity`** 结尾，以区分 Domain 层的 Model。
      * *例：* `ContactProfileEntity` (DB) vs `ContactProfile` (Domain).

  * **规范 B：表名映射**

      * `tableName` 必须是复数、下划线风格。
      * *例：* `@Entity(tableName = "contact_profiles")`

  * **规范 C：主键与列名**

      * 必须显式指定 `@ColumnInfo(name = "xxx")`。这能让你的 Kotlin 变量名（camelCase）和数据库列名（snake\_case）解耦。
      * *好处：* 以后你重构代码改变量名，不会导致数据库数据丢失。

<!-- end list -->

```kotlin
// 示例规范
@Entity(tableName = "brain_tags") // SQL 表名
data class BrainTagEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0, // 默认值设为 0，插入时 Room 会自动生成

    @ColumnInfo(name = "contact_id", index = true) // SQL 列名 + 索引
    val contactId: String,

    @ColumnInfo(name = "tag_type") // 映射: tagType -> tag_type
    val type: String
)
```

-----

### Step 3: 翻译器规范 (Type Converters)

解决 Gson 序列化的地方。

  * **规范 A：空安全处理**

      * 数据库读出来的字符串可能是 `null`（虽然我们设了 Not Null，但要防万一）。代码必须处理 `String?` 并返回非空的 `Map`。

  * **规范 B：泛型处理**

      * 使用 Gson 的 `TypeToken` 时，必须写清楚泛型类型。

<!-- end list -->

```kotlin
// 示例规范
class RoomTypeConverters {
    @TypeConverter
    fun fromStringMap(value: String?): Map<String, String> {
        if (value.isNullOrEmpty()) return emptyMap() // 防御性编程
        // ... Gson 解析逻辑 ...
    }
}
```

-----

### Step 4: DAO 规范 (Data Access Objects)

这是写 SQL 的地方。

  * **规范 A：函数命名**

      * 查询：`get...` 或 `find...`
      * 插入/更新：`insertOrUpdate...` (Upsert)
      * 删除：`delete...`

  * **规范 B：返回值类型**

      * **一次性操作 (IO)**：必须挂起 `suspend fun`。适用于 Insert/Delete/Update。
      * **流式查询 (Stream)**：必须返回 `Flow<T>`，**不加** `suspend`。适用于 `getAll...`。

  * **规范 C：冲突策略**

      * 默认使用 `onConflict = OnConflictStrategy.REPLACE` 实现“覆盖更新”。

<!-- end list -->

```kotlin
// 示例规范
@Dao
interface ContactDao {
    // 读流 (无 suspend)
    @Query("SELECT * FROM profiles")
    fun getAllProfiles(): Flow<List<ContactProfileEntity>>

    // 写 (有 suspend)
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertProfile(entity: ContactProfileEntity)
}
```

-----

### Step 5: 仓库实现规范 (Repository Impl)

这是最关键的逻辑层。

  * **规范 A：映射函数 (Mappers)**

      * **禁止**在 Repository 类外部暴露 Entity。
      * 必须编写私有的扩展函数 `toDomain()` 和 `toEntity()` 来处理数据转换。
      * *位置：* 直接写在 `ContactRepositoryImpl.kt` 文件的底部。

  * **规范 B：构造函数注入**

      * 必须使用 `@Inject` 注入 DAO，而不是自己 `database.dao()`。

  * **规范 C：数据清洗**

      * 如果数据库存的是 JSON String，必须在这里转成 Map，绝对不能把 String 扔给 Domain 层。

<!-- end list -->

```kotlin
// 示例规范
class ContactRepositoryImpl @Inject constructor(
    private val dao: ContactDao
) : ContactRepository {

    override fun getAllProfiles(): Flow<List<ContactProfile>> {
        return dao.getAllProfiles().map { entities ->
            entities.map { it.toDomain() } // 调用映射函数
        }
    }

    // --- Private Mappers (写在文件底部) ---
    private fun ContactProfileEntity.toDomain(): ContactProfile {
        return ContactProfile(
            id = this.id,
            facts = Gson().fromJson(...) // 转换逻辑
        )
    }
}
```

