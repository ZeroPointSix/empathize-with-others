# 服务层开发规范

## 概述

本文档定义了服务层(Domain Layer)的代码规范,包括命名、代码组织、依赖注入、错误处理和测试规范。遵循这些规范可以保证代码的一致性、可维护性和可测试性。

---

## 一、命名规范

### 1.1 UseCase 命名

**规范**:动词 + 名词 + `UseCase` 后缀

**格式**:`[动词][业务对象]UseCase`

**示例**:
```kotlin
// ✅ 正确示例
AnalyzeChatUseCase      // 分析聊天
CheckDraftUseCase       // 检查草稿
FeedTextUseCase         // 喂养文本
SaveProfileUseCase      // 保存画像
DeleteContactUseCase    // 删除联系人

// ❌ 错误示例
ChatAnalyzer            // 缺少UseCase后缀
AnalyzeUseCase          // 缺少业务对象
ChatUseCase             // 动词不明确
```

**常用动词清单**:
- `Analyze` - 分析
- `Check` - 检查
- `Feed` - 喂养
- `Save` - 保存
- `Delete` - 删除
- `Update` - 更新
- `Get` - 获取
- `Validate` - 验证
- `Process` - 处理

### 1.2 Service 命名

**规范**:名词 + `Engine` / `Service` / `Manager` 后缀

**格式**:`[领域名称][Engine|Service|Manager]`

**示例**:
```kotlin
// ✅ 正确示例
PrivacyEngine           // 隐私引擎(核心算法)
ValidationService       // 验证服务(业务规则)
CacheManager            // 缓存管理器(资源管理)

// ❌ 错误示例
Privacy                 // 缺少后缀
DoPrivacy               // 使用了动词
PrivacyHelper           // Helper是反模式
```

**后缀选择指南**:
- `Engine` - 核心算法、计算密集型(如PrivacyEngine)
- `Service` - 业务规则、流程封装
- `Manager` - 资源管理、状态维护

### 1.3 文件命名

**规范**:PascalCase(大驼峰),与类名保持一致

**目录结构**:
```
domain/
├── model/              # 领域模型
│   ├── AnalysisResult.kt
│   ├── BrainTag.kt
│   └── ContactProfile.kt
├── repository/         # 仓库接口
│   ├── AiRepository.kt
│   ├── ContactRepository.kt
│   └── BrainTagRepository.kt
├── service/            # 领域服务
│   ├── PrivacyEngine.kt
│   └── ValidationService.kt
└── usecase/            # 用例
    ├── AnalyzeChatUseCase.kt
    ├── CheckDraftUseCase.kt
    └── FeedTextUseCase.kt
```

### 1.4 变量命名

**规范**:camelCase(小驼峰),语义化命名

```kotlin
// ✅ 正确示例
val contactProfile: ContactProfile
val maskedContext: List<String>
val analysisResult: Result<AnalysisResult>

// ❌ 错误示例
val cp: ContactProfile          // 过度缩写
val data: ContactProfile        // 语义不明确
val contactProfileData: ContactProfile  // 冗余的Data后缀
```

---

## 二、代码组织规范

### 2.1 UseCase 标准结构

每个UseCase必须遵循以下结构:

```kotlin
/**
 * [一句话描述业务场景]
 *
 * 触发场景: [用户操作描述]
 * 功能: [详细功能说明]
 */
class XxxUseCase @Inject constructor(
    // 1. 依赖声明(按字母顺序排列)
    private val repository1: Repository1,
    private val repository2: Repository2,
    private val service: Service
) {
    /**
     * 执行用例
     *
     * @param param1 参数说明
     * @param param2 参数说明
     * @return 返回值说明
     */
    suspend operator fun invoke(
        param1: String,
        param2: Int
    ): Result<OutputType> {
        return try {
            // 2. 前置检查
            validateInput(param1, param2)
            
            // 3. 数据加载
            val data = loadData(param1)
            
            // 4. 业务处理
            val result = processData(data, param2)
            
            // 5. 结果返回
            Result.success(result)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    // 6. 私有辅助方法(按调用顺序排列)
    private suspend fun validateInput(param1: String, param2: Int) {
        // 验证逻辑
    }
    
    private suspend fun loadData(param1: String): DataType {
        // 加载逻辑
    }
    
    private suspend fun processData(data: DataType, param2: Int): OutputType {
        // 处理逻辑
    }
}
```

**关键规范**:
1. **依赖注入**:所有依赖必须通过构造函数注入
2. **operator fun invoke**:使UseCase可以像函数一样调用
3. **suspend**:所有IO操作都必须是挂起函数
4. **Result封装**:统一使用`Result<T>`包装返回值
5. **私有方法**:复杂逻辑拆分为私有方法

### 2.2 Service 标准结构

```kotlin
/**
 * [领域服务描述]
 *
 * 职责: [核心功能说明]
 */
object PrivacyEngine {
    /**
     * [方法功能说明]
     *
     * @param param1 参数说明
     * @return 返回值说明
     */
    fun methodName(param1: String, param2: Map<String, String>): String {
        // 纯函数实现(无副作用)
        return result
    }
}
```

**关键规范**:
1. **object单例**:Service通常声明为`object`
2. **纯函数**:无状态、无副作用、可预测
3. **不依赖Repository**:数据由调用方传入

### 2.3 导入顺序规范

```kotlin
// 1. Android SDK
import android.content.Context
import android.util.Log

// 2. 第三方库
import javax.inject.Inject
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first

// 3. 项目内部(按层级排序)
import com.empathy.ai.domain.model.AnalysisResult
import com.empathy.ai.domain.repository.AiRepository
import com.empathy.ai.domain.service.PrivacyEngine
```

---

## 三、依赖注入规范

### 3.1 构造函数注入

**规范**:必须使用构造函数注入,禁止字段注入

```kotlin
// ✅ 正确:构造函数注入
class AnalyzeChatUseCase @Inject constructor(
    private val contactRepository: ContactRepository,
    private val aiRepository: AiRepository
)

// ❌ 错误:字段注入
class AnalyzeChatUseCase {
    @Inject
    lateinit var contactRepository: ContactRepository
}
```

**原因**:
- 构造函数注入保证依赖不可变
- 便于单元测试(可以手动传入Mock)
- 避免`lateinit`的空安全问题

### 3.2 依赖接口而非实现

```kotlin
// ✅ 正确:依赖接口
class AnalyzeChatUseCase @Inject constructor(
    private val contactRepository: ContactRepository  // 接口
)

// ❌ 错误:依赖实现类
class AnalyzeChatUseCase @Inject constructor(
    private val contactRepository: ContactRepositoryImpl  // 实现类
)
```

### 3.3 依赖声明顺序

**规范**:按依赖类型和字母顺序排列

```kotlin
class AnalyzeChatUseCase @Inject constructor(
    // 1. Repository(按字母顺序)
    private val aiRepository: AiRepository,
    private val brainTagRepository: BrainTagRepository,
    private val contactRepository: ContactRepository,
    private val privacyRepository: PrivacyRepository,
    
    // 2. Service(按字母顺序)
    private val privacyEngine: PrivacyEngine,
    
    // 3. 其他依赖
    private val settingsRepository: SettingsRepository
)
```

---

## 四、错误处理规范

### 4.1 Result 封装模式

**规范**:所有UseCase必须返回`Result<T>`

```kotlin
suspend operator fun invoke(...): Result<OutputType> {
    return try {
        // 业务逻辑
        val result = doSomething()
        Result.success(result)
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

**禁止**:直接抛出异常到表现层

```kotlin
// ❌ 错误:直接抛异常
suspend operator fun invoke(...): OutputType {
    return doSomething()  // 可能抛异常
}
```

### 4.2 异常转换规范

**规范**:将数据层的技术异常转换为业务异常

```kotlin
suspend operator fun invoke(...): Result<OutputType> {
    return try {
        val apiKey = settingsRepository.getApiKey().getOrNull()
        
        // 业务规则检查
        if (apiKey.isNullOrBlank()) {
            return Result.failure(
                IllegalStateException("未配置 API Key,请先在设置中配置")
            )
        }
        
        // 调用Repository
        val result = aiRepository.analyze(...).getOrThrow()
        Result.success(result)
        
    } catch (e: HttpException) {
        // 转换HTTP异常为业务异常
        val message = when (e.code()) {
            401 -> "API Key无效,请检查配置"
            429 -> "请求过于频繁,请稍后再试"
            500 -> "服务暂时不可用,请稍后再试"
            else -> "网络请求失败: ${e.message}"
        }
        Result.failure(IllegalStateException(message, e))
        
    } catch (e: IOException) {
        // 转换网络异常
        Result.failure(IllegalStateException("网络连接失败,请检查网络设置", e))
        
    } catch (e: Exception) {
        // 兜底异常
        Result.failure(e)
    }
}
```

### 4.3 空值处理规范

**规范**:使用Kotlin的空安全特性,明确处理null情况

```kotlin
// ✅ 正确:明确处理null
val profile = contactRepository.getProfile(id).getOrNull()
    ?: return Result.failure(IllegalStateException("未找到联系人画像: $id"))

// ❌ 错误:使用!!强制解包
val profile = contactRepository.getProfile(id).getOrNull()!!
```

---

## 五、协程使用规范

### 5.1 Suspend 函数规范

**规范**:所有IO操作必须声明为`suspend`函数

```kotlin
// ✅ 正确
suspend operator fun invoke(...): Result<OutputType>

// ❌ 错误:阻塞主线程
fun invoke(...): Result<OutputType>
```

### 5.2 并行与串行调用

**串行调用**(有依赖关系):
```kotlin
suspend fun loadData() {
    val profile = contactRepository.getProfile(id).getOrThrow()
    val tags = brainTagRepository.getTagsForContact(profile.id).first()
}
```

**并行调用**(无依赖关系):
```kotlin
suspend fun loadData() = coroutineScope {
    val profileDeferred = async { contactRepository.getProfile(id).getOrThrow() }
    val tagsDeferred = async { brainTagRepository.getAllTags().getOrThrow() }
    
    val profile = profileDeferred.await()
    val tags = tagsDeferred.await()
}
```

### 5.3 Flow 使用规范

**规范**:Repository返回的Flow需要使用`first()`或`collect`转换

```kotlin
// ✅ 正确:使用first()获取一次性数据
val tags = brainTagRepository.getTagsForContact(id).first()

// ✅ 正确:使用collect订阅流式数据(较少在UseCase中使用)
brainTagRepository.getTagsForContact(id).collect { tags ->
    // 处理每次更新
}

// ❌ 错误:直接返回Flow(应该在ViewModel中订阅)
return brainTagRepository.getTagsForContact(id)
```

---

## 六、测试规范

### 6.1 单元测试结构

每个UseCase必须有对应的测试类:

```
test/
└── domain/
    └── usecase/
        ├── AnalyzeChatUseCaseTest.kt
        ├── CheckDraftUseCaseTest.kt
        └── FeedTextUseCaseTest.kt
```

### 6.2 测试类模板

```kotlin
class AnalyzeChatUseCaseTest {
    // 1. Mock对象声明
    private lateinit var contactRepository: ContactRepository
    private lateinit var aiRepository: AiRepository
    private lateinit var useCase: AnalyzeChatUseCase
    
    @Before
    fun setup() {
        // 2. 初始化Mock
        contactRepository = mockk()
        aiRepository = mockk()
        useCase = AnalyzeChatUseCase(
            contactRepository = contactRepository,
            aiRepository = aiRepository
        )
    }
    
    @Test
    fun `invoke成功时应返回分析结果`() = runTest {
        // Given: 准备测试数据
        val mockProfile = ContactProfile(...)
        coEvery { contactRepository.getProfile(any()) } returns Result.success(mockProfile)
        coEvery { aiRepository.analyzeChat(any(), any()) } returns Result.success(mockResult)
        
        // When: 执行用例
        val result = useCase.invoke("contact_123", listOf("Hello"))
        
        // Then: 验证结果
        assertTrue(result.isSuccess)
        assertEquals(expectedResult, result.getOrNull())
    }
    
    @Test
    fun `invoke时API Key未配置应返回失败`() = runTest {
        // Given
        coEvery { settingsRepository.getApiKey() } returns Result.success(null)
        
        // When
        val result = useCase.invoke("contact_123", 