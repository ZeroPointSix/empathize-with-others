# BUG-00005: 输入删除导致崩溃问题分析（恶性Bug）

## 问题描述
在添加联系人界面，先输入一些字符然后再删除，会导致程序崩溃。这是一个恶性Bug，严重影响用户体验。

## 1. 机制分析

### 框架运行机制
```
用户输入 → TextField.onValueChange → ContactDetailUiEvent.UpdateName
        → ContactDetailViewModel.updateName() → _uiState.update { name = newValue }
        → Compose重组 → TextField显示新值
```

### 正常流程
1. 用户在TextField中输入字符
2. 触发onValueChange回调
3. 发送UpdateName事件到ViewModel
4. ViewModel更新UiState中的name字段
5. Compose检测到状态变化，重组TextField
6. TextField显示更新后的值

### 当前问题
- 输入后删除字符导致崩溃
- 可能是空字符串处理、验证逻辑或Compose重组问题

## 2. 潜在根因树（Root Cause Tree）

### 框架机制层
- [ ] Compose重组异常：状态更新触发无限重组
- [ ] TextField状态管理：内部状态与外部状态冲突
- [ ] 协程取消异常：快速输入导致协程竞争

### 模块行为层
- [ ] `updateName()`方法中的空字符串处理
- [ ] 验证逻辑抛出未捕获异常
- [ ] `updateEditedProfile()`在空值时崩溃
- [ ] `require`或`check`断言失败

### 使用方式层
- [ ] TextField的value和onValueChange不匹配
- [ ] 状态更新过于频繁导致竞争条件

### 环境层
- [ ] 内存不足导致崩溃
- [ ] 特定Android版本的兼容性问题

## 3. 排查路径

### 第一步：获取崩溃日志
```bash
adb logcat *:E | grep -i "empathy\|crash\|exception"
```

### 第二步：检查updateName方法
```kotlin
// 文件: ContactDetailViewModel.kt
private fun updateName(name: String) {
    // 检查是否有空值处理问题
}
```

### 第三步：检查ContactProfile模型
```kotlin
// 文件: domain/model/ContactProfile.kt
data class ContactProfile(
    val name: String,  // 是否有require(name.isNotBlank())？
    ...
)
```

### 第四步：检查updateEditedProfile方法
```kotlin
// 可能在创建ContactProfile时触发断言失败
```

## 4. 最可能的根因

### 根因1：ContactProfile的require断言（最可能）
**推理过程**：
- ContactProfile模型中有 `require(name.isNotBlank())`
- 当用户删除所有字符时，name变为空字符串
- `updateEditedProfile()`尝试创建新的ContactProfile
- require断言失败，抛出IllegalArgumentException
- 异常未被捕获，导致崩溃

**验证方法**：
```kotlin
// ContactProfile.kt
data class ContactProfile(...) {
    init {
        require(name.isNotBlank()) { "name不能为空" }  // 这里会崩溃
    }
}
```

### 根因2：Fact模型的require断言
**推理过程**：
- 如果updateEditedProfile涉及Facts处理
- Fact模型也有require断言
- 可能在某个环节触发

### 根因3：快速输入导致的协程竞争
**推理过程**：
- 每次输入都触发状态更新
- 快速删除可能导致多个协程同时执行
- 状态不一致导致崩溃

## 5. 稳定修复方案

### 方案A：移除或放宽模型层的require断言

#### 5.1 修改ContactProfile
```kotlin
// ContactProfile.kt
data class ContactProfile(
    val id: String,
    val name: String,
    val targetGoal: String,
    ...
) {
    init {
        require(id.isNotBlank()) { "id不能为空" }
        // 移除name的require，改为在保存时验证
        // require(name.isNotBlank()) { "name不能为空" }
    }
}
```

#### 5.2 在ViewModel中添加防护
```kotlin
// ContactDetailViewModel.kt
private fun updateName(name: String) {
    _uiState.update {
        it.copy(
            name = name,
            hasUnsavedChanges = name != it.originalProfile?.name,
            nameError = null
        )
    }
    
    // 只有在编辑模式且name不为空时才更新editedProfile
    if (_uiState.value.isEditMode && name.isNotBlank()) {
        updateEditedProfile()
    }
}
```

#### 5.3 修改updateEditedProfile添加空值检查
```kotlin
private fun updateEditedProfile() {
    val currentState = _uiState.value
    
    // 空值检查，避免创建无效的ContactProfile
    if (currentState.name.isBlank()) {
        return  // 不更新editedProfile
    }
    
    val editedProfile = ContactProfile(
        id = currentState.contactId.ifBlank { UUID.randomUUID().toString() },
        name = currentState.name,
        targetGoal = currentState.targetGoal,
        contextDepth = currentState.contextDepth,
        facts = currentState.facts
    )
    
    _uiState.update { it.copy(editedProfile = editedProfile) }
}
```

### 方案B：使用try-catch包装（临时方案）
```kotlin
private fun updateEditedProfile() {
    try {
        // 原有逻辑
    } catch (e: IllegalArgumentException) {
        // 忽略验证失败，等待用户继续输入
        Log.w("ContactDetail", "Profile验证失败: ${e.message}")
    }
}
```

### 推荐方案
采用方案A，因为：
1. 从根本上解决问题，而不是掩盖
2. 验证应该在保存时进行，而不是输入时
3. 允许用户自由编辑，只在提交时验证

### 机制解释
1. 模型层的require断言适用于数据库加载的数据
2. 用户输入过程中的中间状态不应触发断言
3. 验证逻辑应该分层：输入时提示，保存时强制

## 6. 紧急修复步骤

1. **立即**：在updateEditedProfile中添加空值检查
2. **短期**：修改ContactProfile移除name的require
3. **长期**：重构验证逻辑，区分输入验证和保存验证

## 7. 待验证项
- [ ] 获取实际崩溃日志确认根因
- [ ] 检查ContactProfile的init块
- [ ] 检查Fact模型的init块
- [ ] 测试修复后的输入删除场景
