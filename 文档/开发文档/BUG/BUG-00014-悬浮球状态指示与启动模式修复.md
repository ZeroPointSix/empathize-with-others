# BUG-00014: 悬浮球状态指示与启动模式修复

> **状态**: ✅ 代码修复已完成，待用户验证
> **修复日期**: 2025-12-18
> **修复者**: Kiro

## 1. 问题描述

### 问题一：退出后重进直接显示对话框
- **现象**：用户最小化悬浮窗到悬浮球后退出应用，重新进入时直接显示对话框而非悬浮球
- **期望**：退出时是悬浮球模式，重进时应该还是悬浮球模式

### 问题二：AI请求没有状态指示和通知
- **现象**：发送AI请求后最小化，悬浮球没有显示加载状态，AI完成后也没有通知
- **日志证据**：`最小化到悬浮球，hasActiveAiRequest: false`（应该是 true）

## 2. 根因分析

### 问题一根因
`FloatingWindowService.showFloatingView()` 方法在启动时直接调用 `showFloatingViewV2()` 创建对话框，没有检查用户上次退出时的显示模式。

**缺失逻辑**：
- 没有保存"最后显示模式"（悬浮球/对话框）
- 启动时没有检查是否应该以悬浮球模式启动

### 问题二根因
AI调用流程（`handleAnalyzeV2`、`handlePolishV2`、`handleReplyV2`、`handleRegenerateV2`）中没有调用状态回调方法：
- `onAiRequestStarted()` - 标记请求开始
- `onAiRequestCompleted()` - 标记请求成功
- `onAiRequestFailed()` - 标记请求失败

**日志证据**：
```
10:22:28.296  使用 Provider 超时配置...
10:22:28.314  --> POST https://api-inference.modelscope.cn/...
10:22:29.136  最小化到悬浮球，hasActiveAiRequest: false  ← 应该是 true！
```

## 3. 修复方案

### 修复一：添加显示模式持久化

**FloatingWindowPreferences.kt 新增**：
```kotlin
// 常量
const val DISPLAY_MODE_BUBBLE = "BUBBLE"
const val DISPLAY_MODE_DIALOG = "DIALOG"
private const val KEY_DISPLAY_MODE = "display_mode"

// 方法
fun saveDisplayMode(mode: String)
fun getDisplayMode(): String
fun shouldStartAsBubble(): Boolean
```

**FloatingWindowService.kt 修改**：
1. `showFloatingView()` - 启动时检查 `shouldStartAsBubble()`
2. `showFloatingViewV2()` - 保存模式为 DIALOG
3. `minimizeToFloatingBubble()` - 保存模式为 BUBBLE
4. `expandFromBubble()` - 保存模式为 DIALOG

### 修复二：在AI调用流程中集成状态回调

**修改的方法**：
- `handleAnalyzeV2()` - 添加 `onAiRequestStarted(ANALYZE)` 和结果回调
- `handlePolishV2()` - 添加 `onAiRequestStarted(POLISH)` 和结果回调
- `handleReplyV2()` - 添加 `onAiRequestStarted(REPLY)` 和结果回调
- `handleRegenerateV2()` - 添加 `onAiRequestStarted(tab)` 和结果回调

**修改模式**：
```kotlin
private fun handleXxxV2(contactId: String, text: String) {
    floatingViewV2?.showLoading("...")
    
    // TD-00010: 标记AI请求开始
    onAiRequestStarted(ActionType.XXX)
    
    serviceScope.launch {
        try {
            val result = withTimeout(timeoutMs) { xxxUseCase(...) }
            result.fold(
                onSuccess = { 
                    // ... 显示结果
                    onAiRequestCompleted(ActionType.XXX)  // TD-00010
                },
                onFailure = { 
                    // ... 显示错误
                    onAiRequestFailed(error)  // TD-00010
                }
            )
        } catch (e: Exception) {
            // ... 显示错误
            onAiRequestFailed(e)  // TD-00010
        }
    }
}
```

## 4. 修改的文件

| 文件 | 修改内容 |
|------|----------|
| `FloatingWindowPreferences.kt` | 新增显示模式相关常量和方法 |
| `FloatingWindowService.kt` | 1. `showFloatingView()` 添加悬浮球模式检查<br>2. `showFloatingViewV2()` 保存显示模式<br>3. `minimizeToFloatingBubble()` 保存显示模式<br>4. `expandFromBubble()` 保存显示模式<br>5. `handleAnalyzeV2()` 添加状态回调<br>6. `handlePolishV2()` 添加状态回调<br>7. `handleReplyV2()` 添加状态回调<br>8. `handleRegenerateV2()` 添加状态回调 |

## 5. 验证方法

### 验证问题一修复
1. 启动应用，打开悬浮窗
2. 点击最小化按钮，悬浮窗变为悬浮球
3. 退出应用（杀进程）
4. 重新启动应用
5. **预期**：应该显示悬浮球而非对话框

### 验证问题二修复
1. 启动应用，打开悬浮窗
2. 输入内容，点击发送
3. 立即点击最小化按钮
4. **预期**：悬浮球显示旋转加载动画（LOADING状态）
5. 等待AI返回结果
6. **预期**：悬浮球变为绿色勾（SUCCESS状态），收到系统通知

## 6. 实现状态

### ✅ 已完成的代码修改

| 文件 | 修改内容 | 状态 |
|------|----------|------|
| `FloatingWindowPreferences.kt` | 新增 `DISPLAY_MODE_BUBBLE`、`DISPLAY_MODE_DIALOG` 常量 | ✅ |
| `FloatingWindowPreferences.kt` | 新增 `saveDisplayMode()`、`getDisplayMode()`、`shouldStartAsBubble()` 方法 | ✅ |
| `FloatingWindowService.kt` | `showFloatingView()` 添加悬浮球模式检查 | ✅ |
| `FloatingWindowService.kt` | `showFloatingViewV2()` 保存显示模式为 DIALOG | ✅ |
| `FloatingWindowService.kt` | `minimizeToFloatingBubble()` 保存显示模式为 BUBBLE | ✅ |
| `FloatingWindowService.kt` | `expandFromBubble()` 保存显示模式为 DIALOG | ✅ |
| `FloatingWindowService.kt` | `handleAnalyzeV2()` 添加 `onAiRequestStarted(ANALYZE)` 和结果回调 | ✅ |
| `FloatingWindowService.kt` | `handlePolishV2()` 添加 `onAiRequestStarted(POLISH)` 和结果回调 | ✅ |
| `FloatingWindowService.kt` | `handleReplyV2()` 添加 `onAiRequestStarted(REPLY)` 和结果回调 | ✅ |
| `FloatingWindowService.kt` | `handleRegenerateV2()` 添加 `onAiRequestStarted(tab)` 和结果回调 | ✅ |

### ⏳ 待用户验证

需要用户重新构建应用并测试以下场景：

1. **问题一验证**：最小化后退出再进入，应该显示悬浮球
2. **问题二验证**：发送AI请求后最小化，悬浮球应该显示加载动画
3. **问题三验证**：AI完成后，悬浮球应该变为成功/失败状态，并收到系统通知

## 7. 相关文档

- [TDD-00010-悬浮球状态指示与拖动技术设计](../TDD/TDD-00010-悬浮球状态指示与拖动技术设计.md)
- [TD-00010-悬浮球状态指示与拖动任务清单](../TD/TD-00010-悬浮球状态指示与拖动任务清单.md)
