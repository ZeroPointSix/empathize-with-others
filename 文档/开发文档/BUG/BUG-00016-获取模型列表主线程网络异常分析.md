# BUG-00016 获取模型列表主线程网络异常分析

> 创建日期: 2025-12-18 | 状态: ✅ 已修复 | 优先级: 高

## 问题描述

### 现象
在真机上点击"获取模型列表"按钮时，应用抛出 `NetworkOnMainThreadException` 异常，导致获取模型列表失败。

### 复现步骤
1. 在真机上运行应用
2. 进入 AI 服务商配置页面
3. 填写 API 端点和 API Key
4. 点击"获取模型列表"按钮
5. 观察到错误提示

### 错误日志
```
2025-12-18 19:31:02.849 AiProvider...sitoryImpl E  获取模型列表失败 (Ask Gemini)
android.os.NetworkOnMainThreadException
    at android.os.StrictMode$AndroidBlockGuardPolicy.onNetwork(StrictMode.java:1793)
    at com.android.org.conscrypt.Platform.blockGuardOnNetwork(Platform.java:408)
    ...
    at okhttp3.ResponseBody.string(ResponseBody.kt:187)
    at com.empathy.ai.data.repository.AiProviderRepositoryImpl.fetchAvailableModels-gIAlu-s(AiProviderRepositoryImpl.kt:375)
    ...
    at android.os.Handler.handleCallback(Handler.java:959)
    at android.os.Looper.loop(Looper.java:387)
```

### 环境差异
| 环境 | 表现 |
|------|------|
| 虚拟机（模拟器） | 正常工作 |
| 真机 | 抛出 NetworkOnMainThreadException |

---

## 根因分析

### 1. 机制分析

#### Android 主线程网络限制
- Android 3.0+ 禁止在主线程执行网络操作
- `StrictMode` 检测到主线程网络操作时抛出 `NetworkOnMainThreadException`
- 这是为了防止 ANR（Application Not Responding）

#### Kotlin 协程调度机制
- `suspend` 函数不会自动切换线程，只是"可挂起"
- `viewModelScope.launch { }` 默认使用 `Dispatchers.Main`
- `withContext(Dispatchers.IO) { }` 只在其代码块内切换到 IO 线程

### 2. 问题代码定位

**文件**: `AiProviderRepositoryImpl.kt`
**方法**: `fetchAvailableModels()`
**行号**: 约 342-420 行

```kotlin
override suspend fun fetchAvailableModels(provider: AiProvider): Result<List<AiModel>> {
    return try {
        // ... 验证和构建请求 ...

        // 执行请求 - 这部分在 IO 线程 ✅
        val response = kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {
            client.newCall(request).execute()
        }
        // ⬆️ withContext 结束，自动切回主线程

        // 处理响应 - 这部分在主线程 ❌
        when (response.code) {
            200 -> {
                val responseBody = response.body?.string()  // ❌ 网络 IO 在主线程！
                // ...
            }
        }
    } catch (e: Exception) {
        // ...
    }
}
```

### 3. 根因确认

**根本原因**: `withContext(Dispatchers.IO)` 的范围太小，只包裹了 `execute()` 调用，而 `response.body?.string()` 是一个网络 IO 操作（读取响应体），它在 `withContext` 块外部执行，因此在主线程运行。

**OkHttp 响应体读取机制**:
- `execute()` 只是发送请求并获取响应头
- `response.body?.string()` 才是真正读取响应体数据
- 这是一个"惰性"操作，需要从网络读取数据

### 4. 虚拟机可行的原因

| 因素 | 虚拟机 | 真机 |
|------|--------|------|
| StrictMode 配置 | 可能较宽松 | 严格执行 |
| 网络延迟 | 本地网络快 | 真实网络延迟 |
| 连接复用 | 数据可能已缓存 | 需要真正网络 IO |
| 响应体大小 | 测试数据小 | 实际数据可能大 |
| Android 版本 | 可能较旧 | 通常较新 |

---

## 影响范围

### 受影响的功能
1. **获取模型列表** - `fetchAvailableModels()` - 直接受影响
2. **测试连接** - `testConnection()` - 可能有同样问题（需验证）

### 受影响的文件
- `app/src/main/java/com/empathy/ai/data/repository/AiProviderRepositoryImpl.kt`

### 用户影响
- 真机用户无法自动获取 AI 服务商的模型列表
- 需要手动输入模型 ID

---

## 修复方案

### 方案 A：扩大 withContext(IO) 范围（推荐）

将整个网络请求和响应处理都放在 IO 线程：

```kotlin
override suspend fun fetchAvailableModels(provider: AiProvider): Result<List<AiModel>> {
    return withContext(Dispatchers.IO) {  // ← 整个方法体都在 IO 线程
        try {
            // 基本验证
            if (provider.baseUrl.isBlank() || provider.apiKey.isBlank()) {
                return@withContext Result.failure(
                    IllegalArgumentException("服务商配置不完整：需要 baseUrl 和 apiKey")
                )
            }

            // 构建 Models API URL
            val modelsUrl = buildModelsUrl(provider.baseUrl)
            android.util.Log.d("AiProviderRepositoryImpl", "获取模型列表 URL: $modelsUrl")

            // 创建 OkHttp 客户端
            val client = okhttp3.OkHttpClient.Builder()
                .connectTimeout(15, java.util.concurrent.TimeUnit.SECONDS)
                .readTimeout(15, java.util.concurrent.TimeUnit.SECONDS)
                .build()

            // 构建请求
            val request = okhttp3.Request.Builder()
                .url(modelsUrl)
                .addHeader("Authorization", "Bearer ${provider.apiKey}")
                .addHeader("Content-Type", "application/json")
                .get()
                .build()

            // 执行请求（现在整个都在 IO 线程）
            val response = client.newCall(request).execute()

            // 处理响应（也在 IO 线程）
            when (response.code) {
                200 -> {
                    val responseBody = response.body?.string()  // ✅ 现在在 IO 线程
                    response.close()

                    if (responseBody.isNullOrBlank()) {
                        return@withContext Result.failure(Exception("服务商返回空响应"))
                    }

                    // 解析响应
                    val modelsResponse = parseModelsResponse(responseBody)
                    if (modelsResponse == null) {
                        return@withContext Result.failure(Exception("无法解析模型列表响应"))
                    }

                    // 过滤并转换模型
                    val chatModels = modelsResponse.data
                        .filter { isChatModel(it.id) }
                        .map { dto ->
                            AiModel(
                                id = dto.id,
                                displayName = generateDisplayName(dto.id)
                            )
                        }
                        .sortedBy { it.id }

                    android.util.Log.d("AiProviderRepositoryImpl", "获取到 ${chatModels.size} 个聊天模型")
                    Result.success(chatModels)
                }
                401 -> {
                    response.close()
                    Result.failure(Exception("API Key 无效（401）"))
                }
                403 -> {
                    response.close()
                    Result.failure(Exception("API Key 权限不足（403）"))
                }
                404 -> {
                    response.close()
                    Result.failure(Exception("该服务商不支持获取模型列表（404）"))
                }
                429 -> {
                    response.close()
                    Result.failure(Exception("API 配额已用尽（429）"))
                }
                else -> {
                    val errorBody = response.body?.string() ?: "未知错误"
                    response.close()
                    Result.failure(Exception("HTTP ${response.code}: $errorBody"))
                }
            }
        } catch (e: java.net.SocketTimeoutException) {
            Result.failure(Exception("请求超时，请检查网络连接"))
        } catch (e: java.net.UnknownHostException) {
            Result.failure(Exception("无法解析主机名，请检查 API 端点"))
        } catch (e: java.net.ConnectException) {
            Result.failure(Exception("网络连接失败"))
        } catch (e: Exception) {
            android.util.Log.e("AiProviderRepositoryImpl", "获取模型列表失败", e)
            Result.failure(Exception("获取模型列表失败：${e.message}"))
        }
    }
}
```

### 同时修复 testConnection 方法

`testConnection()` 方法也有同样的问题，需要同步修复。

---

## 测试计划

### 单元测试

| 测试用例 | 描述 | 预期结果 |
|----------|------|----------|
| `fetchAvailableModels should execute on IO dispatcher` | 验证网络请求在 IO 线程执行 | 不抛出 NetworkOnMainThreadException |
| `fetchAvailableModels should return model list on success` | 成功获取模型列表 | 返回非空模型列表 |
| `fetchAvailableModels should handle HTTP 401` | 处理 API Key 无效 | 返回适当错误信息 |
| `fetchAvailableModels should handle HTTP 404` | 处理端点不存在 | 返回适当错误信息 |
| `fetchAvailableModels should handle network timeout` | 处理网络超时 | 返回超时错误信息 |
| `testConnection should execute on IO dispatcher` | 验证测试连接在 IO 线程执行 | 不抛出异常 |

### 集成测试（真机）

| 测试用例 | 描述 | 预期结果 |
|----------|------|----------|
| 真机获取 OpenAI 模型列表 | 使用真实 OpenAI API | 成功返回模型列表 |
| 真机获取 DeepSeek 模型列表 | 使用真实 DeepSeek API | 成功返回模型列表 |
| 真机获取 ModelScope 模型列表 | 使用真实 ModelScope API | 成功返回模型列表 |
| 真机测试连接 | 测试服务商连接 | 成功返回连接状态 |

---

## 任务清单

- [x] 1. 修复 `fetchAvailableModels()` 方法的线程调度
- [x] 2. 修复 `testConnection()` 方法的线程调度（确认有同样问题并修复）
- [x] 3. 编写单元测试验证线程调度
- [ ] 4. 在真机上验证修复效果
- [x] 5. 更新相关文档

---

## 相关文档

- [SR-00001-模型列表自动获取与调试日志优化](../特殊要求/SR-00001-模型列表自动获取与调试日志优化.md)
- [AiProviderRepositoryImpl.kt](../../app/src/main/java/com/empathy/ai/data/repository/AiProviderRepositoryImpl.kt)

---

## 修复记录

| 日期 | 操作 | 执行者 |
|------|------|--------|
| 2025-12-18 | 创建问题分析文档 | Kiro |
| 2025-12-18 | 修复 fetchAvailableModels() 线程调度 | Kiro |
| 2025-12-18 | 修复 testConnection() 线程调度 | Kiro |
| 2025-12-18 | 创建线程调度测试用例 | Kiro |

## 修复详情

### 修改的文件

1. **AiProviderRepositoryImpl.kt**
   - `fetchAvailableModels()`: 将整个网络操作包裹在 `withContext(Dispatchers.IO)` 中
   - `testConnection()`: 同样将整个网络操作包裹在 `withContext(Dispatchers.IO)` 中

### 修复前后对比

**修复前（错误）：**
```kotlin
// 只有 execute() 在 IO 线程
val response = withContext(Dispatchers.IO) {
    client.newCall(request).execute()
}
// response.body?.string() 在主线程执行 ❌
val responseBody = response.body?.string()
```

**修复后（正确）：**
```kotlin
// 整个网络操作都在 IO 线程
return withContext(Dispatchers.IO) {
    val response = client.newCall(request).execute()
    val responseBody = response.body?.string()  // ✅ 在 IO 线程
    // ...
}
```

### 新增测试文件

- `AiProviderRepositoryThreadingTest.kt`: 专门测试线程调度的正确性
