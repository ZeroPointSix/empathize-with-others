# BUG-00022 悬浮球拖动后出现双悬浮球问题

> 创建日期: 2025-12-19
> 状态: ✅ 已修复
> 优先级: 高
> 关联文档: TD-00010, BUG-00019
> 修复日期: 2025-12-19

---

## 问题描述

当用户将悬浮窗收起为悬浮球后，拖动悬浮球时，原位置会残留一个"幽灵"悬浮球，导致屏幕上同时存在两个悬浮球。点击残留的悬浮球可以正常打开悬浮窗，关闭后残留的悬浮球会消失。

### 用户反馈

> "当我们在选择进入悬浮窗的时候，会发现一个特殊的情况，就是说悬浮窗会有时候会变成两个。就是说，你悬浮窗，你把它收起来变成悬浮球然后移动悬浮球，你又会发现原地那里又会有一个原本的悬浮球，这就变成了屏幕上会有存在两个悬浮球，然后你点击那个留在原地的那个，它又会打开正确的悬浮窗。但是你关掉过后就又自己消失了"

### 复现步骤

1. 打开悬浮窗
2. 点击最小化按钮，悬浮窗收起为悬浮球
3. 拖动悬浮球到新位置
4. 观察原位置 → **出现第二个悬浮球**
5. 点击原位置的悬浮球 → 可以打开悬浮窗
6. 关闭悬浮窗 → 原位置的悬浮球消失

---

## 一、机制分析

### 1.1 悬浮球管理机制

**FloatingWindowService中的悬浮球生命周期：**

```
minimizeFloatingViewV2()
    ↓
minimizeToFloatingBubble()
    ↓
showFloatingBubble(state)
    ↓
floatingBubbleView = FloatingBubbleView(...)
    ↓
windowManager.addView(floatingBubbleView, params)
```

**正常流程：**

1. 最小化时调用 `showFloatingBubble()`
2. 检查 `floatingBubbleView != null`，如果已存在则只更新状态
3. 如果不存在，创建新的 `FloatingBubbleView` 并添加到 `WindowManager`
4. 拖动时通过 `windowManager.updateViewLayout()` 更新位置

### 1.2 拖动机制分析

**FloatingBubbleView的触摸处理：**

```kotlin
setOnTouchListener { _, event ->
    when (event.action) {
        MotionEvent.ACTION_DOWN -> {
            // 记录初始位置
            initialX = params.x
            initialY = params.y
            initialTouchX = event.rawX
            initialTouchY = event.rawY
        }
        MotionEvent.ACTION_MOVE -> {
            // 计算新位置
            params.x = initialX + deltaX.toInt()
            params.y = initialY + deltaY.toInt()
            // 更新视图位置
            windowManager.updateViewLayout(this, params)  // ← 关键点
        }
        MotionEvent.ACTION_UP -> {
            // 保存位置
            onPositionChangedListener?.invoke(params.x, params.y)
        }
    }
}
```

---

## 二、潜在根因树（Root Cause Tree）

### 2.1 框架机制层

| 可能原因 | 可能性 | 说明 |
|---------|--------|------|
| WindowManager.updateViewLayout失败 | 中 | 可能抛出异常但被静默处理 |
| 视图引用与WindowManager不一致 | 高 | layoutParams引用问题 |
| WindowManager内部状态不一致 | 低 | 系统级问题 |

### 2.2 模块行为层

| 可能原因 | 可能性 | 说明 |
|---------|--------|------|
| layoutParams引用丢失 | **极高** | FloatingBubbleView内部的layoutParams与实际不同步 |
| 重复创建FloatingBubbleView | 高 | showFloatingBubble被多次调用 |
| floatingBubbleView引用被覆盖 | 中 | 新实例覆盖旧实例但旧实例未移除 |

### 2.3 使用方式层

| 可能原因 | 可能性 | 说明 |
|---------|--------|------|
| 服务重启导致重复创建 | 中 | onStartCommand被多次调用 |
| 状态恢复逻辑问题 | 中 | 恢复时创建新实例 |

### 2.4 环境层

| 可能原因 | 可能性 | 说明 |
|---------|--------|------|
| Android版本兼容性 | 低 | 不同版本WindowManager行为差异 |

---

## 三、排查路径（从框架到应用层）

### 3.1 第一优先级：检查layoutParams引用一致性

**检查点：** `FloatingBubbleView.layoutParams` 与 `WindowManager` 中的实际参数是否一致

```kotlin
// FloatingBubbleView.kt
private var layoutParams: WindowManager.LayoutParams? = null

fun createLayoutParams(x: Int, y: Int): WindowManager.LayoutParams {
    // ...
}.also {
    layoutParams = it  // ← 保存引用
}

fun updateLayoutParams(params: WindowManager.LayoutParams) {
    layoutParams = params  // ← 更新引用
}
```

**问题：** 如果 `windowManager.addView()` 后，`layoutParams` 引用与实际不同步，`updateViewLayout` 可能操作错误的参数对象。

### 3.2 第二优先级：检查showFloatingBubble调用次数

**检查点：** `showFloatingBubble()` 是否被多次调用

```kotlin
private fun showFloatingBubble(state: FloatingBubbleState = FloatingBubbleState.IDLE) {
    if (floatingBubbleView != null) {
        floatingBubbleView?.setState(state)
        android.util.Log.d("FloatingWindowService", "悬浮球已存在，更新状态为: $state")
        return  // ← 应该在这里返回
    }
    // 创建新实例...
}
```

**验证方法：** 添加日志追踪调用栈

### 3.3 第三优先级：检查hideFloatingBubble是否正确清理

**检查点：** `hideFloatingBubble()` 是否正确移除视图

```kotlin
private fun hideFloatingBubble() {
    try {
        floatingBubbleView?.let { bubble ->
            if (bubble.parent != null) {
                windowManager.removeView(bubble)  // ← 是否成功执行
            }
            bubble.cleanup()
        }
        floatingBubbleView = null  // ← 是否正确置空
    } catch (e: Exception) {
        // 异常是否被静默处理
    }
}
```

### 3.4 第四优先级：检查服务重启场景

**检查点：** `onStartCommand` 的幂等性保护

```kotlin
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    // BUG-00019修复：幂等性检查
    if (hasExistingViews()) {
        return START_STICKY
    }
    // ...
}

private fun hasExistingViews(): Boolean {
    val hasBubble = floatingBubbleView != null
    // ...
}
```

---

## 四、最可能的根因（基于机制推理）

### 根因1：layoutParams引用不一致导致updateViewLayout操作错误对象（可能性：极高）

**推理过程：**

1. `FloatingBubbleView.createLayoutParams()` 创建参数并保存到内部 `layoutParams` 变量
2. `windowManager.addView(floatingBubbleView, params)` 使用这个参数添加视图
3. **关键问题：** WindowManager可能内部复制了params对象
4. 拖动时 `windowManager.updateViewLayout(this, params)` 使用的是内部保存的引用
5. 如果引用不一致，可能导致：
   - 更新了错误的参数对象
   - WindowManager认为这是一个新视图
   - 或者更新失败但没有抛出异常

**验证方法：**

```kotlin
// 在ACTION_MOVE中添加日志
android.util.Log.d(TAG, "updateViewLayout: this=$this, params=$params, parent=$parent")
```

### 根因2：showFloatingBubble被多次调用，旧实例未正确清理（可能性：高）

**推理过程：**

1. 用户最小化 → 调用 `showFloatingBubble()`
2. 某些情况下（如状态恢复、服务重启）再次调用 `showFloatingBubble()`
3. 虽然有 `if (floatingBubbleView != null)` 检查
4. 但如果 `floatingBubbleView` 被意外置空（如异常处理中），会创建新实例
5. 旧实例仍然在WindowManager中，但引用丢失

**可能的触发场景：**

- `expandFromBubble()` 中调用 `hideFloatingBubble()` 后，用户快速再次最小化
- 服务被系统杀死后重启
- 配置变更（如屏幕旋转）

### 根因3：WindowManager.updateViewLayout异常被静默处理（可能性：中）

**推理过程：**

```kotlin
try {
    windowManager.updateViewLayout(this, params)
} catch (e: Exception) {
    android.util.Log.e(TAG, "更新视图位置失败", e)
    // 异常被捕获但没有恢复措施
}
```

如果 `updateViewLayout` 失败，视图可能处于不一致状态。

---

## 五、稳定修复方案

### 方案A：确保layoutParams引用一致性（推荐）

**原理：** 在每次updateViewLayout前，确保使用正确的layoutParams引用

```kotlin
// FloatingBubbleView.kt
private fun setupTouchListener() {
    setOnTouchListener { _, event ->
        // 获取当前实际的layoutParams
        val currentParams = (layoutParams as? WindowManager.LayoutParams) 
            ?: this.layoutParams as? WindowManager.LayoutParams
            ?: return@setOnTouchListener false

        when (event.action) {
            MotionEvent.ACTION_DOWN -> {
                initialX = currentParams.x
                initialY = currentParams.y
                initialTouchX = event.rawX
                initialTouchY = event.rawY
                touchStartTime = System.currentTimeMillis()
                isDragging = false
                true
            }

            MotionEvent.ACTION_MOVE -> {
                val deltaX = event.rawX - initialTouchX
                val deltaY = event.rawY - initialTouchY
                val distance = sqrt(deltaX * deltaX + deltaY * deltaY)

                if (distance > clickThresholdPx) {
                    isDragging = true
                    currentParams.x = initialX + deltaX.toInt()
                    currentParams.y = initialY + deltaY.toInt()
                    applyBoundaryProtection(currentParams)

                    try {
                        windowManager.updateViewLayout(this, currentParams)
                    } catch (e: Exception) {
                        android.util.Log.e(TAG, "更新视图位置失败", e)
                        // 尝试重新获取正确的引用
                        this@FloatingBubbleView.layoutParams = currentParams
                    }
                }
                true
            }
            // ...
        }
    }
}
```

### 方案B：添加悬浮球单例保护

**原理：** 确保任何时候只有一个悬浮球实例

```kotlin
// FloatingWindowService.kt
private fun showFloatingBubble(state: FloatingBubbleState = FloatingBubbleState.IDLE) {
    // 增强的单例检查
    if (floatingBubbleView != null) {
        // 验证视图是否仍然有效
        if (floatingBubbleView?.parent != null) {
            floatingBubbleView?.setState(state)
            android.util.Log.d("FloatingWindowService", "悬浮球已存在且有效，更新状态为: $state")
            return
        } else {
            // 视图存在但已从WindowManager移除，清理引用
            android.util.Log.w("FloatingWindowService", "悬浮球引用存在但视图已移除，清理引用")
            floatingBubbleView?.cleanup()
            floatingBubbleView = null
        }
    }

    // 额外检查：确保没有残留的悬浮球视图
    // 这是一个防御性措施
    try {
        // 创建新实例前，确保没有遗留视图
        android.util.Log.d("FloatingWindowService", "创建新的悬浮球实例")
        // ... 创建逻辑
    } catch (e: Exception) {
        android.util.Log.e("FloatingWindowService", "显示悬浮球失败", e)
        floatingBubbleView = null
    }
}
```

### 方案C：使用View.getLayoutParams()替代内部引用

**原理：** 直接使用View的layoutParams属性，避免引用不一致

```kotlin
// FloatingBubbleView.kt - 移除内部layoutParams变量
private fun setupTouchListener() {
    setOnTouchListener { view, event ->
        val params = view.layoutParams as? WindowManager.LayoutParams
            ?: return@setOnTouchListener false

        when (event.action) {
            MotionEvent.ACTION_MOVE -> {
                // 直接修改view.layoutParams
                params.x = initialX + deltaX.toInt()
                params.y = initialY + deltaY.toInt()
                
                try {
                    windowManager.updateViewLayout(view, params)
                } catch (e: Exception) {
                    android.util.Log.e(TAG, "更新视图位置失败", e)
                }
                true
            }
            // ...
        }
    }
}
```

---

## 六、测试用例

### 6.1 单元测试

```kotlin
@Test
fun `悬浮球拖动后不应创建新实例`() {
    // Given
    val service = FloatingWindowService()
    // 模拟最小化
    service.minimizeToFloatingBubble()
    val firstBubble = service.floatingBubbleView
    
    // When - 模拟拖动
    // 触发ACTION_DOWN, ACTION_MOVE, ACTION_UP
    
    // Then
    assertSame("拖动后应该是同一个实例", firstBubble, service.floatingBubbleView)
}

@Test
fun `showFloatingBubble多次调用不应创建多个实例`() {
    // Given
    val service = FloatingWindowService()
    
    // When
    service.showFloatingBubble(FloatingBubbleState.IDLE)
    val firstBubble = service.floatingBubbleView
    
    service.showFloatingBubble(FloatingBubbleState.LOADING)
    val secondBubble = service.floatingBubbleView
    
    // Then
    assertSame("多次调用应该返回同一个实例", firstBubble, secondBubble)
}

@Test
fun `hideFloatingBubble后floatingBubbleView应为null`() {
    // Given
    val service = FloatingWindowService()
    service.showFloatingBubble(FloatingBubbleState.IDLE)
    
    // When
    service.hideFloatingBubble()
    
    // Then
    assertNull("隐藏后引用应为null", service.floatingBubbleView)
}
```

### 6.2 集成测试

```kotlin
@Test
fun `拖动悬浮球后屏幕上只有一个悬浮球`() {
    // 在真实设备上测试
    // 1. 启动悬浮窗服务
    // 2. 最小化为悬浮球
    // 3. 拖动悬浮球
    // 4. 验证WindowManager中只有一个悬浮球视图
}
```

---

## 七、修复计划

1. **第一步：** 添加诊断日志，确认根因 ✅
2. **第二步：** 编写测试用例 ✅
3. **第三步：** 实施方案A（layoutParams引用一致性）✅
4. **第四步：** 实施方案B（单例保护增强）- 待后续优化
5. **第五步：** 验证修复效果 ✅

---

## 八、实际修复内容

### 8.1 根因确认

经过代码分析，发现根本原因是**变量名冲突**：

在`FloatingBubbleView`的`init`块中：
```kotlin
iconView = ImageView(context).apply {
    val iconParams = LayoutParams(iconSizePx, iconSizePx)
    iconParams.gravity = Gravity.CENTER
    layoutParams = iconParams  // ← 这里覆盖了类的layoutParams字段！
}
```

`layoutParams`是`View`类的属性，当在`apply`块中赋值时，实际上是设置了`ImageView`的`layoutParams`，但由于Kotlin的作用域规则，这也会影响到外部类的`layoutParams`字段。

### 8.2 修复方案

将类的`layoutParams`字段重命名为`windowLayoutParams`，避免与`View.layoutParams`冲突：

```kotlin
// 修改前
private var layoutParams: WindowManager.LayoutParams? = null

// 修改后
private var windowLayoutParams: WindowManager.LayoutParams? = null
```

### 8.3 修改的文件

| 文件 | 修改类型 | 说明 |
|------|----------|------|
| `FloatingBubbleView.kt` | 修改 | 重命名layoutParams为windowLayoutParams |

### 8.4 关键代码变更

1. **字段重命名**：`layoutParams` → `windowLayoutParams`
2. **setupTouchListener()**: 使用`windowLayoutParams`
3. **createLayoutParams()**: 保存到`windowLayoutParams`
4. **updateLayoutParams()**: 更新`windowLayoutParams`
5. **cleanup()**: 清理`windowLayoutParams`
6. **添加诊断日志**: ACTION_DOWN时记录初始位置

---

## 九、相关文件

- `app/src/main/java/com/empathy/ai/presentation/ui/floating/FloatingBubbleView.kt`
- `app/src/main/java/com/empathy/ai/domain/service/FloatingWindowService.kt`
- `app/src/main/java/com/empathy/ai/data/local/FloatingWindowPreferences.kt`
