# BUG-00026 事实删除/编辑"未找到事实"问题分析与修复

## 问题描述

用户在事实流中添加事实后，尝试删除或编辑时出现"未找到事实"错误。

## 根因分析

### 日志证据

**第一次反序列化 (11:25:35)**：
```
[0] id=654aabe0-cbb6-4de8-8ef7-0e1986cc1581, key=情感表达模式
```

**第二次反序列化 (11:25:42)** - 同一条 JSON，但 id 完全不同：
```
[0] id=91f2cb05-99ad-4451-90a0-54cabf3d81cd, key=情感表达模式
```

### 根因确认

**JSON 中没有存储 `id` 字段！**

查看 JSON 内容：
```json
[{"key":"情感表达模式","value":"...","timestamp":1766213279515,"source":"AI_INFERRED"}]
```

没有 `"id"` 字段，所以每次反序列化时 `Fact.id` 使用默认值 `UUID.randomUUID().toString()` 生成新的 UUID。

### 技术原因

`Fact` 是一个 Kotlin data class，`id` 字段有默认值：
```kotlin
data class Fact(
    val id: String = UUID.randomUUID().toString(),  // 有默认值
    ...
)
```

使用 `KotlinJsonAdapterFactory` 时，Moshi 默认会跳过有默认值的字段进行序列化。这导致：
1. 序列化时：`id` 字段不被写入 JSON
2. 反序列化时：由于 JSON 中没有 `id`，使用默认值生成新的 UUID
3. 结果：每次从数据库读取时，同一条 Fact 的 id 都不同

## 修复方案

### 方案：使用自定义 Moshi JsonAdapter

在 `FactListConverter.kt` 中添加自定义适配器，确保 `id` 字段被正确序列化和反序列化：

```kotlin
/**
 * Fact的JSON中间表示
 */
@JsonClass(generateAdapter = true)
data class FactJson(
    val id: String,
    val key: String,
    val value: String,
    val timestamp: Long,
    val source: String,
    val isUserModified: Boolean = false,
    val lastModifiedTime: Long = 0L,
    val originalKey: String? = null,
    val originalValue: String? = null
)

/**
 * Fact的自定义Moshi适配器
 */
class FactJsonAdapter {
    @ToJson
    fun toJson(fact: Fact): FactJson {
        return FactJson(
            id = fact.id,  // 显式包含 id
            key = fact.key,
            value = fact.value,
            timestamp = fact.timestamp,
            source = fact.source.name,
            isUserModified = fact.isUserModified,
            lastModifiedTime = fact.lastModifiedTime,
            originalKey = fact.originalKey,
            originalValue = fact.originalValue
        )
    }

    @FromJson
    fun fromJson(json: FactJson): Fact {
        return Fact(
            id = json.id.ifBlank { UUID.randomUUID().toString() },  // 读取 id，空则生成
            key = json.key,
            value = json.value,
            timestamp = json.timestamp,
            source = try { FactSource.valueOf(json.source) } catch (e: Exception) { FactSource.MANUAL },
            isUserModified = json.isUserModified,
            lastModifiedTime = if (json.lastModifiedTime > 0) json.lastModifiedTime else json.timestamp,
            originalKey = json.originalKey,
            originalValue = json.originalValue
        )
    }
}

// 在 Moshi 构建时添加自定义适配器
private val moshi: Moshi by lazy {
    Moshi.Builder()
        .add(FactJsonAdapter())  // 添加自定义适配器
        .addLast(KotlinJsonAdapterFactory())
        .build()
}
```

### 修复后的 JSON 格式

修复后，序列化的 JSON 将包含 `id` 字段：
```json
[{"id":"654aabe0-cbb6-4de8-8ef7-0e1986cc1581","key":"情感表达模式","value":"...","timestamp":1766213279515,"source":"AI_INFERRED"}]
```

### 向后兼容性

修复方案保持向后兼容：
- 旧数据（没有 `id` 字段）：反序列化时生成新的 UUID
- 新数据（有 `id` 字段）：正确读取存储的 UUID

## 修改的文件

1. **app/src/main/java/com/empathy/ai/data/local/converter/FactListConverter.kt**
   - 添加 `FactJson` 数据类
   - 添加 `FactJsonAdapter` 自定义适配器
   - 修改 Moshi 构建器使用自定义适配器

## 状态

- [x] 根因分析完成
- [x] 修复方案实施
- [x] 编译验证通过
- [x] 单元测试通过 (21个测试用例)
- [ ] 功能测试验证（等待用户测试）

## 测试步骤

1. 运行应用，进入联系人详情页
2. 添加一个新事实
3. 观察日志，确认序列化后的 JSON 包含 `id` 字段
4. 尝试编辑该事实，应该成功
5. 尝试删除该事实，应该成功

## 注意事项

**旧数据迁移**：已存在的数据（没有 `id` 字段）在首次读取时会生成新的 UUID。如果用户在修复前添加了事实但未编辑/删除，这些事实在修复后首次加载时会获得新的 id，之后就能正常编辑/删除了。
