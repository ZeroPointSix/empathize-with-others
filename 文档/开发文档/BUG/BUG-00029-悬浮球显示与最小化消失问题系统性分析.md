# BUG-00029: 悬浮球显示与最小化消失问题系统性分析

> 创建日期: 2025-12-21
> 状态: 已修复
> 优先级: P0 (严重影响用户体验)

## 问题描述

### 问题一：悬浮球不能在自己程序界面外显示
- 现象：悬浮球只在应用内可见，切换到其他应用后消失
- 影响：用户无法在其他应用中使用悬浮窗功能

### 问题二：最小化后悬浮球直接消失
- 现象：点击最小化按钮后，悬浮球短暂显示后消失
- 影响：用户无法恢复悬浮窗，必须重新打开应用

## 相关日志

```
PROCESS ENDED (4112) for package com.empathy.ai
PROCESS STARTED (4523) for package com.empathy.ai
Failed to get gpu service
```

## 机制分析

### Android 悬浮窗框架运行机制

1. **权限层**: SYSTEM_ALERT_WINDOW 权限检查
2. **服务层**: 前台服务 (Foreground Service) 保活
3. **窗口层**: WindowManager.addView() 添加悬浮视图
4. **类型层**: TYPE_APPLICATION_OVERLAY (API 26+)


### 正常流程

```
启动服务 → onStartCommand() → startForeground() → showFloatingView()
                                                        ↓
                                    shouldStartAsBubble() 检查
                                      ↓ true          ↓ false
                                showFloatingBubble() / showFloatingViewV2()
                                                        ↓
                                    windowManager.addView(view, params)
```

### 最小化流程

```
用户点击最小化 → minimizeFloatingViewV2() → minimizeToFloatingBubble()
                                                    ↓
                                    1. 保存当前状态
                                    2. floatingViewV2.visibility=GONE
                                    3. showFloatingBubble()
                                    4. saveDisplayMode(BUBBLE)  ← 问题点！
```

## 根因分析

### 根因 #1：显示模式保存时机错误（最可能）

**问题代码位置**: `FloatingWindowService.minimizeToFloatingBubble()`

```kotlin
private fun minimizeToFloatingBubble() {
    // 1. 保存状态
    floatingViewV2?.let { view ->
        floatingWindowPreferences.saveUiState(view.getCurrentState())
    }
    // 2. 隐藏悬浮窗
    floatingViewV2?.visibility = View.GONE
    // 3. 显示悬浮球
    showFloatingBubble(bubbleState)
    // 4. ⚠️ 保存显示模式在最后！
    floatingWindowPreferences.saveDisplayMode(DISPLAY_MODE_BUBBLE)
}
```

**问题**: 如果进程在步骤3和步骤4之间被系统杀死，显示模式不会被保存为BUBBLE。
服务重启时 `shouldStartAsBubble()` 返回 false，导致以对话框模式启动而非悬浮球模式。

### 根因 #2：onDestroy 未清理悬浮球视图

**问题代码位置**: `FloatingWindowService.onDestroy()`

当前 onDestroy 清理了：
- minimizedIndicatorV2 ✓
- floatingViewV2 ✓
- floatingView ✓
- floatingBubbleView ✗ **未清理！**

这可能导致内存泄漏和状态不一致。

### 根因 #3：showFloatingBubble 异常处理不完善

**问题代码位置**: `FloatingWindowService.showFloatingBubble()`

```kotlin
} catch (e: Exception) {
    android.util.Log.e("FloatingWindowService", "显示悬浮球失败", e)
    floatingBubbleView = null  // 异常后置空，但没有降级方案
}
```

**问题**: 异常被静默处理，用户看不到任何UI反馈。


## 修复方案

### 方案 A：修复显示模式保存时机

**修改文件**: `FloatingWindowService.kt`

**修改内容**: 将 `saveDisplayMode(BUBBLE)` 移到最前面执行

```kotlin
private fun minimizeToFloatingBubble() {
    // ⭐ 修复：先保存显示模式
    floatingWindowPreferences.saveDisplayMode(DISPLAY_MODE_BUBBLE)
    
    // 保存当前状态
    floatingViewV2?.let { view ->
        floatingWindowPreferences.saveUiState(view.getCurrentState())
    }
    
    // 显示悬浮球
    val bubbleState = if (hasActiveAiRequest) FloatingBubbleState.LOADING else FloatingBubbleState.IDLE
    val success = showFloatingBubble(bubbleState)
    
    // 只有悬浮球显示成功才隐藏悬浮窗
    if (success) {
        floatingViewV2?.visibility = View.GONE
    }
}
```

### 方案 B：修复 onDestroy 清理逻辑

**修改文件**: `FloatingWindowService.kt`

**修改内容**: 在 onDestroy 中添加悬浮球清理

```kotlin
override fun onDestroy() {
    // ... 现有清理代码 ...
    
    // 新增：清理悬浮球视图
    try {
        floatingBubbleView?.let { bubble ->
            if (bubble.parent != null) {
                windowManager.removeView(bubble)
            }
            bubble.cleanup()
        }
    } catch (e: Exception) {
        Log.e(TAG, "移除悬浮球视图失败", e)
    }
    floatingBubbleView = null
}
```

### 方案 C：增强 showFloatingBubble 返回值

**修改文件**: `FloatingWindowService.kt`

**修改内容**: 让方法返回是否成功，并提供降级方案

```kotlin
private fun showFloatingBubble(state: FloatingBubbleState): Boolean {
    // ... 现有代码 ...
    return try {
        windowManager.addView(floatingBubbleView, params)
        true
    } catch (e: Exception) {
        Log.e(TAG, "显示悬浮球失败", e)
        floatingBubbleView = null
        // 降级：显示简单指示器
        showMinimizedIndicatorV2Safe()
        false
    }
}
```

## 测试用例

见 `FloatingWindowServiceBubbleVisibilityTest.kt`

## 相关文件

- `app/src/main/java/com/empathy/ai/domain/service/FloatingWindowService.kt`
- `app/src/main/java/com/empathy/ai/presentation/ui/floating/FloatingBubbleView.kt`
- `app/src/main/java/com/empathy/ai/data/local/FloatingWindowPreferences.kt`

## 验收标准

1. [ ] 悬浮球在应用外可见
2. [ ] 最小化后悬浮球持续显示
3. [ ] 进程重启后悬浮球正确恢复
4. [ ] 点击悬浮球可展开悬浮窗


## 修复记录

### 2025-12-21 修复实施

#### 修改文件
1. `app/src/main/java/com/empathy/ai/domain/service/FloatingWindowService.kt`

#### 修改内容

**1. minimizeToFloatingBubble() 方法重构**
- 将 `saveDisplayMode(BUBBLE)` 移到方法最前面执行
- 新增 `showFloatingBubbleSafe()` 方法，返回是否成功
- 先显示悬浮球再隐藏悬浮窗，确保用户始终有可操作的UI
- 悬浮球创建失败时恢复悬浮窗可见性

**2. 新增 showFloatingBubbleSafe() 方法**
- 返回 Boolean 表示是否成功
- 失败时清理部分创建的资源
- 提供降级方案（FAB指示器）

**3. onDestroy() 方法增强**
- 新增悬浮球视图清理逻辑
- 确保 floatingBubbleView 被正确移除和清理

#### 新增测试
- `FloatingWindowServiceBubbleVisibilityTest.kt` - 8个测试用例

## 技术总结

### 问题根因
1. 显示模式保存时机错误：在最小化流程最后才保存，进程被杀时状态丢失
2. onDestroy 未清理悬浮球：导致内存泄漏和状态不一致
3. 异常处理不完善：悬浮球创建失败时用户无法操作

### 修复原理
1. **原子性保证**：先保存状态再执行操作，确保进程被杀后能正确恢复
2. **完整清理**：onDestroy 中清理所有视图资源
3. **降级方案**：悬浮球创建失败时提供备选UI
