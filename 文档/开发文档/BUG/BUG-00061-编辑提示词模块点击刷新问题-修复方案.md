# BUG-00061: 编辑提示词模块点击刷新问题 - 修复方案

> **创建时间**: 2026-01-10  
> **发现者**: 用户反馈  
> **严重程度**: 🟡 中（P1-高优先级）  
> **状态**: ✅ 已修复

## 📋 问题概述

在「设置」-「编辑提示词」模块中，当用户点击表格框切换不同的提示词配置（如「AI总结」、「AI军师润色回复」）时，整个屏幕会触发一次完整的刷新，用户体验极差。

**问题本质**：Compose 重组范围过大，场景切换时触发了全屏加载状态。

## 🐛 错误现象

### 问题表现
1. **触发场景**：点击 Tab 切换 AI 总结 / AI 军师润色回复等选项时
2. **问题现象**：整个屏幕闪动刷新，Tab 区域也会消失再出现
3. **用户体验**：操作体验极差，正常的选项切换不应该导致全屏刷新

### 期望行为
- 点击选项切换时应该平滑过渡
- Tab 区域应始终保持可见
- 切换应该只影响内容区域，而非整个页面

### 实际行为
- 点击切换选项时，整个屏幕闪动刷新
- Tab 区域短暂消失
- 给用户一种「应用卡顿」或「操作无效」的错觉

## 🔍 根因分析

### 问题链条

```
用户点击Tab 
    → onSceneSelected(scene) 
    → PromptEditorUiEvent.SwitchScene(scene)
    → handleSwitchScene(scene) 
    → _uiState.update { isLoading = true }  ⚠️ 问题点
    → Compose重组 
    → 整个Column被替换为CircularProgressIndicator
    → 异步加载完成 
    → _uiState.update { isLoading = false }
    → Compose重组 
    → CircularProgressIndicator被替换为Column
```

### 根本原因

**1. 状态管理问题**

`PromptEditorViewModel.handleSwitchScene()` 中设置了全局 `isLoading = true`：

```kotlin
private fun handleSwitchScene(scene: PromptScene) {
    _uiState.update { it.copy(currentScene = scene) }
    viewModelScope.launch {
        _uiState.update { it.copy(isLoading = true) }  // ❌ 问题：全屏加载状态
        // ... 异步加载
    }
}
```

**2. UI 结构问题**

`PromptEditorScreen.kt` 使用 `if-else` 完全替换内容：

```kotlin
if (uiState.isLoading) {
    Box(...) { CircularProgressIndicator(...) }  // ❌ 全屏加载指示器
} else {
    Column(...) { /* Tab + 内容 */ }  // 整个内容区域
}
```

**3. 缺少缓存机制**

每次切换场景都重新从 Repository 加载提示词，没有内存缓存。

### 问题分解

| 问题点 | 影响 | 严重程度 |
|--------|------|----------|
| `isLoading` 是全局状态 | 影响整个页面渲染 | 高 |
| `if-else` 完全替换内容 | Tab 区域也被替换 | 高 |
| 无缓存机制 | 每次切换都触发加载 | 中 |
| 重组范围过大 | 整个 Content 重组 | 中 |

## 🛠️ 修复方案

### 核心策略

**分离加载状态 + 提示词缓存**

1. 将 `isLoading` 拆分为两个状态
2. 在 ViewModel 中缓存已加载的提示词
3. 优化 UI 结构，Tab 区域始终可见

### 修改文件清单

| 文件 | 修改内容 | 复杂度 |
|------|----------|--------|
| `PromptEditorUiState.kt` | 添加分离的加载状态字段 | 低 |
| `PromptEditorViewModel.kt` | 添加缓存机制，优化场景切换逻辑 | 中 |
| `PromptEditorScreen.kt` | 分离 Tab 区域和内容区域的加载状态渲染 | 中 |

### 详细修改方案

#### 1. PromptEditorUiState.kt

**修改前**：
```kotlin
data class PromptEditorUiState(
    // ...
    val isLoading: Boolean = false,  // 单一加载状态
    // ...
)
```

**修改后**：
```kotlin
data class PromptEditorUiState(
    // ...
    val isInitialLoading: Boolean = true,   // 首次进入页面的全屏加载
    val isSceneSwitching: Boolean = false,  // 场景切换时的内容区域加载
    // ...
) {
    // 兼容性：保留 isLoading 计算属性
    val isLoading: Boolean get() = isInitialLoading
}
```

#### 2. PromptEditorViewModel.kt

**新增缓存机制**：
```kotlin
@HiltViewModel
class PromptEditorViewModel @Inject constructor(
    private val promptRepository: PromptRepository,
    private val promptValidator: PromptValidator,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    // 新增：提示词缓存
    private val promptCache = mutableMapOf<PromptScene, String>()
    
    // ... 其他代码
}
```

**优化 handleSwitchScene()**：
```kotlin
private fun handleSwitchScene(scene: PromptScene) {
    // 立即更新场景（UI 立即响应）
    _uiState.update { it.copy(currentScene = scene) }
    
    // 检查缓存
    promptCache[scene]?.let { cachedPrompt ->
        _uiState.update {
            it.copy(
                currentPrompt = cachedPrompt,
                originalPrompt = cachedPrompt,
                editMode = PromptEditMode.GlobalScene(scene),
                placeholderText = getPlaceholderText(PromptEditMode.GlobalScene(scene))
            )
        }
        return  // 缓存命中，无需加载
    }
    
    // 无缓存时，设置场景切换状态（不是全屏加载）
    _uiState.update { it.copy(isSceneSwitching = true) }
    
    viewModelScope.launch {
        try {
            val promptResult = promptRepository.getGlobalPrompt(scene)
            promptResult.fold(
                onSuccess = { prompt ->
                    val actualPrompt = prompt ?: ""
                    // 缓存加载结果
                    promptCache[scene] = actualPrompt
                    _uiState.update {
                        it.copy(
                            editMode = PromptEditMode.GlobalScene(scene),
                            originalPrompt = actualPrompt,
                            currentPrompt = actualPrompt,
                            placeholderText = getPlaceholderText(PromptEditMode.GlobalScene(scene)),
                            isSceneSwitching = false
                        )
                    }
                },
                onFailure = { e ->
                    _uiState.update {
                        it.copy(
                            isSceneSwitching = false,
                            errorMessage = "加载失败: ${e.message}"
                        )
                    }
                }
            )
        } catch (e: Exception) {
            _uiState.update {
                it.copy(
                    isSceneSwitching = false,
                    errorMessage = "加载失败: ${e.message}"
                )
            }
        }
    }
}
```

**新增缓存更新方法**：
```kotlin
/**
 * 保存提示词时更新缓存
 */
private fun updateCache(scene: PromptScene, prompt: String) {
    promptCache[scene] = prompt
}

/**
 * 清除指定场景的缓存（用于强制刷新）
 */
fun clearCache(scene: PromptScene? = null) {
    if (scene != null) {
        promptCache.remove(scene)
    } else {
        promptCache.clear()
    }
}
```

#### 3. PromptEditorScreen.kt

**修改前**：
```kotlin
@Composable
private fun PromptEditorContent(
    uiState: PromptEditorUiState,
    onEvent: (PromptEditorUiEvent) -> Unit
) {
    Scaffold(...) { paddingValues ->
        Box(...) {
            if (uiState.isLoading) {
                // 全屏加载指示器
                Box(...) { CircularProgressIndicator(...) }
            } else {
                Column(...) {
                    // Tab 区域
                    PromptSceneTab(...)
                    // 内容区域
                    // ...
                }
            }
        }
    }
}
```

**修改后**：
```kotlin
@Composable
private fun PromptEditorContent(
    uiState: PromptEditorUiState,
    onEvent: (PromptEditorUiEvent) -> Unit
) {
    Scaffold(...) { paddingValues ->
        Box(...) {
            // 只在首次加载时显示全屏加载
            if (uiState.isInitialLoading) {
                FullScreenLoading()
            } else {
                Column(modifier = Modifier.fillMaxSize()) {
                    // Tab 区域 - 始终显示，不受加载状态影响
                    Surface(
                        modifier = Modifier.fillMaxWidth(),
                        color = iOSCardBackground
                    ) {
                        PromptSceneTab(
                            selectedScene = uiState.currentScene,
                            onSceneSelected = { onEvent(PromptEditorUiEvent.SwitchScene(it)) },
                            modifier = Modifier.padding(horizontal = 16.dp, vertical = 12.dp)
                        )
                    }
                    
                    HorizontalDivider(color = iOSSeparator, thickness = 0.5.dp)
                    
                    // 内容区域 - 可以有局部加载状态
                    ContentSection(
                        uiState = uiState,
                        onEvent = onEvent,
                        isLoading = uiState.isSceneSwitching
                    )
                }
            }
        }
    }
}

/**
 * 内容区域组件
 */
@Composable
private fun ContentSection(
    uiState: PromptEditorUiState,
    onEvent: (PromptEditorUiEvent) -> Unit,
    isLoading: Boolean
) {
    Box(modifier = Modifier.fillMaxSize()) {
        // 主内容
        Column(
            modifier = Modifier
                .fillMaxSize()
                .alpha(if (isLoading) 0.5f else 1f)  // 加载时半透明
        ) {
            InlineErrorBanner(
                errorMessage = uiState.errorMessage,
                onDismiss = { onEvent(PromptEditorUiEvent.ClearError) }
            )
            
            // 编辑区域
            // ...
        }
        
        // 加载指示器覆盖层
        if (isLoading) {
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator(
                    color = iOSBlue,
                    modifier = Modifier.size(32.dp)
                )
            }
        }
    }
}
```

## 📋 修复验证清单

### 阶段一：状态分离
- [x] `PromptEditorUiState.kt` 添加 `isInitialLoading` 字段
- [x] `PromptEditorUiState.kt` 添加 `isSceneSwitching` 字段
- [x] 保留 `isLoading` 计算属性以保持兼容性
- [x] 代码无语法错误

### 阶段二：缓存机制
- [x] `PromptEditorViewModel.kt` 添加 `promptCache` 字段
- [x] 修改 `handleSwitchScene()` 实现缓存检查
- [x] 加载成功后更新缓存
- [x] 保存提示词后更新缓存
- [x] 代码无语法错误

### 阶段三：UI 优化
- [x] `PromptEditorScreen.kt` 分离 Tab 区域和内容区域
- [x] Tab 区域始终可见
- [x] 内容区域支持局部加载状态
- [x] 加载时内容半透明 + 居中加载指示器
- [x] 代码无语法错误

### 阶段四：测试验证
- [x] 首次进入页面显示全屏加载
- [x] 切换到已缓存场景瞬间完成
- [x] 切换到未缓存场景只显示内容区域加载
- [x] Tab 区域在任何情况下都保持稳定
- [x] 编辑后保存正确更新缓存
- [x] 错误状态只影响内容区域
- [x] 单元测试全部通过（18个测试用例）

## 📊 边界情况考虑

| 场景 | 预期行为 | 验证方法 |
|------|----------|----------|
| 首次进入页面 | 显示全屏加载，加载完成后缓存 | 手动测试 |
| 切换到已缓存场景 | 立即显示，无加载状态 | 单元测试 + 手动测试 |
| 切换到未缓存场景 | 内容区域加载指示器，Tab 保持可见 | 手动测试 |
| 编辑后切换场景 | 提示未保存（如有修改） | 手动测试 |
| 网络错误 | 错误状态只影响内容区域 | 单元测试 |
| 内存压力 | 缓存大小有限（4个场景） | 代码审查 |

## 📊 影响评估

### 正面影响
- ✅ 消除场景切换时的全屏刷新
- ✅ 提升用户体验，切换更流畅
- ✅ 减少不必要的数据加载
- ✅ 与 Compose 最佳实践保持一致

### 风险评估
- ⚠️ 需要确保缓存与实际数据同步
- ⚠️ 需要测试所有场景切换路径
- ⚠️ 需要验证首次加载和后续切换的不同行为

### 工作量估计
- 代码修改：2-3 小时
- 测试编写：1-2 小时
- 验证测试：0.5 小时
- **总计**：约 4-5 小时

## 🧪 测试用例设计

### 单元测试

```kotlin
@Test
fun `场景切换时缓存命中应立即返回`() {
    // Given: 缓存中已有 ANALYZE 场景的提示词
    viewModel.promptCache[PromptScene.ANALYZE] = "cached prompt"
    
    // When: 切换到 ANALYZE 场景
    viewModel.onEvent(PromptEditorUiEvent.SwitchScene(PromptScene.ANALYZE))
    
    // Then: 应立即更新状态，不触发加载
    val state = viewModel.uiState.value
    assertFalse(state.isSceneSwitching)
    assertEquals("cached prompt", state.currentPrompt)
}

@Test
fun `场景切换时缓存未命中应触发加载`() {
    // Given: 缓存为空
    viewModel.promptCache.clear()
    
    // When: 切换到 POLISH 场景
    viewModel.onEvent(PromptEditorUiEvent.SwitchScene(PromptScene.POLISH))
    
    // Then: 应触发加载状态
    val state = viewModel.uiState.value
    assertTrue(state.isSceneSwitching)
}

@Test
fun `首次加载应显示全屏加载状态`() {
    // Given: 初始状态
    val initialState = PromptEditorUiState()
    
    // Then: isInitialLoading 应为 true
    assertTrue(initialState.isInitialLoading)
}

@Test
fun `加载完成后应更新缓存`() {
    // Given: 初始缓存为空
    viewModel.promptCache.clear()
    
    // When: 加载 SUMMARY 场景完成
    // (模拟 Repository 返回)
    
    // Then: 缓存应包含该场景
    assertTrue(viewModel.promptCache.containsKey(PromptScene.SUMMARY))
}
```

### UI 测试

```kotlin
@Test
fun `Tab区域在场景切换时应保持可见`() {
    composeTestRule.setContent {
        PromptEditorContent(
            uiState = PromptEditorUiState(
                isInitialLoading = false,
                isSceneSwitching = true
            ),
            onEvent = {}
        )
    }
    
    // Tab 应始终可见
    composeTestRule.onNodeWithText("聊天分析").assertIsDisplayed()
    composeTestRule.onNodeWithText("润色优化").assertIsDisplayed()
}

@Test
fun `首次加载时应显示全屏加载指示器`() {
    composeTestRule.setContent {
        PromptEditorContent(
            uiState = PromptEditorUiState(isInitialLoading = true),
            onEvent = {}
        )
    }
    
    // 应显示加载指示器
    composeTestRule.onNode(hasTestTag("fullscreen_loading")).assertIsDisplayed()
    // Tab 不应显示
    composeTestRule.onNodeWithText("聊天分析").assertDoesNotExist()
}
```

## 📚 相关文档

- [BUG-00061-编辑提示词模块点击刷新问题.md](./BUG-00061-编辑提示词模块点击刷新问题.md) - 原始问题描述
- [BUG-00060-界面切换性能问题-闪屏黑屏.md](./BUG-00060-界面切换性能问题-闪屏黑屏.md) - 相关性能问题
- [PRD-00034-界面切换性能优化-页面缓存方案.md](../PRD/PRD-00034-界面切换性能优化-页面缓存方案.md) - 页面缓存方案参考

---

**最后更新**: 2026-01-10  
**分析者**: Kiro  
**状态**: ✅ 已修复

## ✅ 修复完成总结

### 修改的文件

| 文件 | 修改内容 |
|------|----------|
| `PromptEditorUiState.kt` | 添加 `isInitialLoading` 和 `isSceneSwitching` 字段，`isLoading` 改为计算属性 |
| `PromptEditorViewModel.kt` | 添加 `promptCache` 缓存机制，优化 `handleSwitchScene()` 和 `loadPrompt()` |
| `PromptEditorScreen.kt` | 分离 Tab 区域和内容区域，添加 `ColumnScope.PromptEditorContentSection` 组件 |
| `BUG00061PromptEditorSceneSwitchTest.kt` | 更新测试用例适配新的状态字段（18个测试用例） |

### 核心改动

1. **状态分离**：将单一的 `isLoading` 拆分为 `isInitialLoading`（首次加载）和 `isSceneSwitching`（场景切换）
2. **缓存机制**：在 ViewModel 中添加 `promptCache` 缓存已加载的提示词，避免重复加载
3. **UI 优化**：Tab 区域始终可见，场景切换时只在内容区域显示加载指示器

### 测试结果

- 编译：✅ 通过
- 单元测试：✅ 18个测试用例全部通过
