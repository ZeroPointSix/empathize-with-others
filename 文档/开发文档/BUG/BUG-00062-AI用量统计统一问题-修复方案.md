# BUG-00062ï¼šAIç”¨é‡ç»Ÿè®¡ç»Ÿä¸€é—®é¢˜ - ä¿®å¤æ–¹æ¡ˆ

## æ–‡æ¡£ä¿¡æ¯

| å±æ€§ | å€¼ |
|------|-----|
| æ–‡æ¡£ç¼–å· | BUG-00062-FIX |
| é—®é¢˜ç¼–å· | BUG-00062 |
| åˆ›å»ºæ—¥æœŸ | 2026-01-10 |
| å®Œæˆæ—¥æœŸ | 2026-01-10 |
| ä¼˜å…ˆçº§ | P1-é«˜ |
| é¢„è®¡å·¥æ—¶ | 3å°æ—¶ |
| å®é™…å·¥æ—¶ | 2å°æ—¶ |
| çŠ¶æ€ | âœ… å·²å®Œæˆ |

---

## 1. é—®é¢˜åˆ†æ

### 1.1 é—®é¢˜æ ¹å› 

é€šè¿‡ä»£ç åˆ†æï¼Œå‘ç°ä»¥ä¸‹ä¸¤ä¸ª AI è°ƒç”¨æ–¹æ³•**ç¼ºå°‘ç”¨é‡ç»Ÿè®¡**ï¼š

| æ–¹æ³• | æ–‡ä»¶ä½ç½® | è°ƒç”¨åœºæ™¯ | ç»Ÿè®¡çŠ¶æ€ |
|------|----------|----------|----------|
| `generateText` | `AiRepositoryImpl.kt:572-606` | AIæ€»ç»“ | âŒ æ— ç»Ÿè®¡ |
| `generateTextStream` | `AiRepositoryImpl.kt:1230-1275` | AIå†›å¸ˆå¯¹è¯ | âŒ æ— ç»Ÿè®¡ |

### 1.2 ç°æœ‰ç»Ÿè®¡è¦†ç›–æƒ…å†µ

| æ–¹æ³• | ç»Ÿè®¡çŠ¶æ€ | è°ƒç”¨åœºæ™¯ |
|------|----------|----------|
| `analyzeChat` | âœ… æœ‰ç»Ÿè®¡ | æ‚¬æµ®çª—åˆ†æ |
| `polishDraft` | âœ… æœ‰ç»Ÿè®¡ | æ‚¬æµ®çª—æ¶¦è‰² |
| `generateReply` | âœ… æœ‰ç»Ÿè®¡ | æ‚¬æµ®çª—å›å¤ |
| `queryKnowledge` | âœ… æœ‰ç»Ÿè®¡ | æ‚¬æµ®çª—çŸ¥è¯†æŸ¥è¯¢ |
| `generateText` | âŒ æ— ç»Ÿè®¡ | AIæ€»ç»“ï¼ˆAiSummaryProcessorï¼‰ |
| `generateTextStream` | âŒ æ— ç»Ÿè®¡ | AIå†›å¸ˆå¯¹è¯ï¼ˆSendAdvisorMessageStreamingUseCaseï¼‰ |

### 1.3 è°ƒç”¨é“¾è·¯åˆ†æ

#### AIæ€»ç»“è°ƒç”¨é“¾è·¯
```
SummarizeDailyConversationsUseCase.invoke()
    â†“
AiSummaryProcessor.process()
    â†“
aiRepository.generateText()  â† ç¼ºå°‘ç»Ÿè®¡
```

#### AIå†›å¸ˆè°ƒç”¨é“¾è·¯
```
AiAdvisorChatViewModel.sendMessage()
    â†“
SendAdvisorMessageStreamingUseCase.invoke()
    â†“
aiRepository.generateTextStream()  â† ç¼ºå°‘ç»Ÿè®¡
    â†“
Flow<AiStreamChunk> â†’ Complete/Error
```

---

## 2. ä¿®å¤æ–¹æ¡ˆ

### 2.1 æ–¹æ¡ˆæ¦‚è¿°

é‡‡ç”¨**æ··åˆæ–¹æ¡ˆ**ï¼š
- **generateText**ï¼šåœ¨ Repository å±‚æ·»åŠ ç»Ÿè®¡ï¼ˆå‚è€ƒ polishDraft å®ç°ï¼‰
- **generateTextStream**ï¼šåœ¨ UseCase å±‚æ·»åŠ ç»Ÿè®¡ï¼ˆå› ä¸ºæµå¼å“åº”çš„ token ä¿¡æ¯åœ¨ Complete ä¸­ï¼‰

### 2.2 ä¿®æ”¹æ¸…å•

#### ä¿®æ”¹1ï¼šAiRepositoryImpl.generateText

**æ–‡ä»¶**ï¼š`data/src/main/kotlin/com/empathy/ai/data/repository/AiRepositoryImpl.kt`

**ä¿®æ”¹å†…å®¹**ï¼š
```kotlin
override suspend fun generateText(
    provider: AiProvider,
    prompt: String,
    systemInstruction: String
): Result<String> {
    val startTime = System.currentTimeMillis()  // ğŸ†• æ·»åŠ 
    val model = selectModel(provider)           // ğŸ†• ç§»åˆ°å¤–å±‚
    
    return try {
        val url = buildChatCompletionsUrl(provider.baseUrl)
        val headers = mapOf(
            "Authorization" to "Bearer ${provider.apiKey}",
            "Content-Type" to "application/json"
        )
        val messages = listOf(
            MessageDto(role = "system", content = systemInstruction),
            MessageDto(role = "user", content = prompt)
        )
        val request = ChatRequestDto(
            model = model,
            messages = messages,
            temperature = 0.7,
            stream = false
        )

        val response = withRetry { api.chatCompletion(url, headers, request) }
        val content = response.choices.firstOrNull()?.message?.content
            ?: return Result.failure(Exception("Empty response from AI"))
        
        // ğŸ†• è®°å½•æˆåŠŸçš„ç”¨é‡
        val requestTimeMs = System.currentTimeMillis() - startTime
        recordUsage(
            providerId = provider.id,
            providerName = provider.name,
            modelId = model,
            promptTokens = estimateTokens(systemInstruction + prompt),
            completionTokens = estimateTokens(content),
            requestTimeMs = requestTimeMs,
            isSuccess = true
        )
        
        Result.success(content)

    } catch (e: HttpException) {
        val errorBody = try { e.response()?.errorBody()?.string() ?: "No error body" } catch (ex: Exception) { "Failed to read error body" }
        // ğŸ†• è®°å½•å¤±è´¥çš„ç”¨é‡
        val requestTimeMs = System.currentTimeMillis() - startTime
        recordUsage(
            providerId = provider.id,
            providerName = provider.name,
            modelId = model,
            promptTokens = estimateTokens(systemInstruction + prompt),
            completionTokens = 0,
            requestTimeMs = requestTimeMs,
            isSuccess = false,
            errorMessage = "HTTP ${e.code()}"
        )
        Result.failure(Exception("HTTP ${e.code()}: $errorBody"))
    } catch (e: Exception) {
        Log.e("AiRepositoryImpl", "æ–‡æœ¬ç”Ÿæˆå¤±è´¥", e)
        // ğŸ†• è®°å½•å¤±è´¥çš„ç”¨é‡
        val requestTimeMs = System.currentTimeMillis() - startTime
        recordUsage(
            providerId = provider.id,
            providerName = provider.name,
            modelId = model,
            promptTokens = estimateTokens(systemInstruction + prompt),
            completionTokens = 0,
            requestTimeMs = requestTimeMs,
            isSuccess = false,
            errorMessage = e.message
        )
        Result.failure(e)
    }
}
```

#### ä¿®æ”¹2ï¼šSendAdvisorMessageStreamingUseCase

**æ–‡ä»¶**ï¼š`domain/src/main/kotlin/com/empathy/ai/domain/usecase/SendAdvisorMessageStreamingUseCase.kt`

**ä¿®æ”¹å†…å®¹**ï¼š

1. æ·»åŠ ä¾èµ–æ³¨å…¥ï¼š
```kotlin
class SendAdvisorMessageStreamingUseCase @Inject constructor(
    private val aiAdvisorRepository: AiAdvisorRepository,
    private val aiRepository: AiRepository,
    private val contactRepository: ContactRepository,
    private val aiProviderRepository: AiProviderRepository,
    private val brainTagRepository: BrainTagRepository,
    private val apiUsageRepository: ApiUsageRepository,  // ğŸ†• æ–°å¢
    private val logger: Logger
)
```

2. åœ¨ Complete å¤„ç†å—ä¸­æ·»åŠ ç”¨é‡è®°å½•ï¼š
```kotlin
is AiStreamChunk.Complete -> {
    val finalContent = chunk.fullText.ifEmpty { contentBuilder.toString() }
    
    // æ›´æ–°Blockå†…å®¹
    aiAdvisorRepository.updateBlockContent(
        blockId = mainTextBlock.id,
        content = finalContent,
        status = MessageBlockStatus.SUCCESS
    )
    
    // æ›´æ–°Messageçš„contentå’Œstatus
    aiAdvisorRepository.updateMessageContentAndStatus(
        messageId = aiMessageId,
        content = finalContent,
        status = SendStatus.SUCCESS
    )
    
    // ğŸ†• è®°å½•æˆåŠŸçš„ç”¨é‡
    val requestTimeMs = System.currentTimeMillis() - startTime
    recordUsageForAdvisor(
        provider = provider,
        promptTokens = chunk.usage?.promptTokens ?: estimateTokens(prompt),
        completionTokens = chunk.usage?.completionTokens ?: estimateTokens(finalContent),
        requestTimeMs = requestTimeMs,
        isSuccess = true
    )
    
    emit(StreamingState.Completed(finalContent, chunk.usage))
}
```

3. åœ¨ Error å¤„ç†å—ä¸­æ·»åŠ ç”¨é‡è®°å½•ï¼š
```kotlin
is AiStreamChunk.Error -> {
    val errorContent = "[AIå“åº”å¤±è´¥: ${chunk.error.message ?: "æœªçŸ¥é”™è¯¯"}]"
    aiAdvisorRepository.updateMessageContentAndStatus(
        messageId = aiMessageId,
        content = errorContent,
        status = SendStatus.FAILED
    )
    
    // ğŸ†• è®°å½•å¤±è´¥çš„ç”¨é‡
    val requestTimeMs = System.currentTimeMillis() - startTime
    recordUsageForAdvisor(
        provider = provider,
        promptTokens = estimateTokens(prompt),
        completionTokens = 0,
        requestTimeMs = requestTimeMs,
        isSuccess = false,
        errorMessage = chunk.error.message
    )
    
    emit(StreamingState.Error(chunk.error))
}
```

4. æ·»åŠ è¾…åŠ©æ–¹æ³•ï¼š
```kotlin
/**
 * è®°å½•AIå†›å¸ˆçš„ç”¨é‡
 */
private suspend fun recordUsageForAdvisor(
    provider: AiProvider,
    promptTokens: Int,
    completionTokens: Int,
    requestTimeMs: Long,
    isSuccess: Boolean,
    errorMessage: String? = null
) {
    try {
        apiUsageRepository.recordUsage(
            ApiUsageRecord(
                id = UUID.randomUUID().toString(),
                providerId = provider.id,
                providerName = provider.name,
                modelId = provider.models.firstOrNull() ?: "unknown",
                modelName = provider.models.firstOrNull() ?: "unknown",
                promptTokens = promptTokens,
                completionTokens = completionTokens,
                totalTokens = promptTokens + completionTokens,
                requestTimeMs = requestTimeMs,
                isSuccess = isSuccess,
                errorMessage = errorMessage,
                createdAt = System.currentTimeMillis()
            )
        )
    } catch (e: Exception) {
        logger.w(TAG, "è®°å½•AIå†›å¸ˆç”¨é‡å¤±è´¥: ${e.message}")
    }
}

/**
 * ä¼°ç®—Tokenæ•°é‡
 */
private fun estimateTokens(text: String): Int {
    val chineseCount = text.count { it.code in 0x4E00..0x9FFF }
    val otherCount = text.length - chineseCount
    return (chineseCount / 1.5 + otherCount / 4.0).toInt().coerceAtLeast(1)
}
```

#### ä¿®æ”¹3ï¼šæ›´æ–°DIæ¨¡å—

**æ–‡ä»¶**ï¼š`app/src/main/java/com/empathy/ai/di/AiAdvisorModule.kt`

**ä¿®æ”¹å†…å®¹**ï¼š
```kotlin
@Provides
@Singleton
fun provideSendAdvisorMessageStreamingUseCase(
    aiAdvisorRepository: AiAdvisorRepository,
    aiRepository: AiRepository,
    contactRepository: ContactRepository,
    aiProviderRepository: AiProviderRepository,
    brainTagRepository: BrainTagRepository,
    apiUsageRepository: ApiUsageRepository,  // ğŸ†• æ–°å¢
    logger: Logger
): SendAdvisorMessageStreamingUseCase {
    return SendAdvisorMessageStreamingUseCase(
        aiAdvisorRepository,
        aiRepository,
        contactRepository,
        aiProviderRepository,
        brainTagRepository,
        apiUsageRepository,  // ğŸ†• æ–°å¢
        logger
    )
}
```

---

## 3. ä»»åŠ¡æ¸…å•

| ä»»åŠ¡ID | æè¿° | æ–‡ä»¶ | é¢„è®¡å·¥æ—¶ | ä¼˜å…ˆçº§ | ä¾èµ– | çŠ¶æ€ |
|--------|------|------|----------|--------|------|------|
| T1 | ä¿®æ”¹ generateText æ·»åŠ ç”¨é‡ç»Ÿè®¡ | `AiRepositoryImpl.kt` | 0.5h | P0 | - | âœ… å®Œæˆ |
| T2 | ä¿®æ”¹ SendAdvisorMessageStreamingUseCase æ·»åŠ ä¾èµ–æ³¨å…¥ | `SendAdvisorMessageStreamingUseCase.kt` | 0.25h | P0 | - | âœ… å®Œæˆ |
| T3 | ä¿®æ”¹ SendAdvisorMessageStreamingUseCase æ·»åŠ ç”¨é‡è®°å½• | `SendAdvisorMessageStreamingUseCase.kt` | 0.5h | P0 | T2 | âœ… å®Œæˆ |
| T4 | æ›´æ–° AiAdvisorModule DIé…ç½® | `AiAdvisorModule.kt` | 0.25h | P0 | T2 | âœ… å®Œæˆ |
| T5 | æ›´æ–° SendAdvisorMessageStreamingUseCaseTest æµ‹è¯• | `SendAdvisorMessageStreamingUseCaseTest.kt` | 0.25h | P1 | T3 | âœ… å®Œæˆ |
| T6 | ç¼–è¯‘éªŒè¯ | - | 0.25h | P0 | T1-T5 | âœ… å®Œæˆ |

---

## 4. æµ‹è¯•ç”¨ä¾‹

### 4.1 å•å…ƒæµ‹è¯•

#### T5: AiRepositoryImpl.generateText ç”¨é‡ç»Ÿè®¡æµ‹è¯•

```kotlin
@Test
fun `generateText should record usage on success`() = runTest {
    // Given
    val provider = createTestProvider()
    val prompt = "æµ‹è¯•æç¤ºè¯"
    val systemInstruction = "ç³»ç»ŸæŒ‡ä»¤"
    val expectedResponse = "AIå“åº”å†…å®¹"
    
    coEvery { api.chatCompletion(any(), any(), any()) } returns createMockResponse(expectedResponse)
    
    // When
    val result = repository.generateText(provider, prompt, systemInstruction)
    
    // Then
    assertTrue(result.isSuccess)
    coVerify { 
        apiUsageRepository.recordUsage(match { 
            it.providerId == provider.id && 
            it.isSuccess == true &&
            it.promptTokens > 0 &&
            it.completionTokens > 0
        })
    }
}

@Test
fun `generateText should record usage on failure`() = runTest {
    // Given
    val provider = createTestProvider()
    coEvery { api.chatCompletion(any(), any(), any()) } throws IOException("ç½‘ç»œé”™è¯¯")
    
    // When
    val result = repository.generateText(provider, "prompt", "system")
    
    // Then
    assertTrue(result.isFailure)
    coVerify { 
        apiUsageRepository.recordUsage(match { 
            it.isSuccess == false &&
            it.errorMessage != null
        })
    }
}
```

#### T6: SendAdvisorMessageStreamingUseCase ç”¨é‡ç»Ÿè®¡æµ‹è¯•

```kotlin
@Test
fun `invoke should record usage on streaming complete`() = runTest {
    // Given
    val contactId = "contact-1"
    val sessionId = "session-1"
    val userMessage = "ä½ å¥½"
    val provider = createTestProvider()
    
    coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(provider)
    coEvery { aiRepository.generateTextStream(any(), any(), any()) } returns flowOf(
        AiStreamChunk.Started,
        AiStreamChunk.TextDelta("ä½ å¥½"),
        AiStreamChunk.Complete("ä½ å¥½ï¼Œæœ‰ä»€ä¹ˆå¯ä»¥å¸®åŠ©ä½ çš„ï¼Ÿ", TokenUsage(10, 20))
    )
    
    // When
    useCase(contactId, sessionId, userMessage).collect()
    
    // Then
    coVerify { 
        apiUsageRepository.recordUsage(match { 
            it.providerId == provider.id && 
            it.isSuccess == true &&
            it.promptTokens == 10 &&
            it.completionTokens == 20
        })
    }
}

@Test
fun `invoke should record usage on streaming error`() = runTest {
    // Given
    coEvery { aiRepository.generateTextStream(any(), any(), any()) } returns flowOf(
        AiStreamChunk.Started,
        AiStreamChunk.Error(IOException("ç½‘ç»œé”™è¯¯"))
    )
    
    // When
    useCase("contact-1", "session-1", "ä½ å¥½").collect()
    
    // Then
    coVerify { 
        apiUsageRepository.recordUsage(match { 
            it.isSuccess == false &&
            it.errorMessage == "ç½‘ç»œé”™è¯¯"
        })
    }
}
```

### 4.2 é›†æˆæµ‹è¯•

#### T7: ç«¯åˆ°ç«¯éªŒè¯

```kotlin
@Test
fun `AIå†›å¸ˆå¯¹è¯åç”¨é‡ç»Ÿè®¡åº”æ˜¾ç¤ºè®°å½•`() {
    // 1. è¿›å…¥AIå†›å¸ˆç•Œé¢
    // 2. å‘é€ä¸€æ¡æ¶ˆæ¯
    // 3. ç­‰å¾…AIå“åº”å®Œæˆ
    // 4. è¿›å…¥è®¾ç½® â†’ AIé…ç½® â†’ ç”¨é‡ç»Ÿè®¡
    // 5. éªŒè¯æ˜¾ç¤ºäº†æœ¬æ¬¡å¯¹è¯çš„ç”¨é‡è®°å½•
}

@Test
fun `AIæ€»ç»“æ‰§è¡Œåç”¨é‡ç»Ÿè®¡åº”æ˜¾ç¤ºè®°å½•`() {
    // 1. ç¡®ä¿æœ‰æœªæ€»ç»“çš„å¯¹è¯è®°å½•
    // 2. è§¦å‘æ¯æ—¥æ€»ç»“ï¼ˆæˆ–æ‰‹åŠ¨æ€»ç»“ï¼‰
    // 3. ç­‰å¾…æ€»ç»“å®Œæˆ
    // 4. è¿›å…¥è®¾ç½® â†’ AIé…ç½® â†’ ç”¨é‡ç»Ÿè®¡
    // 5. éªŒè¯æ˜¾ç¤ºäº†æœ¬æ¬¡æ€»ç»“çš„ç”¨é‡è®°å½•
}
```

---

## 5. é£é™©è¯„ä¼°

| é£é™© | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|------|------|------|----------|
| æµå¼å“åº” token ä¿¡æ¯ä¸å‡†ç¡® | ç»Ÿè®¡æ•°æ®åå·® | ä¸­ | ä½¿ç”¨ estimateTokens ä½œä¸ºå¤‡é€‰ |
| ä¾èµ–æ³¨å…¥å˜æ›´å¯¼è‡´ç¼–è¯‘é”™è¯¯ | æ„å»ºå¤±è´¥ | ä½ | æ›´æ–° DI æ¨¡å—é…ç½® |
| æ€§èƒ½å½±å“ | è½»å¾®å»¶è¿Ÿ | ä½ | å¼‚æ­¥è®°å½•ï¼Œä¸é˜»å¡ä¸»æµç¨‹ |
| è®°å½•å¤±è´¥å¯¼è‡´å¼‚å¸¸ | åŠŸèƒ½ä¸­æ–­ | ä½ | try-catch åŒ…è£¹ï¼Œä»…è®°å½•è­¦å‘Šæ—¥å¿— |

---

## 6. éªŒæ”¶æ ‡å‡†

### 6.1 åŠŸèƒ½éªŒæ”¶

- [x] AIå†›å¸ˆå¯¹è¯åï¼Œç”¨é‡ç»Ÿè®¡é¡µé¢æ˜¾ç¤ºå¯¹åº”è®°å½•
- [x] AIæ€»ç»“æ‰§è¡Œåï¼Œç”¨é‡ç»Ÿè®¡é¡µé¢æ˜¾ç¤ºå¯¹åº”è®°å½•
- [x] å¤±è´¥çš„è¯·æ±‚ä¹Ÿè¢«æ­£ç¡®è®°å½•ï¼ˆisSuccess=falseï¼‰
- [x] Token è®¡æ•°åŸºæœ¬å‡†ç¡®ï¼ˆä½¿ç”¨APIè¿”å›å€¼æˆ–ä¼°ç®—å€¼ï¼‰
- [x] ç”¨é‡ç»Ÿè®¡é¡µé¢çš„æŒ‰æœåŠ¡å•†/æŒ‰æ¨¡å‹åˆ†ç±»æ­£ç¡®

### 6.2 æŠ€æœ¯éªŒæ”¶

- [x] ç¼–è¯‘é€šè¿‡ï¼ˆBUILD SUCCESSFULï¼‰
- [x] æµ‹è¯•æ–‡ä»¶æ›´æ–°å®Œæˆ
- [x] æ— è¿è¡Œæ—¶å´©æºƒé£é™©ï¼ˆtry-catchä¿æŠ¤ï¼‰
- [x] æ—¥å¿—è¾“å‡ºæ­£å¸¸

---

## 7. ç›¸å…³æ–‡æ¡£

- [BUG-00062-AIç”¨é‡ç»Ÿè®¡ç»Ÿä¸€é—®é¢˜.md](./BUG-00062-AIç”¨é‡ç»Ÿè®¡ç»Ÿä¸€é—®é¢˜.md) - é—®é¢˜æè¿°
- [TDD-00025-AIé…ç½®åŠŸèƒ½å®Œå–„æŠ€æœ¯è®¾è®¡.md](../TDD/TDD-00025-AIé…ç½®åŠŸèƒ½å®Œå–„æŠ€æœ¯è®¾è®¡.md) - ç”¨é‡ç»Ÿè®¡åŸå§‹è®¾è®¡
- [FD-00025-AIé…ç½®åŠŸèƒ½å®Œå–„åŠŸèƒ½è®¾è®¡.md](../FD/FD-00025-AIé…ç½®åŠŸèƒ½å®Œå–„åŠŸèƒ½è®¾è®¡.md) - åŠŸèƒ½è®¾è®¡æ–‡æ¡£

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2026-01-10
