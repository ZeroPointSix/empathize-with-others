# BUG-00074：悬浮球重新生成 UI 层级混乱问题

## 问题概述
**问题分类**: UI 显示异常
**优先级**: P1-高
**发现版本**: v1.1.0 (dev)
**发现时间**: 2026-01-16

---

## 问题描述

### 现象描述
在其他系统界面点击生成 APP 后，如果想要重新生成，结果并不会直接展示在悬浮窗中，而是会在 APP 里面提示出来，用户无法看到重新生成的结果。

### 期望行为
1. 用户在 APP 外点击生成 → 最小化到悬浮球
2. 点击重新生成按钮 → 结果应该在悬浮窗中显示
3. 或者自动展开悬浮窗显示结果

### 实际行为
1. 用户在 APP 外点击生成 → 最小化到悬浮球
2. 点击重新生成按钮 → 结果显示在不可见的窗口中
3. 用户无法看到重新生成的结果

---

## 问题分析

### 影响范围
- 悬浮窗服务（FloatingWindowService）
- 重新生成功能流程
- UI 层级管理

### 根因定位

#### 核心问题
重新生成功能在最小化状态下，结果被显示在不可见的 FloatingViewV2 窗口中，而不是直接在悬浮球或通知中显示。

#### 根本原因

**原因 1: 窗口可见性检查缺失**
- 文件: `app/src/main/java/com/empathy/ai/domain/service/FloatingWindowService.kt`
- 位置: 行 2826-2870
- 问题: `handleRegenerateV2()` 方法不检查 floatingViewV2 的可见性

```kotlin
private fun handleRegenerateV2(tab: ActionType, instruction: String?) {
    floatingViewV2?.showLoading("AI正在重新生成...")  // 直接显示，不检查可见性

    serviceScope.launch {
        // ... 处理逻辑
        floatingViewV2?.showResult(aiResult)  // 行 2850: 直接显示结果
    }
}
```

**原因 2: 最小化状态下窗口不可见**
- 文件: `app/src/main/java/com/empathy/ai/domain/service/FloatingWindowService.kt`
- 位置: 行 3300
- 问题: 最小化时设置 `floatingViewV2.visibility = View.GONE`

```kotlin
private fun minimizeToFloatingBubble() {
    floatingViewV2?.visibility = View.GONE  // 窗口不可见
    // ... 但重新生成仍然调用 floatingViewV2?.showResult()
}
```

**原因 3: UI 层级配置相同**
- 文件: `presentation/src/main/kotlin/com/empathy/ai/presentation/ui/floating/FloatingBubbleView.kt`
- 位置: 行 338-363
- 问题: 悬浮球和悬浮窗都使用相同的 `TYPE_APPLICATION_OVERLAY` 层级

```kotlin
// FloatingViewV2 的层级 (FloatingWindowService.kt 行 2215-2220)
val type = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
    WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
} else {
    WindowManager.LayoutParams.TYPE_PHONE
}

// FloatingBubbleView 的层级 (FloatingBubbleView.kt 行 342-347)
val type = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
    WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
} else {
    WindowManager.LayoutParams.TYPE_PHONE
}
```

### 数据流分析

**正常场景（APP 内重新生成）**:
```
用户点击重新生成 → ResultCard.btnRegenerate 点击
→ FloatingViewV2.onRegenerateListener 回调
→ FloatingWindowService.handleRegenerateV2()
→ floatingViewV2?.showResult() 显示结果
→ 结果在 FloatingViewV2 中显示 ✓
```

**问题场景（APP 外最小化后重新生成）**:
```
用户在 APP 外点击生成 → 最小化到悬浮球
→ floatingViewV2.visibility = View.GONE (行 3300)
→ 用户点击悬浮球上的重新生成按钮
→ FloatingWindowService.handleRegenerateV2()
→ floatingViewV2?.showResult() 显示结果
→ 但 floatingViewV2 不可见！
→ 结果显示在 APP 内（用户看不到）✗
```

### UI 层级结构图

```
WindowManager 层级结构：
├── TYPE_APPLICATION_OVERLAY (Android 8.0+) / TYPE_PHONE (< 8.0)
│   ├── FloatingViewV2 (对话框窗口)
│   │   ├── TabSwitcher (Tab 切换器)
│   │   ├── 输入区域
│   │   ├── ResultCard (结果卡片)
│   │   │   ├── btnCopy (复制按钮)
│   │   │   └── btnRegenerate (重新生成按钮)
│   │   └── RefinementOverlay (微调对话框)
│   │
│   └── FloatingBubbleView (悬浮球)
│       ├── iconView (图标)
│       └── progressView (进度条)
```

---

## 修复方案

### 方案 1: 在重新生成前检查窗口可见性（推荐）

**修改文件**: `app/src/main/java/com/empathy/ai/domain/service/FloatingWindowService.kt`
**修改位置**: 行 2826-2870 `handleRegenerateV2()` 方法

**修改思路**:
```kotlin
private fun handleRegenerateV2(tab: ActionType, instruction: String?) {
    // 检查 floatingViewV2 是否可见
    if (floatingViewV2?.visibility != View.VISIBLE) {
        // 如果不可见，先展开悬浮窗
        expandFromBubble()
    }

    floatingViewV2?.showLoading("AI正在重新生成...")
    // ... 后续逻辑
}
```

**优点**:
- 修改范围小，风险低
- 直接解决核心问题
- 不影响其他功能

**缺点**:
- 需要确保 `expandFromBubble()` 方法的正确性

---

### 方案 2: 调整 WindowManager 层级

**修改文件**:
- `app/src/main/java/com/empathy/ai/domain/service/FloatingWindowService.kt`
- `presentation/src/main/kotlin/com/empathy/ai/presentation/ui/floating/FloatingBubbleView.kt`

**修改思路**:
为悬浮球和悬浮窗使用不同的层级优先级，确保悬浮球始终在最上层。

**优点**:
- 从根本上解决层级混乱问题
- 提升整体 UI 层级管理

**缺点**:
- 修改范围较大
- 可能影响其他悬浮窗功能
- 需要充分测试

---

### 方案 3: 在最小化时保存重新生成状态

**修改文件**: `app/src/main/java/com/empathy/ai/domain/service/FloatingWindowService.kt`
**修改位置**: 行 3290-3310 `minimizeToFloatingBubble()` 方法

**修改思路**:
```kotlin
private fun minimizeToFloatingBubble() {
    // 保存当前是否有待显示的结果
    floatingViewV2?.let { view ->
        val hasResult = view.getCurrentState().lastResult != null
        floatingWindowPreferences.savePendingResult(hasResult)
    }
    // ... 后续逻辑
}
```

**优点**:
- 可以在展开时恢复状态
- 提升用户体验

**缺点**:
- 需要额外的状态管理
- 实现复杂度较高

---

## 测试步骤

### 测试场景 1: APP 外最小化后重新生成
1. 在其他应用界面，点击悬浮球
2. 输入内容，点击【帮我分析】
3. 等待 AI 生成结果
4. 最小化到悬浮球
5. 点击悬浮球上的重新生成按钮
6. **验证**: 结果应该在悬浮窗中显示（自动展开）

### 测试场景 2: 从悬浮球展开后重新生成
1. 点击悬浮球展开悬浮窗
2. 点击重新生成按钮
3. **验证**: 结果应该在悬浮窗中显示

### 测试场景 3: APP 内重新生成
1. 在 APP 内打开悬浮窗
2. 输入内容，点击【帮我分析】
3. 等待 AI 生成结果
4. 点击重新生成按钮
5. **验证**: 结果应该在悬浮窗中显示

---

## 验收标准
1. ✅ APP 外最小化后重新生成，结果能正确显示
2. ✅ 从悬浮球展开后重新生成，结果能正确显示
3. ✅ APP 内重新生成功能不受影响
4. ✅ 悬浮球和悬浮窗的层级关系正确
5. ✅ 不影响其他悬浮窗功能

---

## 相关文件

### 核心文件
- `app/src/main/java/com/empathy/ai/domain/service/FloatingWindowService.kt`
  - `handleRegenerateV2()` (行 2826-2870)
  - `minimizeToFloatingBubble()` (行 3290-3310)
  - `expandFromBubble()` (行 3013-3050)

- `presentation/src/main/kotlin/com/empathy/ai/presentation/ui/floating/FloatingViewV2.kt`
  - `setOnRegenerateListener()` (行 540-541)
  - `showResult()` (行 XXX)

- `presentation/src/main/kotlin/com/empathy/ai/presentation/ui/floating/FloatingBubbleView.kt`
  - `createLayoutParams()` (行 338-363)
  - `setState()` (行 XXX)

- `presentation/src/main/kotlin/com/empathy/ai/presentation/ui/floating/ResultCard.kt`
  - `setOnRegenerateClickListener()` (行 363-364)

---

## 技术细节

### WindowManager 层级配置

**FloatingViewV2 配置**:
```kotlin
// 行 2222-2228
val params = WindowManager.LayoutParams(
    WindowManager.LayoutParams.MATCH_PARENT,
    WindowManager.LayoutParams.WRAP_CONTENT,
    type,
    WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or
        WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH,
    PixelFormat.TRANSLUCENT
).apply {
    gravity = Gravity.TOP or Gravity.CENTER_HORIZONTAL
}
```

**FloatingBubbleView 配置**:
```kotlin
// 行 348-358
return WindowManager.LayoutParams(
    sizePx,
    sizePx,
    type,
    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
            WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
    PixelFormat.TRANSLUCENT
).apply {
    gravity = Gravity.TOP or Gravity.START
    this.x = x
    this.y = y
}
```

### 关键标志说明

| 标志 | 用途 | 影响 |
|------|------|------|
| `FLAG_NOT_TOUCH_MODAL` | 触摸事件穿透 | FloatingViewV2 使用，允许触摸事件传递到下层 |
| `FLAG_WATCH_OUTSIDE_TOUCH` | 监听外部触摸 | FloatingViewV2 使用，检测外部点击 |
| `FLAG_NOT_FOCUSABLE` | 不获取焦点 | FloatingBubbleView 使用，不影响其他窗口焦点 |
| `FLAG_LAYOUT_NO_LIMITS` | 允许超出屏幕 | FloatingBubbleView 使用，允许拖动到屏幕边缘 |

---

## 变更日志
| 日期 | 版本 | 变更内容 | 作者 |
|------|------|----------|------|
| 2026-01-16 | v1.0 | 创建问题与修复方案文档 | Claude |

---

## 附录：完整调查报告

详细的技术分析和代码审查结果请参考探索报告：
- Agent ID: ab35d3c
- 探索时间: 2026-01-16 13:28

### 关键发现总结

1. **窗口可见性检查缺失**: `handleRegenerateV2()` 不检查窗口可见性
2. **层级配置相同**: 悬浮球和悬浮窗使用相同的 WindowManager 层级
3. **状态同步问题**: 悬浮球状态更新依赖于 floatingBubbleView 存在

### 建议优先级

1. **高**: 在 `handleRegenerateV2()` 中检查窗口可见性，如果不可见则先展开
2. **中**: 调整 WindowManager 层级配置，为悬浮球设置更高的优先级
3. **低**: 优化状态同步机制，确保悬浮球和悬浮窗状态一致
