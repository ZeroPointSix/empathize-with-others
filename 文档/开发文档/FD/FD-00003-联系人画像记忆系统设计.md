# FD-00003-联系人画像记忆系统设计

## 1. 文档信息

| 项目 | 内容 |
|------|------|
| 文档类型 | FD (Functional Document) |
| 文档编号 | FD-00003 |
| 功能名称 | 联系人画像记忆系统 |
| 版本 | 1.1 |
| 创建日期 | 2025-12-14 |
| 最后更新 | 2025-12-14 |
| 作者 | Claude |
| 审核人 | 待定 |
| 关联文档 | PRD-00003-联系人画像记忆系统需求 |

## 2. 功能概述

### 2.1 功能定位

联系人画像记忆系统是共情AI助手的核心智能模块，为AI分析提供持久化的上下文记忆能力。通过三层记忆架构（短期对话记录→中期每日总结→长期联系人画像），让AI能够"记住"用户与联系人的互动历史，提供更精准的沟通建议。

### 2.2 设计原则

- **自动化优先**: 对话记录和每日总结自动执行，用户无感知
- **智能筛选**: 上下文构建时智能筛选相关信息，避免信息过载
- **渐进增强**: 关系分数和标签随互动自动更新，越用越准
- **容错降级**: AI服务不可用时自动降级到本地统计
- **隐私保护**: 所有数据本地存储，不上传到服务器

### 2.3 MVP范围

**本次实现**：
- ✅ 对话记录自动存储
- ✅ 每日总结生成（AI驱动）
- ✅ Facts结构增强（带时间戳和来源）
- ✅ 关系分数系统（0-100分）
- ✅ 智能上下文构建（分层筛选）
- ✅ 关系分数UI展示

**明确不包含**：
- ❌ Facts手动编辑UI
- ❌ 对话记录详细查看界面
- ❌ 向量搜索
- ❌ 记忆可视化


## 3. 系统架构设计

### 3.1 三层记忆架构

```
┌─────────────────────────────────────────────────────────────┐
│                      表现层 (Presentation)                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │ ChatScreen  │  │ContactDetail│  │ 关系分数展示组件    │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      领域层 (Domain)                         │
│  ┌─────────────────┐  ┌─────────────────────────────────┐  │
│  │AnalyzeChatUseCase│  │SummarizeDailyConversationsUseCase│  │
│  └─────────────────┘  └─────────────────────────────────┘  │
│  ┌─────────────────┐  ┌─────────────────────────────────┐  │
│  │ ContextBuilder  │  │       RetryPolicy               │  │
│  └─────────────────┘  └─────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      数据层 (Data)                           │
│  ┌─────────────────┐  ┌─────────────────────────────────┐  │
│  │ConversationRepo │  │       ContactRepository         │  │
│  └─────────────────┘  └─────────────────────────────────┘  │
│  ┌─────────────────┐  ┌─────────────────────────────────┐  │
│  │  AiRepository   │  │      BrainTagRepository         │  │
│  └─────────────────┘  └─────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      存储层 (Storage)                        │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   Room Database                      │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌────────┐ │   │
│  │  │ profiles │ │brain_tags│ │conv_logs │ │summaries│ │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └────────┘ │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 数据流设计

```
┌─────────────────────────────────────────────────────────────┐
│                    实时分析流程                              │
├─────────────────────────────────────────────────────────────┤
│  用户输入 ──→ 保存对话记录 ──→ 构建上下文 ──→ AI分析       │
│                    │                │            │          │
│                    ↓                ↓            ↓          │
│              conversation_logs   筛选facts   保存AI回复     │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    每日总结流程                              │
├─────────────────────────────────────────────────────────────┤
│  新一天首次打开App                                          │
│        ↓                                                    │
│  查询未总结对话 ──→ 按联系人分组 ──→ AI生成总结            │
│        │                              │                     │
│        ↓                              ↓                     │
│  无对话则跳过              解析JSON并更新数据               │
│                                       │                     │
│                    ┌──────────────────┼──────────────────┐  │
│                    ↓                  ↓                  ↓  │
│              更新facts          更新BrainTag        更新分数│
│                    │                  │                  │  │
│                    └──────────────────┼──────────────────┘  │
│                                       ↓                     │
│                              标记对话为已总结               │
└─────────────────────────────────────────────────────────────┘
```


## 4. 数据库版本管理

### 4.1 版本状态

| 项目 | 值 |
|------|-----|
| 当前生产版本 | v3 |
| 目标版本 | v4 |
| 迁移策略 | Migration脚本 + 破坏性迁移降级 |

### 4.2 版本历史

| 版本 | 变更内容 | 发布日期 |
|------|---------|---------|
| v1 | 初始版本，包含profiles、brain_tags表 | 2025-11-xx |
| v2 | 添加ai_providers表 | 2025-11-xx |
| v3 | 当前版本，优化索引 | 2025-12-xx |
| v4 | 目标版本，添加记忆系统相关表和字段 | 待发布 |

### 4.3 v3→v4迁移内容

**新增表**：
- `conversation_logs` - 对话记录表
- `daily_summaries` - 每日总结表

**修改表**：
- `profiles` - 添加 `relationship_score`、`last_interaction_date` 字段
- `profiles` - `facts_json` 格式从 `Map<String, String>` 改为 `List<Fact>`

### 4.4 数据迁移详细方案

#### 4.4.1 Migration脚本

```kotlin
val MIGRATION_3_4 = object : Migration(3, 4) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // 1. 创建conversation_logs表
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS conversation_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                contact_id TEXT NOT NULL,
                user_input TEXT NOT NULL,
                ai_response TEXT,
                timestamp INTEGER NOT NULL,
                is_summarized INTEGER NOT NULL DEFAULT 0,
                FOREIGN KEY(contact_id) REFERENCES profiles(id) ON DELETE CASCADE
            )
        """)
        
        // 2. 创建conversation_logs索引
        database.execSQL("CREATE INDEX idx_conv_contact ON conversation_logs(contact_id)")
        database.execSQL("CREATE INDEX idx_conv_timestamp ON conversation_logs(timestamp)")
        database.execSQL("CREATE INDEX idx_conv_summarized ON conversation_logs(is_summarized)")
        
        // 3. 创建daily_summaries表
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS daily_summaries (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                contact_id TEXT NOT NULL,
                summary_date TEXT NOT NULL,
                content TEXT NOT NULL,
                key_events_json TEXT NOT NULL,
                relationship_score INTEGER NOT NULL,
                created_at INTEGER NOT NULL,
                FOREIGN KEY(contact_id) REFERENCES profiles(id) ON DELETE CASCADE
            )
        """)
        
        // 4. 创建daily_summaries索引
        database.execSQL("CREATE INDEX idx_summary_contact ON daily_summaries(contact_id)")
        database.execSQL("CREATE INDEX idx_summary_date ON daily_summaries(summary_date)")
        database.execSQL("CREATE UNIQUE INDEX idx_summary_contact_date ON daily_summaries(contact_id, summary_date)")
        
        // 5. 添加profiles新字段
        database.execSQL("ALTER TABLE profiles ADD COLUMN relationship_score INTEGER NOT NULL DEFAULT 50")
        database.execSQL("ALTER TABLE profiles ADD COLUMN last_interaction_date TEXT")
        
        // 6. 迁移facts_json格式（Map → List<Fact>）
        migrateFactsFormat(database)
    }
    
    private fun migrateFactsFormat(database: SupportSQLiteDatabase) {
        val cursor = database.query("SELECT id, facts_json FROM profiles")
        cursor.use {
            while (it.moveToNext()) {
                val id = it.getString(0)
                val oldFactsJson = it.getString(1)
                val newFactsJson = convertMapToFactList(oldFactsJson)
                database.execSQL(
                    "UPDATE profiles SET facts_json = ? WHERE id = ?",
                    arrayOf(newFactsJson, id)
                )
            }
        }
    }
    
    private fun convertMapToFactList(oldJson: String): String {
        if (oldJson.isBlank() || oldJson == "{}") return "[]"
        
        return try {
            val moshi = Moshi.Builder().build()
            val mapAdapter = moshi.adapter<Map<String, String>>(
                Types.newParameterizedType(Map::class.java, String::class.java, String::class.java)
            )
            val oldMap = mapAdapter.fromJson(oldJson) ?: emptyMap()
            
            val now = System.currentTimeMillis()
            val factList = oldMap.map { (key, value) ->
                Fact(key = key, value = value, timestamp = now, source = FactSource.MANUAL)
            }
            
            val listAdapter = moshi.adapter<List<Fact>>(
                Types.newParameterizedType(List::class.java, Fact::class.java)
            )
            listAdapter.toJson(factList)
        } catch (e: Exception) {
            "[]"
        }
    }
}
```

#### 4.4.2 TypeConverter兼容旧格式

```kotlin
class FactListConverter {
    private val moshi = Moshi.Builder().build()
    
    @TypeConverter
    fun fromFactList(facts: List<Fact>?): String {
        if (facts == null) return "[]"
        val adapter = moshi.adapter<List<Fact>>(
            Types.newParameterizedType(List::class.java, Fact::class.java)
        )
        return adapter.toJson(facts)
    }
    
    @TypeConverter
    fun toFactList(json: String?): List<Fact> {
        if (json.isNullOrBlank()) return emptyList()
        
        return try {
            // 尝试解析为List<Fact>
            val listAdapter = moshi.adapter<List<Fact>>(
                Types.newParameterizedType(List::class.java, Fact::class.java)
            )
            listAdapter.fromJson(json) ?: emptyList()
        } catch (e: Exception) {
            // 降级：尝试解析为旧格式Map<String, String>
            try {
                val mapAdapter = moshi.adapter<Map<String, String>>(
                    Types.newParameterizedType(Map::class.java, String::class.java, String::class.java)
                )
                val oldMap = mapAdapter.fromJson(json) ?: emptyMap()
                val now = System.currentTimeMillis()
                oldMap.map { (key, value) ->
                    Fact(key = key, value = value, timestamp = now, source = FactSource.MANUAL)
                }
            } catch (e2: Exception) {
                emptyList()
            }
        }
    }
}
```

#### 4.4.3 迁移失败处理

```kotlin
// AppDatabase.kt
@Database(
    entities = [
        ContactProfileEntity::class,
        BrainTagEntity::class,
        AiProviderEntity::class,
        ConversationLogEntity::class,
        DailySummaryEntity::class
    ],
    version = 4,
    exportSchema = true
)
@TypeConverters(RoomTypeConverters::class)
abstract class AppDatabase : RoomDatabase() {
    
    companion object {
        fun build(context: Context): AppDatabase {
            return Room.databaseBuilder(
                context.applicationContext,
                AppDatabase::class.java,
                "empathy_database"
            )
            .addMigrations(MIGRATION_3_4)
            .fallbackToDestructiveMigration()  // MVP阶段降级方案
            .build()
        }
    }
}
```


## 5. 数据模型设计

### 5.1 Fact数据结构

**Domain模型**：
```kotlin
data class Fact(
    val key: String,           // 字段名，如"性格特点"、"兴趣爱好"
    val value: String,         // 字段值
    val timestamp: Long,       // 创建/更新时间（自动记录）
    val source: FactSource     // 来源：MANUAL 或 AI_INFERRED
)

enum class FactSource {
    MANUAL,        // 用户手动添加
    AI_INFERRED    // AI推断
}
```

**预定义字段**：
| 字段名 | 常量名 | 说明 |
|--------|--------|------|
| 性格特点 | PERSONALITY | 联系人的性格描述 |
| 兴趣爱好 | INTERESTS | 联系人的兴趣爱好 |
| 沟通雷区 | TABOOS | 需要避免的话题 |
| 喜好偏好 | PREFERENCES | 联系人的喜好 |
| 家庭情况 | FAMILY | 家庭相关信息 |
| 工作情况 | WORK | 工作相关信息 |
| 健康状况 | HEALTH | 健康相关信息 |
| 生活习惯 | HABITS | 日常习惯 |

**JSON存储格式**：
```json
[
  {
    "key": "性格特点",
    "value": "急性子但讨厌被push",
    "timestamp": 1734134400000,
    "source": "MANUAL"
  },
  {
    "key": "兴趣爱好",
    "value": "钓鱼、看球赛",
    "timestamp": 1734220800000,
    "source": "AI_INFERRED"
  }
]
```

### 5.2 ContactProfile扩展

**Domain模型**：
```kotlin
data class ContactProfile(
    val id: String,
    val name: String,
    val targetGoal: String,
    val contextDepth: Int = 10,
    val facts: List<Fact> = emptyList(),           // 修改：从Map改为List
    val relationshipScore: Int = 50,               // 新增：关系分数 0-100
    val lastInteractionDate: String? = null        // 新增：最后互动日期
)
```

**数据库Entity**：
```kotlin
@Entity(tableName = "profiles")
data class ContactProfileEntity(
    @PrimaryKey
    @ColumnInfo(name = "id")
    val id: String,
    
    @ColumnInfo(name = "name")
    val name: String,
    
    @ColumnInfo(name = "target_goal")
    val targetGoal: String,
    
    @ColumnInfo(name = "context_depth")
    val contextDepth: Int = 10,
    
    @ColumnInfo(name = "facts_json")
    val factsJson: String = "[]",
    
    @ColumnInfo(name = "relationship_score")
    val relationshipScore: Int = 50,
    
    @ColumnInfo(name = "last_interaction_date")
    val lastInteractionDate: String? = null
)
```

### 5.3 ConversationLog（对话记录）

**Domain模型**：
```kotlin
data class ConversationLog(
    val id: Long = 0,
    val contactId: String,
    val userInput: String,
    val aiResponse: String?,
    val timestamp: Long,
    val isSummarized: Boolean = false
) {
    fun getDateString(): String {
        val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        return sdf.format(Date(timestamp))
    }
}
```

**数据库Entity**：
```kotlin
@Entity(
    tableName = "conversation_logs",
    foreignKeys = [
        ForeignKey(
            entity = ContactProfileEntity::class,
            parentColumns = ["id"],
            childColumns = ["contact_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["contact_id"]),
        Index(value = ["timestamp"]),
        Index(value = ["is_summarized"])
    ]
)
data class ConversationLogEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0,
    
    @ColumnInfo(name = "contact_id")
    val contactId: String,
    
    @ColumnInfo(name = "user_input")
    val userInput: String,
    
    @ColumnInfo(name = "ai_response")
    val aiResponse: String?,
    
    @ColumnInfo(name = "timestamp")
    val timestamp: Long,
    
    @ColumnInfo(name = "is_summarized")
    val isSummarized: Boolean = false
)
```

### 5.4 DailySummary（每日总结）

**Domain模型**：
```kotlin
data class DailySummary(
    val id: Long = 0,
    val contactId: String,
    val summaryDate: String,
    val content: String,
    val keyEvents: List<KeyEvent>,
    val newFacts: List<Fact>,
    val updatedTags: List<TagUpdate>,
    val relationshipScoreChange: Int,
    val relationshipTrend: RelationshipTrend
)

data class KeyEvent(
    val event: String,
    val importance: Int  // 1-10
)

data class TagUpdate(
    val action: String,  // "ADD" | "REMOVE"
    val type: String,    // "RISK_RED" | "STRATEGY_GREEN"
    val content: String
)

enum class RelationshipTrend {
    IMPROVING,   // 改善中
    STABLE,      // 稳定
    DECLINING    // 下降中
}
```

**数据库Entity**：
```kotlin
@Entity(
    tableName = "daily_summaries",
    foreignKeys = [
        ForeignKey(
            entity = ContactProfileEntity::class,
            parentColumns = ["id"],
            childColumns = ["contact_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["contact_id"]),
        Index(value = ["summary_date"]),
        Index(value = ["contact_id", "summary_date"], unique = true)
    ]
)
data class DailySummaryEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0,
    
    @ColumnInfo(name = "contact_id")
    val contactId: String,
    
    @ColumnInfo(name = "summary_date")
    val summaryDate: String,
    
    @ColumnInfo(name = "content")
    val content: String,
    
    @ColumnInfo(name = "key_events_json")
    val keyEventsJson: String,
    
    @ColumnInfo(name = "relationship_score")
    val relationshipScore: Int,
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long
)
```


## 6. API设计

### 6.1 ConversationRepository接口

```kotlin
/**
 * 对话记录仓库接口
 * 负责管理用户与联系人的对话记录
 */
interface ConversationRepository {
    
    /**
     * 保存用户输入
     * @param contactId 联系人ID
     * @param userInput 用户输入的聊天记录
     * @param timestamp 时间戳（毫秒）
     * @return 保存的对话记录ID
     * @throws DatabaseException 数据库操作失败
     */
    suspend fun saveUserInput(
        contactId: String,
        userInput: String,
        timestamp: Long = System.currentTimeMillis()
    ): Result<Long>
    
    /**
     * 更新AI回复
     * @param logId 对话记录ID
     * @param aiResponse AI的分析回复
     * @return 操作结果
     * @throws DatabaseException 数据库操作失败
     * @throws IllegalArgumentException logId不存在
     */
    suspend fun updateAiResponse(
        logId: Long,
        aiResponse: String
    ): Result<Unit>
    
    /**
     * 获取未总结的对话记录
     * @param sinceTimestamp 起始时间戳（只获取此时间之后的记录）
     * @return 未总结的对话记录列表
     */
    suspend fun getUnsummarizedLogs(
        sinceTimestamp: Long
    ): Result<List<ConversationLog>>
    
    /**
     * 获取指定联系人在指定日期的对话记录
     * @param contactId 联系人ID
     * @param date 日期字符串，格式"yyyy-MM-dd"
     * @return 对话记录列表
     */
    suspend fun getLogsByContactAndDate(
        contactId: String,
        date: String
    ): Result<List<ConversationLog>>
    
    /**
     * 标记对话为已总结
     * @param logIds 对话记录ID列表
     * @return 操作结果
     */
    suspend fun markAsSummarized(
        logIds: List<Long>
    ): Result<Unit>
    
    /**
     * 删除指定联系人的所有对话记录
     * @param contactId 联系人ID
     * @return 删除的记录数
     */
    suspend fun deleteByContactId(
        contactId: String
    ): Result<Int>
    
    /**
     * 清理过期的已总结对话
     * @param beforeTimestamp 此时间之前的已总结对话将被删除
     * @return 删除的记录数
     */
    suspend fun cleanupOldSummarizedLogs(
        beforeTimestamp: Long
    ): Result<Int>
}
```

### 6.2 ContactRepository扩展接口

```kotlin
/**
 * ContactRepository扩展方法
 * 用于支持记忆系统的联系人数据操作
 */
interface ContactRepository {
    // ... 现有方法 ...
    
    /**
     * 更新联系人的关系分数
     * @param contactId 联系人ID
     * @param newScore 新的关系分数（0-100）
     * @return 操作结果
     * @throws IllegalArgumentException 分数超出范围
     */
    suspend fun updateRelationshipScore(
        contactId: String,
        newScore: Int
    ): Result<Unit>
    
    /**
     * 更新联系人的Facts
     * @param contactId 联系人ID
     * @param facts 新的Facts列表
     * @return 操作结果
     */
    suspend fun updateFacts(
        contactId: String,
        facts: List<Fact>
    ): Result<Unit>
    
    /**
     * 添加单个Fact
     * @param contactId 联系人ID
     * @param fact 要添加的Fact
     * @return 操作结果
     */
    suspend fun addFact(
        contactId: String,
        fact: Fact
    ): Result<Unit>
    
    /**
     * 更新最后互动日期
     * @param contactId 联系人ID
     * @param date 日期字符串，格式"yyyy-MM-dd"
     * @return 操作结果
     */
    suspend fun updateLastInteractionDate(
        contactId: String,
        date: String
    ): Result<Unit>
    
    /**
     * 批量更新联系人数据（事务）
     * @param contactId 联系人ID
     * @param facts 新的Facts列表（可选）
     * @param relationshipScore 新的关系分数（可选）
     * @param lastInteractionDate 最后互动日期（可选）
     * @return 操作结果
     */
    suspend fun updateContactData(
        contactId: String,
        facts: List<Fact>? = null,
        relationshipScore: Int? = null,
        lastInteractionDate: String? = null
    ): Result<Unit>
}
```

### 6.3 DailySummaryRepository接口

```kotlin
/**
 * 每日总结仓库接口
 */
interface DailySummaryRepository {
    
    /**
     * 保存每日总结
     * @param summary 每日总结对象
     * @return 保存的总结ID
     */
    suspend fun saveSummary(
        summary: DailySummary
    ): Result<Long>
    
    /**
     * 获取指定联系人的所有总结
     * @param contactId 联系人ID
     * @return 总结列表，按日期倒序
     */
    suspend fun getSummariesByContact(
        contactId: String
    ): Result<List<DailySummary>>
    
    /**
     * 获取指定日期的总结
     * @param contactId 联系人ID
     * @param date 日期字符串
     * @return 总结对象，不存在则返回null
     */
    suspend fun getSummaryByDate(
        contactId: String,
        date: String
    ): Result<DailySummary?>
    
    /**
     * 检查指定日期是否已有总结
     * @param contactId 联系人ID
     * @param date 日期字符串
     * @return 是否存在
     */
    suspend fun hasSummaryForDate(
        contactId: String,
        date: String
    ): Result<Boolean>
}
```

### 6.4 DAO接口定义

```kotlin
@Dao
interface ConversationLogDao {
    
    @Insert
    suspend fun insert(log: ConversationLogEntity): Long
    
    @Query("UPDATE conversation_logs SET ai_response = :aiResponse WHERE id = :logId")
    suspend fun updateAiResponse(logId: Long, aiResponse: String)
    
    @Query("""
        SELECT * FROM conversation_logs 
        WHERE is_summarized = 0 AND timestamp >= :sinceTimestamp
        ORDER BY timestamp ASC
    """)
    suspend fun getUnsummarizedLogs(sinceTimestamp: Long): List<ConversationLogEntity>
    
    @Query("""
        SELECT * FROM conversation_logs 
        WHERE contact_id = :contactId 
        AND date(timestamp/1000, 'unixepoch', 'localtime') = :date
        ORDER BY timestamp ASC
    """)
    suspend fun getLogsByContactAndDate(contactId: String, date: String): List<ConversationLogEntity>
    
    @Query("UPDATE conversation_logs SET is_summarized = 1 WHERE id IN (:logIds)")
    suspend fun markAsSummarized(logIds: List<Long>)
    
    @Query("DELETE FROM conversation_logs WHERE contact_id = :contactId")
    suspend fun deleteByContactId(contactId: String): Int
    
    @Query("DELETE FROM conversation_logs WHERE is_summarized = 1 AND timestamp < :beforeTimestamp")
    suspend fun cleanupOldSummarizedLogs(beforeTimestamp: Long): Int
}

@Dao
interface DailySummaryDao {
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(summary: DailySummaryEntity): Long
    
    @Query("SELECT * FROM daily_summaries WHERE contact_id = :contactId ORDER BY summary_date DESC")
    suspend fun getSummariesByContact(contactId: String): List<DailySummaryEntity>
    
    @Query("SELECT * FROM daily_summaries WHERE contact_id = :contactId AND summary_date = :date")
    suspend fun getSummaryByDate(contactId: String, date: String): DailySummaryEntity?
    
    @Query("SELECT EXISTS(SELECT 1 FROM daily_summaries WHERE contact_id = :contactId AND summary_date = :date)")
    suspend fun hasSummaryForDate(contactId: String, date: String): Boolean
}
```


## 7. 核心组件详细设计

### 7.1 ContextBuilder详细设计

**职责**：智能构建AI分析所需的上下文，筛选相关信息避免过载

```kotlin
/**
 * 上下文构建器
 * 负责从联系人数据中筛选相关信息，构建AI分析所需的上下文
 */
@Singleton
class ContextBuilder @Inject constructor() {
    
    companion object {
        const val MAX_FACTS_COUNT = 20
        const val RECENT_DAYS = 7
        const val MEDIUM_DAYS = 30
    }
    
    /**
     * 构建分析上下文
     * @param contact 联系人信息
     * @param tags 联系人标签列表
     * @param userInput 用户输入的聊天记录
     * @return 构建好的Prompt字符串
     */
    fun buildAnalysisContext(
        contact: ContactProfile,
        tags: List<BrainTag>,
        userInput: String
    ): String {
        val sb = StringBuilder()
        
        // 1. 基本信息（必选）
        sb.appendLine("【联系人信息】")
        sb.appendLine("姓名：${contact.name}")
        sb.appendLine("目标：${contact.targetGoal}")
        sb.appendLine("关系分数：${contact.relationshipScore}/100")
        sb.appendLine()
        
        // 2. 雷区标签（必选）
        val riskTags = tags.filter { it.type == TagType.RISK_RED }
        if (riskTags.isNotEmpty()) {
            sb.appendLine("【雷区标签】")
            riskTags.forEach { sb.appendLine("- ${it.content}") }
            sb.appendLine()
        }
        
        // 3. 策略标签（必选）
        val strategyTags = tags.filter { it.type == TagType.STRATEGY_GREEN }
        if (strategyTags.isNotEmpty()) {
            sb.appendLine("【策略标签】")
            strategyTags.forEach { sb.appendLine("- ${it.content}") }
            sb.appendLine()
        }
        
        // 4. 筛选后的Facts
        val relevantFacts = selectRelevantFacts(contact.facts)
        if (relevantFacts.isNotEmpty()) {
            sb.appendLine("【已知事实】")
            relevantFacts.forEach { fact ->
                val dateStr = formatDate(fact.timestamp)
                val sourceStr = if (fact.source == FactSource.MANUAL) "手动" else "AI推断"
                sb.appendLine("- ${fact.key}：${fact.value} ($dateStr, $sourceStr)")
            }
            sb.appendLine()
        }
        
        // 5. 用户输入
        sb.appendLine("【用户提供的聊天记录】")
        sb.appendLine(userInput)
        
        return sb.toString()
    }
    
    /**
     * 筛选相关Facts
     * 
     * 筛选规则：
     * 1. 最近7天：全部保留
     * 2. 7-30天：只保留MANUAL来源
     * 3. 30天以上：只保留MANUAL来源
     * 4. 按时间倒序排序
     * 5. 最多保留20条
     */
    fun selectRelevantFacts(facts: List<Fact>): List<Fact> {
        val now = System.currentTimeMillis()
        val sevenDaysAgo = now - RECENT_DAYS * 24 * 60 * 60 * 1000L
        val thirtyDaysAgo = now - MEDIUM_DAYS * 24 * 60 * 60 * 1000L
        
        // 分层筛选
        val recentFacts = facts.filter { it.timestamp >= sevenDaysAgo }
        val mediumFacts = facts.filter { 
            it.timestamp < sevenDaysAgo && 
            it.timestamp >= thirtyDaysAgo &&
            it.source == FactSource.MANUAL
        }
        val oldFacts = facts.filter { 
            it.timestamp < thirtyDaysAgo &&
            it.source == FactSource.MANUAL
        }
        
        // 合并并限制数量
        return (recentFacts + mediumFacts + oldFacts)
            .sortedByDescending { it.timestamp }
            .take(MAX_FACTS_COUNT)
    }
    
    private fun formatDate(timestamp: Long): String {
        val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        return sdf.format(Date(timestamp))
    }
}
```


### 7.2 SummarizeDailyConversationsUseCase详细设计

**职责**：执行每日总结流程，更新联系人画像数据

```kotlin
/**
 * 每日对话总结用例
 * 在新一天首次打开App时执行，总结昨日对话并更新联系人数据
 */
class SummarizeDailyConversationsUseCase @Inject constructor(
    private val conversationRepository: ConversationRepository,
    private val contactRepository: ContactRepository,
    private val brainTagRepository: BrainTagRepository,
    private val dailySummaryRepository: DailySummaryRepository,
    private val aiRepository: AiRepository,
    private val memoryPreferences: MemoryPreferences
) {
    companion object {
        const val MAX_RETRY_DAYS = 7
        const val MAX_AI_RETRIES = 3
    }
    
    /**
     * 执行每日总结
     * @return 总结结果，包含成功和失败的联系人数量
     */
    suspend operator fun invoke(): Result<SummaryResult> {
        return withContext(Dispatchers.IO) {
            try {
                // 1. 检查是否需要执行
                val lastSummaryDate = memoryPreferences.getLastSummaryDate()
                val today = getCurrentDateString()
                
                if (lastSummaryDate == today) {
                    return@withContext Result.success(SummaryResult(skipped = true))
                }
                
                // 2. 获取未总结的对话（最多7天前）
                val sevenDaysAgo = System.currentTimeMillis() - MAX_RETRY_DAYS * 24 * 60 * 60 * 1000L
                val unsummarizedLogs = conversationRepository
                    .getUnsummarizedLogs(sevenDaysAgo)
                    .getOrThrow()
                
                if (unsummarizedLogs.isEmpty()) {
                    memoryPreferences.setLastSummaryDate(today)
                    return@withContext Result.success(SummaryResult(noData = true))
                }
                
                // 3. 按联系人和日期分组
                val groupedLogs = unsummarizedLogs
                    .groupBy { it.contactId }
                    .flatMap { (contactId, logs) ->
                        logs.groupBy { it.getDateString() }
                            .map { (date, dateLogs) -> Triple(contactId, date, dateLogs) }
                    }
                
                // 4. 对每组执行总结
                var successCount = 0
                var failedCount = 0
                var usedFallback = false
                
                groupedLogs.forEach { (contactId, date, logs) ->
                    try {
                        val result = summarizeForContact(contactId, logs, date)
                        if (result.usedFallback) usedFallback = true
                        successCount++
                    } catch (e: Exception) {
                        Log.e("DailySummary", "Failed for $contactId on $date", e)
                        failedCount++
                    }
                }
                
                // 5. 更新最后总结日期
                memoryPreferences.setLastSummaryDate(today)
                
                Result.success(SummaryResult(
                    successCount = successCount,
                    failedCount = failedCount,
                    usedFallback = usedFallback
                ))
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
    
    /**
     * 为单个联系人执行总结
     */
    private suspend fun summarizeForContact(
        contactId: String,
        logs: List<ConversationLog>,
        date: String
    ): SummarizeResult {
        // 1. 获取联系人当前状态
        val contact = contactRepository.getProfile(contactId).getOrThrow()
        val tags = brainTagRepository.getTagsByContact(contactId).getOrThrow()
        
        // 2. 尝试AI总结
        var summary: DailySummary? = null
        var usedFallback = false
        var retryCount = 0
        
        while (summary == null && retryCount < MAX_AI_RETRIES) {
            try {
                summary = generateAiSummary(contact, tags, logs, date)
            } catch (e: Exception) {
                retryCount++
                if (retryCount >= MAX_AI_RETRIES) {
                    // 使用降级方案
                    summary = fallbackSummary(contactId, logs, date)
                    usedFallback = true
                } else {
                    delay(1000L * retryCount) // 指数退避
                }
            }
        }
        
        // 3. 更新数据
        updateContactData(contactId, summary!!, logs)
        
        return SummarizeResult(usedFallback = usedFallback)
    }
    
    /**
     * 生成AI总结
     */
    private suspend fun generateAiSummary(
        contact: ContactProfile,
        tags: List<BrainTag>,
        logs: List<ConversationLog>,
        date: String
    ): DailySummary {
        val prompt = buildSummaryPrompt(contact, tags, logs, date)
        val response = aiRepository.generateSummary(prompt).getOrThrow()
        return parseSummaryResponse(contact.id, date, response)
    }
    
    /**
     * 降级方案：本地统计
     */
    private fun fallbackSummary(
        contactId: String,
        logs: List<ConversationLog>,
        date: String
    ): DailySummary {
        val summary = "昨日共${logs.size}次互动（AI总结暂时不可用）"
        
        val keyEvents = logs.map { log ->
            KeyEvent(
                event = "互动记录",
                importance = (log.userInput.length / 100).coerceIn(1, 5)
            )
        }.take(3)
        
        val scoreChange = when {
            logs.size >= 3 -> +2
            logs.size == 2 -> +1
            else -> 0
        }
        
        return DailySummary(
            contactId = contactId,
            summaryDate = date,
            content = summary,
            keyEvents = keyEvents,
            newFacts = emptyList(),
            updatedTags = emptyList(),
            relationshipScoreChange = scoreChange,
            relationshipTrend = RelationshipTrend.STABLE
        )
    }
    
    /**
     * 更新联系人数据（事务）
     */
    private suspend fun updateContactData(
        contactId: String,
        summary: DailySummary,
        logs: List<ConversationLog>
    ) {
        // 1. 获取当前联系人数据
        val contact = contactRepository.getProfile(contactId).getOrThrow()
        
        // 2. 合并Facts
        val updatedFacts = mergeFacts(contact.facts, summary.newFacts)
        
        // 3. 计算新分数
        val newScore = (contact.relationshipScore + summary.relationshipScoreChange)
            .coerceIn(0, 100)
        
        // 4. 批量更新联系人数据
        contactRepository.updateContactData(
            contactId = contactId,
            facts = updatedFacts,
            relationshipScore = newScore,
            lastInteractionDate = summary.summaryDate
        )
        
        // 5. 更新标签
        summary.updatedTags.forEach { tagUpdate ->
            when (tagUpdate.action) {
                "ADD" -> {
                    val tagType = if (tagUpdate.type == "RISK_RED") 
                        TagType.RISK_RED else TagType.STRATEGY_GREEN
                    brainTagRepository.addTag(
                        BrainTag(
                            contactId = contactId,
                            type = tagType,
                            content = tagUpdate.content,
                            source = TagSource.AI_INFERRED
                        )
                    )
                }
                "REMOVE" -> {
                    brainTagRepository.removeTagByContent(contactId, tagUpdate.content)
                }
            }
        }
        
        // 6. 保存每日总结
        dailySummaryRepository.saveSummary(summary)
        
        // 7. 标记对话为已总结
        conversationRepository.markAsSummarized(logs.map { it.id })
    }
    
    /**
     * 合并Facts，处理重复key
     */
    private fun mergeFacts(existing: List<Fact>, newFacts: List<Fact>): List<Fact> {
        val factMap = existing.associateBy { it.key }.toMutableMap()
        
        newFacts.forEach { newFact ->
            val existingFact = factMap[newFact.key]
            if (existingFact == null || newFact.timestamp > existingFact.timestamp) {
                factMap[newFact.key] = newFact
            }
        }
        
        return factMap.values.toList()
    }
}

data class SummaryResult(
    val skipped: Boolean = false,
    val noData: Boolean = false,
    val successCount: Int = 0,
    val failedCount: Int = 0,
    val usedFallback: Boolean = false
)

data class SummarizeResult(
    val usedFallback: Boolean = false
)
```


## 8. 错误处理设计

### 8.1 错误处理流程图

#### 8.1.1 AI调用错误处理流程

```
┌─────────────────────────────────────────────────────────────┐
│                    AI调用错误处理流程                        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │   发起AI请求    │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │   请求成功？    │
                    └────────┬────────┘
                             │
              ┌──────────────┼──────────────┐
              │ 是           │              │ 否
              ▼              │              ▼
    ┌─────────────────┐      │    ┌─────────────────┐
    │   解析响应      │      │    │   识别错误类型  │
    └────────┬────────┘      │    └────────┬────────┘
             │               │             │
             ▼               │             ▼
    ┌─────────────────┐      │    ┌─────────────────────────────┐
    │   解析成功？    │      │    │ 网络错误/超时/5xx → 重试    │
    └────────┬────────┘      │    │ 401 → 提示配置API密钥       │
             │               │    │ 429 → 直接降级              │
    ┌────────┼────────┐      │    │ JSON解析失败 → 重试         │
    │ 是     │        │ 否   │    └────────────┬────────────────┘
    ▼        │        ▼      │                 │
┌───────┐    │   ┌───────┐   │                 ▼
│ 返回  │    │   │ 重试  │   │       ┌─────────────────┐
│ 结果  │    │   │ 解析  │   │       │   重试次数<3?   │
└───────┘    │   └───┬───┘   │       └────────┬────────┘
             │       │       │                │
             │       ▼       │       ┌────────┼────────┐
             │  ┌─────────┐  │       │ 是     │        │ 否
             │  │重试<3?  │  │       ▼        │        ▼
             │  └────┬────┘  │  ┌─────────┐   │   ┌─────────┐
             │       │       │  │ 等待后  │   │   │ 启用    │
             │  ┌────┼────┐  │  │ 重试    │   │   │ 降级    │
             │  │是  │    │否│  └────┬────┘   │   │ 方案    │
             │  ▼    │    ▼  │       │        │   └────┬────┘
             │ 重试  │  降级 │       └────────┘        │
             │       │       │                         ▼
             │       │       │                   ┌─────────┐
             │       │       │                   │ 本地    │
             │       │       │                   │ 统计    │
             │       │       │                   └─────────┘
             └───────┴───────┘
```

#### 8.1.2 数据更新错误处理流程

```
┌─────────────────────────────────────────────────────────────┐
│                    数据更新错误处理流程                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │   开始事务      │
                    └────────┬────────┘
                             │
              ┌──────────────┼──────────────┐
              │              │              │
              ▼              ▼              ▼
    ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
    │ 更新Facts   │  │ 更新标签    │  │ 更新分数    │
    └──────┬──────┘  └──────┬──────┘  └──────┬──────┘
           │                │                │
           └────────────────┼────────────────┘
                            │
                            ▼
                   ┌─────────────────┐
                   │   全部成功？    │
                   └────────┬────────┘
                            │
              ┌─────────────┼─────────────┐
              │ 是          │             │ 否
              ▼             │             ▼
    ┌─────────────────┐     │    ┌─────────────────┐
    │   提交事务      │     │    │   回滚事务      │
    └────────┬────────┘     │    └────────┬────────┘
             │              │             │
             ▼              │             ▼
    ┌─────────────────┐     │    ┌─────────────────┐
    │ 标记对话已总结  │     │    │ 保留未总结状态  │
    └────────┬────────┘     │    └────────┬────────┘
             │              │             │
             ▼              │             ▼
    ┌─────────────────┐     │    ┌─────────────────┐
    │   完成         │     │    │ 记录错误日志    │
    └─────────────────┘     │    └────────┬────────┘
                            │             │
                            │             ▼
                            │    ┌─────────────────┐
                            │    │ 下次继续尝试    │
                            │    └─────────────────┘
                            │
                            └─────────────────────────
```

### 8.2 错误类型和处理策略

| 错误类型 | 检测方式 | 重试次数 | 重试间隔 | 降级方案 |
|---------|---------|---------|---------|---------|
| 网络错误 | IOException | 3次 | 1s, 2s, 4s | 本地统计 |
| API额度用完 | HTTP 429 | 0次 | - | 本地统计 |
| API密钥无效 | HTTP 401 | 0次 | - | 提示配置 |
| 响应超时 | TimeoutException | 1次 | 5s | 本地统计 |
| JSON解析失败 | JsonException | 3次 | 1s | 本地统计 |
| 服务不可用 | HTTP 5xx | 3次 | 2s, 4s, 8s | 本地统计 |
| 数据库错误 | SQLiteException | 1次 | 100ms | 保留状态 |

### 8.3 重试策略实现

```kotlin
/**
 * 重试策略配置
 */
object RetryPolicy {
    const val MAX_RETRIES = 3
    const val INITIAL_DELAY_MS = 1000L
    const val MAX_DELAY_MS = 10000L
    const val MULTIPLIER = 2.0
    
    /**
     * 计算重试延迟（指数退避）
     */
    fun calculateDelay(retryCount: Int): Long {
        val delay = INITIAL_DELAY_MS * MULTIPLIER.pow(retryCount.toDouble())
        return delay.toLong().coerceAtMost(MAX_DELAY_MS)
    }
    
    /**
     * 判断是否应该重试
     */
    fun shouldRetry(error: Throwable, retryCount: Int): Boolean {
        if (retryCount >= MAX_RETRIES) return false
        
        return when (error) {
            is IOException -> true
            is SocketTimeoutException -> true
            is HttpException -> error.code() in listOf(500, 502, 503, 504)
            is JsonDataException -> true
            else -> false
        }
    }
    
    /**
     * 判断是否应该直接降级（不重试）
     */
    fun shouldFallbackImmediately(error: Throwable): Boolean {
        return when (error) {
            is HttpException -> error.code() in listOf(401, 429)
            else -> false
        }
    }
}

/**
 * 带重试的执行器
 */
suspend fun <T> executeWithRetry(
    block: suspend () -> T,
    onRetry: (Int, Throwable) -> Unit = { _, _ -> }
): Result<T> {
    var lastError: Throwable? = null
    var retryCount = 0
    
    while (retryCount <= RetryPolicy.MAX_RETRIES) {
        try {
            return Result.success(block())
        } catch (e: Throwable) {
            lastError = e
            
            if (RetryPolicy.shouldFallbackImmediately(e)) {
                break
            }
            
            if (!RetryPolicy.shouldRetry(e, retryCount)) {
                break
            }
            
            onRetry(retryCount, e)
            delay(RetryPolicy.calculateDelay(retryCount))
            retryCount++
        }
    }
    
    return Result.failure(lastError ?: Exception("Unknown error"))
}
```

### 8.4 错误恢复机制

```kotlin
/**
 * 错误恢复管理器
 */
@Singleton
class ErrorRecoveryManager @Inject constructor(
    private val memoryPreferences: MemoryPreferences
) {
    /**
     * 记录失败的总结任务
     */
    suspend fun recordFailedSummary(contactId: String, date: String, error: Throwable) {
        val failedTasks = memoryPreferences.getFailedSummaryTasks().toMutableList()
        failedTasks.add(FailedSummaryTask(contactId, date, System.currentTimeMillis(), error.message))
        memoryPreferences.setFailedSummaryTasks(failedTasks)
    }
    
    /**
     * 获取待重试的任务
     */
    suspend fun getPendingRetryTasks(): List<FailedSummaryTask> {
        val sevenDaysAgo = System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000L
        return memoryPreferences.getFailedSummaryTasks()
            .filter { it.timestamp >= sevenDaysAgo }
    }
    
    /**
     * 清理过期的失败任务
     */
    suspend fun cleanupExpiredTasks() {
        val sevenDaysAgo = System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000L
        val validTasks = memoryPreferences.getFailedSummaryTasks()
            .filter { it.timestamp >= sevenDaysAgo }
        memoryPreferences.setFailedSummaryTasks(validTasks)
    }
    
    /**
     * 标记任务成功
     */
    suspend fun markTaskSuccess(contactId: String, date: String) {
        val tasks = memoryPreferences.getFailedSummaryTasks()
            .filterNot { it.contactId == contactId && it.date == date }
        memoryPreferences.setFailedSummaryTasks(tasks)
    }
}

data class FailedSummaryTask(
    val contactId: String,
    val date: String,
    val timestamp: Long,
    val errorMessage: String?
)
```


## 9. 性能设计

### 9.1 性能指标

| 操作 | 目标时间 | 说明 |
|------|---------|------|
| 对话记录保存 | < 100ms | 不阻塞UI |
| 上下文构建 | < 200ms | 包含数据库查询 |
| 每日总结（单个联系人） | < 10s | 后台执行 |
| 每日总结（全部） | < 30s | 后台执行 |
| Facts列表加载 | < 50ms | 使用Flow |
| 关系分数更新 | < 50ms | 单字段更新 |

### 9.2 性能测试方案

#### 9.2.1 测试环境

| 项目 | 规格 |
|------|------|
| 测试设备 | Android模拟器 / 中端真机 |
| Android版本 | API 24 (最低) / API 34 (最新) |
| 内存 | 2GB RAM |
| 存储 | 内部存储 |
| 网络 | WiFi / 4G模拟 |

#### 9.2.2 测试数据准备

```kotlin
object TestDataGenerator {
    /**
     * 生成测试联系人数据
     */
    fun generateContacts(count: Int): List<ContactProfile> {
        return (1..count).map { i ->
            ContactProfile(
                id = "contact_$i",
                name = "测试联系人$i",
                targetGoal = "测试目标$i",
                facts = generateFacts(Random.nextInt(10, 50)),
                relationshipScore = Random.nextInt(0, 100)
            )
        }
    }
    
    /**
     * 生成测试Facts
     */
    fun generateFacts(count: Int): List<Fact> {
        val keys = listOf("性格特点", "兴趣爱好", "工作情况", "家庭情况", "自定义字段")
        return (1..count).map { i ->
            Fact(
                key = "${keys.random()}$i",
                value = "测试值" + "x".repeat(Random.nextInt(10, 100)),
                timestamp = System.currentTimeMillis() - Random.nextLong(0, 60 * 24 * 60 * 60 * 1000L),
                source = if (Random.nextBoolean()) FactSource.MANUAL else FactSource.AI_INFERRED
            )
        }
    }
    
    /**
     * 生成测试对话记录
     */
    fun generateConversationLogs(contactId: String, count: Int): List<ConversationLog> {
        return (1..count).map { i ->
            ConversationLog(
                contactId = contactId,
                userInput = "测试用户输入" + "x".repeat(Random.nextInt(100, 500)),
                aiResponse = "测试AI回复" + "x".repeat(Random.nextInt(200, 1000)),
                timestamp = System.currentTimeMillis() - Random.nextLong(0, 7 * 24 * 60 * 60 * 1000L),
                isSummarized = false
            )
        }
    }
}
```

#### 9.2.3 测试用例

```kotlin
@RunWith(AndroidJUnit4::class)
class PerformanceTest {
    
    @get:Rule
    val benchmarkRule = BenchmarkRule()
    
    /**
     * 测试对话记录保存性能
     * 基准：< 100ms
     */
    @Test
    fun testConversationLogSavePerformance() {
        benchmarkRule.measureRepeated {
            runBlocking {
                val log = ConversationLog(
                    contactId = "test_contact",
                    userInput = "x".repeat(500),
                    aiResponse = null,
                    timestamp = System.currentTimeMillis()
                )
                
                val startTime = System.currentTimeMillis()
                conversationRepository.saveUserInput(
                    log.contactId, log.userInput, log.timestamp
                )
                val duration = System.currentTimeMillis() - startTime
                
                assertTrue("保存耗时: ${duration}ms", duration < 100)
            }
        }
    }
    
    /**
     * 测试上下文构建性能
     * 基准：< 200ms
     */
    @Test
    fun testContextBuildPerformance() {
        // 准备数据：50条Facts
        val contact = TestDataGenerator.generateContacts(1).first()
            .copy(facts = TestDataGenerator.generateFacts(50))
        val tags = (1..20).map { 
            BrainTag(contactId = contact.id, type = TagType.RISK_RED, content = "标签$it")
        }
        
        benchmarkRule.measureRepeated {
            val startTime = System.currentTimeMillis()
            val context = contextBuilder.buildAnalysisContext(
                contact, tags, "测试用户输入"
            )
            val duration = System.currentTimeMillis() - startTime
            
            assertTrue("构建耗时: ${duration}ms", duration < 200)
            assertTrue("上下文不为空", context.isNotBlank())
        }
    }
    
    /**
     * 测试每日总结性能（单个联系人）
     * 基准：< 10s
     */
    @Test
    fun testSingleContactSummaryPerformance() {
        // 准备数据：10条对话记录
        val contactId = "test_contact"
        val logs = TestDataGenerator.generateConversationLogs(contactId, 10)
        
        runBlocking {
            logs.forEach { log ->
                conversationRepository.saveUserInput(log.contactId, log.userInput, log.timestamp)
            }
            
            val startTime = System.currentTimeMillis()
            // 模拟AI调用（使用mock）
            val result = summarizeUseCase.summarizeForContact(contactId, logs, "2025-12-14")
            val duration = System.currentTimeMillis() - startTime
            
            assertTrue("总结耗时: ${duration}ms", duration < 10000)
        }
    }
    
    /**
     * 测试批量总结性能
     * 基准：< 30s（10个联系人）
     */
    @Test
    fun testBatchSummaryPerformance() {
        // 准备数据：10个联系人，每个5条对话
        val contacts = TestDataGenerator.generateContacts(10)
        
        runBlocking {
            contacts.forEach { contact ->
                contactRepository.insertProfile(contact)
                val logs = TestDataGenerator.generateConversationLogs(contact.id, 5)
                logs.forEach { log ->
                    conversationRepository.saveUserInput(log.contactId, log.userInput, log.timestamp)
                }
            }
            
            val startTime = System.currentTimeMillis()
            val result = summarizeUseCase()
            val duration = System.currentTimeMillis() - startTime
            
            assertTrue("批量总结耗时: ${duration}ms", duration < 30000)
        }
    }
    
    /**
     * 测试Facts筛选性能
     * 基准：< 50ms（100条Facts）
     */
    @Test
    fun testFactsFilterPerformance() {
        val facts = TestDataGenerator.generateFacts(100)
        
        benchmarkRule.measureRepeated {
            val startTime = System.currentTimeMillis()
            val filtered = contextBuilder.selectRelevantFacts(facts)
            val duration = System.currentTimeMillis() - startTime
            
            assertTrue("筛选耗时: ${duration}ms", duration < 50)
            assertTrue("筛选结果不超过20条", filtered.size <= 20)
        }
    }
}
```

#### 9.2.4 性能基准和验收标准

| 测试项 | 数据规模 | 基准时间 | 验收标准 |
|--------|---------|---------|---------|
| 对话保存 | 单条500字 | < 100ms | 95%请求达标 |
| 上下文构建 | 50条Facts + 20标签 | < 200ms | 95%请求达标 |
| Facts筛选 | 100条Facts | < 50ms | 99%请求达标 |
| 单联系人总结 | 10条对话 | < 10s | 90%请求达标 |
| 批量总结 | 10联系人×5对话 | < 30s | 90%请求达标 |
| 内存占用 | 总结过程 | < 100MB | 峰值不超标 |

### 9.3 优化策略

#### 9.3.1 数据库优化

```kotlin
// 1. 使用索引优化查询
@Query("""
    SELECT * FROM conversation_logs 
    WHERE contact_id = :contactId 
    AND is_summarized = 0
    ORDER BY timestamp ASC
""")
suspend fun getUnsummarizedByContact(contactId: String): List<ConversationLogEntity>

// 2. 批量操作使用事务
@Transaction
suspend fun batchUpdateSummarized(logIds: List<Long>) {
    logIds.chunked(100).forEach { chunk ->
        markAsSummarized(chunk)
    }
}

// 3. 使用Flow实现响应式查询
@Query("SELECT * FROM profiles WHERE id = :contactId")
fun observeProfile(contactId: String): Flow<ContactProfileEntity?>
```

#### 9.3.2 内存优化

```kotlin
// 1. 分页加载对话记录
suspend fun getLogsPaged(
    contactId: String,
    pageSize: Int = 20,
    offset: Int = 0
): List<ConversationLog>

// 2. 及时释放大对象
suspend fun processLargeSummary(logs: List<ConversationLog>) {
    logs.chunked(10).forEach { chunk ->
        processBatch(chunk)
        // 允许GC回收
        System.gc()
    }
}

// 3. 使用WeakReference缓存
private val contextCache = WeakHashMap<String, String>()
```

#### 9.3.3 网络优化

```kotlin
// 1. 压缩Prompt长度
fun compressPrompt(prompt: String, maxLength: Int = 4000): String {
    if (prompt.length <= maxLength) return prompt
    // 智能截断，保留关键信息
    return truncateIntelligently(prompt, maxLength)
}

// 2. 使用连接池
val okHttpClient = OkHttpClient.Builder()
    .connectionPool(ConnectionPool(5, 5, TimeUnit.MINUTES))
    .build()

// 3. 批量处理减少请求次数
suspend fun batchSummarize(contacts: List<String>): Map<String, DailySummary> {
    // 合并多个联系人的总结请求
}
```


## 10. 页面设计

### 10.1 联系人详情页增强

**关系分数展示区域**：
```
┌─────────────────────────────────────────────────────────────┐
│ 王总                                                        │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 关系分数                                             │   │
│  │ 65/100                                              │   │
│  │ ████████████████████░░░░░░░░░░                      │   │
│  │ 最后互动：2025-12-13          趋势：改善中 ↗        │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 已知事实                                             │   │
│  │ ┌─────────────────────────────────────────────────┐ │   │
│  │ │ 性格特点                              2025-12-10 │ │   │
│  │ │ 急性子但讨厌被push                      手动添加 │ │   │
│  │ └─────────────────────────────────────────────────┘ │   │
│  │ ┌─────────────────────────────────────────────────┐ │   │
│  │ │ 兴趣爱好                              2025-12-08 │ │   │
│  │ │ 钓鱼                                    AI推断  │ │   │
│  │ └─────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 标签                                                 │   │
│  │ [🔴 不要提前妻] [🟢 多聊工作话题]                    │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 10.2 关系分数组件设计

```kotlin
@Composable
fun RelationshipScoreSection(
    score: Int,                        // 0-100
    lastInteractionDate: String?,      // "2025-12-13"
    trend: RelationshipTrend?,         // IMPROVING/STABLE/DECLINING
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant
        )
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                text = "关系分数",
                style = MaterialTheme.typography.titleSmall
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(
                    text = "$score/100",
                    style = MaterialTheme.typography.headlineMedium,
                    fontWeight = FontWeight.Bold
                )
                
                Spacer(modifier = Modifier.width(16.dp))
                
                // 趋势图标
                trend?.let {
                    TrendIcon(trend = it)
                }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // 进度条
            LinearProgressIndicator(
                progress = score / 100f,
                modifier = Modifier
                    .fillMaxWidth()
                    .height(8.dp)
                    .clip(RoundedCornerShape(4.dp)),
                color = getScoreColor(score),
                trackColor = MaterialTheme.colorScheme.surfaceVariant
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // 最后互动日期
            lastInteractionDate?.let {
                Text(
                    text = "最后互动：$it",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

@Composable
private fun getScoreColor(score: Int): Color {
    return when {
        score <= 30 -> MaterialTheme.colorScheme.error
        score <= 60 -> MaterialTheme.colorScheme.tertiary
        else -> MaterialTheme.colorScheme.primary
    }
}

@Composable
private fun TrendIcon(trend: RelationshipTrend) {
    val (icon, color, text) = when (trend) {
        RelationshipTrend.IMPROVING -> Triple(
            Icons.Default.TrendingUp,
            Color(0xFF4CAF50),
            "改善中"
        )
        RelationshipTrend.STABLE -> Triple(
            Icons.Default.TrendingFlat,
            MaterialTheme.colorScheme.primary,
            "稳定"
        )
        RelationshipTrend.DECLINING -> Triple(
            Icons.Default.TrendingDown,
            MaterialTheme.colorScheme.error,
            "下降中"
        )
    }
    
    Row(verticalAlignment = Alignment.CenterVertically) {
        Icon(
            imageVector = icon,
            contentDescription = text,
            tint = color,
            modifier = Modifier.size(20.dp)
        )
        Spacer(modifier = Modifier.width(4.dp))
        Text(
            text = text,
            style = MaterialTheme.typography.bodySmall,
            color = color
        )
    }
}
```

### 10.3 Facts列表组件设计

```kotlin
@Composable
fun FactItem(
    fact: Fact,
    modifier: Modifier = Modifier
) {
    Surface(
        modifier = modifier.fillMaxWidth(),
        color = MaterialTheme.colorScheme.surfaceVariant,
        shape = RoundedCornerShape(8.dp)
    ) {
        Column(modifier = Modifier.padding(12.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = fact.key,
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Medium
                )
                Text(
                    text = formatDate(fact.timestamp),
                    style = MaterialTheme.typography.labelSmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            
            Spacer(modifier = Modifier.height(4.dp))
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = fact.value,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.weight(1f)
                )
                
                Text(
                    text = if (fact.source == FactSource.MANUAL) "手动添加" else "AI推断",
                    style = MaterialTheme.typography.labelSmall,
                    color = if (fact.source == FactSource.MANUAL)
                        MaterialTheme.colorScheme.onSurfaceVariant
                    else
                        MaterialTheme.colorScheme.primary
                )
            }
        }
    }
}
```


## 11. 状态管理设计

### 11.1 ContactDetailUiState扩展

```kotlin
data class ContactDetailUiState(
    // 现有字段
    val isLoading: Boolean = false,
    val error: String? = null,
    val contact: ContactProfile? = null,
    val tags: List<BrainTag> = emptyList(),
    
    // 新增字段
    val relationshipScore: Int = 50,
    val lastInteractionDate: String? = null,
    val relationshipTrend: RelationshipTrend? = null,
    val facts: List<Fact> = emptyList(),
    
    // UI交互状态
    val showAddFactDialog: Boolean = false,
    val showEditFactDialog: Boolean = false,
    val selectedFact: Fact? = null
)
```

### 11.2 ChatUiState扩展

```kotlin
data class ChatUiState(
    // 现有字段
    val isLoading: Boolean = false,
    val error: String? = null,
    val contact: ContactProfile? = null,
    val messages: List<ChatMessage> = emptyList(),
    val analysisResult: AnalysisResult? = null,
    
    // 新增字段
    val isSavingConversation: Boolean = false,
    val conversationSaved: Boolean = false,
    
    // 上下文信息（用于调试）
    val contextFactsCount: Int = 0,
    val contextTagsCount: Int = 0
)
```

### 11.3 每日总结状态

```kotlin
// 在Application级别管理
data class DailySummaryState(
    val isRunning: Boolean = false,
    val lastSummaryDate: String? = null,
    val pendingContacts: Int = 0,
    val completedContacts: Int = 0,
    val failedContacts: Int = 0,
    val usedFallback: Boolean = false
)
```

## 12. 测试设计

### 12.1 单元测试

**ContextBuilder测试**：
```kotlin
class ContextBuilderTest {
    private lateinit var contextBuilder: ContextBuilder
    
    @Before
    fun setup() {
        contextBuilder = ContextBuilder()
    }
    
    @Test
    fun `筛选facts时优先保留最近7天的`() {
        // Given
        val now = System.currentTimeMillis()
        val facts = listOf(
            Fact("key1", "value1", now - 1 * 24 * 60 * 60 * 1000L, FactSource.MANUAL),
            Fact("key2", "value2", now - 10 * 24 * 60 * 60 * 1000L, FactSource.MANUAL),
            Fact("key3", "value3", now - 40 * 24 * 60 * 60 * 1000L, FactSource.MANUAL)
        )
        
        // When
        val result = contextBuilder.selectRelevantFacts(facts)
        
        // Then
        assertEquals(3, result.size)
        assertEquals("key1", result[0].key)
    }
    
    @Test
    fun `筛选facts时7-30天只保留手动添加的`() {
        // Given
        val now = System.currentTimeMillis()
        val facts = listOf(
            Fact("key1", "value1", now - 10 * 24 * 60 * 60 * 1000L, FactSource.MANUAL),
            Fact("key2", "value2", now - 10 * 24 * 60 * 60 * 1000L, FactSource.AI_INFERRED)
        )
        
        // When
        val result = contextBuilder.selectRelevantFacts(facts)
        
        // Then
        assertEquals(1, result.size)
        assertEquals("key1", result[0].key)
    }
    
    @Test
    fun `筛选facts时最多保留20条`() {
        // Given
        val facts = (1..30).map {
            Fact("key$it", "value$it", System.currentTimeMillis(), FactSource.MANUAL)
        }
        
        // When
        val result = contextBuilder.selectRelevantFacts(facts)
        
        // Then
        assertEquals(20, result.size)
    }
}
```

**SummarizeDailyConversationsUseCase测试**：
```kotlin
class SummarizeDailyConversationsUseCaseTest {
    @MockK
    private lateinit var conversationRepository: ConversationRepository
    @MockK
    private lateinit var contactRepository: ContactRepository
    @MockK
    private lateinit var aiRepository: AiRepository
    
    private lateinit var useCase: SummarizeDailyConversationsUseCase
    
    @Before
    fun setup() {
        MockKAnnotations.init(this)
        useCase = SummarizeDailyConversationsUseCase(
            conversationRepository,
            contactRepository,
            // ... 其他依赖
        )
    }
    
    @Test
    fun `无未总结对话时直接返回成功`() = runTest {
        // Given
        coEvery { conversationRepository.getUnsummarizedLogs(any()) } returns 
            Result.success(emptyList())
        
        // When
        val result = useCase()
        
        // Then
        assertTrue(result.isSuccess)
        assertTrue(result.getOrNull()?.noData == true)
        coVerify(exactly = 0) { aiRepository.generateSummary(any()) }
    }
    
    @Test
    fun `AI失败时使用降级方案`() = runTest {
        // Given
        val logs = listOf(mockConversationLog())
        coEvery { conversationRepository.getUnsummarizedLogs(any()) } returns 
            Result.success(logs)
        coEvery { aiRepository.generateSummary(any()) } throws IOException()
        
        // When
        val result = useCase()
        
        // Then
        assertTrue(result.isSuccess)
        assertTrue(result.getOrNull()?.usedFallback == true)
    }
}
```

### 12.2 集成测试

**数据库迁移测试**：
```kotlin
@RunWith(AndroidJUnit4::class)
class MigrationTest {
    @get:Rule
    val helper = MigrationTestHelper(
        InstrumentationRegistry.getInstrumentation(),
        AppDatabase::class.java
    )
    
    @Test
    fun testMigration3To4() {
        // 创建v3数据库并插入测试数据
        val db = helper.createDatabase(TEST_DB, 3)
        db.execSQL("""
            INSERT INTO profiles (id, name, target_goal, context_depth, facts_json)
            VALUES ('test-id', '测试', '测试目标', 10, '{"性格":"急性子"}')
        """)
        db.close()
        
        // 执行迁移
        helper.runMigrationsAndValidate(TEST_DB, 4, true, MIGRATION_3_4)
        
        // 验证迁移结果
        val migratedDb = Room.databaseBuilder(
            ApplicationProvider.getApplicationContext(),
            AppDatabase::class.java,
            TEST_DB
        ).addMigrations(MIGRATION_3_4).build()
        
        val profile = migratedDb.contactDao().getById("test-id")
        assertEquals(50, profile?.relationshipScore)
        assertTrue(profile?.factsJson?.contains("急性子") == true)
    }
}
```

### 12.3 UI测试

```kotlin
@RunWith(AndroidJUnit4::class)
class RelationshipScoreComponentTest {
    @get:Rule
    val composeTestRule = createComposeRule()
    
    @Test
    fun `关系分数正确显示`() {
        composeTestRule.setContent {
            RelationshipScoreSection(
                score = 65,
                lastInteractionDate = "2025-12-13",
                trend = RelationshipTrend.IMPROVING
            )
        }
        
        composeTestRule.onNodeWithText("65/100").assertExists()
        composeTestRule.onNodeWithText("最后互动：2025-12-13").assertExists()
        composeTestRule.onNodeWithText("改善中").assertExists()
    }
    
    @Test
    fun `Facts列表正确显示时间戳和来源`() {
        val fact = Fact(
            key = "性格特点",
            value = "急性子",
            timestamp = 1734134400000,
            source = FactSource.AI_INFERRED
        )
        
        composeTestRule.setContent {
            FactItem(fact = fact)
        }
        
        composeTestRule.onNodeWithText("性格特点").assertExists()
        composeTestRule.onNodeWithText("急性子").assertExists()
        composeTestRule.onNodeWithText("AI推断").assertExists()
    }
}
```


## 13. 验收标准

### 13.1 功能验收

**对话记录功能**：
- [ ] 用户发起分析时自动保存用户输入
- [ ] AI回复后自动保存回复内容
- [ ] 对话记录包含完整的时间戳和联系人关联
- [ ] 即使AI分析失败，用户输入也会被保存

**每日总结功能**：
- [ ] 新一天首次打开App时自动触发
- [ ] 总结能正确提取昨日所有对话
- [ ] 总结能自动发现并添加新的facts
- [ ] 总结能自动调整BrainTag标签
- [ ] 总结能自动更新关系分数
- [ ] AI失败时启用降级方案

**Facts功能**：
- [ ] Facts结构包含key、value、timestamp、source
- [ ] Facts能正确保存和读取
- [ ] 旧版本数据能自动迁移

**关系分数功能**：
- [ ] 新联系人默认分数为50
- [ ] 分数在0-100范围内
- [ ] 每日总结后分数能正确更新
- [ ] UI正确显示分数和趋势

**上下文构建功能**：
- [ ] 能正确筛选相关facts
- [ ] Facts总数控制在20条以内
- [ ] 所有BrainTag标签都会被包含

### 13.2 性能验收

- [ ] 对话记录保存时间 < 100ms
- [ ] 上下文构建时间 < 200ms
- [ ] 每日总结执行时间 < 30秒
- [ ] 不阻塞UI线程
- [ ] 无内存泄漏

### 13.3 UI验收

- [ ] 关系分数展示直观易懂
- [ ] 进度条颜色正确反映分数区间
- [ ] 趋势图标正确显示
- [ ] Facts列表清晰易读
- [ ] 时间戳格式友好
- [ ] 来源标记清晰

## 14. 附录

### 14.1 相关文档

- [PRD-00003-联系人画像记忆系统需求](../PRD/PRD-00003-联系人画像记忆系统需求.md)
- [TDD-00003-记忆系统架构设计](../TDD/TDD-00003-记忆系统架构设计.md)（待创建）

### 14.2 文件清单

**新增文件**：
```
domain/
├── model/
│   ├── Fact.kt
│   ├── FactSource.kt
│   ├── ConversationLog.kt
│   ├── DailySummary.kt
│   ├── KeyEvent.kt
│   ├── TagUpdate.kt
│   └── RelationshipTrend.kt
├── repository/
│   ├── ConversationRepository.kt
│   └── DailySummaryRepository.kt
├── usecase/
│   └── SummarizeDailyConversationsUseCase.kt
└── util/
    ├── ContextBuilder.kt
    └── RetryPolicy.kt

data/
├── local/
│   ├── entity/
│   │   ├── ConversationLogEntity.kt
│   │   └── DailySummaryEntity.kt
│   ├── dao/
│   │   ├── ConversationLogDao.kt
│   │   └── DailySummaryDao.kt
│   └── MemoryPreferences.kt
└── repository/
    ├── ConversationRepositoryImpl.kt
    └── DailySummaryRepositoryImpl.kt

presentation/
└── ui/
    └── component/
        ├── RelationshipScoreSection.kt
        └── FactItem.kt
```

**修改文件**：
```
domain/model/ContactProfile.kt          # 添加relationshipScore, lastInteractionDate, facts类型变更
data/local/entity/ContactProfileEntity.kt  # 添加新字段
data/local/AppDatabase.kt               # 添加新Entity、DAO和Migration
data/local/converter/RoomTypeConverters.kt  # 添加Fact列表转换器
domain/usecase/AnalyzeChatUseCase.kt    # 集成对话记录保存
presentation/ui/screen/contact/ContactDetailScreen.kt  # 添加关系分数展示
presentation/viewmodel/ContactDetailViewModel.kt  # 添加新状态
app/EmpathyApplication.kt               # 添加每日总结触发
```

### 14.3 变更记录

| 版本 | 日期 | 变更内容 | 变更人 |
|------|------|----------|--------|
| v1.0 | 2025-12-14 | 初始版本 | Claude |
| v1.1 | 2025-12-14 | 添加核心组件详细设计、API设计、数据迁移方案、性能测试方案、错误处理流程图 | Claude |
