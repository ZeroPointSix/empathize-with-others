# FD-00005: æç¤ºè¯ç®¡ç†ç³»ç»ŸåŠŸèƒ½è®¾è®¡

> **æ–‡æ¡£ç±»å‹**: åŠŸèƒ½è®¾è®¡æ–‡æ¡£ (FD)  
> **ç‰ˆæœ¬**: 1.1  
> **åˆ›å»ºæ—¥æœŸ**: 2025-12-16  
> **æœ€åæ›´æ–°**: 2025-12-16  
> **è´Ÿè´£äºº**: Kiro  
> **å®¡æŸ¥äºº**: Roo  
> **çŠ¶æ€**: âœ… å®¡æŸ¥é€šè¿‡ï¼ˆå¾…å¼€å‘ï¼‰  
> **ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­  
> **å…³è”PRD**: PRD-00005  
> **å…³è”è°ƒç ”**: RESEARCH-00001  
> **å…³è”å®¡æŸ¥**: DR-00010

---

## ğŸ“œ ç‰ˆæœ¬å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | ä½œè€… | å˜æ›´è¯´æ˜ |
|------|------|------|----------|
| 1.0 | 2025-12-16 | Kiro | åˆå§‹ç‰ˆæœ¬ï¼ŒåŒ…å«å®Œæ•´æ¶æ„è®¾è®¡ |
| 1.1 | 2025-12-16 | Kiro | æ ¹æ®DR-00010å®¡æŸ¥æŠ¥å‘Šè¡¥å……ï¼šç‰ˆæœ¬å†å²ã€å®‰å…¨æ€§å¢å¼ºã€æ€§èƒ½ä¼˜åŒ–ã€ä¾èµ–è¯´æ˜ |

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°æç¤ºè¯ç®¡ç†ç³»ç»Ÿçš„æŠ€æœ¯æ¶æ„ã€ç»„ä»¶è®¾è®¡ã€æ•°æ®æµå’Œå®ç°ç»†èŠ‚ã€‚

**è®¾è®¡ç›®æ ‡**ï¼š
- å°†æç¤ºè¯ä»ç¡¬ç¼–ç ä¸­æŠ½ç¦»ï¼Œå®ç°å¯é…ç½®åŒ–
- æ”¯æŒå˜é‡æ’å€¼ï¼Œè®©æç¤ºè¯èƒ½å¼•ç”¨åŠ¨æ€æ•°æ®
- åŒºåˆ†ç³»ç»Ÿæç¤ºè¯å’Œç”¨æˆ·æç¤ºè¯ï¼Œç¡®ä¿AIè¾“å‡ºæ ¼å¼æ­£ç¡®
- æ”¯æŒå…¨å±€å’Œè”ç³»äººçº§åˆ«çš„æç¤ºè¯é…ç½®
- æä¾›å†å²è®°å½•å’Œæ¢å¤åŠŸèƒ½

**ä¾èµ–åº“ç‰ˆæœ¬**ï¼š
- Moshi: 1.15.1ï¼ˆJSONåºåˆ—åŒ–ï¼‰
- Room: 2.6.1ï¼ˆæ•°æ®åº“ï¼‰
- Kotlin Coroutines: 1.9.0ï¼ˆå¼‚æ­¥å¤„ç†ï¼‰
- Hilt: 2.52ï¼ˆä¾èµ–æ³¨å…¥ï¼‰

---

## ğŸ“‘ ç›®å½•

1. [æ•´ä½“æ¶æ„](#æ•´ä½“æ¶æ„)
2. [æ•°æ®æ¨¡å‹è®¾è®¡](#æ•°æ®æ¨¡å‹è®¾è®¡)
3. [æ ¸å¿ƒç»„ä»¶è®¾è®¡](#æ ¸å¿ƒç»„ä»¶è®¾è®¡)
4. [æ•°æ®å­˜å‚¨è®¾è®¡](#æ•°æ®å­˜å‚¨è®¾è®¡)
5. [æ¥å£è®¾è®¡](#æ¥å£è®¾è®¡)
6. [ä¸ç°æœ‰ä»£ç çš„é›†æˆè®¾è®¡](#ä¸ç°æœ‰ä»£ç çš„é›†æˆè®¾è®¡)
7. [å®‰å…¨æ€§è®¾è®¡](#å®‰å…¨æ€§è®¾è®¡)
8. [æ€§èƒ½ä¼˜åŒ–è®¾è®¡](#æ€§èƒ½ä¼˜åŒ–è®¾è®¡)
9. [å®æ–½è®¡åˆ’](#å®æ–½è®¡åˆ’)
10. [é”™è¯¯å¤„ç†æœºåˆ¶](#é”™è¯¯å¤„ç†æœºåˆ¶)
11. [æµ‹è¯•ç­–ç•¥](#æµ‹è¯•ç­–ç•¥)


---

## ğŸ—ï¸ æ•´ä½“æ¶æ„

### æ¶æ„å±‚æ¬¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Presentation Layer                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ SettingsScreenâ”‚  â”‚PromptEditor â”‚  â”‚PromptPreview â”‚  â”‚
â”‚  â”‚  (æç¤ºè¯å…¥å£) â”‚  â”‚  (ç¼–è¾‘ç•Œé¢)  â”‚  â”‚  (é¢„è§ˆç•Œé¢)  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Domain Layer                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚PromptBuilder â”‚  â”‚VariableResolverâ”‚ â”‚PromptValidatorâ”‚ â”‚
â”‚  â”‚  (æç¤ºè¯æ„å»º) â”‚  â”‚  (å˜é‡è§£æ)   â”‚  â”‚  (è¾“å…¥éªŒè¯)  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚PromptRepositoryâ”‚ â”‚SystemPrompts â”‚                    â”‚
â”‚  â”‚   (æ¥å£)      â”‚  â”‚  (ç³»ç»Ÿçº¦æŸ)  â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Data Layer                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚PromptRepositoryâ”‚ â”‚PromptFileStorageâ”‚ â”‚ContactDao  â”‚  â”‚
â”‚  â”‚     Impl      â”‚  â”‚  (JSONæ–‡ä»¶)   â”‚  â”‚(custom_prompt)â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¨¡å—åˆ’åˆ†

```
domain/
â”œâ”€â”€ repository/
â”‚   â””â”€â”€ PromptRepository.kt              # æç¤ºè¯ä»“åº“æ¥å£
â”œâ”€â”€ model/
â”‚   â”œâ”€â”€ PromptScene.kt                   # åœºæ™¯æšä¸¾
â”‚   â”œâ”€â”€ PromptContext.kt                 # å˜é‡ä¸Šä¸‹æ–‡
â”‚   â”œâ”€â”€ GlobalPromptConfig.kt            # å…¨å±€é…ç½®æ¨¡å‹
â”‚   â”œâ”€â”€ ScenePromptConfig.kt             # åœºæ™¯é…ç½®æ¨¡å‹
â”‚   â””â”€â”€ PromptHistoryItem.kt             # å†å²è®°å½•æ¨¡å‹
â”œâ”€â”€ util/
â”‚   â”œâ”€â”€ PromptBuilder.kt                 # æç¤ºè¯æ„å»ºå™¨
â”‚   â”œâ”€â”€ PromptVariableResolver.kt        # å˜é‡è§£æå™¨
â”‚   â”œâ”€â”€ PromptValidator.kt               # è¾“å…¥éªŒè¯å™¨
â”‚   â””â”€â”€ SystemPrompts.kt                 # ç³»ç»Ÿæç¤ºè¯å¸¸é‡

data/
â”œâ”€â”€ repository/
â”‚   â””â”€â”€ PromptRepositoryImpl.kt          # ä»“åº“å®ç°
â”œâ”€â”€ local/
â”‚   â”œâ”€â”€ PromptFileStorage.kt             # JSONæ–‡ä»¶å­˜å‚¨
â”‚   â””â”€â”€ DefaultPrompts.kt                # é»˜è®¤æç¤ºè¯æ¨¡æ¿

di/
â””â”€â”€ PromptModule.kt                      # Hiltä¾èµ–æ³¨å…¥æ¨¡å—
```


---

## ğŸ“Š æ•°æ®æ¨¡å‹è®¾è®¡

### æ ¸å¿ƒæ•°æ®æ¨¡å‹

#### 1. PromptSceneï¼ˆåœºæ™¯æšä¸¾ï¼‰

**èŒè´£**ï¼šå®šä¹‰æç¤ºè¯åº”ç”¨çš„åœºæ™¯ç±»å‹åŠå…¶å¯ç”¨å˜é‡

```kotlin
enum class PromptScene(
    val displayName: String,
    val description: String,
    val availableVariables: List<String>
) {
    ANALYZE(
        displayName = "èŠå¤©åˆ†æ",
        description = "åˆ†æèŠå¤©ä¸Šä¸‹æ–‡ï¼Œæä¾›æ²Ÿé€šå»ºè®®",
        availableVariables = listOf(
            "contact_name", "relationship_status",
            "risk_tags", "strategy_tags", "facts_count"
        )
    ),
    CHECK(
        displayName = "å®‰å…¨æ£€æŸ¥",
        description = "æ£€æŸ¥è‰ç¨¿å†…å®¹æ˜¯å¦è§¦å‘é£é™©è§„åˆ™",
        availableVariables = listOf("contact_name", "risk_tags")
    ),
    EXTRACT(
        displayName = "ä¿¡æ¯æå–",
        description = "ä»æ–‡æœ¬ä¸­æå–å…³é”®ä¿¡æ¯",
        availableVariables = listOf("contact_name")
    ),
    SUMMARY(
        displayName = "æ¯æ—¥æ€»ç»“",
        description = "ç”Ÿæˆæ¯æ—¥å¯¹è¯æ€»ç»“",
        availableVariables = listOf(
            "contact_name", "relationship_status",
            "facts_count", "today_date"
        )
    )
}
```

#### 2. PromptContextï¼ˆå˜é‡ä¸Šä¸‹æ–‡ï¼‰

**èŒè´£**ï¼šæ‰¿è½½å˜é‡æ’å€¼æ‰€éœ€çš„åŠ¨æ€æ•°æ®

```kotlin
data class PromptContext(
    val contactName: String? = null,
    val relationshipStatus: String? = null,
    val riskTags: List<String> = emptyList(),
    val strategyTags: List<String> = emptyList(),
    val factsCount: Int = 0,
    val todayDate: String = ""
) {
    /**
     * æ ¹æ®å˜é‡åè·å–å¯¹åº”çš„å€¼
     * @param name å˜é‡åï¼ˆå°å†™ï¼‰
     * @return å˜é‡å€¼ï¼Œæœªæ‰¾åˆ°è¿”å›null
     */
    fun getVariable(name: String): String? = when (name.lowercase()) {
        "contact_name" -> contactName
        "relationship_status" -> relationshipStatus
        "risk_tags" -> riskTags.joinToString("ã€").ifEmpty { "æ— " }
        "strategy_tags" -> strategyTags.joinToString("ã€").ifEmpty { "æ— " }
        "facts_count" -> factsCount.toString()
        "today_date" -> todayDate
        else -> null
    }

    companion object {
        /**
         * ä»ContactProfileæ„å»ºä¸Šä¸‹æ–‡
         */
        fun fromContact(contact: ContactProfile): PromptContext {
            val riskTags = contact.facts
                .filter { it.key == "é›·åŒº" }
                .map { it.value }
            val strategyTags = contact.facts
                .filter { it.key == "ç­–ç•¥" }
                .map { it.value }

            return PromptContext(
                contactName = contact.name,
                relationshipStatus = contact.relationshipLevel?.displayName,
                riskTags = riskTags,
                strategyTags = strategyTags,
                factsCount = contact.facts.size,
                todayDate = java.time.LocalDate.now().toString()
            )
        }
    }
}
```


#### 3. GlobalPromptConfigï¼ˆå…¨å±€é…ç½®ï¼‰

**èŒè´£**ï¼šç®¡ç†å…¨å±€æç¤ºè¯é…ç½®çš„å®Œæ•´ç»“æ„

```kotlin
data class GlobalPromptConfig(
    val version: Int = 1,
    val lastModified: String = "",
    val prompts: Map<PromptScene, ScenePromptConfig> = emptyMap()
) {
    companion object {
        /**
         * åˆ›å»ºé»˜è®¤é…ç½®
         */
        fun createDefault(): GlobalPromptConfig {
            return GlobalPromptConfig(
                version = 1,
                lastModified = java.time.Instant.now().toString(),
                prompts = PromptScene.values().associateWith { scene ->
                    ScenePromptConfig(
                        userPrompt = DefaultPrompts.getDefault(scene),
                        enabled = true,
                        history = emptyList()
                    )
                }
            )
        }
    }
}

data class ScenePromptConfig(
    val userPrompt: String,
    val enabled: Boolean = true,
    val history: List<PromptHistoryItem> = emptyList()
) {
    companion object {
        const val MAX_HISTORY_SIZE = 3
    }

    /**
     * æ·»åŠ å†å²è®°å½•ï¼Œè¶…è¿‡é™åˆ¶è‡ªåŠ¨åˆ é™¤æœ€æ—§çš„
     */
    fun addHistory(oldPrompt: String): ScenePromptConfig {
        val newHistory = listOf(
            PromptHistoryItem(
                timestamp = java.time.Instant.now().toString(),
                userPrompt = oldPrompt
            )
        ) + history

        return copy(
            history = newHistory.take(MAX_HISTORY_SIZE)
        )
    }
}

data class PromptHistoryItem(
    val timestamp: String,
    val userPrompt: String
)
```

#### 4. PromptValidationResultï¼ˆéªŒè¯ç»“æœï¼‰

**èŒè´£**ï¼šç»Ÿä¸€ç®¡ç†æç¤ºè¯éªŒè¯ç»“æœ

```kotlin
sealed class PromptValidationResult {
    object Success : PromptValidationResult()

    data class Error(
        val message: String,
        val errorType: ErrorType
    ) : PromptValidationResult()

    enum class ErrorType {
        TOO_LONG,           // è¶…å‡ºé•¿åº¦é™åˆ¶
        EMPTY,              // å†…å®¹ä¸ºç©º
        INVALID_VARIABLE    // åŒ…å«æ— æ•ˆå˜é‡
    }
}
```


---

## ğŸ”§ æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. PromptVariableResolverï¼ˆå˜é‡è§£æå™¨ï¼‰

**èŒè´£**ï¼šè§£ææç¤ºè¯ä¸­çš„å˜é‡å ä½ç¬¦å¹¶æ›¿æ¢ä¸ºå®é™…å€¼

```kotlin
@Singleton
class PromptVariableResolver @Inject constructor() {

    companion object {
        // åŒ¹é… {{å˜é‡å}} æ ¼å¼ï¼Œå¿½ç•¥å¤§å°å†™
        private val VARIABLE_PATTERN = Regex("\\{\\{(\\w+)\\}\\}", RegexOption.IGNORE_CASE)
    }

    /**
     * è§£ææ¨¡æ¿ä¸­çš„å˜é‡å¹¶æ›¿æ¢
     * @param template åŒ…å«å˜é‡å ä½ç¬¦çš„æ¨¡æ¿å­—ç¬¦ä¸²
     * @param context å˜é‡ä¸Šä¸‹æ–‡
     * @return æ›¿æ¢åçš„å­—ç¬¦ä¸²
     */
    fun resolve(template: String, context: PromptContext): String {
        return VARIABLE_PATTERN.replace(template) { match ->
            val variableName = match.groupValues[1].lowercase()
            context.getVariable(variableName) ?: match.value // æœªçŸ¥å˜é‡ä¿æŒåŸæ ·
        }
    }

    /**
     * æå–æ¨¡æ¿ä¸­ä½¿ç”¨çš„æ‰€æœ‰å˜é‡å
     * @param template æ¨¡æ¿å­—ç¬¦ä¸²
     * @return å˜é‡ååˆ—è¡¨
     */
    fun extractVariables(template: String): List<String> {
        return VARIABLE_PATTERN.findAll(template)
            .map { it.groupValues[1].lowercase() }
            .distinct()
            .toList()
    }

    /**
     * éªŒè¯æ¨¡æ¿ä¸­çš„å˜é‡æ˜¯å¦éƒ½åœ¨å…è®¸åˆ—è¡¨ä¸­
     * @param template æ¨¡æ¿å­—ç¬¦ä¸²
     * @param allowedVariables å…è®¸çš„å˜é‡åˆ—è¡¨
     * @return æ— æ•ˆå˜é‡åˆ—è¡¨
     */
    fun findInvalidVariables(
        template: String,
        allowedVariables: List<String>
    ): List<String> {
        val usedVariables = extractVariables(template)
        val allowedSet = allowedVariables.map { it.lowercase() }.toSet()
        return usedVariables.filter { it !in allowedSet }
    }
}
```

### 2. PromptValidatorï¼ˆè¾“å…¥éªŒè¯å™¨ï¼‰

**èŒè´£**ï¼šéªŒè¯ç”¨æˆ·è¾“å…¥çš„æç¤ºè¯æ˜¯å¦ç¬¦åˆè§„èŒƒ

```kotlin
@Singleton
class PromptValidator @Inject constructor(
    private val variableResolver: PromptVariableResolver
) {
    companion object {
        const val MAX_PROMPT_LENGTH = 1000
        const val MIN_PROMPT_LENGTH = 0 // å…è®¸ä¸ºç©ºï¼ˆä½¿ç”¨é»˜è®¤ï¼‰
    }

    /**
     * éªŒè¯æç¤ºè¯
     * @param prompt ç”¨æˆ·è¾“å…¥çš„æç¤ºè¯
     * @param scene åº”ç”¨åœºæ™¯ï¼ˆç”¨äºéªŒè¯å˜é‡ï¼‰
     * @return éªŒè¯ç»“æœ
     */
    fun validate(prompt: String, scene: PromptScene): PromptValidationResult {
        // é•¿åº¦æ£€æŸ¥
        if (prompt.length > MAX_PROMPT_LENGTH) {
            return PromptValidationResult.Error(
                message = "æç¤ºè¯é•¿åº¦ä¸èƒ½è¶…è¿‡${MAX_PROMPT_LENGTH}å­—ç¬¦ï¼Œå½“å‰${prompt.length}å­—ç¬¦",
                errorType = PromptValidationResult.ErrorType.TOO_LONG
            )
        }

        // å˜é‡æœ‰æ•ˆæ€§æ£€æŸ¥ï¼ˆå¯é€‰ï¼Œä»…è­¦å‘Šï¼‰
        val invalidVariables = variableResolver.findInvalidVariables(
            template = prompt,
            allowedVariables = scene.availableVariables
        )
        if (invalidVariables.isNotEmpty()) {
            return PromptValidationResult.Error(
                message = "åŒ…å«æ— æ•ˆå˜é‡: ${invalidVariables.joinToString(", ")}",
                errorType = PromptValidationResult.ErrorType.INVALID_VARIABLE
            )
        }

        return PromptValidationResult.Success
    }
}
```


### 3. SystemPromptsï¼ˆç³»ç»Ÿæç¤ºè¯ï¼‰

**èŒè´£**ï¼šç®¡ç†ä¸å¯ä¿®æ”¹çš„ç³»ç»Ÿçº¦æŸæç¤ºè¯

```kotlin
object SystemPrompts {

    /**
     * è·å–åœºæ™¯çš„ç³»ç»Ÿå¤´éƒ¨ï¼ˆè§’è‰²å®šä¹‰å’Œä»»åŠ¡è¯´æ˜ï¼‰
     */
    fun getHeader(scene: PromptScene): String = when (scene) {
        PromptScene.ANALYZE -> """
            |ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ç¤¾äº¤æ²Ÿé€šåˆ†æåŠ©æ‰‹ã€‚
            |ä½ çš„ä»»åŠ¡æ˜¯åˆ†æç”¨æˆ·æä¾›çš„èŠå¤©è®°å½•ï¼Œç†è§£å¯¹è¯åŒæ–¹çš„æƒ…ç»ªå’Œæ„å›¾ï¼Œ
            |å¹¶ç»™å‡ºå…·ä½“ã€å¯æ“ä½œçš„æ²Ÿé€šå»ºè®®ã€‚
        """.trimMargin()

        PromptScene.CHECK -> """
            |ä½ æ˜¯ä¸€ä¸ªæ•æ„Ÿè¯é¢˜æ£€æµ‹åŠ©æ‰‹ã€‚
            |ä½ çš„ä»»åŠ¡æ˜¯æ£€æŸ¥ç”¨æˆ·å‡†å¤‡å‘é€çš„æ¶ˆæ¯ï¼Œåˆ¤æ–­æ˜¯å¦å¯èƒ½è§¦å‘å¯¹æ–¹çš„æ•æ„Ÿç‚¹æˆ–é›·åŒºã€‚
        """.trimMargin()

        PromptScene.EXTRACT -> """
            |ä½ æ˜¯ä¸€ä¸ªä¿¡æ¯æå–åŠ©æ‰‹ã€‚
            |ä½ çš„ä»»åŠ¡æ˜¯ä»å¯¹è¯æ–‡æœ¬ä¸­æå–å…³é”®çš„ä¸ªäººä¿¡æ¯ã€åå¥½å’Œé‡è¦äº‹ä»¶ã€‚
        """.trimMargin()

        PromptScene.SUMMARY -> """
            |ä½ æ˜¯ä¸€ä¸ªå¯¹è¯æ€»ç»“åŠ©æ‰‹ã€‚
            |ä½ çš„ä»»åŠ¡æ˜¯åˆ†æä»Šæ—¥çš„å¯¹è¯è®°å½•ï¼Œç”Ÿæˆç®€æ´çš„æ€»ç»“æŠ¥å‘Šã€‚
        """.trimMargin()
    }

    /**
     * è·å–åœºæ™¯çš„ç³»ç»Ÿå°¾éƒ¨ï¼ˆè¾“å‡ºæ ¼å¼çº¦æŸï¼‰
     */
    fun getFooter(scene: PromptScene): String = when (scene) {
        PromptScene.ANALYZE -> """
            |ã€è¾“å‡ºæ ¼å¼è¦æ±‚ã€‘
            |è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºï¼Œä¸è¦æ·»åŠ ä»»ä½•é¢å¤–å†…å®¹ï¼š
            |{
            |  "riskLevel": "SAFE|WARNING|DANGER",
            |  "emotionAnalysis": "å¯¹æ–¹æƒ…ç»ªåˆ†æ",
            |  "intentAnalysis": "å¯¹æ–¹æ„å›¾åˆ†æ",
            |  "strategyAnalysis": "æ²Ÿé€šç­–ç•¥å»ºè®®",
            |  "replySuggestion": "å…·ä½“å›å¤å»ºè®®æ–‡æœ¬",
            |  "riskPoints": ["é£é™©ç‚¹1", "é£é™©ç‚¹2"]
            |}
            |
            |ã€é‡è¦çº¦æŸã€‘
            |- åªè¾“å‡ºJSONï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–æ–‡å­—
            |- ä¸è¦ä½¿ç”¨Markdownæ ¼å¼
            |- riskLevelåªèƒ½æ˜¯SAFEã€WARNINGã€DANGERä¸‰ä¸ªå€¼ä¹‹ä¸€
            |- ä»¥ä¸‹æ˜¯ç”¨æˆ·é…ç½®ï¼Œè‹¥ä¸ç³»ç»Ÿæ ¼å¼å†²çªï¼Œä»¥ç³»ç»Ÿæ ¼å¼ä¸ºå‡†
        """.trimMargin()

        PromptScene.CHECK -> """
            |ã€è¾“å‡ºæ ¼å¼è¦æ±‚ã€‘
            |è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºï¼š
            |{
            |  "isSafe": true|false,
            |  "riskLevel": "SAFE|WARNING|DANGER",
            |  "issues": ["é—®é¢˜1", "é—®é¢˜2"],
            |  "suggestion": "ä¿®æ”¹å»ºè®®"
            |}
            |
            |ã€é‡è¦çº¦æŸã€‘
            |- åªè¾“å‡ºJSONï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–æ–‡å­—
            |- ä»¥ä¸‹æ˜¯ç”¨æˆ·é…ç½®ï¼Œè‹¥ä¸ç³»ç»Ÿæ ¼å¼å†²çªï¼Œä»¥ç³»ç»Ÿæ ¼å¼ä¸ºå‡†
        """.trimMargin()

        PromptScene.EXTRACT -> """
            |ã€è¾“å‡ºæ ¼å¼è¦æ±‚ã€‘
            |è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºï¼š
            |{
            |  "facts": [
            |    {"key": "åˆ†ç±»", "value": "å…·ä½“ä¿¡æ¯", "confidence": 0.9}
            |  ]
            |}
            |
            |ã€é‡è¦çº¦æŸã€‘
            |- åªè¾“å‡ºJSONï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–æ–‡å­—
            |- confidenceå–å€¼èŒƒå›´0-1
            |- ä»¥ä¸‹æ˜¯ç”¨æˆ·é…ç½®ï¼Œè‹¥ä¸ç³»ç»Ÿæ ¼å¼å†²çªï¼Œä»¥ç³»ç»Ÿæ ¼å¼ä¸ºå‡†
        """.trimMargin()

        PromptScene.SUMMARY -> """
            |ã€è¾“å‡ºæ ¼å¼è¦æ±‚ã€‘
            |è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºï¼š
            |{
            |  "summary": "ä»Šæ—¥æ€»ç»“",
            |  "highlights": ["äº®ç‚¹1", "äº®ç‚¹2"],
            |  "concerns": ["å…³æ³¨ç‚¹1"],
            |  "newFacts": [{"key": "åˆ†ç±»", "value": "ä¿¡æ¯"}],
            |  "relationshipTrend": "UP|STABLE|DOWN"
            |}
            |
            |ã€é‡è¦çº¦æŸã€‘
            |- åªè¾“å‡ºJSONï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–æ–‡å­—
            |- ä»¥ä¸‹æ˜¯ç”¨æˆ·é…ç½®ï¼Œè‹¥ä¸ç³»ç»Ÿæ ¼å¼å†²çªï¼Œä»¥ç³»ç»Ÿæ ¼å¼ä¸ºå‡†
        """.trimMargin()
    }
}
```


### 4. PromptBuilderï¼ˆæç¤ºè¯æ„å»ºå™¨ï¼‰

**èŒè´£**ï¼šæŒ‰ç…§åˆå¹¶è§„åˆ™æ„å»ºå®Œæ•´çš„ç³»ç»ŸæŒ‡ä»¤

> âš ï¸ **æ€§èƒ½ä¼˜åŒ–**ï¼šé¿å…ä½¿ç”¨å ä½ç¬¦æ›¿æ¢æ¨¡å¼ï¼Œæ”¹ä¸ºç›´æ¥æ‹¼æ¥ä»¥å‡å°‘å†…å­˜å¼€é”€

```kotlin
@Singleton
class PromptBuilder @Inject constructor(
    private val promptRepository: PromptRepository,
    private val variableResolver: PromptVariableResolver
) {
    /**
     * æ„å»ºå®Œæ•´çš„ç³»ç»ŸæŒ‡ä»¤ï¼ˆç›´æ¥æ‹¼æ¥æ¨¡å¼ï¼Œé¿å…å ä½ç¬¦æ›¿æ¢çš„å†…å­˜å¼€é”€ï¼‰
     * åˆå¹¶é¡ºåºï¼šç³»ç»Ÿå¤´éƒ¨ â†’ ç”¨æˆ·æŒ‡ä»¤ â†’ ä¸Šä¸‹æ–‡æ•°æ® â†’ ç³»ç»Ÿå°¾éƒ¨
     *
     * @param scene åº”ç”¨åœºæ™¯
     * @param contactId è”ç³»äººIDï¼ˆå¯é€‰ï¼Œç”¨äºè·å–è”ç³»äººä¸“å±æç¤ºè¯ï¼‰
     * @param context å˜é‡ä¸Šä¸‹æ–‡
     * @param contextData ä¸Šä¸‹æ–‡æ•°æ®ï¼ˆèŠå¤©è®°å½•ã€Factsç­‰ï¼‰ï¼Œç›´æ¥ä¼ å…¥é¿å…äºŒæ¬¡æ›¿æ¢
     * @return æ„å»ºå¥½çš„ç³»ç»ŸæŒ‡ä»¤
     */
    suspend fun buildSystemInstruction(
        scene: PromptScene,
        contactId: String? = null,
        context: PromptContext,
        contextData: String = ""
    ): String {
        return buildString {
            // 1. ç³»ç»Ÿè§’è‰²å®šä¹‰ï¼ˆSystem Headerï¼‰
            append(SystemPrompts.getHeader(scene))
            appendLine()
            appendLine()

            // 2. ç”¨æˆ·è‡ªå®šä¹‰æŒ‡ä»¤ï¼ˆæŒ‡ä»¤ä¼˜å…ˆï¼Œæ”¾åœ¨æ•°æ®ä¹‹å‰ï¼‰
            val globalPrompt = promptRepository.getGlobalPrompt(scene)
            i   appendLine()
            }

            // è”ç³»äººå•ç‹¬æç¤ºè¯ï¼ˆä¼˜å…ˆçº§æ›´é«˜ï¼‰
            if (contactId != null) {
                val contactPrompt = promptRepository.getContactPrompt(contactId)
                if (!contactPrompt.isNullOrBlank()) {
                    appendLine("ã€é’ˆå¯¹æ­¤è”ç³»äººçš„ç‰¹æ®ŠæŒ‡ä»¤ã€‘")
                    val resolvedPrompt = variableResolver.resolve(contactPrompt, context)
                    appendLine(resolvedPrompt)
                    appendLine()
                }
            }

            // 3. ä¸Šä¸‹æ–‡æ•°æ®å ä½æ ‡è®°ï¼ˆç”±è°ƒç”¨æ–¹åœ¨æ­¤å¤„æ’å…¥å®é™…æ•°æ®ï¼‰
            appendLine("ã€ä¸Šä¸‹æ–‡æ•°æ®ã€‘")
            appendLine("{{CONTEXT_DATA_PLACEHOLDER}}")
            appendLine()

            // 4. è¾“å‡ºæ ¼å¼çº¦æŸï¼ˆSystem Footerï¼‰
            append(SystemPrompts.getFooter(scene))
        }
    }

    /**
     * æ›¿æ¢ä¸Šä¸‹æ–‡æ•°æ®å ä½ç¬¦
     * @param instruction åŒ…å«å ä½ç¬¦çš„æŒ‡ä»¤
     * @param contextData å®é™…çš„ä¸Šä¸‹æ–‡æ•°æ®
     * @return å®Œæ•´çš„æŒ‡ä»¤
     */
    fun injectContextData(instruction: String, contextData: String): String {
        return instruction.replace("{{CONTEXT_DATA_PLACEHOLDER}}", contextData)
    }
}
```

### 5. DefaultPromptsï¼ˆé»˜è®¤æç¤ºè¯ï¼‰

**èŒè´£**ï¼šæä¾›ç³»ç»Ÿå†…ç½®çš„é»˜è®¤ç”¨æˆ·æç¤ºè¯æ¨¡æ¿

```kotlin
object DefaultPrompts {

    fun getDefault(scene: PromptScene): String = when (scene) {
        PromptScene.ANALYZE -> """
            |è¯·åŸºäºæä¾›çš„ä¿¡æ¯ï¼Œåˆ†æå½“å‰èŠå¤©æƒ…å†µï¼Œå¹¶ç»™å‡º:
            |1. å¯¹æ–¹å½“å‰çš„æƒ…ç»ªå’Œæ½œåœ¨æ„å›¾
            |2. å¯èƒ½å­˜åœ¨çš„é£é™©ç‚¹
            |3. å…·ä½“çš„å›å¤å»ºè®®ï¼ˆå¯ç›´æ¥å‘é€çš„æ–‡æœ¬ï¼‰
            |
            |æ³¨æ„äº‹é¡¹:
            |- ä¸¥æ ¼éµå®ˆé›·åŒºè­¦å‘Šï¼Œä¸è¦è§¦ç¢°æ•æ„Ÿè¯é¢˜
            |- ä¼˜å…ˆä½¿ç”¨ç­–ç•¥å»ºè®®ä¸­çš„æ–¹æ³•
            |- å›å¤è¦çœŸè¯šã€è‡ªç„¶ï¼Œä¸è¦å¤ªè¿‡åˆ»æ„
            |- å¦‚æœå‘ç°é«˜é£é™©æƒ…å†µï¼Œè¯·æ˜ç¡®æ ‡æ³¨
        """.trimMargin()

        PromptScene.CHECK -> """
            |è¯·ä»”ç»†æ£€æŸ¥ç”¨æˆ·çš„è‰ç¨¿å†…å®¹ï¼Œåˆ¤æ–­æ˜¯å¦è§¦å‘äº†ä»»ä½•é£é™©è§„åˆ™ã€‚
            |å¦‚æœå‘ç°é—®é¢˜ï¼Œè¯·ç»™å‡ºå…·ä½“çš„ä¿®æ”¹å»ºè®®ã€‚
            |
            |é‡ç‚¹å…³æ³¨:
            |- æ˜¯å¦è§¦åŠå¯¹æ–¹çš„é›·åŒºè¯é¢˜
            |- è¯­æ°”æ˜¯å¦å¯èƒ½å¼•èµ·è¯¯è§£
            |- æ˜¯å¦æœ‰æ•æ„Ÿè¯æ±‡éœ€è¦æ›¿æ¢
        """.trimMargin()

        PromptScene.EXTRACT -> """
            |è¯·ä»æ–‡æœ¬ä¸­æå–å…³é”®ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼š
            |- å¯¹æ–¹é€éœ²çš„ä¸ªäººä¿¡æ¯ï¼ˆç”Ÿæ—¥ã€çˆ±å¥½ã€å·¥ä½œç­‰ï¼‰
            |- éœ€è¦æ³¨æ„çš„é›·åŒºè¯é¢˜
            |- æœ‰æ•ˆçš„æ²Ÿé€šç­–ç•¥
            |
            |æå–æ—¶è¯·æ³¨æ„:
            |- åªæå–æ˜ç¡®æåˆ°çš„ä¿¡æ¯ï¼Œä¸è¦æ¨æµ‹
            |- æ ‡æ³¨ä¿¡æ¯çš„å¯ä¿¡åº¦
        """.trimMargin()

        PromptScene.SUMMARY -> """
            |è¯·åˆ†æä»Šæ—¥çš„å¯¹è¯è®°å½•ï¼Œç”Ÿæˆç®€æ´çš„æ€»ç»“ï¼ŒåŒ…æ‹¬ï¼š
            |- æ–°å‘ç°çš„äº‹å®ä¿¡æ¯
            |- å…³ç³»å˜åŒ–è¶‹åŠ¿
            |- éœ€è¦å…³æ³¨çš„è¦ç‚¹
            |
            |æ€»ç»“è¦æ±‚:
            |- çªå‡ºä»Šæ—¥äº’åŠ¨çš„äº®ç‚¹
            |- æ ‡æ³¨éœ€è¦æ³¨æ„çš„é—®é¢˜
            |- ç»™å‡ºåç»­æ²Ÿé€šå»ºè®®
        """.trimMargin()
    }
}
```


---

## ğŸ’¾ æ•°æ®å­˜å‚¨è®¾è®¡

### 1. JSONæ–‡ä»¶å­˜å‚¨

**æ–‡ä»¶è·¯å¾„**ï¼š`/data/data/com.empathy.ai/files/prompts/global_prompts.json`

```kotlin
@Singleton
class PromptFileStorage @Inject constructor(
    @ApplicationContext private val context: Context,
    private val moshi: Moshi
) {
    companion object {
        private const val PROMPTS_DIR = "prompts"
        private const val GLOBAL_PROMPTS_FILE = "global_prompts.json"
    }

    private val promptsDir: File
        get() = File(context.filesDir, PROMPTS_DIR).also { it.mkdirs() }

    private val globalPromptsFile: File
        get() = File(promptsDir, GLOBAL_PROMPTS_FILE)

    private val adapter: JsonAdapter<GlobalPromptConfig> by lazy {
        moshi.adapter(GlobalPromptConfig::class.java)
    }

    /**
     * è¯»å–å…¨å±€é…ç½®
     */
    suspend fun readGlobalConfig(): Result<GlobalPromptConfig> = withContext(Dispatchers.IO) {
        try {
            if (!globalPromptsFile.exists()) {
                // é¦–æ¬¡ä½¿ç”¨ï¼Œåˆ›å»ºé»˜è®¤é…ç½®
                val defaultConfig = GlobalPromptConfig.createDefault()
                writeGlobalConfig(defaultConfig)
                return@withContext Result.success(defaultConfig)
            }

            val json = globalPromptsFile.readText(Charsets.UTF_8)
            val config = adapter.fromJson(json)
                ?: return@withContext Result.failure(Exception("è§£æé…ç½®æ–‡ä»¶å¤±è´¥"))

            Result.success(config)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * å†™å…¥å…¨å±€é…ç½®
     */
    suspend fun writeGlobalConfig(config: GlobalPromptConfig): Result<Unit> =
        withContext(Dispatchers.IO) {
            try {
                val updatedConfig = config.copy(
                    lastModified = java.time.Instant.now().toString()
                )
                val json = adapter.toJson(updatedConfig)
                globalPromptsFile.writeText(json, Charsets.UTF_8)
                Result.success(Unit)
            } catch (e: Exception) {
                Result.failure(e)
            }
        }

    /**
     * é‡ç½®ä¸ºé»˜è®¤é…ç½®
     */
    suspend fun resetToDefault(): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val defaultConfig = GlobalPromptConfig.createDefault()
            writeGlobalConfig(defaultConfig)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### 2. æ•°æ®åº“å­˜å‚¨ï¼ˆè”ç³»äººæç¤ºè¯ï¼‰

**æ•°æ®åº“è¿ç§»**ï¼šä¸º `contact_profiles` è¡¨æ·»åŠ  `custom_prompt` å­—æ®µ

```kotlin
// AppDatabase.kt ä¸­æ·»åŠ è¿ç§»
val MIGRATION_8_9 = object : Migration(8, 9) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL(
            "ALTER TABLE contact_profiles ADD COLUMN custom_prompt TEXT DEFAULT NULL"
        )
    }
}

// ContactProfileEntity.kt ä¸­æ·»åŠ å­—æ®µ
@Entity(tableName = "contact_profiles")
data class ContactProfileEntity(
    @PrimaryKey
    @ColumnInfo(name = "id")
    val id: String,

    @ColumnInfo(name = "name")
    val name: String,

    // ... å…¶ä»–å­—æ®µ ...

    @ColumnInfo(name = "custom_prompt")
    val customPrompt: String? = null  // æ–°å¢ï¼šè”ç³»äººä¸“å±æç¤ºè¯
)
```

### 3. JSONç»“æ„ç¤ºä¾‹

```json
{
  "version": 1,
  "lastModified": "2025-12-16T10:30:00Z",
  "prompts": {
    "ANALYZE": {
      "userPrompt": "è¯·æ ¹æ®{{contact_name}}çš„æ€§æ ¼ç‰¹ç‚¹è¿›è¡Œåˆ†æ...",
      "enabled": true,
      "history": [
        {
          "timestamp": "2025-12-15T08:00:00Z",
          "userPrompt": "æ—§ç‰ˆæœ¬çš„æç¤ºè¯..."
        }
      ]
    },
    "CHECK": {
      "userPrompt": "æ£€æŸ¥æ—¶è¦ç‰¹åˆ«æ³¨æ„{{risk_tags}}...",
      "enabled": true,
      "history": []
    },
    "EXTRACT": {
      "userPrompt": "æå–{{contact_name}}çš„å…³é”®ä¿¡æ¯...",
      "enabled": true,
      "history": []
    },
    "SUMMARY": {
      "userPrompt": "æ€»ç»“{{today_date}}çš„äº’åŠ¨äº®ç‚¹...",
      "enabled": true,
      "history": []
    }
  }
}
```


---

## ğŸ”Œ æ¥å£è®¾è®¡

### 1. PromptRepository æ¥å£

```kotlin
interface PromptRepository {

    // ==================== å…¨å±€æç¤ºè¯ ====================

    /**
     * è·å–æŒ‡å®šåœºæ™¯çš„å…¨å±€ç”¨æˆ·æç¤ºè¯
     * @param scene åœºæ™¯ç±»å‹
     * @return ç”¨æˆ·æç¤ºè¯å†…å®¹ï¼Œå¦‚æœæœªè®¾ç½®è¿”å›é»˜è®¤å€¼
     */
    suspend fun getGlobalPrompt(scene: PromptScene): String

    /**
     * ä¿å­˜æŒ‡å®šåœºæ™¯çš„å…¨å±€ç”¨æˆ·æç¤ºè¯
     * @param scene åœºæ™¯ç±»å‹
     * @param prompt æç¤ºè¯å†…å®¹
     * @return æ“ä½œç»“æœ
     */
    suspend fun saveGlobalPrompt(scene: PromptScene, prompt: String): Result<Unit>

    /**
     * é‡ç½®æŒ‡å®šåœºæ™¯çš„æç¤ºè¯ä¸ºé»˜è®¤å€¼
     * @param scene åœºæ™¯ç±»å‹
     * @return æ“ä½œç»“æœ
     */
    suspend fun resetGlobalPromptToDefault(scene: PromptScene): Result<Unit>

    /**
     * è·å–æŒ‡å®šåœºæ™¯çš„æç¤ºè¯ä¿®æ”¹å†å²
     * @param scene åœºæ™¯ç±»å‹
     * @return å†å²è®°å½•åˆ—è¡¨ï¼ˆæœ€å¤š3æ¡ï¼‰
     */
    suspend fun getPromptHistory(scene: PromptScene): List<PromptHistoryItem>

    /**
     * ä»å†å²è®°å½•æ¢å¤æç¤ºè¯
     * @param scene åœºæ™¯ç±»å‹
     * @param historyIndex å†å²è®°å½•ç´¢å¼•ï¼ˆ0ä¸ºæœ€è¿‘ä¸€æ¡ï¼‰
     * @return æ“ä½œç»“æœ
     */
    suspend fun restoreFromHistory(scene: PromptScene, historyIndex: Int): Result<Unit>

    /**
     * æ£€æŸ¥æŒ‡å®šåœºæ™¯çš„æç¤ºè¯æ˜¯å¦å¯ç”¨
     * @param scene åœºæ™¯ç±»å‹
     * @return æ˜¯å¦å¯ç”¨
     */
    suspend fun isPromptEnabled(scene: PromptScene): Boolean

    /**
     * è®¾ç½®æŒ‡å®šåœºæ™¯çš„æç¤ºè¯å¯ç”¨çŠ¶æ€
     * @param scene åœºæ™¯ç±»å‹
     * @param enabled æ˜¯å¦å¯ç”¨
     * @return æ“ä½œç»“æœ
     */
    suspend fun setPromptEnabled(scene: PromptScene, enabled: Boolean): Result<Unit>

    // ==================== è”ç³»äººæç¤ºè¯ ====================

    /**
     * è·å–è”ç³»äººä¸“å±æç¤ºè¯
     * @param contactId è”ç³»äººID
     * @return æç¤ºè¯å†…å®¹ï¼Œæœªè®¾ç½®è¿”å›null
     */
    suspend fun getContactPrompt(contactId: String): String?

    /**
     * ä¿å­˜è”ç³»äººä¸“å±æç¤ºè¯
     * @param contactId è”ç³»äººID
     * @param prompt æç¤ºè¯å†…å®¹ï¼Œä¼ nullæ¸…é™¤
     * @return æ“ä½œç»“æœ
     */
    suspend fun saveContactPrompt(contactId: String, prompt: String?): Result<Unit>

    /**
     * æ¸…é™¤è”ç³»äººä¸“å±æç¤ºè¯
     * @param contactId è”ç³»äººID
     * @return æ“ä½œç»“æœ
     */
    suspend fun clearContactPrompt(contactId: String): Result<Unit>
}
```

### 2. PromptRepositoryImpl å®ç°

```kotlin
@Singleton
class PromptRepositoryImpl @Inject constructor(
    private val fileStorage: PromptFileStorage,
    private val contactDao: ContactDao
) : PromptRepository {

    // å†…å­˜ç¼“å­˜
    private var cachedConfig: GlobalPromptConfig? = null
    private val cacheLock = Mutex()

    override suspend fun getGlobalPrompt(scene: PromptScene): String {
        val config = getOrLoadConfig()
        return config.prompts[scene]?.userPrompt
            ?: DefaultPrompts.getDefault(scene)
    }

    override suspend fun saveGlobalPrompt(scene: PromptScene, prompt: String): Result<Unit> {
        return cacheLock.withLock {
            try {
                val config = getOrLoadConfig()
                val currentSceneConfig = config.prompts[scene]
                    ?: ScenePromptConfig(userPrompt = "", enabled = true)

                // ä¿å­˜å½“å‰ç‰ˆæœ¬åˆ°å†å²
                val updatedSceneConfig = currentSceneConfig
                    .addHistory(currentSceneConfig.userPrompt)
                    .copy(userPrompt = prompt)

                val updatedConfig = config.copy(
                    prompts = config.prompts + (scene to updatedSceneConfig)
                )

                fileStorage.writeGlobalConfig(updatedConfig).also {
                    if (it.isSuccess) {
                        cachedConfig = updatedConfig
                    }
                }
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }

    override suspend fun resetGlobalPromptToDefault(scene: PromptScene): Result<Unit> {
        return saveGlobalPrompt(scene, DefaultPrompts.getDefault(scene))
    }

    override suspend fun getPromptHistory(scene: PromptScene): List<PromptHistoryItem> {
        val config = getOrLoadConfig()
        return config.prompts[scene]?.history ?: emptyList()
    }

    override suspend fun restoreFromHistory(
        scene: PromptScene,
        historyIndex: Int
    ): Result<Unit> {
        val history = getPromptHistory(scene)
        if (historyIndex !in history.indices) {
            return Result.failure(IndexOutOfBoundsException("å†å²è®°å½•ç´¢å¼•æ— æ•ˆ"))
        }
        return saveGlobalPrompt(scene, history[historyIndex].userPrompt)
    }

    override suspend fun isPromptEnabled(scene: PromptScene): Boolean {
        val config = getOrLoadConfig()
        return config.prompts[scene]?.enabled ?: true
    }

    override suspend fun setPromptEnabled(scene: PromptScene, enabled: Boolean): Result<Unit> {
        return cacheLock.withLock {
            try {
                val config = getOrLoadConfig()
                val currentSceneConfig = config.prompts[scene]
                    ?: ScenePromptConfig(
                        userPrompt = DefaultPrompts.getDefault(scene),
                        enabled = true
                    )

                val updatedConfig = config.copy(
                    prompts = config.prompts + (scene to currentSceneConfig.copy(enabled = enabled))
                )

                fileStorage.writeGlobalConfig(updatedConfig).also {
                    if (it.isSuccess) {
                        cachedConfig = updatedConfig
                    }
                }
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }

    override suspend fun getContactPrompt(contactId: String): String? {
        return contactDao.getCustomPrompt(contactId)
    }

    override suspend fun saveContactPrompt(contactId: String, prompt: String?): Result<Unit> {
        return try {
            contactDao.updateCustomPrompt(contactId, prompt)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    override suspend fun clearContactPrompt(contactId: String): Result<Unit> {
        return saveContactPrompt(contactId, null)
    }

    private suspend fun getOrLoadConfig(): GlobalPromptConfig {
        return cachedConfig ?: run {
            val result = fileStorage.readGlobalConfig()
            result.getOrElse { GlobalPromptConfig.createDefault() }.also {
                cachedConfig = it
            }
        }
    }
}
```


### 3. ContactDao æ‰©å±•

```kotlin
@Dao
interface ContactDao {
    // ... ç°æœ‰æ–¹æ³• ...

    /**
     * è·å–è”ç³»äººçš„è‡ªå®šä¹‰æç¤ºè¯
     */
    @Query("SELECT custom_prompt FROM contact_profiles WHERE id = :contactId")
    suspend fun getCustomPrompt(contactId: String): String?

    /**
     * æ›´æ–°è”ç³»äººçš„è‡ªå®šä¹‰æç¤ºè¯
     */
    @Query("UPDATE contact_profiles SET custom_prompt = :prompt WHERE id = :contactId")
    suspend fun updateCustomPrompt(contactId: String, prompt: String?)
}
```

### 4. Hilt ä¾èµ–æ³¨å…¥æ¨¡å—

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object PromptModule {

    @Provides
    @Singleton
    fun providePromptFileStorage(
        @ApplicationContext context: Context,
        moshi: Moshi
    ): PromptFileStorage {
        return PromptFileStorage(context, moshi)
    }

    @Provides
    @Singleton
    fun providePromptVariableResolver(): PromptVariableResolver {
        return PromptVariableResolver()
    }

    @Provides
    @Singleton
    fun providePromptValidator(
        variableResolver: PromptVariableResolver
    ): PromptValidator {
        return PromptValidator(variableResolver)
    }

    @Provides
    @Singleton
    fun providePromptRepository(
        fileStorage: PromptFileStorage,
        contactDao: ContactDao
    ): PromptRepository {
        return PromptRepositoryImpl(fileStorage, contactDao)
    }

    @Provides
    @Singleton
    fun providePromptBuilder(
        promptRepository: PromptRepository,
        variableResolver: PromptVariableResolver
    ): PromptBuilder {
        return PromptBuilder(promptRepository, variableResolver)
    }
}
```

---

## ğŸ”’ å®‰å…¨æ€§è®¾è®¡

### 1. é…ç½®æ–‡ä»¶å¤‡ä»½æœºåˆ¶

**èŒè´£**ï¼šé˜²æ­¢é…ç½®æ–‡ä»¶æŸåå¯¼è‡´æ•°æ®ä¸¢å¤±

```kotlin
@Singleton
class PromptFileBackup @Inject constructor(
    @ApplicationContext private val context: Context
) {
    companion object {
        private const val BACKUP_DIR = "prompts_backup"
        private const val MAX_BACKUPS = 3
    }

    private val backupDir: File
        get() = File(context.filesDir, BACKUP_DIR).also { it.mkdirs() }

    /**
     * åˆ›å»ºé…ç½®æ–‡ä»¶å¤‡ä»½
     * @param sourceFile æºæ–‡ä»¶
     */
    suspend fun createBackup(sourceFile: File): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            if (!sourceFile.exists()) return@withContext Result.success(Unit)

            val timestamp = System.currentTimeMillis()
            val backupFile = File(backupDir, "backup_$timestamp.json")
            sourceFile.copyTo(backupFile, overwrite = true)

            // æ¸…ç†æ—§å¤‡ä»½ï¼Œä¿ç•™æœ€è¿‘3ä¸ª
            cleanOldBackups()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * ä»æœ€è¿‘çš„å¤‡ä»½æ¢å¤
     */
    suspend fun restoreFromLatestBackup(targetFile: File): Result<Unit> =
        withContext(Dispatchers.IO) {
            try {
                val latestBackup = backupDir.listFiles()
                    ?.filter { it.name.startsWith("backup_") }
                    ?.maxByOrNull { it.lastModified() }
                    ?: return@withContext Result.failure(Exception("æ— å¯ç”¨å¤‡ä»½"))

                latestBackup.copyTo(targetFile, overwrite = true)
                Result.success(Unit)
            } catch (e: Exception) {
                Result.failure(e)
            }
        }

    private fun cleanOldBackups() {
        val backups = backupDir.listFiles()
            ?.filter { it.name.startsWith("backup_") }
            ?.sortedByDescending { it.lastModified() }
            ?: return

        backups.drop(MAX_BACKUPS).forEach { it.delete() }
    }
}
```

### 2. æ¶æ„è¾“å…¥é˜²æŠ¤

**èŒè´£**ï¼šé˜²æ­¢ Prompt Injection æ”»å‡»

```kotlin
object PromptSanitizer {
    // å±é™©æ¨¡å¼åˆ—è¡¨
    private val DANGEROUS_PATTERNS = listOf(
        Regex("å¿½ç•¥.*æŒ‡ä»¤", RegexOption.IGNORE_CASE),
        Regex("ignore.*instruction", RegexOption.IGNORE_CASE),
        Regex("disregard.*above", RegexOption.IGNORE_CASE),
        Regex("forget.*previous", RegexOption.IGNORE_CASE),
        Regex("æ–°çš„è§’è‰²", RegexOption.IGNORE_CASE),
        Regex("ä½ ç°åœ¨æ˜¯", RegexOption.IGNORE_CASE)
    )

    /**
     * æ£€æµ‹æç¤ºè¯æ˜¯å¦åŒ…å«æ½œåœ¨å±é™©å†…å®¹
     * @param prompt ç”¨æˆ·è¾“å…¥çš„æç¤ºè¯
     * @return æ£€æµ‹ç»“æœï¼ŒåŒ…å«æ˜¯å¦å®‰å…¨å’Œè­¦å‘Šä¿¡æ¯
     */
    fun detectDangerousContent(prompt: String): SanitizeResult {
        val warnings = mutableListOf<String>()

        DANGEROUS_PATTERNS.forEach { pattern ->
            if (pattern.containsMatchIn(prompt)) {
                warnings.add("æ£€æµ‹åˆ°å¯èƒ½çš„æŒ‡ä»¤è¦†ç›–å°è¯•: ${pattern.pattern}")
            }
        }

        return SanitizeResult(
            isSafe = warnings.isEmpty(),
            warnings = warnings
        )
    }

    data class SanitizeResult(
        val isSafe: Boolean,
        val warnings: List<String>
    )
}
```

### 3. å¢å¼ºçš„ PromptValidator

```kotlin
@Singleton
class PromptValidator @Inject constructor(
    private val variableResolver: PromptVariableResolver
) {
    companion object {
        const val MAX_PROMPT_LENGTH = 1000
    }

    fun validate(prompt: String, scene: PromptScene): PromptValidationResult {
        // 1. é•¿åº¦æ£€æŸ¥
        if (prompt.length > MAX_PROMPT_LENGTH) {
            return PromptValidationResult.Error(
                message = "æç¤ºè¯é•¿åº¦ä¸èƒ½è¶…è¿‡${MAX_PROMPT_LENGTH}å­—ç¬¦",
                errorType = PromptValidationResult.ErrorType.TOO_LONG
            )
        }

        // 2. å˜é‡æœ‰æ•ˆæ€§æ£€æŸ¥
        val invalidVariables = variableResolver.findInvalidVariables(
            template = prompt,
            allowedVariables = scene.availableVariables
        )
        if (invalidVariables.isNotEmpty()) {
            return PromptValidationResult.Error(
                message = "åŒ…å«æ— æ•ˆå˜é‡: ${invalidVariables.joinToString(", ")}",
                errorType = PromptValidationResult.ErrorType.INVALID_VARIABLE
            )
        }

        // 3. å®‰å…¨æ€§æ£€æŸ¥ï¼ˆè­¦å‘Šä½†ä¸é˜»æ­¢ï¼‰
        val sanitizeResult = PromptSanitizer.detectDangerousContent(prompt)
        if (!sanitizeResult.isSafe) {
            return PromptValidationResult.Warning(
                message = "æ£€æµ‹åˆ°æ½œåœ¨é£é™©å†…å®¹ï¼Œå»ºè®®ä¿®æ”¹",
                warnings = sanitizeResult.warnings
            )
        }

        return PromptValidationResult.Success
    }
}

// æ‰©å±•éªŒè¯ç»“æœç±»å‹
sealed class PromptValidationResult {
    object Success : PromptValidationResult()

    data class Warning(
        val message: String,
        val warnings: List<String>
    ) : PromptValidationResult()

    data class Error(
        val message: String,
        val errorType: ErrorType
    ) : PromptValidationResult()

    enum class ErrorType {
        TOO_LONG,
        EMPTY,
        INVALID_VARIABLE
    }
}
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–è®¾è®¡

### 1. æ­£åˆ™è¡¨è¾¾å¼ç¼–è¯‘ç¼“å­˜

```kotlin
@Singleton
class PromptVariableResolver @Inject constructor() {

    companion object {
        // é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼ï¼Œé¿å…é‡å¤ç¼–è¯‘
        private val VARIABLE_PATTERN: Regex by lazy {
            Regex("\\{\\{(\\w+)\\}\\}", RegexOption.IGNORE_CASE)
        }
    }

    // å˜é‡æ›¿æ¢ç»“æœç¼“å­˜
    private val resolveCache = LruCache<CacheKey, String>(50)

    data class CacheKey(
        val template: String,
        val contextHash: Int
    )

    fun resolve(template: String, context: PromptContext): String {
        val cacheKey = CacheKey(template, context.hashCode())

        // å°è¯•ä»ç¼“å­˜è·å–
        resolveCache.get(cacheKey)?.let { return it }

        // æ‰§è¡Œæ›¿æ¢
        val result = VARIABLE_PATTERN.replace(template) { match ->
            val variableName = match.groupValues[1].lowercase()
            context.getVariable(variableName) ?: match.value
        }

        // å­˜å…¥ç¼“å­˜
        resolveCache.put(cacheKey, result)
        return result
    }

    /**
     * æ¸…é™¤ç¼“å­˜ï¼ˆé…ç½®å˜æ›´æ—¶è°ƒç”¨ï¼‰
     */
    fun clearCache() {
        resolveCache.evictAll()
    }
}
```

### 2. å¼‚æ­¥æ–‡ä»¶æ“ä½œ

```kotlin
@Singleton
class PromptFileStorage @Inject constructor(
    @ApplicationContext private val context: Context,
    private val moshi: Moshi,
    private val backup: PromptFileBackup
) {
    // ä½¿ç”¨ä¸“ç”¨çš„IOè°ƒåº¦å™¨
    private val ioDispatcher = Dispatchers.IO

    // å†…å­˜ç¼“å­˜ï¼Œå‡å°‘æ–‡ä»¶è¯»å–
    @Volatile
    private var cachedConfig: GlobalPromptConfig? = null
    private val cacheLock = Mutex()

    suspend fun readGlobalConfig(): Result<GlobalPromptConfig> = withContext(ioDispatcher) {
        // ä¼˜å…ˆè¿”å›ç¼“å­˜
        cachedConfig?.let { return@withContext Result.success(it) }

        cacheLock.withLock {
            // åŒé‡æ£€æŸ¥
            cachedConfig?.let { return@withContext Result.success(it) }

            try {
                if (!globalPromptsFile.exists()) {
                    val defaultConfig = GlobalPromptConfig.createDefault()
                    writeGlobalConfigInternal(defaultConfig)
                    cachedConfig = defaultConfig
                    return@withContext Result.success(defaultConfig)
                }

                val json = globalPromptsFile.readText(Charsets.UTF_8)
                val config = adapter.fromJson(json)
                    ?: return@withContext Result.failure(Exception("è§£æå¤±è´¥"))

                cachedConfig = config
                Result.success(config)
            } catch (e: Exception) {
                // å°è¯•ä»å¤‡ä»½æ¢å¤
                backup.restoreFromLatestBackup(globalPromptsFile)
                    .onSuccess {
                        return@withContext readGlobalConfig() // é‡è¯•
                    }
                Result.failure(e)
            }
        }
    }

    suspend fun writeGlobalConfig(config: GlobalPromptConfig): Result<Unit> =
        withContext(ioDispatcher) {
            cacheLock.withLock {
                try {
                    // å…ˆå¤‡ä»½
                    backup.createBackup(globalPromptsFile)

                    // å†™å…¥æ–°é…ç½®
                    writeGlobalConfigInternal(config)
                    cachedConfig = config
                    Result.success(Unit)
                } catch (e: Exception) {
                    Result.failure(e)
                }
            }
        }

    private fun writeGlobalConfigInternal(config: GlobalPromptConfig) {
        val updatedConfig = config.copy(
            lastModified = java.time.Instant.now().toString()
        )
        val json = adapter.toJson(updatedConfig)
        globalPromptsFile.writeText(json, Charsets.UTF_8)
    }

    /**
     * ä½¿ç¼“å­˜å¤±æ•ˆ
     */
    fun invalidateCache() {
        cachedConfig = null
    }
}
```

### 3. æ€§èƒ½ç›‘æ§æŒ‡æ ‡

```kotlin
object PromptPerformanceMetrics {
    private val metrics = ConcurrentHashMap<String, MutableList<Long>>()

    /**
     * è®°å½•æ“ä½œè€—æ—¶
     */
    fun recordLatency(operation: String, latencyMs: Long) {
        metrics.getOrPut(operation) { mutableListOf() }.add(latencyMs)

        // ä¿ç•™æœ€è¿‘100æ¡è®°å½•
        metrics[operation]?.let { list ->
            if (list.size > 100) {
                list.removeAt(0)
            }
        }
    }

    /**
     * è·å–å¹³å‡è€—æ—¶
     */
    fun getAverageLatency(operation: String): Double {
        return metrics[operation]?.average() ?: 0.0
    }

    /**
     * æ£€æŸ¥æ˜¯å¦è¶…è¿‡é˜ˆå€¼
     */
    fun checkThreshold(operation: String, thresholdMs: Long): Boolean {
        val avg = getAverageLatency(operation)
        if (avg > thresholdMs) {
            Log.w("PromptMetrics", "$operation å¹³å‡è€—æ—¶ ${avg}ms è¶…è¿‡é˜ˆå€¼ ${thresholdMs}ms")
            return true
        }
        return false
    }

    // é¢„å®šä¹‰æ“ä½œåç§°
    const val OP_RESOLVE_VARIABLES = "resolve_variables"
    const val OP_BUILD_INSTRUCTION = "build_instruction"
    const val OP_READ_CONFIG = "read_config"
    const val OP_WRITE_CONFIG = "write_config"
}

// ä½¿ç”¨ç¤ºä¾‹
suspend fun buildSystemInstruction(...): String {
    val startTime = System.currentTimeMillis()

    val result = // ... æ„å»ºé€»è¾‘

    PromptPerformanceMetrics.recordLatency(
        PromptPerformanceMetrics.OP_BUILD_INSTRUCTION,
        System.currentTimeMillis() - startTime
    )

    return result
}
```

---

## ğŸ“… å®æ–½è®¡åˆ’

### æ€»ä½“æ—¶é—´è§„åˆ’

**é¢„è®¡æ€»å·¥ä½œé‡**: 5-7ä¸ªå·¥ä½œæ—¥  
**å»ºè®®å›¢é˜Ÿè§„æ¨¡**: 1åå¼€å‘å·¥ç¨‹å¸ˆ  
**å¼€å§‹æ—¥æœŸ**: å¾…å®š  
**ç›®æ ‡å®Œæˆæ—¥æœŸ**: å¼€å§‹å1å‘¨å†…

### é˜¶æ®µåˆ’åˆ†

#### é˜¶æ®µ1ï¼šæ•°æ®æ¨¡å‹å’Œå­˜å‚¨å±‚ï¼ˆ1-2å¤©ï¼‰

**ç›®æ ‡**: å»ºç«‹æ•°æ®æ¨¡å‹å’Œå­˜å‚¨åŸºç¡€è®¾æ–½

**äº¤ä»˜ç‰©**:
- [ ] `PromptScene.kt` - åœºæ™¯æšä¸¾
- [ ] `PromptContext.kt` - å˜é‡ä¸Šä¸‹æ–‡
- [ ] `GlobalPromptConfig.kt` - å…¨å±€é…ç½®æ¨¡å‹
- [ ] `PromptFileStorage.kt` - JSONæ–‡ä»¶å­˜å‚¨
- [ ] `DefaultPrompts.kt` - é»˜è®¤æç¤ºè¯æ¨¡æ¿
- [ ] æ•°æ®åº“è¿ç§»è„šæœ¬ `MIGRATION_8_9`

**éªŒæ”¶æ ‡å‡†**:
- JSONæ–‡ä»¶èƒ½æ­£ç¡®è¯»å†™
- é¦–æ¬¡å¯åŠ¨è‡ªåŠ¨åˆ›å»ºé»˜è®¤é…ç½®
- æ•°æ®åº“è¿ç§»æˆåŠŸï¼Œä¸ä¸¢å¤±æ•°æ®

---

#### é˜¶æ®µ2ï¼šæ ¸å¿ƒç»„ä»¶å®ç°ï¼ˆ1-2å¤©ï¼‰

**ç›®æ ‡**: å®ç°å˜é‡è§£æå’Œæç¤ºè¯æ„å»ºæ ¸å¿ƒé€»è¾‘

**äº¤ä»˜ç‰©**:
- [ ] `PromptVariableResolver.kt` - å˜é‡è§£æå™¨
- [ ] `PromptValidator.kt` - è¾“å…¥éªŒè¯å™¨
- [ ] `SystemPrompts.kt` - ç³»ç»Ÿæç¤ºè¯å¸¸é‡
- [ ] `PromptBuilder.kt` - æç¤ºè¯æ„å»ºå™¨

**éªŒæ”¶æ ‡å‡†**:
- å˜é‡ `{{xxx}}` èƒ½æ­£ç¡®è§£æå’Œæ›¿æ¢
- è¶…é•¿æç¤ºè¯è¢«æ­£ç¡®æ‹¦æˆª
- æç¤ºè¯åˆå¹¶é¡ºåºæ­£ç¡®

---

#### é˜¶æ®µ3ï¼šä»“åº“å±‚å®ç°ï¼ˆ1å¤©ï¼‰

**ç›®æ ‡**: å®ç°å®Œæ•´çš„æ•°æ®è®¿é—®å±‚

**äº¤ä»˜ç‰©**:
- [ ] `PromptRepository.kt` - ä»“åº“æ¥å£
- [ ] `PromptRepositoryImpl.kt` - ä»“åº“å®ç°
- [ ] `PromptModule.kt` - Hiltä¾èµ–æ³¨å…¥
- [ ] ContactDaoæ‰©å±•æ–¹æ³•

**éªŒæ”¶æ ‡å‡†**:
- å…¨å±€æç¤ºè¯CRUDæ­£å¸¸
- è”ç³»äººæç¤ºè¯CRUDæ­£å¸¸
- å†å²è®°å½•ä¿å­˜å’Œæ¢å¤æ­£å¸¸

---

#### é˜¶æ®µ4ï¼šé›†æˆç°æœ‰AIè°ƒç”¨ï¼ˆ1-2å¤©ï¼‰

**ç›®æ ‡**: å°†æç¤ºè¯ç³»ç»Ÿé›†æˆåˆ°ç°æœ‰AIè°ƒç”¨æµç¨‹

**äº¤ä»˜ç‰©**:
- [ ] ä¿®æ”¹ `AnalyzeChatUseCase.kt` ä½¿ç”¨ PromptBuilder
- [ ] ä¿®æ”¹ `CheckDraftUseCase.kt` ä½¿ç”¨ PromptBuilder
- [ ] ä¿®æ”¹ `SummarizeDailyConversationsUseCase.kt` ä½¿ç”¨ PromptBuilder
- [ ] ä¿®æ”¹ `AiRepositoryImpl.kt` æ”¯æŒæ–°çš„æç¤ºè¯ç»“æ„

**éªŒæ”¶æ ‡å‡†**:
- ç°æœ‰AIåŠŸèƒ½æ­£å¸¸å·¥ä½œ
- ç”¨æˆ·è‡ªå®šä¹‰æç¤ºè¯ç”Ÿæ•ˆ
- è”ç³»äººä¸“å±æç¤ºè¯ç”Ÿæ•ˆ

---

#### é˜¶æ®µ5ï¼šæµ‹è¯•å’Œæ–‡æ¡£ï¼ˆ1å¤©ï¼‰

**ç›®æ ‡**: ç¡®ä¿è´¨é‡å’Œå®Œå–„æ–‡æ¡£

**äº¤ä»˜ç‰©**:
- [ ] å•å…ƒæµ‹è¯•ï¼ˆè¦†ç›–ç‡â‰¥80%ï¼‰
- [ ] é›†æˆæµ‹è¯•
- [ ] ä½¿ç”¨æ–‡æ¡£

**éªŒæ”¶æ ‡å‡†**:
- æ‰€æœ‰æµ‹è¯•é€šè¿‡
- æ–‡æ¡£å®Œæ•´æ¸…æ™°


### é‡Œç¨‹ç¢‘å’Œäº¤ä»˜ç‰©

| é‡Œç¨‹ç¢‘ | å®Œæˆæ—¥æœŸ | äº¤ä»˜ç‰© | éªŒæ”¶æ ‡å‡† |
|--------|---------|--------|---------|
| M1: æ•°æ®å±‚å®Œæˆ | D+2 | æ•°æ®æ¨¡å‹ã€å­˜å‚¨ã€è¿ç§» | æ–‡ä»¶è¯»å†™æ­£å¸¸ï¼Œè¿ç§»æˆåŠŸ |
| M2: æ ¸å¿ƒç»„ä»¶å®Œæˆ | D+4 | å˜é‡è§£æã€éªŒè¯ã€æ„å»ºå™¨ | å˜é‡æ›¿æ¢æ­£ç¡®ï¼ŒéªŒè¯æœ‰æ•ˆ |
| M3: ä»“åº“å±‚å®Œæˆ | D+5 | Repositoryæ¥å£å’Œå®ç° | CRUDæ“ä½œæ­£å¸¸ |
| M4: é›†æˆå®Œæˆ | D+7 | UseCaseé›†æˆ | AIåŠŸèƒ½æ­£å¸¸ï¼Œæç¤ºè¯ç”Ÿæ•ˆ |
| M5: æµ‹è¯•å®Œæˆ | D+7 | æµ‹è¯•æŠ¥å‘Š | æ‰€æœ‰æµ‹è¯•é€šè¿‡ |

### é£é™©è¯„ä¼°

| é£é™© | ä¸¥é‡ç¨‹åº¦ | æ¦‚ç‡ | å½±å“ | åº”å¯¹æªæ–½ |
|------|---------|------|------|---------|
| JSONè§£æå¤±è´¥ | ğŸŸ¡ ä¸­ | 20% | é…ç½®ä¸¢å¤± | æä¾›é»˜è®¤å€¼å›é€€ï¼Œå¤‡ä»½æœºåˆ¶ |
| æ•°æ®åº“è¿ç§»å¤±è´¥ | ğŸ”´ é«˜ | 10% | æ•°æ®ä¸¢å¤± | å®Œæ•´æµ‹è¯•è¿ç§»è„šæœ¬ï¼Œæä¾›å›æ»šæ–¹æ¡ˆ |
| å˜é‡æ›¿æ¢æ€§èƒ½é—®é¢˜ | ğŸŸ¢ ä½ | 10% | å“åº”å˜æ…¢ | æ­£åˆ™è¡¨è¾¾å¼ä¼˜åŒ–ï¼Œç¼“å­˜ç¼–è¯‘ç»“æœ |
| ä¸ç°æœ‰ä»£ç å†²çª | ğŸŸ¡ ä¸­ | 30% | åŠŸèƒ½å¼‚å¸¸ | æ¸è¿›å¼é›†æˆï¼Œå……åˆ†æµ‹è¯• |

---

## âš ï¸ é”™è¯¯å¤„ç†æœºåˆ¶

### 1. é”™è¯¯ç±»å‹å®šä¹‰

```kotlin
sealed class PromptError : Exception() {
    data class FileReadError(
        override val message: String = "è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥"
    ) : PromptError()

    data class FileWriteError(
        override val message: String = "ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥"
    ) : PromptError()

    data class ValidationError(
        override val message: String,
        val errorType: PromptValidationResult.ErrorType
    ) : PromptError()

    data class DatabaseError(
        override val message: String = "æ•°æ®åº“æ“ä½œå¤±è´¥"
    ) : PromptError()

    data class HistoryNotFoundError(
        override val message: String = "å†å²è®°å½•ä¸å­˜åœ¨"
    ) : PromptError()
}
```

### 2. é”™è¯¯å¤„ç†ç­–ç•¥

```kotlin
// æ–‡ä»¶è¯»å–å¤±è´¥æ—¶çš„å›é€€ç­–ç•¥
suspend fun getGlobalPromptSafe(scene: PromptScene): String {
    return try {
        getGlobalPrompt(scene)
    } catch (e: Exception) {
        Log.e("PromptRepository", "è·å–æç¤ºè¯å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼", e)
        DefaultPrompts.getDefault(scene)
    }
}

// ä¿å­˜å¤±è´¥æ—¶çš„é‡è¯•ç­–ç•¥
suspend fun saveGlobalPromptWithRetry(
    scene: PromptScene,
    prompt: String,
    maxRetries: Int = 3
): Result<Unit> {
    var lastError: Exception? = null
    repeat(maxRetries) { attempt ->
        val result = saveGlobalPrompt(scene, prompt)
        if (result.isSuccess) return result
        lastError = result.exceptionOrNull() as? Exception
        delay(100L * (attempt + 1)) // æŒ‡æ•°é€€é¿
    }
    return Result.failure(lastError ?: Exception("ä¿å­˜å¤±è´¥"))
}
```

### 3. ç”¨æˆ·æç¤º

| é”™è¯¯åœºæ™¯ | ç”¨æˆ·æç¤º | å¤„ç†æ–¹å¼ |
|---------|---------|---------|
| æç¤ºè¯è¿‡é•¿ | "æç¤ºè¯é•¿åº¦ä¸èƒ½è¶…è¿‡1000å­—ç¬¦" | é˜»æ­¢ä¿å­˜ï¼Œæ˜¾ç¤ºå½“å‰å­—æ•° |
| æ— æ•ˆå˜é‡ | "åŒ…å«æ— æ•ˆå˜é‡: xxx" | è­¦å‘Šæç¤ºï¼Œå…è®¸ä¿å­˜ |
| ä¿å­˜å¤±è´¥ | "ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•" | æ˜¾ç¤ºé‡è¯•æŒ‰é’® |
| å†å²æ¢å¤å¤±è´¥ | "æ¢å¤å¤±è´¥ï¼Œå†å²è®°å½•å¯èƒ½å·²æŸå" | æä¾›é‡ç½®é€‰é¡¹ |

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### 1. å•å…ƒæµ‹è¯•

#### PromptVariableResolverTest

```kotlin
class PromptVariableResolverTest {
    private val resolver = PromptVariableResolver()

    @Test
    fun `resolve replaces known variables`() {
        val template = "ä½ å¥½{{contact_name}}ï¼Œä»Šå¤©æ˜¯{{today_date}}"
        val context = PromptContext(
            contactName = "å°æ˜",
            todayDate = "2025-12-16"
        )

        val result = resolver.resolve(template, context)

        assertEquals("ä½ å¥½å°æ˜ï¼Œä»Šå¤©æ˜¯2025-12-16", result)
    }

    @Test
    fun `resolve keeps unknown variables unchanged`() {
        val template = "å˜é‡{{unknown_var}}ä¿æŒåŸæ ·"
        val context = PromptContext()

        val result = resolver.resolve(template, context)

        assertEquals("å˜é‡{{unknown_var}}ä¿æŒåŸæ ·", result)
    }

    @Test
    fun `resolve is case insensitive`() {
        val template = "{{CONTACT_NAME}}å’Œ{{contact_name}}"
        val context = PromptContext(contactName = "æµ‹è¯•")

        val result = resolver.resolve(template, context)

        assertEquals("æµ‹è¯•å’Œæµ‹è¯•", result)
    }

    @Test
    fun `extractVariables returns all variable names`() {
        val template = "{{a}}å’Œ{{b}}è¿˜æœ‰{{a}}"

        val result = resolver.extractVariables(template)

        assertEquals(listOf("a", "b"), result)
    }

    @Test
    fun `findInvalidVariables returns variables not in allowed list`() {
        val template = "{{contact_name}}å’Œ{{invalid}}"
        val allowed = listOf("contact_name", "today_date")

        val result = resolver.findInvalidVariables(template, allowed)

        assertEquals(listOf("invalid"), result)
    }
}
```

#### PromptValidatorTest

```kotlin
class PromptValidatorTest {
    private val resolver = PromptVariableResolver()
    private val validator = PromptValidator(resolver)

    @Test
    fun `validate returns success for valid prompt`() {
        val prompt = "è¿™æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æç¤ºè¯"

        val result = validator.validate(prompt, PromptScene.ANALYZE)

        assertTrue(result is PromptValidationResult.Success)
    }

    @Test
    fun `validate returns error for too long prompt`() {
        val prompt = "a".repeat(1001)

        val result = validator.validate(prompt, PromptScene.ANALYZE)

        assertTrue(result is PromptValidationResult.Error)
        assertEquals(
            PromptValidationResult.ErrorType.TOO_LONG,
            (result as PromptValidationResult.Error).errorType
        )
    }

    @Test
    fun `validate returns error for invalid variables`() {
        val prompt = "ä½¿ç”¨æ— æ•ˆå˜é‡{{invalid_var}}"

        val result = validator.validate(prompt, PromptScene.CHECK)

        assertTrue(result is PromptValidationResult.Error)
        assertEquals(
            PromptValidationResult.ErrorType.INVALID_VARIABLE,
            (result as PromptValidationResult.Error).errorType
        )
    }
}
```

### 2. é›†æˆæµ‹è¯•

```kotlin
@HiltAndroidTest
class PromptRepositoryIntegrationTest {
    @get:Rule
    val hiltRule = HiltAndroidRule(this)

    @Inject
    lateinit var repository: PromptRepository

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun `save and retrieve global prompt`() = runTest {
        val testPrompt = "æµ‹è¯•æç¤ºè¯å†…å®¹"

        repository.saveGlobalPrompt(PromptScene.ANALYZE, testPrompt)
        val result = repository.getGlobalPrompt(PromptScene.ANALYZE)

        assertEquals(testPrompt, result)
    }

    @Test
    fun `history is saved when prompt is updated`() = runTest {
        val prompt1 = "ç¬¬ä¸€ç‰ˆ"
        val prompt2 = "ç¬¬äºŒç‰ˆ"

        repository.saveGlobalPrompt(PromptScene.ANALYZE, prompt1)
        repository.saveGlobalPrompt(PromptScene.ANALYZE, prompt2)

        val history = repository.getPromptHistory(PromptScene.ANALYZE)

        assertEquals(1, history.size)
        assertEquals(prompt1, history[0].userPrompt)
    }

    @Test
    fun `restore from history works correctly`() = runTest {
        val prompt1 = "ç¬¬ä¸€ç‰ˆ"
        val prompt2 = "ç¬¬äºŒç‰ˆ"

        repository.saveGlobalPrompt(PromptScene.ANALYZE, prompt1)
        repository.saveGlobalPrompt(PromptScene.ANALYZE, prompt2)
        repository.restoreFromHistory(PromptScene.ANALYZE, 0)

        val current = repository.getGlobalPrompt(PromptScene.ANALYZE)

        assertEquals(prompt1, current)
    }
}
```

### 3. æµ‹è¯•è¦†ç›–ç›®æ ‡

| æ¨¡å— | ç›®æ ‡è¦†ç›–ç‡ | é‡ç‚¹æµ‹è¯•é¡¹ |
|------|-----------|-----------|
| PromptVariableResolver | 90% | å˜é‡æ›¿æ¢ã€è¾¹ç•Œæƒ…å†µ |
| PromptValidator | 90% | é•¿åº¦éªŒè¯ã€å˜é‡éªŒè¯ |
| PromptBuilder | 85% | åˆå¹¶é¡ºåºã€å˜é‡æ³¨å…¥ |
| PromptRepositoryImpl | 80% | CRUDã€å†å²è®°å½•ã€ç¼“å­˜ |
| PromptFileStorage | 75% | æ–‡ä»¶è¯»å†™ã€é”™è¯¯å¤„ç† |

---

## ï¿½ ä¸ç°æœ‰ä»£ç çš„é›†æˆè®¾è®¡

### 1. AnalyzeChatUseCase é›†æˆ

**å½“å‰å®ç°ä½ç½®**ï¼š`domain/usecase/AnalyzeChatUseCase.kt`

**ä¿®æ”¹æ–¹æ¡ˆ**ï¼š

```kotlin
class AnalyzeChatUseCase @Inject constructor(
    private val aiRepository: AiRepository,
    private val contactRepository: ContactRepository,
    private val promptBuilder: PromptBuilder  // æ–°å¢æ³¨å…¥
) {
    suspend operator fun invoke(
        contactId: String,
        chatHistory: List<ChatMessage>,
        lastMessage: String
    ): Result<AnalysisResult> {
        // 1. è·å–è”ç³»äººä¿¡æ¯
        val contact = contactRepository.getProfile(contactId).getOrNull()
            ?: return Result.failure(Exception("è”ç³»äººä¸å­˜åœ¨"))

        // 2. æ„å»ºå˜é‡ä¸Šä¸‹æ–‡
        val promptContext = PromptContext.fromContact(contact)

        // 3. ä½¿ç”¨ PromptBuilder æ„å»ºç³»ç»ŸæŒ‡ä»¤
        val systemInstruction = promptBuilder.buildSystemInstruction(
            scene = PromptScene.ANALYZE,
            contactId = contactId,
            context = promptContext
        )

        // 4. æ„å»ºä¸Šä¸‹æ–‡æ•°æ®
        val contextData = buildContextData(contact, chatHistory, lastMessage)

        // 5. æ³¨å…¥ä¸Šä¸‹æ–‡æ•°æ®
        val finalInstruction = promptBuilder.injectContextData(
            instruction = systemInstruction,
            contextData = contextData
        )

        // 6. è°ƒç”¨ AI
        return aiRepository.analyzeChat(finalInstruction, lastMessage)
    }

    private fun buildContextData(
        contact: ContactProfile,
        chatHistory: List<ChatMessage>,
        lastMessage: String
    ): String {
        return buildString {
            appendLine("è”ç³»äºº: ${contact.name}")
            appendLine("å·²çŸ¥äº‹å®: ${contact.facts.size}æ¡")
            contact.facts.forEach { fact ->
                appendLine("- ${fact.key}: ${fact.value}")
            }
            appendLine()
            appendLine("å¯¹è¯å†å²:")
            chatHistory.takeLast(10).forEach { msg ->
                appendLine("${msg.role}: ${msg.content}")
            }
            appendLine()
            appendLine("æœ€æ–°æ¶ˆæ¯: $lastMessage")
        }
    }
}
```

### 2. CheckDraftUseCase é›†æˆ

**å½“å‰å®ç°ä½ç½®**ï¼š`domain/usecase/CheckDraftUseCase.kt`

**ä¿®æ”¹æ–¹æ¡ˆ**ï¼š

```kotlin
class CheckDraftUseCase @Inject constructor(
    private val aiRepository: AiRepository,
    private val contactRepository: ContactRepository,
    private val ruleEngine: RuleEngine,
    private val promptBuilder: PromptBuilder  // æ–°å¢æ³¨å…¥
) {
    suspend operator fun invoke(
        contactId: String,
        draft: String
    ): Result<SafetyCheckResult> {
        // 1. æœ¬åœ°è§„åˆ™æ£€æŸ¥ï¼ˆå¿«é€Ÿè·¯å¾„ï¼‰
        val localResult = ruleEngine.checkSafety(draft)
        if (!localResult.isSafe) {
            return Result.success(localResult)
        }

        // 2. è·å–è”ç³»äººä¿¡æ¯
        val contact = contactRepository.getProfile(contactId).getOrNull()

        // 3. æ„å»ºå˜é‡ä¸Šä¸‹æ–‡
        val promptContext = contact?.let { PromptContext.fromContact(it) }
            ?: PromptContext()

        // 4. ä½¿ç”¨ PromptBuilder æ„å»ºç³»ç»ŸæŒ‡ä»¤
        val systemInstruction = promptBuilder.buildSystemInstruction(
            scene = PromptScene.CHECK,
            contactId = contactId,
            context = promptContext
        )

        // 5. æ„å»ºä¸Šä¸‹æ–‡æ•°æ®
        val contextData = buildString {
            appendLine("å¾…æ£€æŸ¥çš„è‰ç¨¿å†…å®¹:")
            appendLine(draft)
            if (contact != null) {
                appendLine()
                appendLine("é›·åŒºæ ‡ç­¾:")
                contact.facts.filter { it.key == "é›·åŒº" }.forEach {
                    appendLine("- ${it.value}")
                }
            }
        }

        // 6. æ³¨å…¥ä¸Šä¸‹æ–‡æ•°æ®å¹¶è°ƒç”¨ AI
        val finalInstruction = promptBuilder.injectContextData(
            instruction = systemInstruction,
            contextData = contextData
        )

        return aiRepository.checkDraft(finalInstruction, draft)
    }
}
```

### 3. SummarizeDailyConversationsUseCase é›†æˆ

**å½“å‰å®ç°ä½ç½®**ï¼š`domain/usecase/SummarizeDailyConversationsUseCase.kt`

**ä¿®æ”¹æ–¹æ¡ˆ**ï¼š

```kotlin
class SummarizeDailyConversationsUseCase @Inject constructor(
    private val conversationRepository: ConversationRepository,
    private val dailySummaryRepository: DailySummaryRepository,
    private val contactRepository: ContactRepository,
    private val aiSummaryProcessor: AiSummaryProcessor,
    private val promptBuilder: PromptBuilder  // æ–°å¢æ³¨å…¥
) {
    suspend operator fun invoke(
        contactId: String,
        date: LocalDate
    ): Result<DailySummary> {
        // 1. è·å–å½“æ—¥å¯¹è¯
        val conversations = conversationRepository
            .getConversationsByContactAndDate(contactId, date)

        if (conversations.isEmpty()) {
            return Result.failure(Exception("å½“æ—¥æ— å¯¹è¯è®°å½•"))
        }

        // 2. è·å–è”ç³»äººä¿¡æ¯
        val contact = contactRepository.getProfile(contactId).getOrNull()

        // 3. æ„å»ºå˜é‡ä¸Šä¸‹æ–‡
        val promptContext = contact?.let { PromptContext.fromContact(it) }
            ?: PromptContext(todayDate = date.toString())

        // 4. ä½¿ç”¨ PromptBuilder æ„å»ºç³»ç»ŸæŒ‡ä»¤
        val systemInstruction = promptBuilder.buildSystemInstruction(
            scene = PromptScene.SUMMARY,
            contactId = contactId,
            context = promptContext
        )

        // 5. æ„å»ºä¸Šä¸‹æ–‡æ•°æ®
        val contextData = buildString {
            appendLine("æ—¥æœŸ: $date")
            appendLine("å¯¹è¯è®°å½•:")
            conversations.forEach { conv ->
                appendLine("[${conv.timestamp}] ${conv.content}")
            }
        }

        // 6. æ³¨å…¥ä¸Šä¸‹æ–‡æ•°æ®
        val finalInstruction = promptBuilder.injectContextData(
            instruction = systemInstruction,
            contextData = contextData
        )

        // 7. è°ƒç”¨ AI ç”Ÿæˆæ€»ç»“
        return aiSummaryProcessor.generateSummary(
            contactId = contactId,
            date = date,
            instruction = finalInstruction,
            conversations = conversations
        )
    }
}
```

### 4. ä¸ç°æœ‰ PromptTemplates çš„å…¼å®¹

**å½“å‰å®ç°ä½ç½®**ï¼š`domain/util/PromptTemplates.kt`

**è¿ç§»ç­–ç•¥**ï¼š

```kotlin
// ä¿ç•™ PromptTemplates ä½œä¸ºè¿‡æ¸¡ï¼Œæ ‡è®°ä¸º @Deprecated
@Deprecated(
    message = "è¯·ä½¿ç”¨ PromptBuilder å’Œ SystemPrompts",
    replaceWith = ReplaceWith("PromptBuilder")
)
object PromptTemplates {
    // ç°æœ‰ä»£ç ä¿æŒä¸å˜ï¼Œé€æ­¥è¿ç§»
}

// æ–°ä»£ç ç»Ÿä¸€ä½¿ç”¨ PromptBuilder
// è¿ç§»å®Œæˆååˆ é™¤ PromptTemplates
```

### 5. æ•°æ®åº“ç‰ˆæœ¬å‡çº§è·¯å¾„

**å½“å‰ç‰ˆæœ¬**ï¼šv7ï¼ˆåŸºäº AppDatabase.ktï¼‰

**å‡çº§åˆ° v8**ï¼š

```kotlin
// AppDatabase.kt
@Database(
    entities = [
        ContactProfileEntity::class,
        // ... å…¶ä»–å®ä½“
    ],
    version = 8,  // ä» 7 å‡çº§åˆ° 8
    exportSchema = true
)
abstract class AppDatabase : RoomDatabase() {
    // ...
}

// è¿ç§»è„šæœ¬
val MIGRATION_7_8 = object : Migration(7, 8) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL(
            "ALTER TABLE contact_profiles ADD COLUMN custom_prompt TEXT DEFAULT NULL"
        )
    }
}

// DatabaseModule.kt ä¸­æ³¨å†Œè¿ç§»
@Provides
@Singleton
fun provideDatabase(@ApplicationContext context: Context): AppDatabase {
    return Room.databaseBuilder(context, AppDatabase::class.java, "empathy_db")
        .addMigrations(
            MIGRATION_1_2,
            MIGRATION_2_3,
            // ... å…¶ä»–è¿ç§»
            MIGRATION_7_8  // æ–°å¢
        )
        .build()
}
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [PRD-00005-æç¤ºè¯ç®¡ç†ç³»ç»Ÿéœ€æ±‚](../PRD/PRD-00005-æç¤ºè¯ç®¡ç†ç³»ç»Ÿéœ€æ±‚.md)
- [RESEARCH-00001-æç¤ºè¯ç³»ç»Ÿè°ƒç ”æŠ¥å‘Š](../è°ƒç ”/RESEARCH-00001-æç¤ºè¯ç³»ç»Ÿè°ƒç ”æŠ¥å‘Š.md)
- [å½“å‰æç¤ºè¯å®ç°åˆ†æ](../../ç‰¹æ®Šè¦æ±‚/å½“å‰æç¤ºè¯å®ç°åˆ†æ.md)
