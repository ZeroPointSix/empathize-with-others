# FD-00008 输入内容身份识别与双向对话历史功能设计

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档编号 | FD-00008 |
| 创建日期 | 2025-12-17 |
| 更新日期 | 2025-12-17 |
| 状态 | 草稿 |
| 关联PRD | PRD-00008 |
| 关联文档 | PRD-00007、FD-00007 |

---

## 1. 功能概述

### 1.1 功能目标

实现输入内容的自动身份识别，让 AI 能够区分"对方说的"和"我要回复的"，从而提供更精准的分析和建议。

### 1.2 核心功能点

| 功能点 | 描述 |
|-------|------|
| 身份前缀自动拼接 | 根据按钮类型自动添加 `【对方说】：` 或 `【我正在回复】：` |
| 双向对话历史存储 | 分析功能存储历史，检查功能不存储 |
| 系统提示词增强 | 让 AI 理解身份标识的含义 |
| UI 渲染优化 | 以自然对话流形式展示历史记录 |

---

## 2. 功能流程设计

### 2.1 【帮我分析】功能流程

```
┌─────────────────────────────────────────────────────────────┐
│                    用户点击【帮我分析】                        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 1. 获取输入框内容                                            │
│    rawInput = "你怎么才回消息？"                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. 添加身份前缀                                              │
│    prefixedInput = "【对方说】：你怎么才回消息？"              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. 保存到对话历史                                            │
│    conversationRepository.saveUserInput(contactId, prefixedInput) │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. 构建历史上下文（带身份前缀）                               │
│    historyContext = conversationContextBuilder.build(...)    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. 组装 Prompt（含身份识别说明 + 防回声规则）                  │
│    systemInstruction = promptBuilder.buildSystemInstruction(...) │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. 调用 AI 分析                                              │
│    aiRepository.analyzeChat(provider, runtimeData, systemInstruction) │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 7. 返回分析结果                                              │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 【帮我检查】功能流程

```
┌─────────────────────────────────────────────────────────────┐
│                    用户点击【帮我检查】                        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 1. 获取输入框内容                                            │
│    rawDraft = "刚才在忙"                                     │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. 添加身份前缀                                              │
│    prefixedDraft = "【我正在回复】：刚才在忙"                  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. 【不保存】到对话历史                                       │
│    // 检查功能不存储，因为只是草稿预检查                       │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. 组装 Prompt（含身份识别说明 + 防回声规则）                  │
│    systemInstruction = promptBuilder.buildSimpleInstruction(...) │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. 调用 AI 检查                                              │
│    aiRepository.checkDraftSafety(provider, prefixedDraft, ...) │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. 返回检查结果                                              │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 历史上下文构建流程

```
┌─────────────────────────────────────────────────────────────┐
│                 构建历史上下文                                │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 1. 查询最近 N 条对话记录                                     │
│    recentLogs = conversationRepository.getRecentConversations(...) │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. 遍历每条记录，解析身份前缀                                 │
│    for (log in recentLogs) {                                 │
│        val (sender, content) = parseIdentityPrefix(log.userInput) │
│    }                                                         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. 计算时间流逝标记                                          │
│    marker = calculateTimeMarker(previousTimestamp, currentTimestamp) │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. 拼接历史上下文字符串                                       │
│    【历史对话】(最近5条)                                      │
│    [历史记录 - 08:30]: 【对方说】：早安                        │
│    [历史记录 - 08:32]: 【我正在回复】：早呀                    │
│    --- (对话暂停了 2 小时) ---                                │
│    [历史记录 - 10:30]: 【对方说】：你在干嘛                    │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 身份前缀设计

### 3.1 前缀常量定义

```kotlin
object IdentityPrefix {
    /** 对方说的内容前缀 */
    const val CONTACT = "【对方说】："
    
    /** 我正在回复的内容前缀 */
    const val USER = "【我正在回复】："
}
```

### 3.2 按钮与前缀映射

| 按钮 | ActionType | 身份前缀 | 是否存储历史 |
|-----|-----------|---------|------------|
| 帮我分析 | ANALYZE | `【对方说】：` | ✅ 是 |
| 帮我检查 | CHECK | `【我正在回复】：` | ❌ 否 |
| 帮我润色（未来） | POLISH | `【我正在回复】：` | ✅ 是（复制后） |

### 3.3 前缀处理逻辑

#### 3.3.1 添加前缀（防双重前缀）

```kotlin
/**
 * 安全地添加身份前缀
 *
 * 防御性编程：如果用户输入已经包含前缀，不重复添加
 *
 * @param content 用户输入内容
 * @param actionType 操作类型
 * @return 带前缀的内容
 */
fun addIdentityPrefix(content: String, actionType: ActionType): String {
    // 先清理可能存在的前缀（防止双重前缀）
    val cleanContent = stripAllPrefixes(content)
    
    // 根据操作类型添加对应前缀
    val prefix = when (actionType) {
        ActionType.ANALYZE -> IdentityPrefix.CONTACT
        ActionType.CHECK -> IdentityPrefix.USER
        ActionType.POLISH -> IdentityPrefix.USER
    }
    
    return "$prefix$cleanContent"
}

/**
 * 去除所有身份前缀（递归处理，防止多重前缀）
 *
 * 场景：用户从截图 OCR 复制了带前缀的内容
 * 输入：【对方说】：【对方说】：真的吗？
 * 输出：真的吗？
 */
fun stripAllPrefixes(content: String): String {
    var result = content
    
    // 循环去除，直到没有前缀为止
    while (true) {
        val stripped = when {
            result.startsWith(IdentityPrefix.CONTACT) ->
                result.removePrefix(IdentityPrefix.CONTACT)
            result.startsWith(IdentityPrefix.USER) ->
                result.removePrefix(IdentityPrefix.USER)
            else -> result
        }
        
        if (stripped == result) break  // 没有更多前缀了
        result = stripped
    }
    
    return result
}
```

#### 3.3.2 解析前缀

```kotlin
/**
 * 解析身份前缀
 *
 * @param content 原始内容（可能带前缀）
 * @return Pair<身份标识, 纯内容>
 */
fun parseIdentityPrefix(content: String): Pair<String, String> {
    // 先清理多重前缀
    val cleanContent = stripAllPrefixes(content)
    
    // 判断原始内容的身份
    return when {
        content.startsWith(IdentityPrefix.CONTACT) ->
            "对方" to cleanContent
        content.startsWith(IdentityPrefix.USER) ->
            "我" to cleanContent
        else ->
            "历史" to cleanContent  // 旧数据兼容
    }
}
```

#### 3.3.3 防双重前缀测试用例

| 输入 | 期望输出 |
|-----|---------|
| `真的吗？` | `【对方说】：真的吗？` |
| `【对方说】：真的吗？` | `【对方说】：真的吗？`（不重复添加） |
| `【对方说】：【对方说】：真的吗？` | `【对方说】：真的吗？`（去除多余前缀） |
| `【我正在回复】：好的` | `【对方说】：好的`（替换为正确前缀） |

---

## 4. 系统提示词设计

### 4.1 身份识别说明

在系统提示词中加入以下说明：

```
【重要】关于输入内容的身份识别：
- 如果内容以【对方说】开头，表示这是对方发给用户的消息
- 如果内容以【我正在回复】开头，表示这是用户打算发送的内容
- 你需要始终站在用户的角度，帮助用户分析对方的意图并给出回复建议
```

### 4.2 防回声规则

在系统提示词的"重要原则"中加入：

```
- 回复时请直接输出分析结果或建议内容，不要重复输入内容，也不要自行添加任何【】格式的角色前缀
```

### 4.3 完整提示词示例

#### ANALYZE 场景

```kotlin
private const val ANALYZE_HEADER = """你是一个专业的社交沟通分析助手（AI军师）。

【重要】关于输入内容的身份识别：
- 如果内容以【对方说】开头，表示这是对方发给用户的消息
- 如果内容以【我正在回复】开头，表示这是用户打算发送的内容
- 你需要始终站在用户的角度，帮助用户分析对方的意图并给出回复建议

你的职责是：
1. 分析聊天上下文和联系人画像
2. 识别对方的情绪状态和沟通意图
3. 发现潜在的沟通风险点
4. 提供具体可行的回复建议

重要原则：
- 保持客观中立，不做道德评判
- 建议应该具体可执行，而非泛泛而谈
- 尊重用户的沟通目标和关系定位
- 永远不要模仿对方说话，而是分析对方的话
- 回复时请直接输出分析结果或建议内容，不要重复输入内容，也不要自行添加任何【】格式的角色前缀"""
```

#### CHECK 场景

```kotlin
private const val CHECK_HEADER = """你是一个社交沟通安全检查助手。

【重要】关于输入内容的身份识别：
- 输入内容以【我正在回复】开头，表示这是用户打算发送的草稿
- 你需要帮助用户检查这段草稿是否存在风险

你的职责是：
1. 检查用户草稿是否触及敏感话题
2. 识别可能引起误解的表达
3. 评估语气是否合适
4. 提供修改建议

重要原则：
- 基于已知的雷区信息进行检查
- 宁可多提醒，不可漏检
- 给出具体的修改建议
- 回复时请直接输出检查结果，不要重复输入内容，也不要自行添加任何【】格式的角色前缀"""
```

---

## 5. UI 渲染设计

### 5.1 设计原则

| 层级 | 处理方式 |
|-----|---------|
| 存储层 | 保留身份前缀（`【对方说】：xxx`） |
| 展示层 | 解析前缀，以自然对话流形式展示 |

### 5.2 气泡布局规则

| 身份前缀 | 对齐方式 | 背景色 | 标签 |
|---------|---------|-------|------|
| `【对方说】：` | 靠左 | `surfaceVariant` | "对方" |
| `【我正在回复】：` | 靠右 | `primaryContainer` | "我" |
| 无前缀（旧数据） | 居中 | `surface` | "历史" |

### 5.3 UI 效果示意

```
┌─────────────────────────────────────────┐
│ 📅 2025-12-17                           │
│                                         │
│ ┌────────────────────┐                  │
│ │ 对方 · 08:30       │                  │
│ │ 你怎么才回消息？    │                  │
│ └────────────────────┘                  │
│                                         │
│                  ┌────────────────────┐ │
│                  │ 我 · 08:35         │ │
│                  │ 刚才在开会          │ │
│                  └────────────────────┘ │
│                                         │
│ --- 对话暂停了 2 小时 ---                │
│                                         │
│ ┌────────────────────┐                  │
│ │ 对方 · 10:30       │                  │
│ │ 你在干嘛呢          │                  │
│ └────────────────────┘                  │
└─────────────────────────────────────────┘
```

### 5.4 编辑对话流程

#### 5.4.1 问题场景

当用户编辑带前缀的历史记录时，需要处理以下问题：
- 编辑框显示什么？（带前缀 vs 纯文本）
- 保存时如何保留身份信息？

#### 5.4.2 解决方案

**加载时**：解析前缀，只显示纯文本，同时记住原始身份

**保存时**：根据记住的身份，重新拼接前缀

```kotlin
/**
 * 编辑对话的状态
 */
data class EditConversationState(
    val logId: Long,
    val originalRole: String,      // 记住原始身份："对方" / "我" / "历史"
    val editableContent: String    // 纯文本内容（不含前缀）
)

/**
 * 加载编辑状态
 */
fun loadEditState(log: ConversationLog): EditConversationState {
    val (role, content) = parseIdentityPrefix(log.userInput)
    return EditConversationState(
        logId = log.id,
        originalRole = role,
        editableContent = content
    )
}

/**
 * 保存编辑内容
 */
fun saveEditedContent(state: EditConversationState, newContent: String): String {
    // 根据原始身份重新拼接前缀
    val prefix = when (state.originalRole) {
        "对方" -> IdentityPrefix.CONTACT
        "我" -> IdentityPrefix.USER
        else -> ""  // 旧数据保持无前缀
    }
    return "$prefix$newContent"
}
```

#### 5.4.3 编辑对话框设计

```kotlin
@Composable
fun EditConversationDialog(
    log: ConversationLog,
    onDismiss: () -> Unit,
    onSave: (String) -> Unit
) {
    // 1. 加载时解析前缀，记住身份
    val editState = remember(log) { loadEditState(log) }
    var editedContent by remember { mutableStateOf(editState.editableContent) }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            // 显示身份标签，让用户知道这是谁说的
            Text("编辑对话 (${editState.originalRole})")
        },
        text = {
            OutlinedTextField(
                value = editedContent,
                onValueChange = { editedContent = it },
                modifier = Modifier.fillMaxWidth()
            )
        },
        confirmButton = {
            TextButton(onClick = {
                // 2. 保存时重新拼接前缀
                val finalContent = saveEditedContent(editState, editedContent)
                onSave(finalContent)
            }) {
                Text("保存")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("取消")
            }
        }
    )
}
```

### 5.5 组件实现

```kotlin
@Composable
fun ConversationBubble(
    log: ConversationLog,
    modifier: Modifier = Modifier
) {
    val (sender, content) = parseIdentityPrefix(log.userInput)
    
    val alignment = when (sender) {
        "对方" -> Alignment.Start
        "我" -> Alignment.End
        else -> Alignment.CenterHorizontally
    }
    
    val backgroundColor = when (sender) {
        "对方" -> MaterialTheme.colorScheme.surfaceVariant
        "我" -> MaterialTheme.colorScheme.primaryContainer
        else -> MaterialTheme.colorScheme.surface
    }
    
    val bubbleShape = when (sender) {
        "对方" -> RoundedCornerShape(4.dp, 16.dp, 16.dp, 16.dp)
        "我" -> RoundedCornerShape(16.dp, 4.dp, 16.dp, 16.dp)
        else -> RoundedCornerShape(16.dp)
    }
    
    Column(
        modifier = modifier.fillMaxWidth(),
        horizontalAlignment = alignment
    ) {
        // 标签和时间
        Row(
            verticalAlignment = Alignment.CenterVertically,
            modifier = Modifier.padding(bottom = 4.dp)
        ) {
            Text(
                text = sender,
                style = MaterialTheme.typography.labelSmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Text(
                text = " · ${formatTime(log.timestamp)}",
                style = MaterialTheme.typography.labelSmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
        
        // 气泡
        Surface(
            shape = bubbleShape,
            color = backgroundColor,
            modifier = Modifier.widthIn(max = 280.dp)
        ) {
            Text(
                text = content,
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.padding(12.dp)
            )
        }
    }
}
```

---

## 6. 数据兼容性设计

### 6.1 旧数据处理

| 数据类型 | 特征 | 处理方式 |
|---------|-----|---------|
| 旧数据 | 不以 `【对方说】：` 或 `【我正在回复】：` 开头 | 显示为"历史"，居中布局 |
| 新数据 | 以身份前缀开头 | 解析前缀，左右布局 |

### 6.2 兼容性代码

```kotlin
fun parseIdentityPrefix(content: String): Pair<String, String> {
    return when {
        content.startsWith(IdentityPrefix.CONTACT) ->
            "对方" to content.removePrefix(IdentityPrefix.CONTACT)
        content.startsWith(IdentityPrefix.USER) ->
            "我" to content.removePrefix(IdentityPrefix.USER)
        else ->
            "历史" to content  // 旧数据兼容，保持原样
    }
}
```

---

## 7. 错误处理设计

### 7.1 异常场景

| 场景 | 处理方式 |
|-----|---------|
| 输入内容为空 | 不添加前缀，直接返回空字符串 |
| 保存历史失败 | 记录日志，不影响主流程 |
| 前缀解析失败 | 降级为"历史"类型 |

### 7.2 日志记录

```kotlin
companion object {
    private const val TAG = "IdentityPrefix"
}

// 保存失败时记录日志
try {
    conversationRepository.saveUserInput(contactId, prefixedInput)
} catch (e: Exception) {
    Log.e(TAG, "保存对话历史失败", e)
    // 不抛出异常，继续主流程
}
```

---

## 8. 测试用例设计

### 8.1 单元测试

#### 8.1.1 基础功能测试

| 测试用例 | 输入 | 期望输出 |
|---------|-----|---------|
| 添加对方前缀 | `"你好"`, `ANALYZE` | `"【对方说】：你好"` |
| 添加我的前缀 | `"你好"`, `CHECK` | `"【我正在回复】：你好"` |
| 解析对方前缀 | `"【对方说】：你好"` | `("对方", "你好")` |
| 解析我的前缀 | `"【我正在回复】：你好"` | `("我", "你好")` |
| 解析无前缀 | `"你好"` | `("历史", "你好")` |
| 多行内容 | `"第一行\n第二行"`, `ANALYZE` | `"【对方说】：第一行\n第二行"` |

#### 8.1.2 防双重前缀测试

| 测试用例 | 输入 | 期望输出 |
|---------|-----|---------|
| 已有相同前缀 | `"【对方说】：你好"`, `ANALYZE` | `"【对方说】：你好"` |
| 已有不同前缀 | `"【我正在回复】：你好"`, `ANALYZE` | `"【对方说】：你好"` |
| 双重前缀 | `"【对方说】：【对方说】：你好"`, `ANALYZE` | `"【对方说】：你好"` |
| 三重前缀 | `"【对方说】：【对方说】：【对方说】：你好"` | `"【对方说】：你好"` |
| 混合前缀 | `"【对方说】：【我正在回复】：你好"`, `ANALYZE` | `"【对方说】：你好"` |

#### 8.1.3 编辑对话测试

| 测试用例 | 输入 | 期望输出 |
|---------|-----|---------|
| 加载编辑状态 | `"【对方说】：你好"` | `EditState(role="对方", content="你好")` |
| 保存编辑内容 | `EditState(role="对方")`, `"再见"` | `"【对方说】：再见"` |
| 保存旧数据编辑 | `EditState(role="历史")`, `"你好"` | `"你好"`（无前缀） |

### 8.2 集成测试

| 测试场景 | 验证点 |
|---------|-------|
| 分析功能完整流程 | 前缀添加 → 历史保存 → AI 调用 → 结果返回 |
| 检查功能完整流程 | 前缀添加 → 不保存历史 → AI 调用 → 结果返回 |
| 历史上下文构建 | 前缀保留 → 时间标记 → 格式正确 |
| UI 渲染 | 前缀解析 → 左右布局 → 样式正确 |

### 8.3 AI 行为测试

| 测试场景 | 验证点 |
|---------|-------|
| AI 理解对方身份 | 输入 `【对方说】：xxx`，AI 分析"对方的意图" |
| AI 理解我的身份 | 输入 `【我正在回复】：xxx`，AI 检查"我的草稿" |
| AI 不回声 | AI 回复不包含 `【】` 格式的前缀 |
| AI 不复读 | AI 回复不重复输入内容 |

---

## 9. 性能考量

### 9.1 性能指标

| 操作 | 目标耗时 |
|-----|---------|
| 前缀添加 | < 1ms |
| 前缀解析 | < 1ms |
| 历史保存 | < 50ms |
| UI 渲染 | < 16ms（60fps） |

### 9.2 优化策略

- 前缀常量使用 `const val`，编译时内联
- 字符串拼接使用 `StringBuilder` 或模板字符串
- UI 渲染使用 `remember` 缓存解析结果

---

## 10. 相关文档

- [PRD-00008-输入内容身份识别与双向对话历史需求](../PRD/PRD-00008-输入内容身份识别与双向对话历史需求.md)
- [PRD-00007-对话上下文连续性增强需求](../PRD/PRD-00007-对话上下文连续性增强需求.md)
- [AnalyzeChatUseCase.kt](../../../app/src/main/java/com/empathy/ai/domain/usecase/AnalyzeChatUseCase.kt)
- [CheckDraftUseCase.kt](../../../app/src/main/java/com/empathy/ai/domain/usecase/CheckDraftUseCase.kt)
- [SystemPrompts.kt](../../../app/src/main/java/com/empathy/ai/domain/util/SystemPrompts.kt)
- [ConversationContextBuilder.kt](../../../app/src/main/java/com/empathy/ai/domain/util/ConversationContextBuilder.kt)
