# FD-00028 AIå†›å¸ˆæµå¼å¯¹è¯å‡çº§åŠŸèƒ½è®¾è®¡

## æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| æ–‡æ¡£ç¼–å· | FD-00028 |
| åˆ›å»ºæ—¥æœŸ | 2026-01-04 |
| æ›´æ–°æ—¥æœŸ | 2026-01-04 |
| çŠ¶æ€ | è‰ç¨¿ |
| å…³è”PRD | PRD-00028 |
| å…³è”TDD | TDD-00028 |
| å…³è”è°ƒç ” | RESEARCH-00003ã€RESEARCH-00004 |
| åŸºç¡€åŠŸèƒ½ | FD-00026 (AIå†›å¸ˆå¯¹è¯åŠŸèƒ½) |

---

## 1. åŠŸèƒ½æ¦‚è¿°

### 1.1 åŠŸèƒ½ç›®æ ‡

åœ¨ç°æœ‰AIå†›å¸ˆå¯¹è¯åŠŸèƒ½ï¼ˆFD-00026ï¼‰åŸºç¡€ä¸Šï¼Œå‡çº§ä¸ºæµå¼å¯¹è¯ä½“éªŒï¼Œå‚è€ƒCherry Studioçš„ä¼˜ç§€è®¾è®¡å®ç°ï¼š

1. **æµå¼å“åº”**ï¼šAIå›å¤å®æ—¶é€å­—æ˜¾ç¤ºï¼Œæå‡äº¤äº’ä½“éªŒ
2. **æ€è€ƒè¿‡ç¨‹å±•ç¤º**ï¼šæ”¯æŒDeepSeek R1ç­‰æ¨¡å‹çš„æ€è€ƒè¿‡ç¨‹å¯è§†åŒ–
3. **Blockæ¶æ„**ï¼šæ¶ˆæ¯æ‹†åˆ†ä¸ºç‹¬ç«‹Blockï¼Œæ”¯æŒå¤šç§å†…å®¹ç±»å‹
4. **è¯·æ±‚æ§åˆ¶**ï¼šæ”¯æŒåœæ­¢ç”Ÿæˆã€é‡æ–°ç”Ÿæˆç­‰æ“ä½œ

### 1.2 æ ¸å¿ƒåŠŸèƒ½ç‚¹

| åŠŸèƒ½ç‚¹ | æè¿° | ä¼˜å…ˆçº§ |
|-------|------|--------|
| SSEæµå¼å“åº” | ä½¿ç”¨Server-Sent Eventså®ç°å®æ—¶æ–‡æœ¬æµ | P0 |
| æ€è€ƒè¿‡ç¨‹å±•ç¤º | å¯æŠ˜å çš„æ€è€ƒè¿‡ç¨‹åŒºåŸŸï¼Œæ˜¾ç¤ºAIæ¨ç†è¿‡ç¨‹ | P0 |
| Blockæ¶æ„ | æ¶ˆæ¯æ‹†åˆ†ä¸ºTHINKING/MAIN_TEXTç­‰Block | P0 |
| åœæ­¢ç”Ÿæˆ | ç”¨æˆ·å¯éšæ—¶ä¸­æ–­AIå“åº” | P1 |
| é‡æ–°ç”Ÿæˆ | é‡æ–°ç”Ÿæˆæœ€åä¸€æ¡AIå›å¤ | P1 |
| æ™ºèƒ½èŠ‚æµ | å‡å°‘æ•°æ®åº“å†™å…¥é¢‘ç‡ï¼Œæå‡æ€§èƒ½ | P1 |
| é™çº§ç­–ç•¥ | SSEå¤±è´¥æ—¶è‡ªåŠ¨é™çº§åˆ°éæµå¼æ¨¡å¼ | P2 |

### 1.3 ä¸ç°æœ‰åŠŸèƒ½çš„åŒºåˆ«

| ç»´åº¦ | FD-00026 (ç°æœ‰) | FD-00028 (å‡çº§) |
|------|----------------|-----------------|
| å“åº”æ–¹å¼ | ä¸€æ¬¡æ€§è¿”å›å®Œæ•´å†…å®¹ | æµå¼é€å­—æ˜¾ç¤º |
| æ€è€ƒè¿‡ç¨‹ | ä¸æ”¯æŒ | æ”¯æŒå±•ç¤ºå’ŒæŠ˜å  |
| æ•°æ®ç»“æ„ | å•ä¸€contentå­—æ®µ | Blockæ¶æ„ï¼ˆå¤šå—ï¼‰ |
| ç”¨æˆ·æ§åˆ¶ | æ—  | åœæ­¢/é‡æ–°ç”Ÿæˆ |
| æ•°æ®åº“å†™å…¥ | å®Œæˆåä¸€æ¬¡å†™å…¥ | æ™ºèƒ½èŠ‚æµæ‰¹é‡å†™å…¥ |


---

## 2. ç³»ç»Ÿæ¶æ„è®¾è®¡

### 2.1 æ¨¡å—åˆ†å¸ƒï¼ˆéµå¾ªClean Architectureï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      :app æ¨¡å—                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ AiAdvisorModule.kt (DIæ¨¡å—æ‰©å±•)                     â”‚   â”‚
â”‚  â”‚ - æµå¼UseCaseæ³¨å…¥                                   â”‚   â”‚
â”‚  â”‚ - BlockUpdateManageræ³¨å…¥                            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â–¼                   â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   :domain æ¨¡å—   â”‚ â”‚   :data æ¨¡å—    â”‚ â”‚  :presentation æ¨¡å—  â”‚
â”‚                 â”‚ â”‚                 â”‚ â”‚                     â”‚
â”‚ ğŸ†• AiStreamChunk â”‚ â”‚ ğŸ†• SseStreamReader â”‚ â”‚ ğŸ†• ThinkingSection  â”‚
â”‚ ğŸ†• MessageBlockType â”‚ â”‚ ğŸ†• BlockUpdateManager â”‚ â”‚ ğŸ†• StreamingBubble â”‚
â”‚ ğŸ†• MessageBlockStatus â”‚ â”‚ ğŸ†• AiAdvisorMessageBlockDao â”‚ â”‚ ğŸ†• StopButton    â”‚
â”‚ ğŸ†• AiAdvisorMessageBlock â”‚ â”‚ ğŸ†• AiAdvisorMessageBlockEntity â”‚ â”‚                â”‚
â”‚ ğŸ†• StreamingState â”‚ â”‚                 â”‚ â”‚                     â”‚
â”‚ ğŸ†• SendAdvisorMessageStreamingUseCase â”‚ â”‚ â”‚                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ¨¡å—èŒè´£è¯´æ˜

| æ¨¡å— | æ–°å¢ç»„ä»¶ | èŒè´£ |
|------|---------|------|
| :domain | AiStreamChunk, MessageBlockType, MessageBlockStatus, AiAdvisorMessageBlock, StreamingState | æµå¼æ•°æ®æ¨¡å‹å®šä¹‰ï¼Œçº¯Kotlinæ— Androidä¾èµ– |
| :data | SseStreamReader, BlockUpdateManager, AiAdvisorMessageBlockDao, AiAdvisorMessageBlockEntity | SSEæµå¼è¯»å–ã€æ™ºèƒ½èŠ‚æµã€æ•°æ®åº“æ“ä½œ |
| :presentation | ThinkingSection, StreamingMessageBubble, StopGenerationButton | æµå¼UIç»„ä»¶ã€æ€è€ƒè¿‡ç¨‹å±•ç¤º |
| :app | AiAdvisorModuleæ‰©å±• | æµå¼ç›¸å…³ä¾èµ–æ³¨å…¥é…ç½® |

### 2.3 æ•°æ®æµè®¾è®¡

```
ç”¨æˆ·å‘é€æ¶ˆæ¯
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AiAdvisorChatViewModel                                      â”‚
â”‚ â”œâ”€â”€ 1. ä¿å­˜ç”¨æˆ·æ¶ˆæ¯                                         â”‚
â”‚ â”œâ”€â”€ 2. åˆ›å»ºAIæ¶ˆæ¯å ä½ï¼ˆPENDINGçŠ¶æ€ï¼‰                        â”‚
â”‚ â”œâ”€â”€ 3. åˆ›å»ºåˆå§‹Blockï¼ˆMAIN_TEXTï¼‰                           â”‚
â”‚ â””â”€â”€ 4. è°ƒç”¨SendAdvisorMessageStreamingUseCase               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SendAdvisorMessageStreamingUseCase                          â”‚
â”‚ â”œâ”€â”€ 1. æ„å»ºAIå†›å¸ˆæç¤ºè¯                                     â”‚
â”‚ â”œâ”€â”€ 2. è°ƒç”¨AiRepository.generateTextStream()                â”‚
â”‚ â””â”€â”€ 3. è¿”å›Flow<StreamingState>                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SseStreamReader (SSEæµå¼è¯»å–)                               â”‚
â”‚ â”œâ”€â”€ è§£æSSEäº‹ä»¶                                             â”‚
â”‚ â”œâ”€â”€ è¯†åˆ«æ€è€ƒå†…å®¹(reasoning_content)                         â”‚
â”‚ â””â”€â”€ å‘å°„AiStreamChunk                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BlockUpdateManager (æ™ºèƒ½èŠ‚æµ)                               â”‚
â”‚ â”œâ”€â”€ å—ç±»å‹å˜åŒ– â†’ ç«‹å³å†™å…¥                                   â”‚
â”‚ â”œâ”€â”€ åŒç±»å‹å†…å®¹ â†’ 300msèŠ‚æµ                                  â”‚
â”‚ â””â”€â”€ å®Œæˆæ—¶ â†’ å¼ºåˆ¶åˆ·æ–°                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
UIå®æ—¶æ›´æ–°ï¼ˆStreamingMessageBubbleï¼‰
```


---

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 é¢†åŸŸæ¨¡å‹ï¼ˆ:domainæ¨¡å—ï¼‰

#### 3.1.1 AiStreamChunkï¼ˆæµå¼æ•°æ®å—ï¼‰

```kotlin
// domain/src/main/kotlin/com/empathy/ai/domain/model/AiStreamChunk.kt

/**
 * AIæµå¼å“åº”æ•°æ®å—
 * 
 * å‚è€ƒCherry Studioçš„ChunkTypeè®¾è®¡ï¼Œå®šä¹‰ç»Ÿä¸€çš„æµå¼äº‹ä»¶ç±»å‹ã€‚
 * æ³¨æ„ï¼šThrowableæ˜¯Kotlinæ ‡å‡†åº“ç±»ï¼Œåœ¨:domainæ¨¡å—ä¸­å¯ä»¥ä½¿ç”¨ã€‚
 */
sealed class AiStreamChunk {
    
    /** å“åº”å¼€å§‹ */
    data object Started : AiStreamChunk()
    
    /** æ–‡æœ¬å¢é‡ */
    data class TextDelta(val text: String) : AiStreamChunk()
    
    /** æ€è€ƒè¿‡ç¨‹å¢é‡ï¼ˆDeepSeek R1ç­‰æ¨¡å‹ï¼‰ */
    data class ThinkingDelta(
        val text: String,
        val thinkingMs: Long? = null
    ) : AiStreamChunk()
    
    /** æ€è€ƒå®Œæˆ */
    data class ThinkingComplete(
        val fullThinking: String,
        val totalMs: Long
    ) : AiStreamChunk()
    
    /** å“åº”å®Œæˆ */
    data class Complete(
        val fullText: String,
        val usage: TokenUsage? = null
    ) : AiStreamChunk()
    
    /** é”™è¯¯ */
    data class Error(val error: Throwable) : AiStreamChunk()
}

/**
 * Tokenä½¿ç”¨ç»Ÿè®¡
 */
data class TokenUsage(
    val promptTokens: Int,
    val completionTokens: Int,
    val totalTokens: Int
)
```

#### 3.1.2 MessageBlockType/MessageBlockStatusï¼ˆæ¶ˆæ¯å—ç±»å‹å’ŒçŠ¶æ€ï¼‰

```kotlin
// domain/src/main/kotlin/com/empathy/ai/domain/model/MessageBlockType.kt

/**
 * æ¶ˆæ¯å—ç±»å‹
 * å‚è€ƒCherry Studioçš„MessageBlockTypeè®¾è®¡
 */
enum class MessageBlockType {
    MAIN_TEXT,    // ä¸»æ–‡æœ¬
    THINKING,     // æ€è€ƒè¿‡ç¨‹
    ERROR         // é”™è¯¯ä¿¡æ¯
    // æœªæ¥æ‰©å±•ï¼šCODE, TOOL, CITATION
}

/**
 * æ¶ˆæ¯å—çŠ¶æ€
 * å‚è€ƒCherry Studioçš„MessageBlockStatusè®¾è®¡
 */
enum class MessageBlockStatus {
    PENDING,      // ç­‰å¾…å¤„ç†
    STREAMING,    // æµå¼æ¥æ”¶ä¸­
    SUCCESS,      // æˆåŠŸå®Œæˆ
    ERROR         // å‘ç”Ÿé”™è¯¯
}
```

#### 3.1.3 AiAdvisorMessageBlockï¼ˆæ¶ˆæ¯å—æ¨¡å‹ï¼‰

```kotlin
// domain/src/main/kotlin/com/empathy/ai/domain/model/AiAdvisorMessageBlock.kt

/**
 * AIå†›å¸ˆæ¶ˆæ¯å—
 * ä¸€æ¡æ¶ˆæ¯å¯ä»¥åŒ…å«å¤šä¸ªå—ï¼ˆæ€è€ƒ+æ–‡æœ¬ï¼‰
 */
data class AiAdvisorMessageBlock(
    val id: String,
    val messageId: String,
    val type: MessageBlockType,
    val status: MessageBlockStatus,
    val content: String,
    val metadata: BlockMetadata? = null,
    val createdAt: Long = System.currentTimeMillis()
) {
    companion object {
        fun createMainTextBlock(
            messageId: String,
            content: String = "",
            status: MessageBlockStatus = MessageBlockStatus.PENDING
        ): AiAdvisorMessageBlock = AiAdvisorMessageBlock(
            id = java.util.UUID.randomUUID().toString(),
            messageId = messageId,
            type = MessageBlockType.MAIN_TEXT,
            status = status,
            content = content
        )
        
        fun createThinkingBlock(
            messageId: String,
            content: String = "",
            status: MessageBlockStatus = MessageBlockStatus.PENDING
        ): AiAdvisorMessageBlock = AiAdvisorMessageBlock(
            id = java.util.UUID.randomUUID().toString(),
            messageId = messageId,
            type = MessageBlockType.THINKING,
            status = status,
            content = content
        )
    }
}

/**
 * å—å…ƒæ•°æ®
 */
data class BlockMetadata(
    val thinkingMs: Long? = null,    // æ€è€ƒè€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
    val tokenCount: Int? = null      // Tokenæ•°é‡
)
```

#### 3.1.4 StreamingStateï¼ˆæµå¼çŠ¶æ€ï¼‰

```kotlin
// domain/src/main/kotlin/com/empathy/ai/domain/model/StreamingState.kt

/**
 * æµå¼çŠ¶æ€
 * ç”¨äºViewModelå’ŒUIä¹‹é—´çš„çŠ¶æ€ä¼ é€’
 */
sealed class StreamingState {
    data class Started(val messageId: String) : StreamingState()
    data class ThinkingUpdate(val content: String, val elapsedMs: Long) : StreamingState()
    data class TextUpdate(val content: String) : StreamingState()
    data class Completed(val fullText: String, val usage: TokenUsage?) : StreamingState()
    data class Error(val error: Throwable) : StreamingState()
}
```


### 3.2 æ•°æ®åº“å®ä½“ï¼ˆ:dataæ¨¡å—ï¼‰

#### 3.2.1 AiAdvisorMessageBlockEntity

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/local/entity/AiAdvisorMessageBlockEntity.kt

@Entity(
    tableName = "ai_advisor_message_blocks",
    foreignKeys = [
        ForeignKey(
            entity = AiAdvisorConversationEntity::class,
            parentColumns = ["id"],
            childColumns = ["message_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index("message_id")]
)
data class AiAdvisorMessageBlockEntity(
    @PrimaryKey
    @ColumnInfo(name = "id")
    val id: String,

    @ColumnInfo(name = "message_id")
    val messageId: String,

    @ColumnInfo(name = "type")
    val type: String,  // MessageBlockType.name

    @ColumnInfo(name = "status")
    val status: String,  // MessageBlockStatus.name

    @ColumnInfo(name = "content")
    val content: String,

    @ColumnInfo(name = "metadata")
    val metadata: String? = null,  // JSONæ ¼å¼

    @ColumnInfo(name = "created_at")
    val createdAt: Long
) {
    fun toDomain(): AiAdvisorMessageBlock = AiAdvisorMessageBlock(
        id = id,
        messageId = messageId,
        type = MessageBlockType.valueOf(type),
        status = MessageBlockStatus.valueOf(status),
        content = content,
        metadata = metadata?.let { parseMetadata(it) },
        createdAt = createdAt
    )
    
    companion object {
        fun fromDomain(block: AiAdvisorMessageBlock): AiAdvisorMessageBlockEntity =
            AiAdvisorMessageBlockEntity(
                id = block.id,
                messageId = block.messageId,
                type = block.type.name,
                status = block.status.name,
                content = block.content,
                metadata = block.metadata?.toJson(),
                createdAt = block.createdAt
            )
            
        private fun parseMetadata(json: String): BlockMetadata? {
            return try {
                // ä½¿ç”¨Moshiè§£æJSON
                val moshi = Moshi.Builder().build()
                val adapter = moshi.adapter(BlockMetadata::class.java)
                adapter.fromJson(json)
            } catch (e: Exception) {
                null
            }
        }
    }
}

private fun BlockMetadata.toJson(): String {
    val moshi = Moshi.Builder().build()
    val adapter = moshi.adapter(BlockMetadata::class.java)
    return adapter.toJson(this)
}
```

### 3.3 æ•°æ®åº“è¿ç§»ï¼ˆv13 â†’ v14ï¼‰

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/local/DatabaseMigrations.kt

/**
 * æ•°æ®åº“è¿ç§» v13 â†’ v14
 * 
 * å˜æ›´å†…å®¹ï¼š
 * 1. æ–°å¢ai_advisor_message_blocksè¡¨
 * 2. ä¸ºç°æœ‰AIæ¶ˆæ¯åˆ›å»ºé»˜è®¤MAIN_TEXT Block
 */
val MIGRATION_13_14 = object : Migration(13, 14) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // 1. åˆ›å»ºæ¶ˆæ¯å—è¡¨
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS ai_advisor_message_blocks (
                id TEXT PRIMARY KEY NOT NULL,
                message_id TEXT NOT NULL,
                type TEXT NOT NULL,
                status TEXT NOT NULL,
                content TEXT NOT NULL,
                metadata TEXT,
                created_at INTEGER NOT NULL,
                FOREIGN KEY (message_id) 
                    REFERENCES ai_advisor_conversations(id) 
                    ON DELETE CASCADE
            )
        """)
        
        // 2. åˆ›å»ºç´¢å¼•ï¼ˆä¼˜åŒ–æŒ‰æ¶ˆæ¯IDæŸ¥è¯¢ï¼‰
        database.execSQL("""
            CREATE INDEX IF NOT EXISTS idx_blocks_message_id 
            ON ai_advisor_message_blocks(message_id)
        """)
        
        // 3. æ•°æ®è¿ç§»ï¼šä¸ºç°æœ‰AIæ¶ˆæ¯åˆ›å»ºé»˜è®¤Block
        database.execSQL("""
            INSERT INTO ai_advisor_message_blocks 
                (id, message_id, type, status, content, created_at)
            SELECT 
                id || '_main_block',
                id,
                'MAIN_TEXT',
                'SUCCESS',
                content,
                created_at
            FROM ai_advisor_conversations
            WHERE message_type = 'AI'
        """)
    }
}
```

### 3.4 AppDatabaseæ›´æ–°

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/local/AppDatabase.kt

@Database(
    entities = [
        // ... ç°æœ‰å®ä½“
        AiAdvisorSessionEntity::class,
        AiAdvisorConversationEntity::class,
        AiAdvisorMessageBlockEntity::class  // ğŸ†• æ–°å¢
    ],
    version = 14,  // ğŸ†• ç‰ˆæœ¬å‡çº§
    exportSchema = true
)
@TypeConverters(RoomTypeConverters::class, FactListConverter::class)
abstract class AppDatabase : RoomDatabase() {
    // ... ç°æœ‰DAO
    
    abstract fun aiAdvisorMessageBlockDao(): AiAdvisorMessageBlockDao  // ğŸ†• æ–°å¢
}
```


---

## 4. Repositoryæ¥å£è®¾è®¡

### 4.1 AiRepositoryæ‰©å±•ï¼ˆ:domainæ¨¡å—ï¼‰

```kotlin
// domain/src/main/kotlin/com/empathy/ai/domain/repository/AiRepository.kt

interface AiRepository {
    // ç°æœ‰æ¥å£ï¼ˆä¿ç•™ï¼‰
    suspend fun generateText(
        provider: AiProvider,
        prompt: String,
        systemInstruction: String
    ): Result<String>
    
    // ğŸ†• æ–°å¢æµå¼æ¥å£
    fun generateTextStream(
        provider: AiProvider,
        prompt: String,
        systemInstruction: String
    ): Flow<AiStreamChunk>
}
```

### 4.2 AiAdvisorRepositoryæ‰©å±•ï¼ˆ:domainæ¨¡å—ï¼‰

```kotlin
// domain/src/main/kotlin/com/empathy/ai/domain/repository/AiAdvisorRepository.kt

interface AiAdvisorRepository {
    // ç°æœ‰æ¥å£ï¼ˆä¿ç•™ï¼‰
    suspend fun saveMessage(message: AiAdvisorConversation): Result<Unit>
    fun getConversations(sessionId: String): Flow<List<AiAdvisorConversation>>
    
    // ğŸ†• æ–°å¢Blockç›¸å…³æ¥å£
    suspend fun saveBlock(block: AiAdvisorMessageBlock): Result<Unit>
    suspend fun updateBlockContent(
        blockId: String, 
        content: String, 
        status: MessageBlockStatus
    ): Result<Unit>
    suspend fun getBlocksByMessageId(messageId: String): Result<List<AiAdvisorMessageBlock>>
    fun observeBlocksByMessageId(messageId: String): Flow<List<AiAdvisorMessageBlock>>
}
```

### 4.3 AiAdvisorMessageBlockDaoï¼ˆ:dataæ¨¡å—ï¼‰

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/local/dao/AiAdvisorMessageBlockDao.kt

@Dao
interface AiAdvisorMessageBlockDao {
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(block: AiAdvisorMessageBlockEntity)
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(blocks: List<AiAdvisorMessageBlockEntity>)
    
    @Update
    suspend fun update(block: AiAdvisorMessageBlockEntity)
    
    @Query("""
        UPDATE ai_advisor_message_blocks 
        SET content = :content, status = :status 
        WHERE id = :blockId
    """)
    suspend fun updateContentAndStatus(
        blockId: String, 
        content: String, 
        status: String
    )
    
    @Query("SELECT * FROM ai_advisor_message_blocks WHERE message_id = :messageId ORDER BY created_at ASC")
    fun observeByMessageId(messageId: String): Flow<List<AiAdvisorMessageBlockEntity>>
    
    @Query("SELECT * FROM ai_advisor_message_blocks WHERE message_id = :messageId ORDER BY created_at ASC")
    suspend fun getByMessageId(messageId: String): List<AiAdvisorMessageBlockEntity>
    
    @Query("DELETE FROM ai_advisor_message_blocks WHERE message_id = :messageId")
    suspend fun deleteByMessageId(messageId: String)
    
    @Delete
    suspend fun delete(block: AiAdvisorMessageBlockEntity)
}
```


---

## 5. UseCaseè®¾è®¡

### 5.1 SendAdvisorMessageStreamingUseCaseï¼ˆæ ¸å¿ƒæµå¼ç”¨ä¾‹ï¼‰

```kotlin
// domain/src/main/kotlin/com/empathy/ai/domain/usecase/SendAdvisorMessageStreamingUseCase.kt

/**
 * å‘é€AIå†›å¸ˆæ¶ˆæ¯ï¼ˆæµå¼ç‰ˆæœ¬ï¼‰
 * 
 * å‚è€ƒCherry Studioçš„æ¶ˆæ¯å‘é€æµç¨‹ï¼Œå®ç°ï¼š
 * 1. ä¿å­˜ç”¨æˆ·æ¶ˆæ¯
 * 2. åˆ›å»ºAIæ¶ˆæ¯å ä½
 * 3. è°ƒç”¨æµå¼API
 * 4. å®æ—¶æ›´æ–°Blockå†…å®¹
 */
class SendAdvisorMessageStreamingUseCase @Inject constructor(
    private val aiAdvisorRepository: AiAdvisorRepository,
    private val aiRepository: AiRepository,
    private val contactRepository: ContactRepository,
    private val aiProviderRepository: AiProviderRepository,
    private val promptBuilder: AdvisorPromptBuilder
) {
    /**
     * å‘é€æ¶ˆæ¯å¹¶è¿”å›æµå¼å“åº”
     * 
     * @param contactId è”ç³»äººID
     * @param sessionId ä¼šè¯ID
     * @param userMessage ç”¨æˆ·æ¶ˆæ¯å†…å®¹
     * @return æµå¼å“åº”Flow
     */
    operator fun invoke(
        contactId: String,
        sessionId: String,
        userMessage: String
    ): Flow<StreamingState> = flow {
        // 1. ä¿å­˜ç”¨æˆ·æ¶ˆæ¯
        val userConversation = AiAdvisorConversation.createUserMessage(
            sessionId = sessionId,
            contactId = contactId,
            content = userMessage,
            sendStatus = SendStatus.SUCCESS
        )
        aiAdvisorRepository.saveMessage(userConversation)
        
        // 2. åˆ›å»ºAIæ¶ˆæ¯å ä½
        val aiMessageId = java.util.UUID.randomUUID().toString()
        val aiMessage = AiAdvisorConversation(
            id = aiMessageId,
            contactId = contactId,
            sessionId = sessionId,
            messageType = MessageType.AI,
            content = "",
            timestamp = System.currentTimeMillis(),
            sendStatus = SendStatus.PENDING
        )
        aiAdvisorRepository.saveMessage(aiMessage)
        
        // 3. åˆ›å»ºåˆå§‹Block
        val mainTextBlock = AiAdvisorMessageBlock.createMainTextBlock(aiMessageId)
        aiAdvisorRepository.saveBlock(mainTextBlock)
        
        emit(StreamingState.Started(aiMessageId))
        
        // 4. è·å–Providerå’Œæ„å»ºæç¤ºè¯
        val provider = aiProviderRepository.getDefaultProvider().getOrThrow()
        val contact = contactRepository.getProfile(contactId).getOrNull()
        val history = aiAdvisorRepository.getRecentConversations(contactId, 10)
        val prompt = promptBuilder.build(contact, history, userMessage)
        
        // 5. è°ƒç”¨æµå¼APIå¹¶å¤„ç†å“åº”
        var thinkingBlockId: String? = null
        val contentBuilder = StringBuilder()
        val thinkingBuilder = StringBuilder()
        var thinkingStartTime = 0L
        
        aiRepository.generateTextStream(provider, prompt, SYSTEM_INSTRUCTION)
            .collect { chunk ->
                when (chunk) {
                    is AiStreamChunk.Started -> { /* å·²å¤„ç† */ }
                    
                    is AiStreamChunk.ThinkingDelta -> {
                        if (thinkingBlockId == null) {
                            thinkingStartTime = System.currentTimeMillis()
                            val thinkingBlock = AiAdvisorMessageBlock.createThinkingBlock(
                                aiMessageId,
                                status = MessageBlockStatus.STREAMING
                            )
                            thinkingBlockId = thinkingBlock.id
                            aiAdvisorRepository.saveBlock(thinkingBlock)
                        }
                        thinkingBuilder.append(chunk.text)
                        emit(StreamingState.ThinkingUpdate(
                            thinkingBuilder.toString(),
                            System.currentTimeMillis() - thinkingStartTime
                        ))
                    }
                    
                    is AiStreamChunk.ThinkingComplete -> {
                        thinkingBlockId?.let { id ->
                            aiAdvisorRepository.updateBlockContent(
                                id, chunk.fullThinking, MessageBlockStatus.SUCCESS
                            )
                        }
                    }
                    
                    is AiStreamChunk.TextDelta -> {
                        contentBuilder.append(chunk.text)
                        emit(StreamingState.TextUpdate(contentBuilder.toString()))
                    }
                    
                    is AiStreamChunk.Complete -> {
                        aiAdvisorRepository.updateBlockContent(
                            mainTextBlock.id,
                            chunk.fullText.ifEmpty { contentBuilder.toString() },
                            MessageBlockStatus.SUCCESS
                        )
                        aiAdvisorRepository.updateMessageStatus(aiMessageId, SendStatus.SUCCESS)
                        emit(StreamingState.Completed(contentBuilder.toString(), chunk.usage))
                    }
                    
                    is AiStreamChunk.Error -> {
                        aiAdvisorRepository.updateMessageStatus(aiMessageId, SendStatus.FAILED)
                        emit(StreamingState.Error(chunk.error))
                    }
                }
            }
    }.catch { e ->
        emit(StreamingState.Error(e))
    }
    
    companion object {
        private const val SYSTEM_INSTRUCTION = """
ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„ç¤¾äº¤æ²Ÿé€šé¡¾é—®ï¼Œå¸®åŠ©ç”¨æˆ·åˆ†æèŠå¤©åœºæ™¯å¹¶æä¾›å»ºè®®ã€‚
è¯·æ ¹æ®è”ç³»äººç”»åƒå’Œå¯¹è¯å†å²ï¼Œç»™å‡ºå…·ä½“ã€å®ç”¨çš„æ²Ÿé€šå»ºè®®ã€‚
"""
    }
}
```


---

## 6. æ•°æ®å±‚å®ç°è®¾è®¡

### 6.1 SseStreamReaderï¼ˆSSEæµå¼è¯»å–å™¨ï¼‰

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/remote/SseStreamReader.kt

/**
 * SSEæµå¼è¯»å–å™¨
 * 
 * ä½¿ç”¨OkHttp EventSourceå®ç°Server-Sent Eventsæµå¼è¯»å–ã€‚
 * å‚è€ƒCherry Studioçš„AiSdkToChunkAdapterè®¾è®¡ã€‚
 */
class SseStreamReader @Inject constructor(
    private val okHttpClient: OkHttpClient
) {
    companion object {
        private const val MAX_RETRY_COUNT = 3
        private const val FALLBACK_THRESHOLD = 3
    }
    
    private var consecutiveFailures = 0
    
    fun stream(
        url: String,
        requestBody: ChatRequestDto,
        headers: Map<String, String>
    ): Flow<AiStreamChunk> = callbackFlow {
        val jsonBody = Moshi.Builder()
            .add(KotlinJsonAdapterFactory())
            .build()
            .adapter(ChatRequestDto::class.java)
            .toJson(requestBody)
        
        val request = Request.Builder()
            .url(url)
            .apply {
                headers.forEach { (key, value) -> addHeader(key, value) }
                addHeader("Accept", "text/event-stream")
                addHeader("Cache-Control", "no-cache")
            }
            .post(jsonBody.toRequestBody("application/json".toMediaType()))
            .build()

        val eventSource = EventSources.createFactory(okHttpClient)
            .newEventSource(request, object : EventSourceListener() {
                
                override fun onOpen(eventSource: EventSource, response: Response) {
                    consecutiveFailures = 0
                    trySend(AiStreamChunk.Started)
                }

                override fun onEvent(
                    eventSource: EventSource,
                    id: String?,
                    type: String?,
                    data: String
                ) {
                    if (data == "[DONE]") return
                    try {
                        val chunk = parseChunk(data)
                        chunk?.let { trySend(it) }
                    } catch (e: Exception) {
                        trySend(AiStreamChunk.Error(e))
                    }
                }

                override fun onClosed(eventSource: EventSource) {
                    channel.close()
                }

                override fun onFailure(
                    eventSource: EventSource,
                    t: Throwable?,
                    response: Response?
                ) {
                    consecutiveFailures++
                    val error = t ?: IOException("SSE connection failed")
                    
                    if (consecutiveFailures >= FALLBACK_THRESHOLD) {
                        trySend(AiStreamChunk.Error(
                            SseFallbackException("è¿ç»­${consecutiveFailures}æ¬¡SSEå¤±è´¥", error)
                        ))
                    } else {
                        trySend(AiStreamChunk.Error(error))
                    }
                    channel.close()
                }
            })

        awaitClose { eventSource.cancel() }
    }
    
    private fun parseChunk(data: String): AiStreamChunk? {
        val json = JSONObject(data)
        
        if (json.has("error")) {
            val message = json.getJSONObject("error").optString("message", "Unknown error")
            return AiStreamChunk.Error(IOException(message))
        }
        
        val choices = json.optJSONArray("choices") ?: return null
        if (choices.length() == 0) return null
        
        val choice = choices.getJSONObject(0)
        val delta = choice.optJSONObject("delta") ?: return null
        
        // DeepSeek R1æ€è€ƒè¿‡ç¨‹
        val reasoning = delta.optString("reasoning_content", "")
        if (reasoning.isNotEmpty()) {
            return AiStreamChunk.ThinkingDelta(reasoning)
        }
        
        // æ™®é€šæ–‡æœ¬å†…å®¹
        val content = delta.optString("content", "")
        if (content.isNotEmpty()) {
            return AiStreamChunk.TextDelta(content)
        }
        
        // å®ŒæˆçŠ¶æ€
        val finishReason = choice.optString("finish_reason", "")
        if (finishReason == "stop") {
            val usage = json.optJSONObject("usage")?.let {
                TokenUsage(
                    promptTokens = it.optInt("prompt_tokens"),
                    completionTokens = it.optInt("completion_tokens"),
                    totalTokens = it.optInt("total_tokens")
                )
            }
            return AiStreamChunk.Complete("", usage)
        }
        
        return null
    }
    
    fun shouldFallbackToNonStreaming(): Boolean = consecutiveFailures >= FALLBACK_THRESHOLD
    fun resetFailureCount() { consecutiveFailures = 0 }
}

class SseFallbackException(message: String, cause: Throwable?) : IOException(message, cause)
```


### 6.2 BlockUpdateManagerï¼ˆæ™ºèƒ½èŠ‚æµæ›´æ–°ç®¡ç†å™¨ï¼‰

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/util/BlockUpdateManager.kt

/**
 * Blockæ›´æ–°ç®¡ç†å™¨
 * 
 * å‚è€ƒCherry Studioçš„BlockManageræ™ºèƒ½èŠ‚æµç­–ç•¥ï¼š
 * - å—ç±»å‹å˜åŒ–æ—¶ç«‹å³å†™å…¥
 * - åŒç±»å‹å†…å®¹ä½¿ç”¨èŠ‚æµï¼ˆ300msï¼‰
 */
class BlockUpdateManager @Inject constructor(
    private val aiAdvisorMessageBlockDao: AiAdvisorMessageBlockDao,
    @IoDispatcher private val ioDispatcher: CoroutineDispatcher
) {
    private var lastBlockType: MessageBlockType? = null
    private val pendingUpdates = ConcurrentHashMap<String, PendingUpdate>()
    private var throttleJob: Job? = null
    private val scope = CoroutineScope(ioDispatcher + SupervisorJob())
    
    data class PendingUpdate(
        val blockId: String,
        val content: String,
        val status: MessageBlockStatus
    )

    suspend fun smartUpdate(
        blockId: String,
        content: String,
        blockType: MessageBlockType,
        status: MessageBlockStatus = MessageBlockStatus.STREAMING,
        isComplete: Boolean = false
    ) {
        val isTypeChanged = lastBlockType != null && lastBlockType != blockType

        if (isTypeChanged || isComplete) {
            flushPendingUpdates()
            withContext(ioDispatcher) {
                aiAdvisorMessageBlockDao.updateContentAndStatus(blockId, content, status.name)
            }
        } else {
            pendingUpdates[blockId] = PendingUpdate(blockId, content, status)
            scheduleFlush()
        }

        lastBlockType = blockType
    }

    private fun scheduleFlush() {
        throttleJob?.cancel()
        throttleJob = scope.launch {
            delay(THROTTLE_DELAY_MS)
            flushPendingUpdates()
        }
    }

    private suspend fun flushPendingUpdates() {
        val updates = pendingUpdates.toMap()
        pendingUpdates.clear()
        
        withContext(ioDispatcher) {
            updates.values.forEach { update ->
                aiAdvisorMessageBlockDao.updateContentAndStatus(
                    update.blockId, update.content, update.status.name
                )
            }
        }
    }
    
    fun reset() {
        lastBlockType = null
        pendingUpdates.clear()
        throttleJob?.cancel()
    }
    
    fun cleanup() { scope.cancel() }

    companion object {
        private const val THROTTLE_DELAY_MS = 300L
    }
}
```

### 6.3 å¤šæ¨¡å‹å…¼å®¹æ€§è¯´æ˜

| æœåŠ¡å•† | æ–‡æœ¬å­—æ®µ | æ€è€ƒè¿‡ç¨‹å­—æ®µ | ç»“æŸæ ‡è®° | æ”¯æŒçŠ¶æ€ |
|--------|---------|-------------|---------|---------|
| OpenAI | `delta.content` | ä¸æ”¯æŒ | `[DONE]` | âœ… æ”¯æŒ |
| DeepSeek Chat | `delta.content` | ä¸æ”¯æŒ | `[DONE]` | âœ… æ”¯æŒ |
| DeepSeek R1 | `delta.content` | `delta.reasoning_content` | `[DONE]` | âœ… æ”¯æŒ |
| Claude | `delta.text` | ä¸æ”¯æŒ | `event: message_stop` | â³ å¾…é€‚é… |

### 6.4 é™çº§ç­–ç•¥

```
SSEè¯·æ±‚ â†’ å¤±è´¥ â†’ é‡è¯•(æœ€å¤š3æ¬¡) â†’ è¿ç»­å¤±è´¥3æ¬¡ â†’ é™çº§åˆ°éæµå¼
                    â†“
                  æˆåŠŸ â†’ é‡ç½®å¤±è´¥è®¡æ•°
```

**é™çº§è§¦å‘æ¡ä»¶**ï¼šè¿ç»­3æ¬¡SSEè¿æ¥å¤±è´¥
**é™çº§åè¡Œä¸º**ï¼šä½¿ç”¨`SendAdvisorMessageUseCase`ï¼ˆéæµå¼ç‰ˆæœ¬ï¼‰


---

## 7. UIç•Œé¢è®¾è®¡

### 7.1 æµå¼æ¶ˆæ¯æ°”æ³¡ï¼ˆStreamingMessageBubbleï¼‰

```kotlin
// presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/advisor/component/StreamingMessageBubble.kt

/**
 * æµå¼æ¶ˆæ¯æ°”æ³¡
 * 
 * æ”¯æŒï¼š
 * - å®æ—¶æ–‡æœ¬æ˜¾ç¤ºï¼ˆæ‰“å­—æœºæ•ˆæœï¼‰
 * - æ€è€ƒè¿‡ç¨‹æŠ˜å å±•ç¤º
 * - æµå¼çŠ¶æ€æŒ‡ç¤ºï¼ˆå…‰æ ‡é—ªçƒï¼‰
 */
@Composable
fun StreamingMessageBubble(
    blocks: List<AiAdvisorMessageBlock>,
    isStreaming: Boolean,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier) {
        blocks.forEach { block ->
            when (block.type) {
                MessageBlockType.THINKING -> {
                    ThinkingSection(
                        content = block.content,
                        isStreaming = block.status == MessageBlockStatus.STREAMING,
                        metadata = block.metadata
                    )
                }
                MessageBlockType.MAIN_TEXT -> {
                    MainTextSection(
                        content = block.content,
                        isStreaming = block.status == MessageBlockStatus.STREAMING
                    )
                }
                MessageBlockType.ERROR -> {
                    ErrorSection(content = block.content)
                }
            }
        }
    }
}

@Composable
private fun MainTextSection(
    content: String,
    isStreaming: Boolean
) {
    Row {
        Text(
            text = content,
            style = MaterialTheme.typography.bodyLarge
        )
        if (isStreaming) {
            StreamingCursor()
        }
    }
}

@Composable
private fun StreamingCursor() {
    val infiniteTransition = rememberInfiniteTransition()
    val alpha by infiniteTransition.animateFloat(
        initialValue = 1f,
        targetValue = 0f,
        animationSpec = infiniteRepeatable(
            animation = tween(500),
            repeatMode = RepeatMode.Reverse
        )
    )
    
    Text(
        text = "â–Œ",
        color = MaterialTheme.colorScheme.primary.copy(alpha = alpha)
    )
}
```

### 7.2 æ€è€ƒè¿‡ç¨‹å±•ç¤ºï¼ˆThinkingSectionï¼‰

```kotlin
// presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/advisor/component/ThinkingSection.kt

/**
 * æ€è€ƒè¿‡ç¨‹å±•ç¤ºç»„ä»¶
 * 
 * å‚è€ƒCherry Studioè®¾è®¡ï¼š
 * - å¯æŠ˜å /å±•å¼€
 * - æ˜¾ç¤ºæ€è€ƒè€—æ—¶
 * - æµå¼æ›´æ–°æ—¶æ˜¾ç¤ºåŠ¨ç”»
 */
@Composable
fun ThinkingSection(
    content: String,
    isStreaming: Boolean,
    metadata: BlockMetadata?,
    modifier: Modifier = Modifier
) {
    var isExpanded by remember { mutableStateOf(false) }
    
    Card(
        modifier = modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)
        )
    ) {
        Column(modifier = Modifier.padding(12.dp)) {
            // æ ‡é¢˜æ ï¼ˆå¯ç‚¹å‡»æŠ˜å ï¼‰
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { isExpanded = !isExpanded },
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Icon(
                        imageVector = Icons.Default.Psychology,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.size(20.dp)
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text(
                        text = if (isStreaming) "æ€è€ƒä¸­..." else "æ€è€ƒè¿‡ç¨‹",
                        style = MaterialTheme.typography.labelMedium,
                        color = MaterialTheme.colorScheme.primary
                    )
                    
                    // æ€è€ƒè€—æ—¶
                    metadata?.thinkingMs?.let { ms ->
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = "${ms / 1000.0}s",
                            style = MaterialTheme.typography.labelSmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
                
                // æŠ˜å /å±•å¼€å›¾æ ‡
                Icon(
                    imageVector = if (isExpanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore,
                    contentDescription = if (isExpanded) "æ”¶èµ·" else "å±•å¼€"
                )
            }
            
            // æ€è€ƒå†…å®¹ï¼ˆå¯æŠ˜å ï¼‰
            AnimatedVisibility(visible = isExpanded) {
                Column {
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = content,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    if (isStreaming) {
                        StreamingCursor()
                    }
                }
            }
        }
    }
}
```


### 7.3 åœæ­¢ç”ŸæˆæŒ‰é’®ï¼ˆStopGenerationButtonï¼‰

```kotlin
// presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/advisor/component/StopGenerationButton.kt

/**
 * åœæ­¢ç”ŸæˆæŒ‰é’®
 * 
 * åœ¨æµå¼å“åº”è¿‡ç¨‹ä¸­æ˜¾ç¤ºï¼Œå…è®¸ç”¨æˆ·ä¸­æ–­AIå“åº”
 */
@Composable
fun StopGenerationButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    OutlinedButton(
        onClick = onClick,
        modifier = modifier,
        colors = ButtonDefaults.outlinedButtonColors(
            contentColor = MaterialTheme.colorScheme.error
        ),
        border = BorderStroke(1.dp, MaterialTheme.colorScheme.error)
    ) {
        Icon(
            imageVector = Icons.Default.Stop,
            contentDescription = null,
            modifier = Modifier.size(18.dp)
        )
        Spacer(modifier = Modifier.width(4.dp))
        Text("åœæ­¢ç”Ÿæˆ")
    }
}
```

### 7.4 AiAdvisorChatViewModelæ‰©å±•

```kotlin
// presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt

@HiltViewModel
class AiAdvisorChatViewModel @Inject constructor(
    private val sendAdvisorMessageStreamingUseCase: SendAdvisorMessageStreamingUseCase,
    private val sendAdvisorMessageUseCase: SendAdvisorMessageUseCase,  // éæµå¼å¤‡ç”¨
    private val getAdvisorConversationsUseCase: GetAdvisorConversationsUseCase,
    private val aiAdvisorRepository: AiAdvisorRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(AiAdvisorChatUiState())
    val uiState: StateFlow<AiAdvisorChatUiState> = _uiState.asStateFlow()
    
    private var streamingJob: Job? = null
    
    fun sendMessage(message: String) {
        val contactId = _uiState.value.contactId ?: return
        val sessionId = _uiState.value.currentSessionId ?: return
        
        _uiState.update { it.copy(isStreaming = true, streamingContent = "") }
        
        streamingJob = viewModelScope.launch {
            sendAdvisorMessageStreamingUseCase(contactId, sessionId, message)
                .collect { state ->
                    when (state) {
                        is StreamingState.Started -> {
                            _uiState.update { it.copy(currentMessageId = state.messageId) }
                        }
                        is StreamingState.ThinkingUpdate -> {
                            _uiState.update { 
                                it.copy(
                                    thinkingContent = state.content,
                                    thinkingElapsedMs = state.elapsedMs
                                )
                            }
                        }
                        is StreamingState.TextUpdate -> {
                            _uiState.update { it.copy(streamingContent = state.content) }
                        }
                        is StreamingState.Completed -> {
                            _uiState.update { 
                                it.copy(
                                    isStreaming = false,
                                    streamingContent = "",
                                    thinkingContent = ""
                                )
                            }
                        }
                        is StreamingState.Error -> {
                            _uiState.update { 
                                it.copy(
                                    isStreaming = false,
                                    error = state.error.message
                                )
                            }
                        }
                    }
                }
        }
    }
    
    fun stopGeneration() {
        streamingJob?.cancel()
        _uiState.update { it.copy(isStreaming = false) }
        // æ›´æ–°æ¶ˆæ¯çŠ¶æ€ä¸ºå·²ä¸­æ–­
        viewModelScope.launch {
            _uiState.value.currentMessageId?.let { messageId ->
                aiAdvisorRepository.updateMessageStatus(messageId, SendStatus.CANCELLED)
            }
        }
    }
    
    fun regenerateLastMessage() {
        // åˆ é™¤æœ€åä¸€æ¡AIæ¶ˆæ¯ï¼Œé‡æ–°å‘é€
        viewModelScope.launch {
            val conversations = _uiState.value.conversations
            val lastAiMessage = conversations.lastOrNull { it.messageType == MessageType.AI }
            val lastUserMessage = conversations.lastOrNull { it.messageType == MessageType.USER }
            
            if (lastAiMessage != null && lastUserMessage != null) {
                aiAdvisorRepository.deleteConversation(lastAiMessage.id)
                sendMessage(lastUserMessage.content)
            }
        }
    }
}

data class AiAdvisorChatUiState(
    val contactId: String? = null,
    val currentSessionId: String? = null,
    val currentMessageId: String? = null,
    val conversations: List<AiAdvisorConversation> = emptyList(),
    val isStreaming: Boolean = false,
    val streamingContent: String = "",
    val thinkingContent: String = "",
    val thinkingElapsedMs: Long = 0,
    val error: String? = null
)
```


---

## 8. ä¾èµ–æ³¨å…¥é…ç½®

### 8.1 DatabaseModuleæ‰©å±•

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/di/DatabaseModule.kt

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    // ... ç°æœ‰é…ç½®
    
    @Provides
    @Singleton
    fun provideAppDatabase(
        @ApplicationContext context: Context
    ): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "empathy_ai_database"
        )
            .addMigrations(
                // ... ç°æœ‰è¿ç§»
                MIGRATION_12_13,
                MIGRATION_13_14  // ğŸ†• æ–°å¢
            )
            .build()
    }
    
    @Provides
    fun provideAiAdvisorMessageBlockDao(database: AppDatabase): AiAdvisorMessageBlockDao {
        return database.aiAdvisorMessageBlockDao()
    }
}
```

### 8.2 NetworkModuleæ‰©å±•

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/di/NetworkModule.kt

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    // ... ç°æœ‰é…ç½®
    
    @Provides
    @Singleton
    @Named("sse")
    fun provideSseOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(0, TimeUnit.SECONDS)  // SSEéœ€è¦æ— é™è¯»å–è¶…æ—¶
            .writeTimeout(30, TimeUnit.SECONDS)
            .retryOnConnectionFailure(true)
            .build()
    }
    
    @Provides
    @Singleton
    fun provideSseStreamReader(
        @Named("sse") okHttpClient: OkHttpClient
    ): SseStreamReader {
        return SseStreamReader(okHttpClient)
    }
}
```

### 8.3 AiAdvisorModuleæ‰©å±•

```kotlin
// app/src/main/java/com/empathy/ai/di/AiAdvisorModule.kt

@Module
@InstallIn(SingletonComponent::class)
object AiAdvisorModule {
    // ... ç°æœ‰é…ç½®
    
    @Provides
    @Singleton
    fun provideBlockUpdateManager(
        aiAdvisorMessageBlockDao: AiAdvisorMessageBlockDao,
        @IoDispatcher ioDispatcher: CoroutineDispatcher
    ): BlockUpdateManager {
        return BlockUpdateManager(aiAdvisorMessageBlockDao, ioDispatcher)
    }
    
    @Provides
    @Singleton
    fun provideSendAdvisorMessageStreamingUseCase(
        aiAdvisorRepository: AiAdvisorRepository,
        aiRepository: AiRepository,
        contactRepository: ContactRepository,
        aiProviderRepository: AiProviderRepository,
        promptBuilder: AdvisorPromptBuilder
    ): SendAdvisorMessageStreamingUseCase {
        return SendAdvisorMessageStreamingUseCase(
            aiAdvisorRepository,
            aiRepository,
            contactRepository,
            aiProviderRepository,
            promptBuilder
        )
    }
}
```


---

## 9. æµ‹è¯•è®¾è®¡

### 9.1 å•å…ƒæµ‹è¯•

| æµ‹è¯•ç±» | æµ‹è¯•å†…å®¹ | æ¨¡å— |
|--------|---------|------|
| `AiStreamChunkTest` | æµå¼æ•°æ®å—æ¨¡å‹æµ‹è¯• | :domain |
| `MessageBlockTypeTest` | æ¶ˆæ¯å—ç±»å‹æšä¸¾æµ‹è¯• | :domain |
| `AiAdvisorMessageBlockTest` | æ¶ˆæ¯å—æ¨¡å‹æµ‹è¯• | :domain |
| `SendAdvisorMessageStreamingUseCaseTest` | æµå¼å‘é€ç”¨ä¾‹æµ‹è¯• | :domain |
| `SseStreamReaderTest` | SSEæµå¼è¯»å–å™¨æµ‹è¯• | :data |
| `BlockUpdateManagerTest` | æ™ºèƒ½èŠ‚æµç®¡ç†å™¨æµ‹è¯• | :data |
| `AiAdvisorMessageBlockDaoTest` | æ¶ˆæ¯å—DAOæµ‹è¯• | :data |
| `AiAdvisorChatViewModelTest` | æµå¼ViewModelæµ‹è¯• | :presentation |

### 9.2 å…³é”®æµ‹è¯•ç”¨ä¾‹

```kotlin
// domain/src/test/kotlin/.../SendAdvisorMessageStreamingUseCaseTest.kt

class SendAdvisorMessageStreamingUseCaseTest {
    
    @Test
    fun `æµå¼å“åº”æ­£å¸¸å®Œæˆæ—¶åº”æ›´æ–°BlockçŠ¶æ€ä¸ºSUCCESS`() = runTest {
        // Given
        val mockAiRepository = mockk<AiRepository>()
        coEvery { mockAiRepository.generateTextStream(any(), any(), any()) } returns flowOf(
            AiStreamChunk.Started,
            AiStreamChunk.TextDelta("Hello"),
            AiStreamChunk.TextDelta(" World"),
            AiStreamChunk.Complete("Hello World", null)
        )
        
        // When
        val result = useCase(contactId, sessionId, "test message").toList()
        
        // Then
        assertThat(result).hasSize(4)
        assertThat(result.last()).isInstanceOf(StreamingState.Completed::class.java)
    }
    
    @Test
    fun `æ€è€ƒè¿‡ç¨‹åº”åˆ›å»ºTHINKINGç±»å‹Block`() = runTest {
        // Given
        coEvery { mockAiRepository.generateTextStream(any(), any(), any()) } returns flowOf(
            AiStreamChunk.Started,
            AiStreamChunk.ThinkingDelta("Let me think..."),
            AiStreamChunk.ThinkingComplete("Let me think...", 1000L),
            AiStreamChunk.TextDelta("Answer"),
            AiStreamChunk.Complete("Answer", null)
        )
        
        // When
        val result = useCase(contactId, sessionId, "test").toList()
        
        // Then
        coVerify { aiAdvisorRepository.saveBlock(match { it.type == MessageBlockType.THINKING }) }
    }
    
    @Test
    fun `SSEè¿æ¥å¤±è´¥æ—¶åº”å‘å°„ErrorçŠ¶æ€`() = runTest {
        // Given
        coEvery { mockAiRepository.generateTextStream(any(), any(), any()) } returns flowOf(
            AiStreamChunk.Started,
            AiStreamChunk.Error(IOException("Connection failed"))
        )
        
        // When
        val result = useCase(contactId, sessionId, "test").toList()
        
        // Then
        assertThat(result.last()).isInstanceOf(StreamingState.Error::class.java)
    }
}
```

### 9.3 æ•°æ®åº“è¿ç§»æµ‹è¯•

```kotlin
// data/src/androidTest/kotlin/.../Migration13To14Test.kt

@RunWith(AndroidJUnit4::class)
class Migration13To14Test {
    
    @get:Rule
    val helper = MigrationTestHelper(
        InstrumentationRegistry.getInstrumentation(),
        AppDatabase::class.java
    )
    
    @Test
    fun migrate13To14_createsMessageBlocksTable() {
        // Given: v13æ•°æ®åº“
        helper.createDatabase(TEST_DB, 13).apply {
            execSQL("""
                INSERT INTO ai_advisor_conversations 
                (id, contact_id, session_id, message_type, content, timestamp, created_at)
                VALUES ('msg1', 'contact1', 'session1', 'AI', 'Hello', 1000, 1000)
            """)
            close()
        }
        
        // When: è¿ç§»åˆ°v14
        helper.runMigrationsAndValidate(TEST_DB, 14, true, MIGRATION_13_14)
        
        // Then: éªŒè¯Blockè¡¨å·²åˆ›å»ºä¸”æ•°æ®å·²è¿ç§»
        val db = helper.openDatabase(TEST_DB, 14)
        val cursor = db.query("SELECT * FROM ai_advisor_message_blocks WHERE message_id = 'msg1'")
        
        assertThat(cursor.count).isEqualTo(1)
        cursor.moveToFirst()
        assertThat(cursor.getString(cursor.getColumnIndex("type"))).isEqualTo("MAIN_TEXT")
        assertThat(cursor.getString(cursor.getColumnIndex("status"))).isEqualTo("SUCCESS")
    }
}
```


---

## 10. å®ç°ä»»åŠ¡æ¸…å•

### 10.1 Phase 1: æ•°æ®å±‚åŸºç¡€ï¼ˆé¢„è®¡2å¤©ï¼‰

| ä»»åŠ¡ID | ä»»åŠ¡æè¿° | ä¼˜å…ˆçº§ | é¢„è®¡å·¥æ—¶ |
|--------|---------|--------|---------|
| T1.1 | åˆ›å»ºAiStreamChunkå¯†å°ç±» | P0 | 1h |
| T1.2 | åˆ›å»ºMessageBlockType/MessageBlockStatusæšä¸¾ | P0 | 0.5h |
| T1.3 | åˆ›å»ºAiAdvisorMessageBlockæ¨¡å‹ | P0 | 1h |
| T1.4 | åˆ›å»ºStreamingStateå¯†å°ç±» | P0 | 0.5h |
| T1.5 | åˆ›å»ºAiAdvisorMessageBlockEntity | P0 | 1h |
| T1.6 | åˆ›å»ºAiAdvisorMessageBlockDao | P0 | 1h |
| T1.7 | ç¼–å†™MIGRATION_13_14è¿ç§»è„šæœ¬ | P0 | 2h |
| T1.8 | æ›´æ–°AppDatabaseï¼ˆç‰ˆæœ¬å‡çº§+æ–°DAOï¼‰ | P0 | 1h |
| T1.9 | ç¼–å†™Migration13To14Test | P0 | 2h |

### 10.2 Phase 2: SSEæµå¼å®ç°ï¼ˆé¢„è®¡2å¤©ï¼‰

| ä»»åŠ¡ID | ä»»åŠ¡æè¿° | ä¼˜å…ˆçº§ | é¢„è®¡å·¥æ—¶ |
|--------|---------|--------|---------|
| T2.1 | åˆ›å»ºSseStreamReader | P0 | 4h |
| T2.2 | åˆ›å»ºSseFallbackException | P0 | 0.5h |
| T2.3 | åˆ›å»ºBlockUpdateManager | P0 | 3h |
| T2.4 | æ‰©å±•AiRepositoryæ¥å£ï¼ˆæ·»åŠ generateTextStreamï¼‰ | P0 | 1h |
| T2.5 | å®ç°AiRepositoryImpl.generateTextStream | P0 | 2h |
| T2.6 | æ‰©å±•AiAdvisorRepositoryæ¥å£ï¼ˆBlockç›¸å…³ï¼‰ | P0 | 1h |
| T2.7 | å®ç°AiAdvisorRepositoryImpl Blockæ–¹æ³• | P0 | 2h |
| T2.8 | ç¼–å†™SseStreamReaderTest | P1 | 2h |
| T2.9 | ç¼–å†™BlockUpdateManagerTest | P1 | 2h |

### 10.3 Phase 3: UseCaseå±‚ï¼ˆé¢„è®¡1å¤©ï¼‰

| ä»»åŠ¡ID | ä»»åŠ¡æè¿° | ä¼˜å…ˆçº§ | é¢„è®¡å·¥æ—¶ |
|--------|---------|--------|---------|
| T3.1 | åˆ›å»ºSendAdvisorMessageStreamingUseCase | P0 | 4h |
| T3.2 | ç¼–å†™SendAdvisorMessageStreamingUseCaseTest | P0 | 3h |
| T3.3 | æ›´æ–°AiAdvisorModuleï¼ˆæµå¼DIé…ç½®ï¼‰ | P0 | 1h |

### 10.4 Phase 4: UIå±‚ï¼ˆé¢„è®¡2å¤©ï¼‰

| ä»»åŠ¡ID | ä»»åŠ¡æè¿° | ä¼˜å…ˆçº§ | é¢„è®¡å·¥æ—¶ |
|--------|---------|--------|---------|
| T4.1 | åˆ›å»ºStreamingMessageBubbleç»„ä»¶ | P0 | 3h |
| T4.2 | åˆ›å»ºThinkingSectionç»„ä»¶ | P0 | 3h |
| T4.3 | åˆ›å»ºStopGenerationButtonç»„ä»¶ | P1 | 1h |
| T4.4 | æ‰©å±•AiAdvisorChatViewModelï¼ˆæµå¼çŠ¶æ€ï¼‰ | P0 | 3h |
| T4.5 | æ›´æ–°AiAdvisorChatScreenï¼ˆé›†æˆæµå¼ç»„ä»¶ï¼‰ | P0 | 3h |
| T4.6 | ç¼–å†™AiAdvisorChatViewModelTest | P1 | 2h |

### 10.5 Phase 5: é›†æˆæµ‹è¯•ï¼ˆé¢„è®¡1å¤©ï¼‰

| ä»»åŠ¡ID | ä»»åŠ¡æè¿° | ä¼˜å…ˆçº§ | é¢„è®¡å·¥æ—¶ |
|--------|---------|--------|---------|
| T5.1 | ç«¯åˆ°ç«¯æµå¼å¯¹è¯æµ‹è¯• | P0 | 3h |
| T5.2 | æ€è€ƒè¿‡ç¨‹å±•ç¤ºæµ‹è¯• | P0 | 2h |
| T5.3 | åœæ­¢ç”ŸæˆåŠŸèƒ½æµ‹è¯• | P1 | 1h |
| T5.4 | é™çº§ç­–ç•¥æµ‹è¯• | P2 | 2h |

---

## 11. é£é™©ä¸ç¼“è§£æªæ–½

| é£é™© | å½±å“ | ç¼“è§£æªæ–½ |
|------|------|---------|
| SSEè¿æ¥ä¸ç¨³å®š | ç”¨æˆ·ä½“éªŒå·® | å®ç°é™çº§ç­–ç•¥ï¼Œè‡ªåŠ¨åˆ‡æ¢éæµå¼æ¨¡å¼ |
| æ•°æ®åº“è¿ç§»å¤±è´¥ | æ•°æ®ä¸¢å¤± | å®Œæ•´çš„è¿ç§»æµ‹è¯•ï¼Œå¤‡ä»½æœºåˆ¶ |
| æ€è€ƒè¿‡ç¨‹è§£æå¤±è´¥ | åŠŸèƒ½ä¸å®Œæ•´ | å¤šæ¨¡å‹å…¼å®¹æ€§æµ‹è¯•ï¼Œfallbackå¤„ç† |
| å†…å­˜å ç”¨è¿‡é«˜ | åº”ç”¨å¡é¡¿ | æ™ºèƒ½èŠ‚æµï¼ŒåŠæ—¶æ¸…ç†èµ„æº |

---

## 12. æ–‡æ¡£ç‰ˆæœ¬å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | ä½œè€… | å˜æ›´å†…å®¹ |
|------|------|------|---------|
| 1.0 | 2026-01-04 | AI Assistant | åˆå§‹ç‰ˆæœ¬ |

---

## 13. å‚è€ƒæ–‡æ¡£

- [PRD-00028 AIå†›å¸ˆæµå¼å¯¹è¯å‡çº§éœ€æ±‚](../PRD/PRD-00028-AIå†›å¸ˆæµå¼å¯¹è¯å‡çº§éœ€æ±‚.md)
- [TDD-00028 AIå†›å¸ˆæµå¼å¯¹è¯å‡çº§æŠ€æœ¯è®¾è®¡](../TDD/TDD-00028-AIå†›å¸ˆæµå¼å¯¹è¯å‡çº§æŠ€æœ¯è®¾è®¡.md)
- [FD-00026 AIå†›å¸ˆå¯¹è¯åŠŸèƒ½è®¾è®¡](./FD-00026-AIå†›å¸ˆå¯¹è¯åŠŸèƒ½è®¾è®¡.md)
- [RESEARCH-00003 Cherryé¡¹ç›®æ¶æ„å¯¹æ¯”åˆ†ææŠ¥å‘Š](../RE/RESEARCH-00003-Cherryé¡¹ç›®æ¶æ„å¯¹æ¯”åˆ†ææŠ¥å‘Š.md)
- [RESEARCH-00004 Cherryé¡¹ç›®AIå¯¹è¯å®ç°æ·±åº¦åˆ†ææŠ¥å‘Š](../RE/RESEARCH-00004-Cherryé¡¹ç›®AIå¯¹è¯å®ç°æ·±åº¦åˆ†ææŠ¥å‘Š.md)
