# è‡ªç”±æ¢ç´¢æŠ¥å‘Š

## åŸºæœ¬ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| æ—¥æœŸ | 2026-01-12 |
| åˆ†æ”¯ | freedom |
| çŠ¶æ€ | ğŸ“–ä»…å‚è€ƒ |
| æ¢ç´¢è€… | free-explorer |
| å†³ç­–æ—¥å¿— | DECISION_JOURNAL.md |

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

- å†³ç­–æ—¥å¿—: `DECISION_JOURNAL.md`
- ç»éªŒç§¯ç´¯: æœªæ–°å¢ï¼ˆæœ¬æ¬¡æ¢ç´¢æ²¡æœ‰ç»è¿‡éªŒè¯çš„é€šç”¨ç»éªŒï¼‰

---

## æ¢ç´¢ä¸»é¢˜

### æ¢ç´¢æ–¹å‘

å›´ç»•â€œè”ç³»äººæœç´¢ä½“éªŒæ¸…æ™°åº¦â€åšæ”¹é€ ã€‚å½“å‰æœç´¢ä¼šè¿‡æ»¤åˆ—è¡¨ï¼Œä½†ç”¨æˆ·åªçœ‹åˆ°ç»“æœå˜å°‘ï¼Œå¹¶ä¸ä¸€å®šèƒ½ç«‹åˆ»ç†è§£â€œåŒ¹é…ç‚¹åœ¨å“ªé‡Œâ€ã€‚å› æ­¤å°è¯•å¼•å…¥è½»é‡çš„å…³é”®è¯é«˜äº®ï¼Œå¹¶æŠŠé«˜äº®é€»è¾‘åšæˆé€šç”¨å·¥å…·å‡½æ•°ï¼Œæ–¹ä¾¿åœ¨ä¸åŒåˆ—è¡¨å¤ç”¨ï¼ŒåŒæ—¶é¿å…é‡å¤ç®—æ³•å¸¦æ¥çš„ç»´æŠ¤æˆæœ¬ã€‚

### åˆ›æ„æ¥æº

1. è”ç³»äººæœç´¢ UI å·²å­˜åœ¨ä½†ç¼ºå°‘æ˜¾å¼åé¦ˆã€‚
2. ç”»åƒæ ‡ç­¾æœç´¢å·²æœ‰é«˜äº®å®ç°ï¼Œä½†é€»è¾‘æ˜¯ç»„ä»¶å†…ç§æœ‰å®ç°ï¼Œæ— æ³•å¤ç”¨ã€‚
3. AI å†›å¸ˆè”ç³»äººé€‰æ‹©é¡µä¹Ÿæœ‰æœç´¢åŠŸèƒ½ï¼Œä½†æ²¡æœ‰é«˜äº®æç¤ºï¼Œä½“éªŒä¸ä¸€è‡´ã€‚

---

## æ¢ç´¢ç›®æ ‡

- åœ¨è”ç³»äººåˆ—è¡¨æœç´¢ç»“æœä¸­é«˜äº®åŒ¹é…å…³é”®è¯ï¼Œè®©ç”¨æˆ·ç«‹åˆ»ç¡®è®¤åŒ¹é…ä½ç½®ã€‚
- å¤ç”¨å·²æœ‰çš„é«˜äº®å®ç°æ€æƒ³ï¼ŒæŠ½å–é€šç”¨å·¥å…·å‡½æ•°ï¼Œå‡å°‘é‡å¤é€»è¾‘ã€‚
- å°†é«˜äº®èƒ½åŠ›åŒæ­¥åˆ° AI å†›å¸ˆè”ç³»äººé€‰æ‹©é¡µï¼Œä¿è¯åŒç±»æœç´¢ä½“éªŒä¸€è‡´ã€‚
- æ‰©å±•é«˜äº®åˆ° AI é…ç½®æœåŠ¡å•†åˆ—è¡¨çš„æœç´¢ç»“æœï¼Œæé«˜å‘½ä¸­å¯è§æ€§ã€‚
- æ‰©å±•é«˜äº®åˆ°æ ‡ç­¾ç®¡ç†åˆ—è¡¨ï¼Œè®©æ ‡ç­¾æœç´¢å‘½ä¸­æ›´ç›´è§‚ã€‚
- è¡¥é½æ ‡ç­¾ç®¡ç†é¡µæœç´¢å…¥å£ï¼Œé¿å…â€œæœ‰æœç´¢çŠ¶æ€ä½†æ— è¾“å…¥â€çš„å‰²è£‚ä½“éªŒã€‚
- AI é…ç½®æœç´¢æ— ç»“æœæç¤ºï¼Œé¿å…åˆ—è¡¨ç©ºç™½å¸¦æ¥çš„è¯¯è§£ã€‚
- æ ‡ç­¾æœç´¢æ çš„è¿”å›å…³é—­è¡Œä¸ºï¼Œç¬¦åˆå¸¸è§æœç´¢äº¤äº’é¢„æœŸã€‚
- ä¿æŒ iOS é£æ ¼çš„ç®€æ´å¤–è§‚ï¼Œä¸å¼•å…¥é¢å¤–å¤æ‚ UIã€‚

---

## æ¢ç´¢è¿‡ç¨‹

### å°è¯• 1ï¼šåœ¨ ContactListItem å†…ç›´æ¥å¤åˆ¶é«˜äº®é€»è¾‘

æœ€åˆè€ƒè™‘ç›´æ¥åœ¨è”ç³»äººåˆ—è¡¨é¡¹ä¸­å¤åˆ¶ `SelectableTagChip` é‡Œçš„é«˜äº®ç®—æ³•ã€‚è¿™æ ·æ”¹åŠ¨å°ï¼Œæ¥å…¥é€Ÿåº¦å¿«ï¼Œä½†ä¼šé€ æˆä¸¤å¥—é‡å¤é€»è¾‘ã€‚ä¸€æ—¦åç»­å‘ç°é«˜äº®ç®—æ³•é—®é¢˜ï¼Œå°±è¦æ”¹å¤šå¤„ï¼Œè€Œä¸”ä¸åŒé¡µé¢çš„é«˜äº®é£æ ¼ä¹Ÿéš¾ä»¥ç»Ÿä¸€ã€‚ç»¼åˆç»´æŠ¤æˆæœ¬ä¸é•¿æœŸä¸€è‡´æ€§ï¼Œè¿™ä¸ªæ–¹æ¡ˆæ²¡æœ‰é‡‡ç”¨ã€‚

### å°è¯• 2ï¼šæŠ½å–é€šç”¨é«˜äº®å·¥å…·å‡½æ•°ï¼ˆé‡‡ç”¨ï¼‰

æˆ‘å†³å®šæŠŠé«˜äº®é€»è¾‘æŠ½ç¦»ä¸º `TextHighlight.kt` å·¥å…·å‡½æ•°ï¼Œé›†ä¸­ç®¡ç†å¤§å°å†™åŒ¹é…ã€åˆ†æ®µæ‹¼æ¥ä¸ SpanStyle æ¸²æŸ“ã€‚è¿™æ ·ä¸ä»…è®©è”ç³»äººåˆ—è¡¨ä½¿ç”¨è¯¥å‡½æ•°ï¼Œä¹Ÿèƒ½æ›¿æ¢æ‰ `SelectableTagChip` çš„å†…åµŒå®ç°ï¼Œé¿å…é‡å¤ã€‚å·¥å…·å‡½æ•°é€šè¿‡ `String.indexOf(..., ignoreCase = true)` æ¥å®šä½åŒ¹é…ä½ç½®ï¼Œé¿å… `lowercase()` é€ æˆå­—ç¬¦é•¿åº¦å˜åŒ–çš„æ½œåœ¨é£é™©ã€‚

### å°è¯• 3ï¼šåœ¨ AI å†›å¸ˆè”ç³»äººé€‰æ‹©é¡µåŒæ­¥é«˜äº®ï¼ˆé‡‡ç”¨ï¼‰

è¯¥é¡µé¢å·²ç»æœ‰æœç´¢è¿‡æ»¤é€»è¾‘ï¼Œä½†è§†è§‰åé¦ˆä¸è¶³ã€‚ä¸ºäº†ä¿è¯ä½“éªŒä¸€è‡´ï¼Œç»™è¯¥åˆ—è¡¨é¡¹æ–°å¢ `highlightQuery` å‚æ•°å¹¶è°ƒç”¨é€šç”¨é«˜äº®å·¥å…·å‡½æ•°ï¼Œä¿è¯æœç´¢å…³é”®è¯åœ¨å§“åå’Œâ€œæœ€åæ¶ˆæ¯é¢„è§ˆâ€ä¸­å¯è§ã€‚è¿™æ ·ç”¨æˆ·åœ¨ä¸¤ä¸ªé¡µé¢çœ‹åˆ°çš„æœç´¢ä½“éªŒæ˜¯ç»Ÿä¸€çš„ã€‚

### å°è¯• 4ï¼šæ·»åŠ â€œåŒ¹é… X ä½è”ç³»äººâ€æç¤ºï¼ˆæ”¾å¼ƒï¼‰

æˆ‘è€ƒè™‘è¿‡åœ¨æœç´¢ç»“æœåˆ—è¡¨é¡¶éƒ¨å¢åŠ ä¸€æ¡è®¡æ•°æç¤ºï¼Œè®©ç”¨æˆ·çŸ¥é“åŒ¹é…æ•°é‡ã€‚ä½†è¿™ä¼šå¼•å…¥é¢å¤–å¸ƒå±€ã€å­—ä½“æ ·å¼ä»¥åŠäº§å“å£å¾„ç¡®è®¤ã€‚è¯¥æ¢ç´¢ç›®æ ‡ä¸»è¦æ˜¯éªŒè¯é«˜äº®æ˜¯å¦æ”¹å–„åé¦ˆï¼Œå› æ­¤æš‚æ—¶ä¸åšè®¡æ•°æç¤ºï¼Œé¿å… UI å¤æ‚åº¦ä¸Šå‡ã€‚

### å°è¯• 5ï¼šè¡¥å……é«˜äº®å·¥å…·å•å…ƒæµ‹è¯•ï¼ˆé‡‡ç”¨ï¼‰

é«˜äº®å·¥å…·å‡½æ•°å±äºçº¯é€»è¾‘å®ç°ï¼Œå®¹æ˜“åœ¨åç»­ä¼˜åŒ–ä¸­å‡ºç°åŒ¹é…èŒƒå›´æˆ–å¤§å°å†™é€»è¾‘å›å½’ã€‚æˆ‘ä¸º `buildHighlightedText` å¢åŠ äº†å°‘é‡å•å…ƒæµ‹è¯•ï¼Œè¦†ç›–ç©ºæŸ¥è¯¢ã€å¤§å°å†™åŒ¹é…ã€å¤šæ¬¡åŒ¹é…èŒƒå›´ä¸‰ç±»æ ¸å¿ƒåœºæ™¯ï¼Œå¹¶å·²è¿è¡Œé€šè¿‡ï¼Œä½œä¸ºåˆå¹¶å‰çš„éªŒè¯åŸºç¡€ã€‚

### å°è¯• 6ï¼šæ·±è‰²æ¨¡å¼é«˜äº®é€æ˜åº¦è°ƒæ•´ï¼ˆé‡‡ç”¨ï¼‰

æˆ‘æ³¨æ„åˆ°é«˜äº®èƒŒæ™¯ä½¿ç”¨å›ºå®š 0.2 é€æ˜åº¦ï¼Œåœ¨æ·±è‰²æ¨¡å¼ä¸‹å¯èƒ½ä¸å¤Ÿæ˜¾çœ¼ã€‚ä¸ºäº†æå‡å¯è§æ€§ï¼Œåœ¨æ·±è‰²æ¨¡å¼ä¸‹å°†é«˜äº®é€æ˜åº¦æå‡åˆ° 0.35ã€‚è¯¥è°ƒæ•´ä»éœ€æ‰‹åŠ¨é¢„è§ˆç¡®è®¤è§†è§‰æ•ˆæœã€‚

### å°è¯• 7ï¼šè¡¥å…… ASCII å¤§å°å†™ä¸æ— åŒ¹é…æµ‹è¯•ï¼ˆé‡‡ç”¨ï¼‰

ç°æœ‰ç”¨ä¾‹è¦†ç›–äº†ä¸­æ–‡åŒ¹é…å’Œå¤šæ¬¡åŒ¹é…ï¼Œä½†æ²¡æœ‰éªŒè¯è‹±æ–‡å¤§å°å†™å¿½ç•¥åŒ¹é…ï¼Œä¹Ÿæ²¡æœ‰è¦†ç›–â€œæ— åŒ¹é…è¿”å›åŸæ–‡â€çš„åœºæ™¯ã€‚æˆ‘è¡¥å……äº† `buildHighlightedText_caseInsensitiveAscii_matchesAndHighlights` å’Œ `buildHighlightedText_noMatch_returnsPlainText` ä¸¤æ¡æµ‹è¯•ï¼Œå¹¶é‡æ–°è¿è¡Œå•æµ‹ç¡®è®¤é€šè¿‡ã€‚

### å°è¯• 8ï¼šæŠ½å–é«˜äº®æ ·å¼å‡½æ•°ï¼ˆé‡‡ç”¨ï¼‰

æ·±è‰²æ¨¡å¼é«˜äº®é€æ˜åº¦è°ƒæ•´åï¼Œæˆ‘å‘ç° ContactListItem ä¸ ContactSelectScreen å†…çš„æ ·å¼ç”Ÿæˆé€»è¾‘å‡ºç°é‡å¤ã€‚ä¸ºé¿å…åç»­è°ƒå‚æ¼æ”¹ï¼Œæˆ‘åœ¨ `TextHighlight.kt` å¢åŠ  `searchHighlightAlpha` ä¸ `createSearchHighlightStyle`ï¼Œé›†ä¸­ç®¡ç†é«˜äº®é€æ˜åº¦ä¸å­—ä½“æƒé‡ï¼Œå¹¶è®©ä¸¤å¤„è°ƒç”¨ç»Ÿä¸€èµ°å·¥å…·å‡½æ•°ã€‚

### å°è¯• 9ï¼šæ‰©å±•åˆ° AI é…ç½®æœåŠ¡å•†åˆ—è¡¨ï¼ˆé‡‡ç”¨ï¼‰

AI é…ç½®é¡µé¢åŒæ ·æœ‰æœç´¢ï¼Œä½†æœåŠ¡å•†åˆ—è¡¨åªæœ‰è¿‡æ»¤ï¼Œæ²¡æœ‰é«˜äº®æç¤ºã€‚æˆ‘å°† `IOSProviderCard` å¢åŠ  `highlightQuery`ï¼Œå¹¶åœ¨ `AiConfigScreen` å†…æŠŠ `uiState.searchQuery` ä¼ å…¥ï¼Œä½¿æœåŠ¡å•†åç§°åœ¨æœç´¢æ—¶å¯è§é«˜äº®ã€‚è¿™æ ·ç”¨æˆ·èƒ½å¿«é€Ÿç¡®è®¤â€œå‘½ä¸­ä½ç½®â€ï¼Œé¿å…åªæœ‰åˆ—è¡¨å˜çŸ­çš„åé¦ˆã€‚

### å°è¯• 10ï¼šæ‰©å±•åˆ°æ ‡ç­¾ç®¡ç†åˆ—è¡¨ï¼ˆé‡‡ç”¨ï¼‰

æ ‡ç­¾ç®¡ç†é¡µå·²æœ‰æœç´¢é€»è¾‘ï¼ˆè¿‡æ»¤æ ‡ç­¾ï¼‰ï¼Œä½†æ ‡ç­¾èŠ¯ç‰‡ä¸å±•ç¤ºå‘½ä¸­ä½ç½®ã€‚æˆ‘åœ¨ `TagChip` å¢åŠ å¯é€‰çš„ `highlightQuery`ï¼Œå¹¶åœ¨ `BrainTagScreen` çš„æ ‡ç­¾åˆ—è¡¨ä¼ å…¥æœç´¢ä¸²ã€‚è¯¥æ”¹åŠ¨å¤ç”¨ç»Ÿä¸€é«˜äº®å·¥å…·å‡½æ•°ï¼Œä½†ç”±äº TagChip èƒŒæ™¯ä¸ºå½©è‰²å®¹å™¨ï¼Œä»éœ€äººå·¥è§†è§‰ç¡®è®¤æ˜¯å¦è¿‡äºçªå…€ã€‚

### å°è¯• 11ï¼šè¡¥é½æ ‡ç­¾ç®¡ç†æœç´¢å…¥å£ï¼ˆé‡‡ç”¨ï¼‰

BrainTagScreen é¡¶éƒ¨æœç´¢å›¾æ ‡åŸæœ¬æ²¡æœ‰è¡Œä¸ºï¼Œå¯¼è‡´æœç´¢çŠ¶æ€â€œå­˜åœ¨ä½†ä¸å¯ç”¨â€ã€‚æˆ‘ä½¿ç”¨ç°æœ‰ `TagSearchBar` ç»„ä»¶ï¼Œåœ¨ TopAppBar ä¸‹æ–¹æŒ‰éœ€å±•ç¤ºæœç´¢æ ï¼Œæœç´¢å…³é—­æ—¶åŒæ—¶è§¦å‘ `ClearSearch`ï¼Œç¡®ä¿æœç´¢çŠ¶æ€å›æ”¶ã€‚è¿™é¡¹æ”¹åŠ¨è®©æ ‡ç­¾ç®¡ç†é¡µçš„æœç´¢å…¥å£å˜ä¸ºå¯ç”¨ï¼Œä½†æœªè¿›è¡Œ UI é¢„è§ˆéªŒè¯ã€‚

### å°è¯• 12ï¼šæ ‡ç­¾æœç´¢æ— ç»“æœæç¤ºï¼ˆé‡‡ç”¨ï¼‰

æ ‡ç­¾æœç´¢æ— å‘½ä¸­æ—¶åˆ—è¡¨åŒºåŸŸä¼šå®Œå…¨ç©ºç™½ï¼Œç”¨æˆ·æ— æ³•ç¡®è®¤æ˜¯å¦â€œæ²¡æœ‰ç»“æœâ€ã€‚æˆ‘åœ¨ `TagList` ä¸­å¢åŠ æ¡ä»¶åˆ†æ”¯ï¼Œå½“ `searchQuery` éç©ºä¸”è¿‡æ»¤ç»“æœä¸ºç©ºæ—¶ï¼Œå±•ç¤º `EmptyView` çš„ NoResults çŠ¶æ€æç¤ºâ€œæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„æ ‡ç­¾â€ã€‚è¯¥æ”¹åŠ¨æé«˜äº†åé¦ˆæ¸…æ™°åº¦ï¼Œä½†æœªè¿›è¡Œ UI é¢„è§ˆéªŒè¯ã€‚

### å°è¯• 13ï¼šAI é…ç½®æœç´¢æ— ç»“æœæç¤ºï¼ˆé‡‡ç”¨ï¼‰

AI é…ç½®é¡µæœç´¢åå¦‚æœæ— åŒ¹é…ï¼ŒæœåŠ¡å•†åˆ—è¡¨ä¼šç©ºç™½ã€‚æˆ‘åœ¨ `AiConfigScreenContent` ä¸­æ–°å¢åˆ†æ”¯ï¼Œå½“ `searchQuery` éç©ºä¸” `filteredProviders` ä¸ºç©ºæ—¶æ˜¾ç¤º `EmptyView.NoResults`ï¼Œæç¤ºâ€œæœªæ‰¾åˆ°åŒ¹é…çš„æœåŠ¡å•†â€ã€‚è¯¥æ”¹åŠ¨ä¸æ ‡ç­¾ã€è”ç³»äººæœç´¢çš„åé¦ˆä¸€è‡´ï¼Œä½†æœªè¿›è¡Œ UI é¢„è§ˆéªŒè¯ã€‚

### å°è¯• 14ï¼šæ ‡ç­¾æœç´¢æ è¿”å›å…³é—­ï¼ˆé‡‡ç”¨ï¼‰

æœç´¢æ å±•å¼€æ—¶ï¼ŒBack æ‰‹åŠ¿ç›´æ¥é€€å‡ºé¡µé¢ä¸ç¬¦åˆé¢„æœŸã€‚æˆ‘å¢åŠ  `BackHandler` é€»è¾‘ï¼Œå½“æœç´¢æ å¯è§æ—¶ä¼˜å…ˆå…³é—­æœç´¢æ å¹¶æ¸…ç©ºæœç´¢ï¼Œå†æ¬¡ Back æ‰ä¼šçœŸæ­£è¿”å›ã€‚è¯¥æ”¹åŠ¨æå‡äº†æœç´¢äº¤äº’ä¸€è‡´æ€§ï¼Œä½†æœªè¿›è¡Œ UI é¢„è§ˆéªŒè¯ã€‚

---
## å®éªŒç»“æœ

### æˆåŠŸçš„å®éªŒ

| å®éªŒ | ç»“æœ | ä»·å€¼è¯„ä¼° |
|------|------|----------|
| æŠ½å–é€šç”¨é«˜äº®å·¥å…·å‡½æ•° | âœ… å¤ç”¨åˆ°å¤šä¸ªç»„ä»¶ | é«˜ |
| è”ç³»äººåˆ—è¡¨æœç´¢é«˜äº® | âœ… åŒ¹é…ä½ç½®æ›´æ¸…æ™° | ä¸­ |
| AI å†›å¸ˆè”ç³»äººé€‰æ‹©é¡µé«˜äº® | âœ… æœç´¢ä½“éªŒä¸€è‡´ | ä¸­ |
| AI é…ç½®æœåŠ¡å•†åˆ—è¡¨é«˜äº® | âœ… å‘½ä¸­åé¦ˆæ›´ç›´è§‚ | ä¸­ |
| æ ‡ç­¾ç®¡ç†åˆ—è¡¨é«˜äº® | âœ… æœç´¢ä½“éªŒæ›´ä¸€è‡´ | ä½ |
| æ ‡ç­¾ç®¡ç†æœç´¢å…¥å£è¡¥é½ | âœ… æœç´¢èƒ½åŠ›å¯ç”¨ | ä¸­ |
| æ ‡ç­¾æœç´¢æ— ç»“æœæç¤º | âœ… åé¦ˆæ›´æ¸…æ™° | ä½ |
| AI é…ç½®æœç´¢æ— ç»“æœæç¤º | âœ… åé¦ˆæ›´æ¸…æ™° | ä½ |
| æ ‡ç­¾æœç´¢æ è¿”å›å…³é—­ | âœ… äº¤äº’æ›´ç¬¦åˆé¢„æœŸ | ä½ |
| é«˜äº®å·¥å…·å•å…ƒæµ‹è¯•ç¼–å†™ | âœ… å·²è¿è¡Œé€šè¿‡ | ä¸­ |
| æ·±è‰²æ¨¡å¼é«˜äº®é€æ˜åº¦è°ƒæ•´ | âš ï¸ ä»£ç å®Œæˆï¼Œå¾…è§†è§‰éªŒè¯ | ä½ |
| é«˜äº®æ ·å¼å‡½æ•°æŠ½å– | âœ… ç»Ÿä¸€æ ·å¼ç”Ÿæˆ | ä¸­ |

### å¤±è´¥/æ”¾å¼ƒçš„å®éªŒ

| å®éªŒ | å¤±è´¥åŸå›  | æ•™è®­ |
|------|----------|------|
| æœç´¢ç»“æœè®¡æ•°æç¤º | éœ€è¦é¢å¤–è®¾è®¡ç¡®è®¤ï¼Œè¶…å‡ºå½“å‰æ¢ç´¢èŒƒå›´ | æ¢ç´¢åº”èšç„¦å¯éªŒè¯æ”¹åŠ¨ï¼Œé¿å…å¼•å…¥æ–° UI äº‰è®® |

---

## ä»£ç å˜æ›´

### å˜æ›´ 1ï¼šæ–°å¢é€šç”¨é«˜äº®å·¥å…·å‡½æ•°

**ä¿®æ”¹åŸå› **ï¼ˆä¸å°‘äº 3 å¥è¯ï¼‰ï¼š
1. ç°æœ‰é«˜äº®é€»è¾‘éšè—åœ¨ `SelectableTagChip` å†…ï¼Œæ— æ³•å¤ç”¨ã€‚
2. è”ç³»äººæœç´¢éœ€è¦é«˜äº®æ—¶ï¼Œå¦‚æœå¤åˆ¶é€»è¾‘ä¼šé€ æˆé‡å¤å®ç°ã€‚
3. æŠ½å–å·¥å…·å‡½æ•°èƒ½é›†ä¸­å¤„ç†å¤§å°å†™åŒ¹é…ä¸åˆ†æ®µæ‹¼æ¥ï¼Œé™ä½æœªæ¥ç»´æŠ¤æˆæœ¬ã€‚
4. æ·±è‰²æ¨¡å¼é«˜äº®éœ€è¦ç»Ÿä¸€é€æ˜åº¦ç­–ç•¥ï¼Œé€‚åˆåœ¨å·¥å…·å±‚é›†ä¸­ç®¡ç†ã€‚

**å½±å“åˆ†æ**ï¼š
- æ–°å¢ `TextHighlight.kt` åªä¾èµ– Compose text APIï¼Œä¸å½±å“ä¸šåŠ¡å±‚ã€‚
- å…¶å®ƒç»„ä»¶å¯ä»¥ç›´æ¥å¤ç”¨è¯¥å‡½æ•°ï¼Œå‡å°‘é‡å¤ä»£ç ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä¿ç•™æ¯ä¸ªç»„ä»¶ç‹¬ç«‹å®ç°é«˜äº®é€»è¾‘ï¼Œä½†ä¼šé€ æˆé‡å¤å’Œé£æ ¼ä¸ä¸€è‡´ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/util/TextHighlight.kt
// æ–°å¢æ–‡ä»¶ï¼Œä¿®æ”¹å‰ä¸å­˜åœ¨
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/util/TextHighlight.kt
package com.empathy.ai.presentation.util

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.AnnotatedString
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.withStyle

fun buildHighlightedText(
    text: String,
    query: String,
    highlightStyle: SpanStyle
): AnnotatedString {
    if (query.isBlank() || text.isEmpty()) {
        return AnnotatedString(text)
    }

    var currentIndex = 0

    return buildAnnotatedString {
        while (currentIndex < text.length) {
            val matchIndex = text.indexOf(query, currentIndex, ignoreCase = true)
            if (matchIndex == -1) {
                append(text.substring(currentIndex))
                break
            }

            if (matchIndex > currentIndex) {
                append(text.substring(currentIndex, matchIndex))
            }

            withStyle(highlightStyle) {
                append(text.substring(matchIndex, matchIndex + query.length))
            }

            currentIndex = matchIndex + query.length
        }
    }
}

fun searchHighlightAlpha(isDarkTheme: Boolean): Float {
    return if (isDarkTheme) 0.35f else 0.2f
}

fun createSearchHighlightStyle(
    isDarkTheme: Boolean,
    baseColor: Color
): SpanStyle {
    return SpanStyle(
        fontWeight = FontWeight.SemiBold,
        background = baseColor.copy(alpha = searchHighlightAlpha(isDarkTheme))
    )
}
```

---

### å˜æ›´ 2ï¼šSelectableTagChip å¤ç”¨é€šç”¨é«˜äº®å·¥å…·

**ä¿®æ”¹åŸå› **ï¼š
1. è¯¥ç»„ä»¶åŸæœ‰çš„é«˜äº®é€»è¾‘ä¸è”ç³»äººåˆ—è¡¨éœ€æ±‚é«˜åº¦ä¸€è‡´ã€‚
2. è‹¥ä¸æŠ½å–ï¼Œä¼šå¯¼è‡´â€œåŒç±»ç®—æ³•é‡å¤â€ã€‚
3. ç»Ÿä¸€å·¥å…·å‡½æ•°åæ›´æ˜“ä¿æŒè§†è§‰ä¸€è‡´æ€§ã€‚

**å½±å“åˆ†æ**ï¼š
- é«˜äº®é€»è¾‘ä»ç»„ä»¶å†…ç§æœ‰å‡½æ•°è¿ç§»åˆ°å·¥å…·å‡½æ•°ã€‚
- ç»„ä»¶è¡Œä¸ºä¸å˜ï¼Œä»…å®ç°æ–¹å¼å˜åŒ–ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä¿ç•™åŸå‡½æ•°å¹¶åœ¨è”ç³»äººåˆ—è¡¨å¤åˆ¶ï¼Œä½†ä¼šå¯¼è‡´é‡å¤å®ç°ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/contact/persona/SelectableTagChip.kt
@OptIn(ExperimentalFoundationApi::class)
@Composable
fun SelectableTagChip(
    fact: Fact,
    isEditMode: Boolean,
    isSelected: Boolean,
    searchQuery: String,
    categoryColor: ComposeCategoryColor,
    onClick: () -> Unit,
    onLongClick: () -> Unit,
    onToggleSelection: () -> Unit,
    modifier: Modifier = Modifier
) {
    // æ ¹æ®é€‰ä¸­çŠ¶æ€å†³å®šé¢œè‰²
    val backgroundColor = if (isSelected) {
        MaterialTheme.colorScheme.primaryContainer
    } else {
        categoryColor.tagBackgroundColor
    }

    val textColor = if (isSelected) {
        MaterialTheme.colorScheme.onPrimaryContainer
    } else {
        categoryColor.tagTextColor
    }

    Row(
        modifier = modifier
            .clip(RoundedCornerShape(16.dp))
            .background(backgroundColor)
            .combinedClickable(
                onClick = {
                    if (isEditMode) {
                        onToggleSelection()
                    } else {
                        onClick()
                    }
                },
                onLongClick = onLongClick
            )
            .padding(horizontal = 12.dp, vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // é€‰ä¸­çŠ¶æ€å›¾æ ‡
        if (isSelected) {
            Icon(
                imageVector = Icons.Default.CheckCircle,
                contentDescription = stringResource(R.string.selected),
                modifier = Modifier.size(16.dp),
                tint = MaterialTheme.colorScheme.primary
            )
            Spacer(modifier = Modifier.width(4.dp))
        }

        // æ ‡ç­¾æ–‡æœ¬ï¼ˆæ”¯æŒæœç´¢é«˜äº®ï¼‰
        Text(
            text = buildHighlightedText(fact.value, searchQuery, textColor),
            style = MaterialTheme.typography.bodyMedium,
            color = textColor
        )
    }
}

@Composable
private fun buildHighlightedText(
    text: String,
    query: String,
    defaultColor: Color
) = buildAnnotatedString {
    if (query.isBlank()) {
        append(text)
        return@buildAnnotatedString
    }

    val lowerText = text.lowercase()
    val lowerQuery = query.lowercase()
    var currentIndex = 0

    while (currentIndex < text.length) {
        val matchIndex = lowerText.indexOf(lowerQuery, currentIndex)
        if (matchIndex == -1) {
            append(text.substring(currentIndex))
            break
        }

        if (matchIndex > currentIndex) {
            append(text.substring(currentIndex, matchIndex))
        }

        withStyle(
            SpanStyle(
                fontWeight = FontWeight.Bold,
                background = MaterialTheme.colorScheme.tertiaryContainer
            )
        ) {
            append(text.substring(matchIndex, matchIndex + query.length))
        }

        currentIndex = matchIndex + query.length
    }
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/contact/persona/SelectableTagChip.kt
@OptIn(ExperimentalFoundationApi::class)
@Composable
fun SelectableTagChip(
    fact: Fact,
    isEditMode: Boolean,
    isSelected: Boolean,
    searchQuery: String,
    categoryColor: ComposeCategoryColor,
    onClick: () -> Unit,
    onLongClick: () -> Unit,
    onToggleSelection: () -> Unit,
    modifier: Modifier = Modifier
) {
    // æ ¹æ®é€‰ä¸­çŠ¶æ€å†³å®šé¢œè‰²
    val backgroundColor = if (isSelected) {
        MaterialTheme.colorScheme.primaryContainer
    } else {
        categoryColor.tagBackgroundColor
    }

    val textColor = if (isSelected) {
        MaterialTheme.colorScheme.onPrimaryContainer
    } else {
        categoryColor.tagTextColor
    }

    Row(
        modifier = modifier
            .clip(RoundedCornerShape(16.dp))
            .background(backgroundColor)
            .combinedClickable(
                onClick = {
                    if (isEditMode) {
                        onToggleSelection()
                    } else {
                        onClick()
                    }
                },
                onLongClick = onLongClick
            )
            .padding(horizontal = 12.dp, vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // é€‰ä¸­çŠ¶æ€å›¾æ ‡
        if (isSelected) {
            Icon(
                imageVector = Icons.Default.CheckCircle,
                contentDescription = stringResource(R.string.selected),
                modifier = Modifier.size(16.dp),
                tint = MaterialTheme.colorScheme.primary
            )
            Spacer(modifier = Modifier.width(4.dp))
        }

        // æ ‡ç­¾æ–‡æœ¬ï¼ˆæ”¯æŒæœç´¢é«˜äº®ï¼‰
        Text(
            text = buildHighlightedText(
                text = fact.value,
                query = searchQuery,
                highlightStyle = SpanStyle(
                    fontWeight = FontWeight.Bold,
                    background = MaterialTheme.colorScheme.tertiaryContainer
                )
            ),
            style = MaterialTheme.typography.bodyMedium,
            color = textColor
        )
    }
}
```

---
### å˜æ›´ 3ï¼šContactListItem æ”¯æŒå…³é”®è¯é«˜äº®

**ä¿®æ”¹åŸå› **ï¼š
1. è”ç³»äººæœç´¢ç»“æœåˆ—è¡¨ç¼ºå°‘å…³é”®è¯åé¦ˆã€‚
2. é«˜äº®åŒ¹é…æ–‡æœ¬å¯ä»¥å¿«é€Ÿç¡®è®¤â€œè¿‡æ»¤ä¾æ®â€ã€‚
3. ä½¿ç”¨é€šç”¨é«˜äº®å·¥å…·å‡½æ•°èƒ½ä¿æŒä¸€è‡´é£æ ¼ã€‚
4. æ·±è‰²æ¨¡å¼ä¸‹æå‡é«˜äº®é€æ˜åº¦ï¼Œé¿å…å¯è§æ€§ä¸è¶³ã€‚

**å½±å“åˆ†æ**ï¼š
- ContactListItem å¢åŠ  `highlightQuery` å‚æ•°ï¼Œé»˜è®¤ç©ºå­—ç¬¦ä¸²ä¸å½±å“ç°æœ‰è°ƒç”¨ã€‚
- ä»…å½±å“ UI æ–‡æœ¬æ¸²æŸ“ï¼Œä¸æ”¹å˜ä¸šåŠ¡é€»è¾‘ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- åœ¨æœç´¢åˆ—è¡¨å¤–å±‚æ¸²æŸ“é«˜äº®ï¼Œä½†æ›´éš¾æ§åˆ¶å•å…ƒæ ¼å†…éƒ¨çš„æ–‡æœ¬æ ·å¼ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/list/ContactListItem.kt
@Composable
fun ContactListItem(
    contact: ContactProfile,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    tagCount: Int = 0,
    showDivider: Boolean = true,
    relativeTime: String? = null
) {
    val (backgroundColor, textColor) = AvatarColors.getColorPair(contact.name)
    val dividerColor = iOSSeparator

    Row(
        modifier = modifier
            .fillMaxWidth()
            .height(72.dp)
            .clickable(onClick = onClick)
            .drawBehind {
                if (showDivider) {
                    val startX = 76.dp.toPx()
                    drawLine(
                        color = dividerColor,
                        start = Offset(startX, size.height - 0.5.dp.toPx()),
                        end = Offset(size.width, size.height - 0.5.dp.toPx()),
                        strokeWidth = 0.5.dp.toPx()
                    )
                }
            }
            .padding(horizontal = 16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // å¤´åƒ (æ·¡è‰²èƒŒæ™¯+æ·±è‰²é¦–å­—æ¯)
        Box(
            modifier = Modifier
                .size(48.dp)
                .background(
                    color = backgroundColor,
                    shape = RoundedCornerShape(4.dp)
                ),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = contact.name.firstOrNull()?.toString()?.uppercase() ?: "?",
                fontSize = 20.sp,
                fontWeight = FontWeight.Medium,
                color = textColor
            )
        }

        Spacer(modifier = Modifier.width(12.dp))

        // è”ç³»äººä¿¡æ¯
        Column(
            modifier = Modifier.weight(1f),
            verticalArrangement = Arrangement.Center
        ) {
            // ç¬¬ä¸€è¡Œï¼šå§“å
            Row(
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = contact.name,
                    fontSize = 17.sp,
                    fontWeight = FontWeight.Normal,
                    color = iOSTextPrimary,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis,
                    modifier = Modifier.weight(1f, fill = false)
                )
            }

            Spacer(modifier = Modifier.height(4.dp))

            // ç¬¬äºŒè¡Œï¼šç›®æ ‡æè¿°
            if (contact.targetGoal.isNotBlank()) {
                Text(
                    text = contact.targetGoal,
                    fontSize = 14.sp,
                    color = iOSTextSecondary,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }
        }

        // å³ä¾§ï¼šæ—¶é—´ + ç®­å¤´
        Column(
            horizontalAlignment = Alignment.End
        ) {
            if (relativeTime != null) {
                Text(
                    text = relativeTime,
                    fontSize = 13.sp,
                    color = iOSTextSecondary
                )
            }
            Icon(
                imageVector = Icons.AutoMirrored.Filled.KeyboardArrowRight,
                contentDescription = "æŸ¥çœ‹è¯¦æƒ…",
                tint = iOSTextSecondary,
                modifier = Modifier.size(20.dp)
            )
        }
    }
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/list/ContactListItem.kt
@Composable
fun ContactListItem(
    contact: ContactProfile,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    tagCount: Int = 0,
    showDivider: Boolean = true,
    relativeTime: String? = null,
    highlightQuery: String = ""
) {
    val (backgroundColor, textColor) = AvatarColors.getColorPair(contact.name)
    val dividerColor = iOSSeparator
    val highlightStyle = createSearchHighlightStyle(
        isDarkTheme = isSystemInDarkTheme(),
        baseColor = iOSBlue
    )

    Row(
        modifier = modifier
            .fillMaxWidth()
            .height(72.dp)
            .clickable(onClick = onClick)
            .drawBehind {
                if (showDivider) {
                    val startX = 76.dp.toPx()
                    drawLine(
                        color = dividerColor,
                        start = Offset(startX, size.height - 0.5.dp.toPx()),
                        end = Offset(size.width, size.height - 0.5.dp.toPx()),
                        strokeWidth = 0.5.dp.toPx()
                    )
                }
            }
            .padding(horizontal = 16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // å¤´åƒ (æ·¡è‰²èƒŒæ™¯+æ·±è‰²é¦–å­—æ¯)
        Box(
            modifier = Modifier
                .size(48.dp)
                .background(
                    color = backgroundColor,
                    shape = RoundedCornerShape(4.dp)
                ),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = contact.name.firstOrNull()?.toString()?.uppercase() ?: "?",
                fontSize = 20.sp,
                fontWeight = FontWeight.Medium,
                color = textColor
            )
        }

        Spacer(modifier = Modifier.width(12.dp))

        // è”ç³»äººä¿¡æ¯
        Column(
            modifier = Modifier.weight(1f),
            verticalArrangement = Arrangement.Center
        ) {
            // ç¬¬ä¸€è¡Œï¼šå§“å
            Row(
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = buildHighlightedText(
                        text = contact.name,
                        query = highlightQuery,
                        highlightStyle = highlightStyle
                    ),
                    fontSize = 17.sp,
                    fontWeight = FontWeight.Normal,
                    color = iOSTextPrimary,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis,
                    modifier = Modifier.weight(1f, fill = false)
                )
            }

            Spacer(modifier = Modifier.height(4.dp))

            // ç¬¬äºŒè¡Œï¼šç›®æ ‡æè¿°
            if (contact.targetGoal.isNotBlank()) {
                Text(
                    text = buildHighlightedText(
                        text = contact.targetGoal,
                        query = highlightQuery,
                        highlightStyle = highlightStyle
                    ),
                    fontSize = 14.sp,
                    color = iOSTextSecondary,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }
        }

        // å³ä¾§ï¼šæ—¶é—´ + ç®­å¤´
        Column(
            horizontalAlignment = Alignment.End
        ) {
            if (relativeTime != null) {
                Text(
                    text = relativeTime,
                    fontSize = 13.sp,
                    color = iOSTextSecondary
                )
            }
            Icon(
                imageVector = Icons.AutoMirrored.Filled.KeyboardArrowRight,
                contentDescription = "æŸ¥çœ‹è¯¦æƒ…",
                tint = iOSTextSecondary,
                modifier = Modifier.size(20.dp)
            )
        }
    }
}
```

---
### å˜æ›´ 4ï¼šContactListScreen æœç´¢æ¨¡å¼ä¼ é€’é«˜äº®å…³é”®è¯

**ä¿®æ”¹åŸå› **ï¼š
1. é«˜äº®é€»è¾‘å·²åŠ å…¥ ContactListItemï¼Œéœ€è¦åœ¨æœç´¢æ¨¡å¼æ—¶ä¼ å…¥å…³é”®è¯ã€‚
2. åªåœ¨æœç´¢æ¨¡å¼ä¼ å…¥å…³é”®è¯ï¼Œé¿å…æ™®é€šåˆ—è¡¨å‡ºç°è¯¯é«˜äº®ã€‚
3. è¯¥æ”¹åŠ¨å±€éƒ¨ä¸”ä¸å½±å“éæœç´¢æµç¨‹ã€‚

**å½±å“åˆ†æ**ï¼š
- ä»…å½±å“æœç´¢æ¨¡å¼åˆ—è¡¨é¡¹æ¸²æŸ“ã€‚
- å¯¹éæœç´¢åœºæ™¯æ— å½±å“ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- åœ¨ ViewModel ä¸­æ„é€ é«˜äº®å­—ç¬¦ä¸²ï¼Œä½†ä¼šå¯¼è‡´ UI é€»è¾‘ä¸‹æ²‰åˆ°çŠ¶æ€å±‚ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/contact/ContactListScreen.kt
private fun SearchModeContent(
    searchQuery: String,
    searchResults: List<ContactProfile>,
    onQueryChange: (String) -> Unit,
    onSearchClose: () -> Unit,
    onContactClick: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    val dimensions = AdaptiveDimensions.current
    val focusRequester = remember { FocusRequester() }
    
    // è‡ªåŠ¨èšç„¦æœç´¢æ¡†
    LaunchedEffect(Unit) {
        focusRequester.requestFocus()
    }
    
    Column(
        modifier = modifier
            .fillMaxSize()
            .background(iOSBackground)
    ) {
        // æœç´¢æ 
        SearchHeader(
            searchQuery = searchQuery,
            onQueryChange = onQueryChange,
            onSearchClose = onSearchClose,
            focusRequester = focusRequester
        )
        
        // æœç´¢ç»“æœ
        when {
            searchResults.isEmpty() && searchQuery.isNotBlank() -> {
                // æ— ç»“æœæç¤º
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    EmptyView(
                        message = "æœªæ‰¾åˆ°åŒ¹é…çš„è”ç³»äºº",
                        actionText = null,
                        onAction = {}
                    )
                }
            }
            searchResults.isNotEmpty() -> {
                // æœç´¢ç»“æœåˆ—è¡¨
                LazyColumn(
                    modifier = Modifier.fillMaxSize()
                ) {
                    item {
                        Surface(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(horizontal = dimensions.spacingMedium),
                            shape = RoundedCornerShape(dimensions.cornerRadiusMedium),
                            color = iOSCardBackground,
                            shadowElevation = 1.dp
                        ) {
                            Column {
                                searchResults.forEachIndexed { index, contact ->
                                    ContactListItem(
                                        contact = contact,
                                        onClick = { onContactClick(contact.id) },
                                        showDivider = index < searchResults.size - 1
                                    )
                                }
                            }
                        }
                    }
                    item {
                        Spacer(modifier = Modifier.height(dimensions.spacingLarge))
                    }
                }
            }
            else -> {
                // æœç´¢è¯ä¸ºç©ºï¼Œæ˜¾ç¤ºæç¤º
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = "è¾“å…¥å…³é”®è¯æœç´¢è”ç³»äºº",
                        color = iOSTextSecondary,
                        fontSize = dimensions.fontSizeBody
                    )
                }
            }
        }
    }
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/contact/ContactListScreen.kt
private fun SearchModeContent(
    searchQuery: String,
    searchResults: List<ContactProfile>,
    onQueryChange: (String) -> Unit,
    onSearchClose: () -> Unit,
    onContactClick: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    val dimensions = AdaptiveDimensions.current
    val focusRequester = remember { FocusRequester() }
    
    // è‡ªåŠ¨èšç„¦æœç´¢æ¡†
    LaunchedEffect(Unit) {
        focusRequester.requestFocus()
    }
    
    Column(
        modifier = modifier
            .fillMaxSize()
            .background(iOSBackground)
    ) {
        // æœç´¢æ 
        SearchHeader(
            searchQuery = searchQuery,
            onQueryChange = onQueryChange,
            onSearchClose = onSearchClose,
            focusRequester = focusRequester
        )
        
        // æœç´¢ç»“æœ
        when {
            searchResults.isEmpty() && searchQuery.isNotBlank() -> {
                // æ— ç»“æœæç¤º
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    EmptyView(
                        message = "æœªæ‰¾åˆ°åŒ¹é…çš„è”ç³»äºº",
                        actionText = null,
                        onAction = {}
                    )
                }
            }
            searchResults.isNotEmpty() -> {
                // æœç´¢ç»“æœåˆ—è¡¨
                LazyColumn(
                    modifier = Modifier.fillMaxSize()
                ) {
                    item {
                        Surface(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(horizontal = dimensions.spacingMedium),
                            shape = RoundedCornerShape(dimensions.cornerRadiusMedium),
                            color = iOSCardBackground,
                            shadowElevation = 1.dp
                        ) {
                            Column {
                                searchResults.forEachIndexed { index, contact ->
                                    ContactListItem(
                                        contact = contact,
                                        onClick = { onContactClick(contact.id) },
                                        showDivider = index < searchResults.size - 1,
                                        highlightQuery = searchQuery
                                    )
                                }
                            }
                        }
                    }
                    item {
                        Spacer(modifier = Modifier.height(dimensions.spacingLarge))
                    }
                }
            }
            else -> {
                // æœç´¢è¯ä¸ºç©ºï¼Œæ˜¾ç¤ºæç¤º
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = "è¾“å…¥å…³é”®è¯æœç´¢è”ç³»äºº",
                        color = iOSTextSecondary,
                        fontSize = dimensions.fontSizeBody
                    )
                }
            }
        }
    }
}
```

---
### å˜æ›´ 5ï¼šContactSelectScreen æœç´¢åˆ—è¡¨é«˜äº®

**ä¿®æ”¹åŸå› **ï¼š
1. AI å†›å¸ˆè”ç³»äººé€‰æ‹©é¡µä¹Ÿæœ‰æœç´¢åŠŸèƒ½ï¼Œä½†ç¼ºä¹é«˜äº®åé¦ˆã€‚
2. åŒç±»åœºæ™¯åº”è¯¥æä¾›ä¸€è‡´ä½“éªŒã€‚
3. å¤ç”¨é€šç”¨é«˜äº®å·¥å…·å‡½æ•°æˆæœ¬ä½ï¼Œæ•ˆæœæ˜ç¡®ã€‚
4. æ·±è‰²æ¨¡å¼ä¸‹åŒæ­¥é«˜äº®é€æ˜åº¦ç­–ç•¥ï¼Œé¿å…ä½“éªŒåˆ†è£‚ã€‚

**å½±å“åˆ†æ**ï¼š
- ContactSelectScreen çš„å†…éƒ¨åˆ—è¡¨ç»„ä»¶å¢åŠ  `highlightQuery`ã€‚
- ä»…æ”¹å˜ UI æ–‡æœ¬æ¸²æŸ“ï¼Œä¸æ”¹å˜é€‰æ‹©é€»è¾‘ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä¿æŒåŸæ ·ï¼Œä½†ä¼šå¯¼è‡´ä¸¤ä¸ªæœç´¢é¡µé¢ä½“éªŒä¸ä¸€è‡´ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/advisor/ContactSelectScreen.kt
private fun ContactList(
    contacts: List<ContactProfile>,
    onContactClick: (ContactProfile) -> Unit
) {
    LazyColumn(
        modifier = Modifier.fillMaxSize()
    ) {
        items(
            items = contacts,
            key = { it.id }
        ) { contact ->
            ContactListItem(
                contact = contact,
                onClick = { onContactClick(contact) }
            )
        }
    }
}

@Composable
private fun ContactListItem(
    contact: ContactProfile,
    onClick: () -> Unit
) {
    val dimensions = AdaptiveDimensions.current
    
    // å¤´åƒé¢œè‰²æ–¹æ¡ˆ
    val avatarColors = listOf(
        Color(0xFFE8EAF6) to Color(0xFF5C6BC0), // indigo
        Color(0xFFE3F2FD) to Color(0xFF42A5F5), // blue
        Color(0xFFFCE4EC) to Color(0xFFEC407A), // rose
        Color(0xFFE8F5E9) to Color(0xFF66BB6A), // emerald
        Color(0xFFE0F7FA) to Color(0xFF26C6DA)  // cyan
    )

    // æ ¹æ®è”ç³»äººIDé€‰æ‹©é¢œè‰²
    val colorIndex = contact.id.hashCode().let { kotlin.math.abs(it) % avatarColors.size }
    val (bgColor, textColor) = avatarColors[colorIndex]

    Column {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable(onClick = onClick)
                .background(iOSCardBackground)
                .padding(horizontal = 16.dp, vertical = 12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // å¤´åƒ
            Box(
                modifier = Modifier
                    .size(44.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(bgColor),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = contact.name.firstOrNull()?.toString() ?: "?",
                    fontSize = dimensions.fontSizeSubtitle,
                    fontWeight = FontWeight.SemiBold,
                    color = textColor
                )
            }

            Spacer(modifier = Modifier.width(12.dp))

            // ä¿¡æ¯åŒºåŸŸ
            Column(modifier = Modifier.weight(1f)) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Text(
                            text = contact.name,
                            fontSize = dimensions.fontSizeSubtitle,
                            fontWeight = FontWeight.Medium,
                            color = iOSTextPrimary
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = contact.getRelationshipLevel().displayName,
                            fontSize = dimensions.fontSizeXSmall,
                            color = iOSTextSecondary
                        )
                    }
                    Text(
                        text = contact.lastInteractionDate ?: "æœªçŸ¥",
                        fontSize = dimensions.fontSizeXSmall,
                        color = iOSTextSecondary
                    )
                }

                Spacer(modifier = Modifier.height(4.dp))

                // æœ€åæ¶ˆæ¯é¢„è§ˆ
                Text(
                    text = contact.targetGoal.ifEmpty { "æš‚æ— æ¶ˆæ¯" },
                    fontSize = dimensions.fontSizeCaption,
                    color = iOSTextSecondary,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }

            Spacer(modifier = Modifier.width(8.dp))

            // å³ç®­å¤´
            Icon(
                imageVector = Icons.AutoMirrored.Filled.KeyboardArrowRight,
                contentDescription = null,
                tint = iOSTextTertiary,
                modifier = Modifier.size(20.dp)
            )
        }

        // åˆ†éš”çº¿
        HorizontalDivider(
            modifier = Modifier.padding(start = 72.dp),
            color = Color(0xFFE5E5EA),
            thickness = 0.5.dp
        )
    }
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/advisor/ContactSelectScreen.kt
private fun ContactList(
    contacts: List<ContactProfile>,
    highlightQuery: String,
    onContactClick: (ContactProfile) -> Unit
) {
    LazyColumn(
        modifier = Modifier.fillMaxSize()
    ) {
        items(
            items = contacts,
            key = { it.id }
        ) { contact ->
            ContactListItem(
                contact = contact,
                onClick = { onContactClick(contact) },
                highlightQuery = highlightQuery
            )
        }
    }
}

@Composable
private fun ContactListItem(
    contact: ContactProfile,
    onClick: () -> Unit,
    highlightQuery: String
) {
    val dimensions = AdaptiveDimensions.current
    val highlightStyle = createSearchHighlightStyle(
        isDarkTheme = isSystemInDarkTheme(),
        baseColor = iOSBlue
    )
    
    // å¤´åƒé¢œè‰²æ–¹æ¡ˆ
    val avatarColors = listOf(
        Color(0xFFE8EAF6) to Color(0xFF5C6BC0), // indigo
        Color(0xFFE3F2FD) to Color(0xFF42A5F5), // blue
        Color(0xFFFCE4EC) to Color(0xFFEC407A), // rose
        Color(0xFFE8F5E9) to Color(0xFF66BB6A), // emerald
        Color(0xFFE0F7FA) to Color(0xFF26C6DA)  // cyan
    )

    // æ ¹æ®è”ç³»äººIDé€‰æ‹©é¢œè‰²
    val colorIndex = contact.id.hashCode().let { kotlin.math.abs(it) % avatarColors.size }
    val (bgColor, textColor) = avatarColors[colorIndex]

    Column {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable(onClick = onClick)
                .background(iOSCardBackground)
                .padding(horizontal = 16.dp, vertical = 12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // å¤´åƒ
            Box(
                modifier = Modifier
                    .size(44.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(bgColor),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = contact.name.firstOrNull()?.toString() ?: "?",
                    fontSize = dimensions.fontSizeSubtitle,
                    fontWeight = FontWeight.SemiBold,
                    color = textColor
                )
            }

            Spacer(modifier = Modifier.width(12.dp))

            // ä¿¡æ¯åŒºåŸŸ
            Column(modifier = Modifier.weight(1f)) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Text(
                            text = buildHighlightedText(
                                text = contact.name,
                                query = highlightQuery,
                                highlightStyle = highlightStyle
                            ),
                            fontSize = dimensions.fontSizeSubtitle,
                            fontWeight = FontWeight.Medium,
                            color = iOSTextPrimary
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = contact.getRelationshipLevel().displayName,
                            fontSize = dimensions.fontSizeXSmall,
                            color = iOSTextSecondary
                        )
                    }
                    Text(
                        text = contact.lastInteractionDate ?: "æœªçŸ¥",
                        fontSize = dimensions.fontSizeXSmall,
                        color = iOSTextSecondary
                    )
                }

                Spacer(modifier = Modifier.height(4.dp))

                // æœ€åæ¶ˆæ¯é¢„è§ˆ
                Text(
                    text = buildHighlightedText(
                        text = contact.targetGoal.ifEmpty { "æš‚æ— æ¶ˆæ¯" },
                        query = highlightQuery,
                        highlightStyle = highlightStyle
                    ),
                    fontSize = dimensions.fontSizeCaption,
                    color = iOSTextSecondary,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }

            Spacer(modifier = Modifier.width(8.dp))

            // å³ç®­å¤´
            Icon(
                imageVector = Icons.AutoMirrored.Filled.KeyboardArrowRight,
                contentDescription = null,
                tint = iOSTextTertiary,
                modifier = Modifier.size(20.dp)
            )
        }

        // åˆ†éš”çº¿
        HorizontalDivider(
            modifier = Modifier.padding(start = 72.dp),
            color = Color(0xFFE5E5EA),
            thickness = 0.5.dp
        )
    }
}
```

---

### å˜æ›´ 6ï¼šæ–°å¢ TextHighlightTest

**ä¿®æ”¹åŸå› **ï¼š
1. é«˜äº®å‡½æ•°æ˜¯çº¯é€»è¾‘å‡½æ•°ï¼Œå®¹æ˜“å› åç»­ä¼˜åŒ–å¼•å…¥å›å½’ã€‚
2. æœ€å°å•å…ƒæµ‹è¯•å¯ä»¥éªŒè¯ç©ºæŸ¥è¯¢ã€å¤§å°å†™åŒ¹é…ã€å¤šæ¬¡åŒ¹é…èŒƒå›´ã€‚
3. æµ‹è¯•æˆæœ¬ä½ï¼Œå¯ä½œä¸ºæ¢ç´¢ç»“æœçš„ç¨³å®šæ€§è¡¥å¼ºã€‚

**å½±å“åˆ†æ**ï¼š
- æ–°å¢ JVM å•å…ƒæµ‹è¯•æ–‡ä»¶ï¼Œä¸å½±å“è¿è¡Œé€»è¾‘ã€‚
- å·²æ‰§è¡Œæµ‹è¯•å¹¶é€šè¿‡ï¼ˆæ„å»ºå«æ—¢æœ‰è­¦å‘Šï¼Œä¸å½±å“ç»“æœï¼‰ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä¸å†™æµ‹è¯•ï¼Œä¾èµ–äººå·¥éªŒè¯ï¼Œä½†å›å½’é£é™©æ›´é«˜ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/util/TextHighlightTest.kt
// æ–°å¢æ–‡ä»¶ï¼Œä¿®æ”¹å‰ä¸å­˜åœ¨
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/util/TextHighlightTest.kt
package com.empathy.ai.presentation.util

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.font.FontWeight
import org.junit.Assert.assertEquals
import org.junit.Assert.assertTrue
import org.junit.Test

class TextHighlightTest {

    private val highlightStyle = SpanStyle(
        fontWeight = FontWeight.SemiBold,
        background = Color(0xFF00FF00)
    )

    @Test
    fun buildHighlightedText_blankQuery_returnsPlainText() {
        val result = buildHighlightedText(
            text = "hello",
            query = "",
            highlightStyle = highlightStyle
        )

        assertEquals("hello", result.text)
        assertTrue(result.spanStyles.isEmpty())
    }

    @Test
    fun buildHighlightedText_caseInsensitive_matchesAndHighlights() {
        val result = buildHighlightedText(
            text = "å¼ ä¸‰",
            query = "å¼ ",
            highlightStyle = highlightStyle
        )

        assertEquals("å¼ ä¸‰", result.text)
        assertEquals(1, result.spanStyles.size)
        val range = result.spanStyles.first()
        assertEquals(0, range.start)
        assertEquals(1, range.end)
        assertEquals(highlightStyle, range.item)
    }

    @Test
    fun buildHighlightedText_caseInsensitiveAscii_matchesAndHighlights() {
        val result = buildHighlightedText(
            text = "Alice",
            query = "aL",
            highlightStyle = highlightStyle
        )

        assertEquals("Alice", result.text)
        assertEquals(1, result.spanStyles.size)
        val range = result.spanStyles.first()
        assertEquals(0, range.start)
        assertEquals(2, range.end)
        assertEquals(highlightStyle, range.item)
    }

    @Test
    fun buildHighlightedText_noMatch_returnsPlainText() {
        val result = buildHighlightedText(
            text = "hello",
            query = "xyz",
            highlightStyle = highlightStyle
        )

        assertEquals("hello", result.text)
        assertTrue(result.spanStyles.isEmpty())
    }

    @Test
    fun buildHighlightedText_multipleMatches_returnsAllRanges() {
        val result = buildHighlightedText(
            text = "bananana",
            query = "na",
            highlightStyle = highlightStyle
        )

        val ranges = result.spanStyles.map { it.start to it.end }
        assertEquals(listOf(2 to 4, 4 to 6, 6 to 8), ranges)
    }

    @Test
    fun searchHighlightAlpha_returnsExpectedValues() {
        assertEquals(0.35f, searchHighlightAlpha(true), 0.0001f)
        assertEquals(0.2f, searchHighlightAlpha(false), 0.0001f)
    }

    @Test
    fun createSearchHighlightStyle_usesBaseColorWithAlpha() {
        val baseColor = Color(0xFF112233)
        val style = createSearchHighlightStyle(isDarkTheme = true, baseColor = baseColor)

        assertEquals(FontWeight.SemiBold, style.fontWeight)
        assertEquals(baseColor.copy(alpha = 0.35f), style.background)
    }
}
```

---

### å˜æ›´ 7ï¼šTagChip æ”¯æŒæœç´¢é«˜äº®å¹¶æ¥å…¥æ ‡ç­¾åˆ—è¡¨

**ä¿®æ”¹åŸå› **ï¼š
1. æ ‡ç­¾ç®¡ç†é¡µæœç´¢åªåšè¿‡æ»¤ï¼Œæ²¡æœ‰å‘½ä¸­æç¤ºï¼Œç”¨æˆ·éš¾ä»¥ç¡®è®¤åŒ¹é…ä½ç½®ã€‚
2. TagChip æ˜¯ç»Ÿä¸€æ ‡ç­¾ç»„ä»¶ï¼Œé€‚åˆæ‰¿è½½é«˜äº®é€»è¾‘ï¼Œé¿å…åœ¨åˆ—è¡¨å±‚åˆ†å‰å®ç°ã€‚
3. å·²æœ‰é«˜äº®å·¥å…·å‡½æ•°å¯å¤ç”¨ï¼Œæ”¹åŠ¨èŒƒå›´å¯æ§ã€‚

**å½±å“åˆ†æ**ï¼š
- TagChip å¢åŠ  `highlightQuery` å¯é€‰å‚æ•°ï¼Œæ—§è°ƒç”¨ä¸å—å½±å“ã€‚
- BrainTagScreen åœ¨åˆ—è¡¨æ¸²æŸ“æ—¶ä¼ å…¥ `searchQuery`ï¼Œç©ºå­—ç¬¦ä¸²æ—¶è¡Œä¸ºä¸åŸæ¥ä¸€è‡´ã€‚
- æ ‡ç­¾é«˜äº®æ•ˆæœåœ¨å½©è‰²å®¹å™¨ä¸Šéœ€è¦äººå·¥éªŒè¯å¯¹æ¯”åº¦ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- åœ¨ TagList å†…éƒ¨æ‰‹å†™å¯Œæ–‡æœ¬é«˜äº®ï¼Œä¸æ”¹ TagChipï¼Œä½†ä¼šé€ æˆç»„ä»¶èŒè´£ä¸ä¸€è‡´ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/chip/TagChip.kt
@Composable
fun TagChip(
    text: String,
    tagType: TagType,
    onDelete: (() -> Unit)? = null,
    onClick: (() -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    val dimensions = AdaptiveDimensions.current
    val colors = getTagColors(tagType)
    
    AssistChip(
        onClick = { onClick?.invoke() },
        label = { Text(text) },
        modifier = modifier,
        leadingIcon = {
            Icon(
                imageVector = when (tagType) {
                    TagType.RISK_RED -> Icons.Default.Warning
                    TagType.STRATEGY_GREEN -> Icons.Default.Lightbulb
                },
                contentDescription = when (tagType) {
                    TagType.RISK_RED -> "é›·åŒº"
                    TagType.STRATEGY_GREEN -> "ç­–ç•¥"
                },
                modifier = Modifier.size(dimensions.iconSizeSmall),
                tint = colors.iconColor
            )
        },
        trailingIcon = if (onDelete != null) {
            {
                IconButton(
                    onClick = onDelete,
                    modifier = Modifier.size(dimensions.iconSizeSmall + 2.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Close,
                        contentDescription = "åˆ é™¤",
                        modifier = Modifier.size(dimensions.iconSizeSmall - 2.dp)
                    )
                }
            }
        } else null,
        colors = AssistChipDefaults.assistChipColors(
            containerColor = colors.backgroundColor,
            labelColor = colors.textColor,
            leadingIconContentColor = colors.iconColor
        )
    )
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/chip/TagChip.kt
@Composable
fun TagChip(
    text: String,
    tagType: TagType,
    highlightQuery: String = "",
    onDelete: (() -> Unit)? = null,
    onClick: (() -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    val dimensions = AdaptiveDimensions.current
    val colors = getTagColors(tagType)
    val highlightStyle = createSearchHighlightStyle(
        isDarkTheme = isSystemInDarkTheme(),
        baseColor = colors.iconColor
    )
    
    AssistChip(
        onClick = { onClick?.invoke() },
        label = {
            Text(
                text = buildHighlightedText(
                    text = text,
                    query = highlightQuery,
                    highlightStyle = highlightStyle
                )
            )
        },
        modifier = modifier,
        leadingIcon = {
            Icon(
                imageVector = when (tagType) {
                    TagType.RISK_RED -> Icons.Default.Warning
                    TagType.STRATEGY_GREEN -> Icons.Default.Lightbulb
                },
                contentDescription = when (tagType) {
                    TagType.RISK_RED -> "é›·åŒº"
                    TagType.STRATEGY_GREEN -> "ç­–ç•¥"
                },
                modifier = Modifier.size(dimensions.iconSizeSmall),
                tint = colors.iconColor
            )
        },
        trailingIcon = if (onDelete != null) {
            {
                IconButton(
                    onClick = onDelete,
                    modifier = Modifier.size(dimensions.iconSizeSmall + 2.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Close,
                        contentDescription = "åˆ é™¤",
                        modifier = Modifier.size(dimensions.iconSizeSmall - 2.dp)
                    )
                }
            }
        } else null,
        colors = AssistChipDefaults.assistChipColors(
            containerColor = colors.backgroundColor,
            labelColor = colors.textColor,
            leadingIconContentColor = colors.iconColor
        )
    )
}
```

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/tag/BrainTagScreen.kt
@Composable
private fun TagList(
    tags: List<BrainTag>,
    searchQuery: String,
    onDeleteTag: (Long) -> Unit,
    onEditTag: (BrainTag) -> Unit,
    modifier: Modifier = Modifier
) {
    // è¿‡æ»¤æ ‡ç­¾
    val filteredTags = if (searchQuery.isBlank()) {
        tags
    } else {
        tags.filter { it.content.contains(searchQuery, ignoreCase = true) }
    }

    // æŒ‰ç±»å‹åˆ†ç»„
    val landmineTags = filteredTags.filter { it.type == TagType.RISK_RED }
    val strategyTags = filteredTags.filter { it.type == TagType.STRATEGY_GREEN }

    LazyColumn(
        modifier = modifier.fillMaxSize(),
        contentPadding = PaddingValues(AppSpacing.lg),
        verticalArrangement = Arrangement.spacedBy(AppSpacing.lg)
    ) {
        // é›·åŒºæ ‡ç­¾
        if (landmineTags.isNotEmpty()) {
            item {
                Text(
                    text = "é›·åŒºæ ‡ç­¾ (${landmineTags.size})",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.error
                )
            }

            items(
                items = landmineTags,
                key = { it.id }
            ) { tag ->
                TagChip(
                    text = tag.content,
                    tagType = tag.type,
                    onDelete = { onDeleteTag(tag.id) },
                    onClick = { onEditTag(tag) },
                    modifier = Modifier.fillMaxWidth()
                )
            }

            item {
                Spacer(modifier = Modifier.height(AppSpacing.sm))
            }
        }

        // ç­–ç•¥æ ‡ç­¾
        if (strategyTags.isNotEmpty()) {
            item {
                Text(
                    text = "ç­–ç•¥æ ‡ç­¾ (${strategyTags.size})",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.primary
                )
            }

            items(
                items = strategyTags,
                key = { it.id }
            ) { tag ->
                TagChip(
                    text = tag.content,
                    tagType = tag.type,
                    onDelete = { onDeleteTag(tag.id) },
                    onClick = { onEditTag(tag) },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    }
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/tag/BrainTagScreen.kt
@Composable
private fun TagList(
    tags: List<BrainTag>,
    searchQuery: String,
    onDeleteTag: (Long) -> Unit,
    onEditTag: (BrainTag) -> Unit,
    modifier: Modifier = Modifier
) {
    // è¿‡æ»¤æ ‡ç­¾
    val filteredTags = if (searchQuery.isBlank()) {
        tags
    } else {
        tags.filter { it.content.contains(searchQuery, ignoreCase = true) }
    }

    // æŒ‰ç±»å‹åˆ†ç»„
    val landmineTags = filteredTags.filter { it.type == TagType.RISK_RED }
    val strategyTags = filteredTags.filter { it.type == TagType.STRATEGY_GREEN }

    LazyColumn(
        modifier = modifier.fillMaxSize(),
        contentPadding = PaddingValues(AppSpacing.lg),
        verticalArrangement = Arrangement.spacedBy(AppSpacing.lg)
    ) {
        // é›·åŒºæ ‡ç­¾
        if (landmineTags.isNotEmpty()) {
            item {
                Text(
                    text = "é›·åŒºæ ‡ç­¾ (${landmineTags.size})",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.error
                )
            }

            items(
                items = landmineTags,
                key = { it.id }
            ) { tag ->
                TagChip(
                    text = tag.content,
                    tagType = tag.type,
                    highlightQuery = searchQuery,
                    onDelete = { onDeleteTag(tag.id) },
                    onClick = { onEditTag(tag) },
                    modifier = Modifier.fillMaxWidth()
                )
            }

            item {
                Spacer(modifier = Modifier.height(AppSpacing.sm))
            }
        }

        // ç­–ç•¥æ ‡ç­¾
        if (strategyTags.isNotEmpty()) {
            item {
                Text(
                    text = "ç­–ç•¥æ ‡ç­¾ (${strategyTags.size})",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.primary
                )
            }

            items(
                items = strategyTags,
                key = { it.id }
            ) { tag ->
                TagChip(
                    text = tag.content,
                    tagType = tag.type,
                    highlightQuery = searchQuery,
                    onDelete = { onDeleteTag(tag.id) },
                    onClick = { onEditTag(tag) },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    }
}
```

---

### å˜æ›´ 8ï¼šæœåŠ¡å•†åˆ—è¡¨æ”¯æŒæœç´¢é«˜äº®

**ä¿®æ”¹åŸå› **ï¼š
1. AI é…ç½®é¡µæ”¯æŒæœç´¢ï¼Œä½†æœåŠ¡å•†åˆ—è¡¨æ²¡æœ‰å‘½ä¸­æç¤ºã€‚
2. è¯¥åˆ—è¡¨å’Œè”ç³»äººåˆ—è¡¨å±äºåŒç±»â€œæœç´¢è¿‡æ»¤åœºæ™¯â€ï¼Œéœ€è¦ä½“éªŒä¸€è‡´ã€‚
3. `IOSProviderCard` æ˜¯ç»Ÿä¸€åˆ—è¡¨é¡¹ç»„ä»¶ï¼Œæ‰©å±•æˆæœ¬ä½ã€‚

**å½±å“åˆ†æ**ï¼š
- `IOSProviderCard` å¢åŠ  `highlightQuery` å‚æ•°å¹¶ä½¿ç”¨ç»Ÿä¸€é«˜äº®æ ·å¼ã€‚
- `ProviderListContent` ä¼ å…¥ `uiState.searchQuery`ï¼Œç©ºæŸ¥è¯¢æ—¶è¡Œä¸ºä¸å˜ã€‚
- æœªè¿›è¡Œ UI è§†è§‰éªŒè¯ï¼Œéœ€ç¡®è®¤é«˜äº®åœ¨æµ…è‰²/æ·±è‰²æ¨¡å¼ä¸‹çš„å¯è¯»æ€§ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä»…ä¿æŒè¿‡æ»¤ä¸é«˜äº®ï¼Œä½†ä½“éªŒä¸€è‡´æ€§ä¸è¶³ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/ios/IOSProviderCard.kt
@Composable
fun IOSProviderCard(
    provider: AiProvider,
    isDefault: Boolean,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    onEdit: (() -> Unit)? = null,
    onDelete: (() -> Unit)? = null,
    showDivider: Boolean = true,
    icon: ImageVector = Icons.Default.Cloud,
    iconBackgroundColor: Color = getProviderColor(provider.name)
) {
    // ä½¿ç”¨å“åº”å¼å°ºå¯¸
    val dimensions = AdaptiveDimensions.current
    val density = LocalDensity.current
    
    val dividerColor = iOSSeparator
    // åˆ†éš”çº¿èµ·å§‹ä½ç½® = padding(16) + iconSize(40) + spacing(12)
    val dividerStartPadding = dimensions.spacingMedium + dimensions.iosIconContainerSize + dimensions.spacingMediumSmall
    
    // æ»‘åŠ¨é˜ˆå€¼ - ä½¿ç”¨å“åº”å¼å°ºå¯¸
    val swipeThresholdDp = dimensions.swipeActionTotalWidth
    val swipeThreshold = with(density) { swipeThresholdDp.toPx() }
    val buttonWidthDp = dimensions.swipeActionButtonWidth
    
    // åˆ—è¡¨é¡¹é«˜åº¦ - å“åº”å¼
    val itemHeight = dimensions.iosListItemHeight + dimensions.spacingLarge // çº¦72dp
    
    var offsetX by remember { mutableFloatStateOf(0f) }
    var isSwipeOpen by remember { mutableStateOf(false) }
    
    val animatedOffsetX by animateFloatAsState(
        targetValue = if (isSwipeOpen) -swipeThreshold else offsetX,
        animationSpec = tween(durationMillis = 200),
        label = "swipeOffset"
    )

    Box(
        modifier = modifier
            .fillMaxWidth()
            .height(itemHeight)
    ) {
        // Action buttons (behind the card)
        Row(
            modifier = Modifier
                .align(Alignment.CenterEnd)
                .fillMaxHeight()
        ) {
            // Delete button (å·¦è¾¹)
            if (onDelete != null) {
                Box(
                    modifier = Modifier
                        .width(buttonWidthDp)
                        .fillMaxHeight()
                        .background(iOSRed)
                        .clickable {
                            isSwipeOpen = false
                            offsetX = 0f
                            onDelete()
                        },
                    contentAlignment = Alignment.Center
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Icon(
                            imageVector = Icons.Default.Delete,
                            contentDescription = "åˆ é™¤",
                            tint = Color.White,
                            modifier = Modifier.size(dimensions.iconSizeMedium)
                        )
                        Text(
                            text = "åˆ é™¤",
                            color = Color.White,
                            fontSize = dimensions.fontSizeXSmall
                        )
                    }
                }
            }
            
            // Edit button (å³è¾¹ï¼Œæ»‘åŠ¨æ—¶å…ˆéœ²å‡º)
            if (onEdit != null) {
                Box(
                    modifier = Modifier
                        .width(buttonWidthDp)
                        .fillMaxHeight()
                        .background(iOSOrange)
                        .clickable {
                            isSwipeOpen = false
                            offsetX = 0f
                            onEdit()
                        },
                    contentAlignment = Alignment.Center
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Icon(
                            imageVector = Icons.Default.Edit,
                            contentDescription = "ç¼–è¾‘",
                            tint = Color.White,
                            modifier = Modifier.size(dimensions.iconSizeMedium)
                        )
                        Text(
                            text = "ç¼–è¾‘",
                            color = Color.White,
                            fontSize = dimensions.fontSizeXSmall
                        )
                    }
                }
            }
        }

        // Main card content (swipeable)
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .height(itemHeight)
                .offset { IntOffset(animatedOffsetX.roundToInt(), 0) }
                .background(Color.White)
                .pointerInput(Unit) {
                    detectHorizontalDragGestures(
                        onDragEnd = {
                            if (offsetX < -swipeThreshold / 2) {
                                isSwipeOpen = true
                            } else {
                                isSwipeOpen = false
                            }
                            offsetX = 0f
                        },
                        onDragCancel = {
                            offsetX = 0f
                            isSwipeOpen = false
                        },
                        onHorizontalDrag = { _, dragAmount ->
                            if (!isSwipeOpen) {
                                val newOffset = (offsetX + dragAmount).coerceIn(-swipeThreshold, 0f)
                                offsetX = newOffset
                            } else {
                                if (dragAmount > 0) {
                                    isSwipeOpen = false
                                    offsetX = 0f
                                }
                            }
                        }
                    )
                }
                .clickable {
                    if (isSwipeOpen) {
                        isSwipeOpen = false
                        offsetX = 0f
                    } else {
                        onClick()
                    }
                }
                .drawBehind {
                    if (showDivider) {
                        val startX = dividerStartPadding.toPx()
                        drawLine(
                            color = dividerColor,
                            start = Offset(startX, size.height - 0.5.dp.toPx()),
                            end = Offset(size.width, size.height - 0.5.dp.toPx()),
                            strokeWidth = 0.5.dp.toPx()
                        )
                    }
                }
                .padding(horizontal = dimensions.spacingMedium),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // å›¾æ ‡å®¹å™¨ (å“åº”å¼å°ºå¯¸)
            Box(
                modifier = Modifier
                    .size(dimensions.iosIconContainerSize)
                    .background(
                        color = iconBackgroundColor,
                        shape = RoundedCornerShape(dimensions.cornerRadiusSmall)
                    ),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = icon,
                    contentDescription = null,
                    tint = Color.White,
                    modifier = Modifier.size(dimensions.iconSizeMedium)
                )
            }

            Spacer(modifier = Modifier.width(dimensions.spacingMediumSmall))

            // æ ‡é¢˜å’Œæè¿° - ä½¿ç”¨å“åº”å¼å­—ä½“
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = provider.name,
                    fontSize = dimensions.fontSizeTitle,
                    fontWeight = FontWeight.SemiBold,
                    color = iOSTextPrimary,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
                Text(
                    text = getProviderDescription(provider),
                    fontSize = dimensions.fontSizeBody,
                    color = iOSTextSecondary,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }

            // é»˜è®¤æ ‡è®°
            if (isDefault) {
                Icon(
                    imageVector = Icons.Default.Check,
                    contentDescription = "é»˜è®¤",
                    tint = iOSBlue,
                    modifier = Modifier.size(dimensions.iconSizeMedium)
                )
            }
        }
    }
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/ios/IOSProviderCard.kt
@Composable
fun IOSProviderCard(
    provider: AiProvider,
    isDefault: Boolean,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    onEdit: (() -> Unit)? = null,
    onDelete: (() -> Unit)? = null,
    showDivider: Boolean = true,
    icon: ImageVector = Icons.Default.Cloud,
    iconBackgroundColor: Color = getProviderColor(provider.name),
    highlightQuery: String = ""
) {
    // ä½¿ç”¨å“åº”å¼å°ºå¯¸
    val dimensions = AdaptiveDimensions.current
    val density = LocalDensity.current
    val highlightStyle = createSearchHighlightStyle(
        isDarkTheme = isSystemInDarkTheme(),
        baseColor = iOSBlue
    )
    
    val dividerColor = iOSSeparator
    // åˆ†éš”çº¿èµ·å§‹ä½ç½® = padding(16) + iconSize(40) + spacing(12)
    val dividerStartPadding = dimensions.spacingMedium + dimensions.iosIconContainerSize + dimensions.spacingMediumSmall
    
    // æ»‘åŠ¨é˜ˆå€¼ - ä½¿ç”¨å“åº”å¼å°ºå¯¸
    val swipeThresholdDp = dimensions.swipeActionTotalWidth
    val swipeThreshold = with(density) { swipeThresholdDp.toPx() }
    val buttonWidthDp = dimensions.swipeActionButtonWidth
    
    // åˆ—è¡¨é¡¹é«˜åº¦ - å“åº”å¼
    val itemHeight = dimensions.iosListItemHeight + dimensions.spacingLarge // çº¦72dp
    
    var offsetX by remember { mutableFloatStateOf(0f) }
    var isSwipeOpen by remember { mutableStateOf(false) }
    
    val animatedOffsetX by animateFloatAsState(
        targetValue = if (isSwipeOpen) -swipeThreshold else offsetX,
        animationSpec = tween(durationMillis = 200),
        label = "swipeOffset"
    )

    Box(
        modifier = modifier
            .fillMaxWidth()
            .height(itemHeight)
    ) {
        // Action buttons (behind the card)
        Row(
            modifier = Modifier
                .align(Alignment.CenterEnd)
                .fillMaxHeight()
        ) {
            // Delete button (å·¦è¾¹)
            if (onDelete != null) {
                Box(
                    modifier = Modifier
                        .width(buttonWidthDp)
                        .fillMaxHeight()
                        .background(iOSRed)
                        .clickable {
                            isSwipeOpen = false
                            offsetX = 0f
                            onDelete()
                        },
                    contentAlignment = Alignment.Center
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Icon(
                            imageVector = Icons.Default.Delete,
                            contentDescription = "åˆ é™¤",
                            tint = Color.White,
                            modifier = Modifier.size(dimensions.iconSizeMedium)
                        )
                        Text(
                            text = "åˆ é™¤",
                            color = Color.White,
                            fontSize = dimensions.fontSizeXSmall
                        )
                    }
                }
            }
            
            // Edit button (å³è¾¹ï¼Œæ»‘åŠ¨æ—¶å…ˆéœ²å‡º)
            if (onEdit != null) {
                Box(
                    modifier = Modifier
                        .width(buttonWidthDp)
                        .fillMaxHeight()
                        .background(iOSOrange)
                        .clickable {
                            isSwipeOpen = false
                            offsetX = 0f
                            onEdit()
                        },
                    contentAlignment = Alignment.Center
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Icon(
                            imageVector = Icons.Default.Edit,
                            contentDescription = "ç¼–è¾‘",
                            tint = Color.White,
                            modifier = Modifier.size(dimensions.iconSizeMedium)
                        )
                        Text(
                            text = "ç¼–è¾‘",
                            color = Color.White,
                            fontSize = dimensions.fontSizeXSmall
                        )
                    }
                }
            }
        }

        // Main card content (swipeable)
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .height(itemHeight)
                .offset { IntOffset(animatedOffsetX.roundToInt(), 0) }
                .background(Color.White)
                .pointerInput(Unit) {
                    detectHorizontalDragGestures(
                        onDragEnd = {
                            if (offsetX < -swipeThreshold / 2) {
                                isSwipeOpen = true
                            } else {
                                isSwipeOpen = false
                            }
                            offsetX = 0f
                        },
                        onDragCancel = {
                            offsetX = 0f
                            isSwipeOpen = false
                        },
                        onHorizontalDrag = { _, dragAmount ->
                            if (!isSwipeOpen) {
                                val newOffset = (offsetX + dragAmount).coerceIn(-swipeThreshold, 0f)
                                offsetX = newOffset
                            } else {
                                if (dragAmount > 0) {
                                    isSwipeOpen = false
                                    offsetX = 0f
                                }
                            }
                        }
                    )
                }
                .clickable {
                    if (isSwipeOpen) {
                        isSwipeOpen = false
                        offsetX = 0f
                    } else {
                        onClick()
                    }
                }
                .drawBehind {
                    if (showDivider) {
                        val startX = dividerStartPadding.toPx()
                        drawLine(
                            color = dividerColor,
                            start = Offset(startX, size.height - 0.5.dp.toPx()),
                            end = Offset(size.width, size.height - 0.5.dp.toPx()),
                            strokeWidth = 0.5.dp.toPx()
                        )
                    }
                }
                .padding(horizontal = dimensions.spacingMedium),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // å›¾æ ‡å®¹å™¨ (å“åº”å¼å°ºå¯¸)
            Box(
                modifier = Modifier
                    .size(dimensions.iosIconContainerSize)
                    .background(
                        color = iconBackgroundColor,
                        shape = RoundedCornerShape(dimensions.cornerRadiusSmall)
                    ),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = icon,
                    contentDescription = null,
                    tint = Color.White,
                    modifier = Modifier.size(dimensions.iconSizeMedium)
                )
            }

            Spacer(modifier = Modifier.width(dimensions.spacingMediumSmall))

            // æ ‡é¢˜å’Œæè¿° - ä½¿ç”¨å“åº”å¼å­—ä½“
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = buildHighlightedText(
                        text = provider.name,
                        query = highlightQuery,
                        highlightStyle = highlightStyle
                    ),
                    fontSize = dimensions.fontSizeTitle,
                    fontWeight = FontWeight.SemiBold,
                    color = iOSTextPrimary,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
                Text(
                    text = getProviderDescription(provider),
                    fontSize = dimensions.fontSizeBody,
                    color = iOSTextSecondary,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }

            // é»˜è®¤æ ‡è®°
            if (isDefault) {
                Icon(
                    imageVector = Icons.Default.Check,
                    contentDescription = "é»˜è®¤",
                    tint = iOSBlue,
                    modifier = Modifier.size(dimensions.iconSizeMedium)
                )
            }
        }
    }
}
```

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/aiconfig/AiConfigScreen.kt
@Composable
private fun ProviderListContent(
    uiState: AiConfigUiState,
    onEvent: (AiConfigUiEvent) -> Unit,
    onNavigateToEditProvider: ((String) -> Unit)?
) {
    val dimensions = AdaptiveDimensions.current
    
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(bottom = dimensions.spacingXLarge)
    ) {
        // æ¨ç†å¼•æ“åˆ†ç»„
        item {
            IOSSettingsSection(
                title = "æ¨ç†å¼•æ“",
                footer = "å‘å·¦æ»‘åŠ¨å¯ç¼–è¾‘æˆ–åˆ é™¤æœåŠ¡å•†ï¼Œç‚¹å‡»åˆ‡æ¢é»˜è®¤å¼•æ“"
            ) {
                val providers = uiState.filteredProviders
                providers.forEachIndexed { index, provider ->
                    IOSProviderCard(
                        provider = provider,
                        isDefault = provider.isDefault,
                        onClick = { 
                            // ç‚¹å‡»ç›´æ¥è®¾ä¸ºé»˜è®¤æœåŠ¡å•†
                            onEvent(AiConfigUiEvent.SetDefaultProvider(provider.id))
                        },
                        onEdit = {
                            // æ»‘åŠ¨ç¼–è¾‘ - å¯¼èˆªåˆ°ç¼–è¾‘é¡µé¢
                            if (onNavigateToEditProvider != null) {
                                onNavigateToEditProvider(provider.id)
                            } else {
                                onEvent(AiConfigUiEvent.ShowEditDialog(provider))
                            }
                        },
                        onDelete = {
                            // æ»‘åŠ¨åˆ é™¤
                            onEvent(AiConfigUiEvent.ShowDeleteConfirmDialog(provider.id))
                        },
                        showDivider = index < providers.lastIndex
                    )
                }
            }
        }

        // é€šç”¨é€‰é¡¹åˆ†ç»„
        item {
            IOSSettingsSection(title = "é€šç”¨é€‰é¡¹") {
                IOSSettingsItem(
                    icon = Icons.Default.Language,
                    iconBackgroundColor = iOSBlue,
                    title = "ç½‘ç»œä»£ç†",
                    value = if (uiState.proxyConfig?.enabled == true) {
                        "${uiState.proxyConfig?.type?.name ?: "HTTP"} ${uiState.proxyConfig?.host ?: ""}:${uiState.proxyConfig?.port ?: ""}"
                    } else {
                        "æœªè®¾ç½®"
                    },
                    showDivider = true,
                    onClick = { onEvent(AiConfigUiEvent.ShowProxyDialog) }
                )
                IOSSettingsItem(
                    icon = Icons.Default.QueryStats,
                    iconBackgroundColor = iOSPurple,
                    title = "ç”¨é‡ç»Ÿè®¡",
                    showDivider = false,
                    onClick = { onEvent(AiConfigUiEvent.NavigateToUsageStats) }
                )
            }
        }
    }
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/aiconfig/AiConfigScreen.kt
@Composable
private fun ProviderListContent(
    uiState: AiConfigUiState,
    onEvent: (AiConfigUiEvent) -> Unit,
    onNavigateToEditProvider: ((String) -> Unit)?
) {
    val dimensions = AdaptiveDimensions.current
    
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(bottom = dimensions.spacingXLarge)
    ) {
        // æ¨ç†å¼•æ“åˆ†ç»„
        item {
            IOSSettingsSection(
                title = "æ¨ç†å¼•æ“",
                footer = "å‘å·¦æ»‘åŠ¨å¯ç¼–è¾‘æˆ–åˆ é™¤æœåŠ¡å•†ï¼Œç‚¹å‡»åˆ‡æ¢é»˜è®¤å¼•æ“"
            ) {
                val providers = uiState.filteredProviders
                providers.forEachIndexed { index, provider ->
                    IOSProviderCard(
                        provider = provider,
                        isDefault = provider.isDefault,
                        onClick = { 
                            // ç‚¹å‡»ç›´æ¥è®¾ä¸ºé»˜è®¤æœåŠ¡å•†
                            onEvent(AiConfigUiEvent.SetDefaultProvider(provider.id))
                        },
                        onEdit = {
                            // æ»‘åŠ¨ç¼–è¾‘ - å¯¼èˆªåˆ°ç¼–è¾‘é¡µé¢
                            if (onNavigateToEditProvider != null) {
                                onNavigateToEditProvider(provider.id)
                            } else {
                                onEvent(AiConfigUiEvent.ShowEditDialog(provider))
                            }
                        },
                        onDelete = {
                            // æ»‘åŠ¨åˆ é™¤
                            onEvent(AiConfigUiEvent.ShowDeleteConfirmDialog(provider.id))
                        },
                        showDivider = index < providers.lastIndex,
                        highlightQuery = uiState.searchQuery
                    )
                }
            }
        }

        // é€šç”¨é€‰é¡¹åˆ†ç»„
        item {
            IOSSettingsSection(title = "é€šç”¨é€‰é¡¹") {
                IOSSettingsItem(
                    icon = Icons.Default.Language,
                    iconBackgroundColor = iOSBlue,
                    title = "ç½‘ç»œä»£ç†",
                    value = if (uiState.proxyConfig?.enabled == true) {
                        "${uiState.proxyConfig?.type?.name ?: "HTTP"} ${uiState.proxyConfig?.host ?: ""}:${uiState.proxyConfig?.port ?: ""}"
                    } else {
                        "æœªè®¾ç½®"
                    },
                    showDivider = true,
                    onClick = { onEvent(AiConfigUiEvent.ShowProxyDialog) }
                )
                IOSSettingsItem(
                    icon = Icons.Default.QueryStats,
                    iconBackgroundColor = iOSPurple,
                    title = "ç”¨é‡ç»Ÿè®¡",
                    showDivider = false,
                    onClick = { onEvent(AiConfigUiEvent.NavigateToUsageStats) }
                )
            }
        }
    }
}
```

---

### å˜æ›´ 9ï¼šæ ‡ç­¾ç®¡ç†é¡µæ¥å…¥æœç´¢æ 

**ä¿®æ”¹åŸå› **ï¼š
1. BrainTagScreen å·²æœ‰æœç´¢äº‹ä»¶ä¸çŠ¶æ€ï¼Œä½† UI æ²¡æœ‰è¾“å…¥å…¥å£ï¼ŒåŠŸèƒ½ä¸å¯ç”¨ã€‚
2. ç°æˆçš„ TagSearchBar å¯å¤ç”¨ï¼Œå‡å°‘é¢å¤– UI è®¾è®¡æˆæœ¬ã€‚
3. å±•ç¤ºåœ¨ TopAppBar ä¸‹æ–¹ä¸å½±å“ä¸»ä½“åˆ—è¡¨å¸ƒå±€ã€‚

**å½±å“åˆ†æ**ï¼š
- BrainTagScreen ä½¿ç”¨ `rememberSaveable` ç®¡ç†æœç´¢æ æ˜¾ç¤ºçŠ¶æ€ã€‚
- å…³é—­æœç´¢æ æ—¶è§¦å‘ `ClearSearch`ï¼Œä¿è¯çŠ¶æ€ä¸€è‡´ã€‚
- UI é¢„è§ˆæœªéªŒè¯ï¼Œéœ€äººå·¥ç¡®è®¤è§†è§‰æ•ˆæœä¸é«˜åº¦ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- å°†è¾“å…¥æ¡†åµŒå…¥ TopAppBarï¼Œä½†å¸ƒå±€æ›´æ‹¥æŒ¤ï¼Œäº¤äº’æˆæœ¬æ›´é«˜ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/tag/BrainTagScreen.kt
@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun BrainTagScreenContent(
    uiState: BrainTagUiState,
    onEvent: (BrainTagUiEvent) -> Unit,
    onNavigateBack: () -> Unit,
    modifier: Modifier = Modifier
) {
    Scaffold(
        modifier = modifier,
        topBar = {
            TopAppBar(
                title = { Text("æ ‡ç­¾ç®¡ç†") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(
                            imageVector = Icons.Default.ArrowBack,
                            contentDescription = "è¿”å›"
                        )
                    }
                },
                actions = {
                    IconButton(onClick = { /* TODO: å®ç°æœç´¢ */ }) {
                        Icon(
                            imageVector = Icons.Default.Search,
                            contentDescription = "æœç´¢"
                        )
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { onEvent(BrainTagUiEvent.ShowAddDialog) }) {
                Icon(
                    imageVector = Icons.Default.Add,
                    contentDescription = "æ·»åŠ æ ‡ç­¾"
                )
            }
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            when {
                uiState.isLoading -> {
                    LoadingIndicatorFullScreen(
                        message = "åŠ è½½æ ‡ç­¾..."
                    )
                }
                uiState.isEmptyState -> {
                    EmptyView(
                        message = "è¿˜æ²¡æœ‰æ ‡ç­¾",
                        actionText = "æ·»åŠ æ ‡ç­¾",
                        onAction = { onEvent(BrainTagUiEvent.ShowAddDialog) },
                        emptyType = EmptyType.NoTags
                    )
                }
                else -> {
                    TagList(
                        tags = uiState.displayTags,
                        searchQuery = uiState.searchQuery,
                        onDeleteTag = { tagId -> onEvent(BrainTagUiEvent.DeleteTag(tagId)) },
                        onEditTag = { tag -> onEvent(BrainTagUiEvent.StartEditTag(tag)) }
                    )
                }
            }
        }
    }
    // æ·»åŠ æ ‡ç­¾å¯¹è¯æ¡†
    if (uiState.showAddDialog) {
        AddTagDialog(
            tagContent = uiState.newTagContent,
            selectedType = uiState.selectedTagType,
            onContentChange = { onEvent(BrainTagUiEvent.UpdateNewTagContent(it)) },
            onTypeChange = { onEvent(BrainTagUiEvent.UpdateSelectedTagType(it)) },
            onDismiss = { onEvent(BrainTagUiEvent.HideAddDialog) },
            onConfirm = { onEvent(BrainTagUiEvent.ConfirmAddTag) }
        )
    }
    // ç¼–è¾‘æ ‡ç­¾å¯¹è¯æ¡† (BUG-00066)
    if (uiState.showEditDialog && uiState.editingTag != null) {
        EditBrainTagDialog(
            tag = uiState.editingTag,
            onConfirm = { tagId, newContent, newType ->
                onEvent(BrainTagUiEvent.ConfirmEditTag(tagId, newContent, newType))
            },
            onDismiss = { onEvent(BrainTagUiEvent.CancelEditTag) }
        )
    }
    // é”™è¯¯æç¤º - iOSé£æ ¼
    uiState.error?.let { error ->
        IOSAlertDialog(
            title = "é”™è¯¯",
            message = error,
            confirmText = "ç¡®å®š",
            onConfirm = { onEvent(BrainTagUiEvent.ClearError) },
            onDismiss = { onEvent(BrainTagUiEvent.ClearError) },
            showDismissButton = false
        )
    }
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/tag/BrainTagScreen.kt
@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun BrainTagScreenContent(
    uiState: BrainTagUiState,
    onEvent: (BrainTagUiEvent) -> Unit,
    onNavigateBack: () -> Unit,
    modifier: Modifier = Modifier
) {
    var isSearchBarVisible by rememberSaveable { mutableStateOf(false) }

    Scaffold(
        modifier = modifier,
        topBar = {
            Column {
                TopAppBar(
                    title = { Text("æ ‡ç­¾ç®¡ç†") },
                    navigationIcon = {
                        IconButton(onClick = onNavigateBack) {
                            Icon(
                                imageVector = Icons.Default.ArrowBack,
                                contentDescription = "è¿”å›"
                            )
                        }
                    },
                    actions = {
                        IconButton(onClick = { isSearchBarVisible = true }) {
                            Icon(
                                imageVector = Icons.Default.Search,
                                contentDescription = "æœç´¢"
                            )
                        }
                    }
                )

                if (isSearchBarVisible) {
                    TagSearchBar(
                        searchQuery = uiState.searchQuery,
                        resultCount = uiState.displayTags.size,
                        onQueryChange = { onEvent(BrainTagUiEvent.UpdateSearchQuery(it)) },
                        onSearchClose = {
                            isSearchBarVisible = false
                            onEvent(BrainTagUiEvent.ClearSearch)
                        }
                    )
                }
            }
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { onEvent(BrainTagUiEvent.ShowAddDialog) }) {
                Icon(
                    imageVector = Icons.Default.Add,
                    contentDescription = "æ·»åŠ æ ‡ç­¾"
                )
            }
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            when {
                uiState.isLoading -> {
                    LoadingIndicatorFullScreen(
                        message = "åŠ è½½æ ‡ç­¾..."
                    )
                }
                uiState.isEmptyState -> {
                    EmptyView(
                        message = "è¿˜æ²¡æœ‰æ ‡ç­¾",
                        actionText = "æ·»åŠ æ ‡ç­¾",
                        onAction = { onEvent(BrainTagUiEvent.ShowAddDialog) },
                        emptyType = EmptyType.NoTags
                    )
                }
                else -> {
                    TagList(
                        tags = uiState.displayTags,
                        searchQuery = uiState.searchQuery,
                        onDeleteTag = { tagId -> onEvent(BrainTagUiEvent.DeleteTag(tagId)) },
                        onEditTag = { tag -> onEvent(BrainTagUiEvent.StartEditTag(tag)) }
                    )
                }
            }
        }
    }
    // æ·»åŠ æ ‡ç­¾å¯¹è¯æ¡†
    if (uiState.showAddDialog) {
        AddTagDialog(
            tagContent = uiState.newTagContent,
            selectedType = uiState.selectedTagType,
            onContentChange = { onEvent(BrainTagUiEvent.UpdateNewTagContent(it)) },
            onTypeChange = { onEvent(BrainTagUiEvent.UpdateSelectedTagType(it)) },
            onDismiss = { onEvent(BrainTagUiEvent.HideAddDialog) },
            onConfirm = { onEvent(BrainTagUiEvent.ConfirmAddTag) }
        )
    }
    // ç¼–è¾‘æ ‡ç­¾å¯¹è¯æ¡† (BUG-00066)
    if (uiState.showEditDialog && uiState.editingTag != null) {
        EditBrainTagDialog(
            tag = uiState.editingTag,
            onConfirm = { tagId, newContent, newType ->
                onEvent(BrainTagUiEvent.ConfirmEditTag(tagId, newContent, newType))
            },
            onDismiss = { onEvent(BrainTagUiEvent.CancelEditTag) }
        )
    }
    // é”™è¯¯æç¤º - iOSé£æ ¼
    uiState.error?.let { error ->
        IOSAlertDialog(
            title = "é”™è¯¯",
            message = error,
            confirmText = "ç¡®å®š",
            onConfirm = { onEvent(BrainTagUiEvent.ClearError) },
            onDismiss = { onEvent(BrainTagUiEvent.ClearError) },
            showDismissButton = false
        )
    }
}
```

---

### å˜æ›´ 10ï¼šæ ‡ç­¾æœç´¢æ— ç»“æœæç¤º

**ä¿®æ”¹åŸå› **ï¼š
1. æœç´¢æ— ç»“æœæ—¶åˆ—è¡¨åŒºåŸŸå®Œå…¨ç©ºç™½ï¼Œç”¨æˆ·å®¹æ˜“è¯¯è§£ä¸ºåŠ è½½å¼‚å¸¸ã€‚
2. EmptyView å·²æœ‰ NoResults ç±»å‹ï¼Œå¯å¤ç”¨ã€‚
3. æœç´¢åé¦ˆåº”æ˜ç¡®å‘ŠçŸ¥ç»“æœä¸ºé›¶ã€‚

**å½±å“åˆ†æ**ï¼š
- ä»…åœ¨ TagList å†…å¢åŠ æ¡ä»¶åˆ†æ”¯ï¼Œåˆ†ç»„é€»è¾‘ä¸å˜ã€‚
- ä»…å½±å“æœç´¢æ— ç»“æœçš„å±•ç¤ºï¼Œä¸å½±å“é»˜è®¤åˆ—è¡¨ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- åœ¨ TagSearchBar é™„è¿‘æç¤ºâ€œ0â€ï¼Œä½†åˆ—è¡¨ä»ç©ºç™½ï¼Œåé¦ˆä¸å¤Ÿæ˜ç¡®ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/tag/BrainTagScreen.kt
@Composable
private fun TagList(
    tags: List<BrainTag>,
    searchQuery: String,
    onDeleteTag: (Long) -> Unit,
    onEditTag: (BrainTag) -> Unit,
    modifier: Modifier = Modifier
) {
    // è¿‡æ»¤æ ‡ç­¾
    val filteredTags = if (searchQuery.isBlank()) {
        tags
    } else {
        tags.filter { it.content.contains(searchQuery, ignoreCase = true) }
    }

    // æŒ‰ç±»å‹åˆ†ç»„
    val landmineTags = filteredTags.filter { it.type == TagType.RISK_RED }
    val strategyTags = filteredTags.filter { it.type == TagType.STRATEGY_GREEN }

    LazyColumn(
        modifier = modifier.fillMaxSize(),
        contentPadding = PaddingValues(AppSpacing.lg),
        verticalArrangement = Arrangement.spacedBy(AppSpacing.lg)
    ) {
        // é›·åŒºæ ‡ç­¾
        if (landmineTags.isNotEmpty()) {
            item {
                Text(
                    text = "é›·åŒºæ ‡ç­¾ (${landmineTags.size})",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.error
                )
            }

            items(
                items = landmineTags,
                key = { it.id }
            ) { tag ->
                TagChip(
                    text = tag.content,
                    tagType = tag.type,
                    highlightQuery = searchQuery,
                    onDelete = { onDeleteTag(tag.id) },
                    onClick = { onEditTag(tag) },
                    modifier = Modifier.fillMaxWidth()
                )
            }

            item {
                Spacer(modifier = Modifier.height(AppSpacing.sm))
            }
        }

        // ç­–ç•¥æ ‡ç­¾
        if (strategyTags.isNotEmpty()) {
            item {
                Text(
                    text = "ç­–ç•¥æ ‡ç­¾ (${strategyTags.size})",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.primary
                )
            }

            items(
                items = strategyTags,
                key = { it.id }
            ) { tag ->
                TagChip(
                    text = tag.content,
                    tagType = tag.type,
                    highlightQuery = searchQuery,
                    onDelete = { onDeleteTag(tag.id) },
                    onClick = { onEditTag(tag) },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    }
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/tag/BrainTagScreen.kt
@Composable
private fun TagList(
    tags: List<BrainTag>,
    searchQuery: String,
    onDeleteTag: (Long) -> Unit,
    onEditTag: (BrainTag) -> Unit,
    modifier: Modifier = Modifier
) {
    // è¿‡æ»¤æ ‡ç­¾
    val filteredTags = if (searchQuery.isBlank()) {
        tags
    } else {
        tags.filter { it.content.contains(searchQuery, ignoreCase = true) }
    }

    if (filteredTags.isEmpty() && searchQuery.isNotBlank()) {
        Box(
            modifier = modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            EmptyView(
                message = "æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„æ ‡ç­¾",
                actionText = null,
                onAction = null,
                emptyType = EmptyType.NoResults
            )
        }
        return
    }

    // æŒ‰ç±»å‹åˆ†ç»„
    val landmineTags = filteredTags.filter { it.type == TagType.RISK_RED }
    val strategyTags = filteredTags.filter { it.type == TagType.STRATEGY_GREEN }

    LazyColumn(
        modifier = modifier.fillMaxSize(),
        contentPadding = PaddingValues(AppSpacing.lg),
        verticalArrangement = Arrangement.spacedBy(AppSpacing.lg)
    ) {
        // é›·åŒºæ ‡ç­¾
        if (landmineTags.isNotEmpty()) {
            item {
                Text(
                    text = "é›·åŒºæ ‡ç­¾ (${landmineTags.size})",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.error
                )
            }

            items(
                items = landmineTags,
                key = { it.id }
            ) { tag ->
                TagChip(
                    text = tag.content,
                    tagType = tag.type,
                    highlightQuery = searchQuery,
                    onDelete = { onDeleteTag(tag.id) },
                    onClick = { onEditTag(tag) },
                    modifier = Modifier.fillMaxWidth()
                )
            }

            item {
                Spacer(modifier = Modifier.height(AppSpacing.sm))
            }
        }

        // ç­–ç•¥æ ‡ç­¾
        if (strategyTags.isNotEmpty()) {
            item {
                Text(
                    text = "ç­–ç•¥æ ‡ç­¾ (${strategyTags.size})",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.primary
                )
            }

            items(
                items = strategyTags,
                key = { it.id }
            ) { tag ->
                TagChip(
                    text = tag.content,
                    tagType = tag.type,
                    highlightQuery = searchQuery,
                    onDelete = { onDeleteTag(tag.id) },
                    onClick = { onEditTag(tag) },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    }
}
```

---

### å˜æ›´ 11ï¼šAI é…ç½®æœç´¢æ— ç»“æœæç¤º

**ä¿®æ”¹åŸå› **ï¼š
1. AI é…ç½®æœç´¢æ— ç»“æœæ—¶åˆ—è¡¨ç©ºç™½ï¼Œåé¦ˆä¸æ˜ç¡®ã€‚
2. æœç´¢ä½“éªŒåº”åœ¨æ‰€æœ‰é¡µé¢ä¿æŒä¸€è‡´çš„â€œæ— ç»“æœâ€æç¤ºã€‚
3. EmptyView.NoResults å·²å­˜åœ¨ï¼Œå¯å¤ç”¨ã€‚

**å½±å“åˆ†æ**ï¼š
- ä»…åœ¨ AiConfigScreenContent çš„å±•ç¤ºåˆ†æ”¯ä¸­æ–°å¢æ¡ä»¶ã€‚
- ä¸å½±å“å·²æœ‰â€œæ— æœåŠ¡å•†â€ç©ºçŠ¶æ€é€»è¾‘ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä¸åšæç¤ºï¼Œç»´æŒç©ºç™½ï¼Œä½†ä½“éªŒä¸ä¸€è‡´ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/aiconfig/AiConfigScreen.kt
when {
    uiState.isLoading -> {
        LoadingIndicatorFullScreen(message = "åŠ è½½æœåŠ¡å•†...")
    }
    uiState.error != null -> {
        FriendlyErrorCard(
            error = UserFriendlyError(
                title = "å‡ºé”™äº†",
                message = uiState.error ?: "æœªçŸ¥é”™è¯¯",
                icon = Icons.Default.Warning
            ),
            onAction = { onEvent(AiConfigUiEvent.LoadProviders) }
        )
    }
    !uiState.hasProviders -> {
        EmptyView(
            message = "è¿˜æ²¡æœ‰é…ç½® AI æœåŠ¡å•†\nç‚¹å‡»å³ä¸Šè§’æŒ‰é’®æ·»åŠ ",
            actionText = null,
            onAction = null
        )
    }
    else -> {
        ProviderListContent(
            uiState = uiState,
            onEvent = onEvent,
            onNavigateToEditProvider = onNavigateToEditProvider
        )
    }
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/aiconfig/AiConfigScreen.kt
when {
    uiState.isLoading -> {
        LoadingIndicatorFullScreen(message = "åŠ è½½æœåŠ¡å•†...")
    }
    uiState.error != null -> {
        FriendlyErrorCard(
            error = UserFriendlyError(
                title = "å‡ºé”™äº†",
                message = uiState.error ?: "æœªçŸ¥é”™è¯¯",
                icon = Icons.Default.Warning
            ),
            onAction = { onEvent(AiConfigUiEvent.LoadProviders) }
        )
    }
    !uiState.hasProviders -> {
        EmptyView(
            message = "è¿˜æ²¡æœ‰é…ç½® AI æœåŠ¡å•†\nç‚¹å‡»å³ä¸Šè§’æŒ‰é’®æ·»åŠ ",
            actionText = null,
            onAction = null
        )
    }
    uiState.searchQuery.isNotBlank() && uiState.filteredProviders.isEmpty() -> {
        EmptyView(
            message = "æœªæ‰¾åˆ°åŒ¹é…çš„æœåŠ¡å•†",
            actionText = null,
            onAction = null,
            emptyType = EmptyType.NoResults
        )
    }
    else -> {
        ProviderListContent(
            uiState = uiState,
            onEvent = onEvent,
            onNavigateToEditProvider = onNavigateToEditProvider
        )
    }
}
```

---

### å˜æ›´ 12ï¼šæ ‡ç­¾æœç´¢æ  BackHandler å…³é—­

**ä¿®æ”¹åŸå› **ï¼š
1. æœç´¢æ å±•å¼€æ—¶ Back ç›´æ¥è¿”å›é¡µé¢ï¼Œäº¤äº’ä¸ç¬¦åˆç”¨æˆ·é¢„æœŸã€‚
2. æœç´¢ UI åº”ä¼˜å…ˆå…³é—­ï¼Œè€Œéç«‹å³é€€å‡ºé¡µé¢ã€‚
3. BackHandler å¯ä»¥åœ¨ UI å±‚ç›´æ¥å¤„ç†ï¼Œæ”¹åŠ¨èŒƒå›´å°ã€‚

**å½±å“åˆ†æ**ï¼š
- ä»…å½±å“ BrainTagScreenContent çš„ Back è¡Œä¸ºã€‚
- å½“æœç´¢æ ä¸å¯è§æ—¶ï¼Œè¿”å›è¡Œä¸ºä¿æŒä¸å˜ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä¿æŒé»˜è®¤è¿”å›è¡Œä¸ºï¼Œä½†ä½“éªŒä¸ä¸€è‡´ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/tag/BrainTagScreen.kt
@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun BrainTagScreenContent(
    uiState: BrainTagUiState,
    onEvent: (BrainTagUiEvent) -> Unit,
    onNavigateBack: () -> Unit,
    modifier: Modifier = Modifier
) {
    var isSearchBarVisible by rememberSaveable { mutableStateOf(false) }

    Scaffold(
        modifier = modifier,
        topBar = {
            Column {
                TopAppBar(
                    title = { Text("æ ‡ç­¾ç®¡ç†") },
                    navigationIcon = {
                        IconButton(onClick = onNavigateBack) {
                            Icon(
                                imageVector = Icons.Default.ArrowBack,
                                contentDescription = "è¿”å›"
                            )
                        }
                    },
                    actions = {
                        IconButton(onClick = { isSearchBarVisible = true }) {
                            Icon(
                                imageVector = Icons.Default.Search,
                                contentDescription = "æœç´¢"
                            )
                        }
                    }
                )

                if (isSearchBarVisible) {
                    TagSearchBar(
                        searchQuery = uiState.searchQuery,
                        resultCount = uiState.displayTags.size,
                        onQueryChange = { onEvent(BrainTagUiEvent.UpdateSearchQuery(it)) },
                        onSearchClose = {
                            isSearchBarVisible = false
                            onEvent(BrainTagUiEvent.ClearSearch)
                        }
                    )
                }
            }
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { onEvent(BrainTagUiEvent.ShowAddDialog) }) {
                Icon(
                    imageVector = Icons.Default.Add,
                    contentDescription = "æ·»åŠ æ ‡ç­¾"
                )
            }
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            when {
                uiState.isLoading -> {
                    LoadingIndicatorFullScreen(
                        message = "åŠ è½½æ ‡ç­¾..."
                    )
                }
                uiState.isEmptyState -> {
                    EmptyView(
                        message = "è¿˜æ²¡æœ‰æ ‡ç­¾",
                        actionText = "æ·»åŠ æ ‡ç­¾",
                        onAction = { onEvent(BrainTagUiEvent.ShowAddDialog) },
                        emptyType = EmptyType.NoTags
                    )
                }
                else -> {
                    TagList(
                        tags = uiState.displayTags,
                        searchQuery = uiState.searchQuery,
                        onDeleteTag = { tagId -> onEvent(BrainTagUiEvent.DeleteTag(tagId)) },
                        onEditTag = { tag -> onEvent(BrainTagUiEvent.StartEditTag(tag)) }
                    )
                }
            }
        }
    }
    // æ·»åŠ æ ‡ç­¾å¯¹è¯æ¡†
    if (uiState.showAddDialog) {
        AddTagDialog(
            tagContent = uiState.newTagContent,
            selectedType = uiState.selectedTagType,
            onContentChange = { onEvent(BrainTagUiEvent.UpdateNewTagContent(it)) },
            onTypeChange = { onEvent(BrainTagUiEvent.UpdateSelectedTagType(it)) },
            onDismiss = { onEvent(BrainTagUiEvent.HideAddDialog) },
            onConfirm = { onEvent(BrainTagUiEvent.ConfirmAddTag) }
        )
    }
    // ç¼–è¾‘æ ‡ç­¾å¯¹è¯æ¡† (BUG-00066)
    if (uiState.showEditDialog && uiState.editingTag != null) {
        EditBrainTagDialog(
            tag = uiState.editingTag,
            onConfirm = { tagId, newContent, newType ->
                onEvent(BrainTagUiEvent.ConfirmEditTag(tagId, newContent, newType))
            },
            onDismiss = { onEvent(BrainTagUiEvent.CancelEditTag) }
        )
    }
    // é”™è¯¯æç¤º - iOSé£æ ¼
    uiState.error?.let { error ->
        IOSAlertDialog(
            title = "é”™è¯¯",
            message = error,
            confirmText = "ç¡®å®š",
            onConfirm = { onEvent(BrainTagUiEvent.ClearError) },
            onDismiss = { onEvent(BrainTagUiEvent.ClearError) },
            showDismissButton = false
        )
    }
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/tag/BrainTagScreen.kt
@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun BrainTagScreenContent(
    uiState: BrainTagUiState,
    onEvent: (BrainTagUiEvent) -> Unit,
    onNavigateBack: () -> Unit,
    modifier: Modifier = Modifier
) {
    var isSearchBarVisible by rememberSaveable { mutableStateOf(false) }

    BackHandler {
        if (isSearchBarVisible) {
            isSearchBarVisible = false
            onEvent(BrainTagUiEvent.ClearSearch)
        } else {
            onNavigateBack()
        }
    }

    Scaffold(
        modifier = modifier,
        topBar = {
            Column {
                TopAppBar(
                    title = { Text("æ ‡ç­¾ç®¡ç†") },
                    navigationIcon = {
                        IconButton(onClick = onNavigateBack) {
                            Icon(
                                imageVector = Icons.Default.ArrowBack,
                                contentDescription = "è¿”å›"
                            )
                        }
                    },
                    actions = {
                        IconButton(onClick = { isSearchBarVisible = true }) {
                            Icon(
                                imageVector = Icons.Default.Search,
                                contentDescription = "æœç´¢"
                            )
                        }
                    }
                )

                if (isSearchBarVisible) {
                    TagSearchBar(
                        searchQuery = uiState.searchQuery,
                        resultCount = uiState.displayTags.size,
                        onQueryChange = { onEvent(BrainTagUiEvent.UpdateSearchQuery(it)) },
                        onSearchClose = {
                            isSearchBarVisible = false
                            onEvent(BrainTagUiEvent.ClearSearch)
                        }
                    )
                }
            }
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { onEvent(BrainTagUiEvent.ShowAddDialog) }) {
                Icon(
                    imageVector = Icons.Default.Add,
                    contentDescription = "æ·»åŠ æ ‡ç­¾"
                )
            }
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            when {
                uiState.isLoading -> {
                    LoadingIndicatorFullScreen(
                        message = "åŠ è½½æ ‡ç­¾..."
                    )
                }
                uiState.isEmptyState -> {
                    EmptyView(
                        message = "è¿˜æ²¡æœ‰æ ‡ç­¾",
                        actionText = "æ·»åŠ æ ‡ç­¾",
                        onAction = { onEvent(BrainTagUiEvent.ShowAddDialog) },
                        emptyType = EmptyType.NoTags
                    )
                }
                else -> {
                    TagList(
                        tags = uiState.displayTags,
                        searchQuery = uiState.searchQuery,
                        onDeleteTag = { tagId -> onEvent(BrainTagUiEvent.DeleteTag(tagId)) },
                        onEditTag = { tag -> onEvent(BrainTagUiEvent.StartEditTag(tag)) }
                    )
                }
            }
        }
    }
    // æ·»åŠ æ ‡ç­¾å¯¹è¯æ¡†
    if (uiState.showAddDialog) {
        AddTagDialog(
            tagContent = uiState.newTagContent,
            selectedType = uiState.selectedTagType,
            onContentChange = { onEvent(BrainTagUiEvent.UpdateNewTagContent(it)) },
            onTypeChange = { onEvent(BrainTagUiEvent.UpdateSelectedTagType(it)) },
            onDismiss = { onEvent(BrainTagUiEvent.HideAddDialog) },
            onConfirm = { onEvent(BrainTagUiEvent.ConfirmAddTag) }
        )
    }
    // ç¼–è¾‘æ ‡ç­¾å¯¹è¯æ¡† (BUG-00066)
    if (uiState.showEditDialog && uiState.editingTag != null) {
        EditBrainTagDialog(
            tag = uiState.editingTag,
            onConfirm = { tagId, newContent, newType ->
                onEvent(BrainTagUiEvent.ConfirmEditTag(tagId, newContent, newType))
            },
            onDismiss = { onEvent(BrainTagUiEvent.CancelEditTag) }
        )
    }
    // é”™è¯¯æç¤º - iOSé£æ ¼
    uiState.error?.let { error ->
        IOSAlertDialog(
            title = "é”™è¯¯",
            message = error,
            confirmText = "ç¡®å®š",
            onConfirm = { onEvent(BrainTagUiEvent.ClearError) },
            onDismiss = { onEvent(BrainTagUiEvent.ClearError) },
            showDismissButton = false
        )
    }
}
```

---

### å˜æ›´ 13ï¼šè”ç³»äººç”»åƒæœç´¢é«˜äº®

**ä¿®æ”¹åŸå› **ï¼š
1. PersonaTab æœç´¢ä»…è¿‡æ»¤åˆ—è¡¨ï¼Œæ²¡æœ‰å‘½ä¸­ä½ç½®æç¤ºï¼Œç”¨æˆ·éš¾ä»¥ç¡®è®¤åŒ¹é…ç‚¹ã€‚
2. è”ç³»äººåˆ—è¡¨/æ ‡ç­¾ç®¡ç†/æœåŠ¡å•†åˆ—è¡¨å·²ç»Ÿä¸€é«˜äº®ï¼Œç”»åƒé¡µç¼ºå¤±ä¼šé€ æˆä½“éªŒå‰²è£‚ã€‚
3. å¤ç”¨ `TextHighlight` å·¥å…·å³å¯ä½æˆæœ¬è¡¥é½ä¸€è‡´æ€§ã€‚

**å½±å“åˆ†æ**ï¼š
- ä»…å½±å“è”ç³»äººç”»åƒé¡µï¼ˆPersonaTabï¼‰æ˜¾ç¤ºå±‚ã€‚
- æœç´¢è¿‡æ»¤é€»è¾‘ä¸å˜ï¼Œä»…å¢åŠ æ–‡æœ¬é«˜äº®æ¸²æŸ“ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä»…è¿‡æ»¤ä¸é«˜äº®ï¼ˆåé¦ˆä¸æ¸…æ™°ï¼‰ã€‚
- åªé«˜äº®æ ‡ç­¾å€¼ï¼Œä¸é«˜äº®ç±»åˆ«æ ‡é¢˜ï¼ˆç±»åˆ«å‘½ä¸­ä¸æ˜æ˜¾ï¼‰ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/contact/persona/PersonaTab.kt
@Composable
fun PersonaTab(
    facts: List<Fact>,
    onFactClick: (Fact) -> Unit,
    onFactLongClick: (Fact) -> Unit,
    showResetButton: Boolean = true,
    modifier: Modifier = Modifier
) {
    val dimensions = AdaptiveDimensions.current
    var searchQuery by rememberSaveable { mutableStateOf("") }
    ...
    SimpleCategoryCard(
        categoryName = category,
        facts = categoryFacts,
        isExpanded = category in expandedCategories,
        onToggle = { ... },
        onFactClick = onFactClick,
        onFactLongClick = onFactLongClick
    )
}

@Composable
private fun SimpleCategoryCard(
    categoryName: String,
    facts: List<Fact>,
    isExpanded: Boolean,
    onToggle: () -> Unit,
    onFactClick: (Fact) -> Unit,
    onFactLongClick: (Fact) -> Unit,
    modifier: Modifier = Modifier
) {
    ...
    Text(
        text = categoryName,
        fontSize = dimensions.fontSizeSubtitle,
        fontWeight = FontWeight.SemiBold,
        color = Color.Black,
        modifier = Modifier.weight(1f)
    )
    ...
    SimpleTagChip(
        text = fact.value,
        color = categoryColor,
        onClick = { onFactClick(fact) },
        onLongClick = { onFactLongClick(fact) }
    )
}

@Composable
private fun SimpleTagChip(
    text: String,
    color: Color,
    onClick: () -> Unit,
    onLongClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Text(
        text = text,
        fontSize = dimensions.fontSizeBody,
        color = color.copy(alpha = 0.9f),
        fontWeight = FontWeight.Medium,
        modifier = Modifier.padding(horizontal = dimensions.spacingMedium, vertical = dimensions.spacingSmall)
    )
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/contact/persona/PersonaTab.kt
@Composable
fun PersonaTab(
    facts: List<Fact>,
    onFactClick: (Fact) -> Unit,
    onFactLongClick: (Fact) -> Unit,
    showResetButton: Boolean = true,
    modifier: Modifier = Modifier
) {
    val dimensions = AdaptiveDimensions.current
    val highlightStyle = createSearchHighlightStyle(
        isDarkTheme = isSystemInDarkTheme(),
        baseColor = iOSBlue
    )
    var searchQuery by rememberSaveable { mutableStateOf("") }
    ...
    SimpleCategoryCard(
        categoryName = category,
        facts = categoryFacts,
        isExpanded = category in expandedCategories,
        searchQuery = searchQuery,
        highlightStyle = highlightStyle,
        onToggle = { ... },
        onFactClick = onFactClick,
        onFactLongClick = onFactLongClick
    )
}

@Composable
private fun SimpleCategoryCard(
    categoryName: String,
    facts: List<Fact>,
    isExpanded: Boolean,
    searchQuery: String,
    highlightStyle: SpanStyle,
    onToggle: () -> Unit,
    onFactClick: (Fact) -> Unit,
    onFactLongClick: (Fact) -> Unit,
    modifier: Modifier = Modifier
) {
    ...
    Text(
        text = buildHighlightedText(
            text = categoryName,
            query = searchQuery,
            highlightStyle = highlightStyle
        ),
        fontSize = dimensions.fontSizeSubtitle,
        fontWeight = FontWeight.SemiBold,
        color = Color.Black,
        modifier = Modifier.weight(1f)
    )
    ...
    SimpleTagChip(
        text = fact.value,
        color = categoryColor,
        onClick = { onFactClick(fact) },
        onLongClick = { onFactLongClick(fact) },
        highlightQuery = searchQuery,
        highlightStyle = highlightStyle
    )
}

@Composable
private fun SimpleTagChip(
    text: String,
    color: Color,
    onClick: () -> Unit,
    onLongClick: () -> Unit,
    highlightQuery: String,
    highlightStyle: SpanStyle,
    modifier: Modifier = Modifier
) {
    Text(
        text = buildHighlightedText(
            text = text,
            query = highlightQuery,
            highlightStyle = highlightStyle
        ),
        fontSize = dimensions.fontSizeBody,
        color = color.copy(alpha = 0.9f),
        fontWeight = FontWeight.Medium,
        modifier = Modifier.padding(horizontal = dimensions.spacingMedium, vertical = dimensions.spacingSmall)
    )
}
```

---

### å˜æ›´ 14ï¼šPersonaTabV2 åˆ†ç±»ä¸æ ‡ç­¾æœç´¢é«˜äº®

**ä¿®æ”¹åŸå› **ï¼š
1. PersonaTabV2 çš„æœç´¢ç»“æœç¼ºå°‘åˆ†ç±»æ ‡é¢˜é«˜äº®ï¼Œåé¦ˆä¸å®Œæ•´ã€‚
2. SelectableTagChip ä½¿ç”¨å›ºå®šé«˜äº®æ ·å¼ï¼Œæ— æ³•ä¸æ•´ä½“é«˜äº®ç­–ç•¥ä¿æŒä¸€è‡´ã€‚
3. å¤ç”¨ `TextHighlight` å·¥å…·å¯æå‡ä¸€è‡´æ€§ä¸å¯ç»´æŠ¤æ€§ã€‚

**å½±å“åˆ†æ**ï¼š
- ä»…å½±å“ PersonaTabV2 çš„åˆ†ç±»æ ‡é¢˜ä¸æ ‡ç­¾æ¸²æŸ“ã€‚
- æœç´¢è¿‡æ»¤é€»è¾‘ä¸å˜ï¼Œä»…å¢åŠ é«˜äº®æ ·å¼ä¼ é€’ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä¿æŒç°çŠ¶ï¼šæœç´¢å‘½ä¸­ä½ç½®ä¸æ˜æ˜¾ã€‚
- ä»…é«˜äº®åˆ†ç±»æ ‡é¢˜ï¼šæ ‡ç­¾å‘½ä¸­ä»ä¸ç›´è§‚ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/contact/persona/DynamicCategoryCard.kt
@Composable
fun DynamicCategoryCard(
    category: FactCategory,
    isEditMode: Boolean,
    selectedFactIds: Set<String>,
    searchQuery: String,
    isDarkMode: Boolean,
    onToggleExpand: () -> Unit,
    onFactClick: (String) -> Unit,
    onFactLongClick: (String) -> Unit,
    onToggleFactSelection: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    val categoryColor = category.color.toComposeColor()

    ...
    Text(
        text = category.key,
        style = MaterialTheme.typography.titleMedium,
        color = categoryColor.titleColor,
        modifier = Modifier.weight(1f)
    )
    ...
    SelectableTagChip(
        fact = fact,
        isEditMode = isEditMode,
        isSelected = selectedFactIds.contains(fact.id),
        searchQuery = searchQuery,
        categoryColor = categoryColor,
        onClick = { onFactClick(fact.id) },
        onLongClick = { onFactLongClick(fact.id) },
        onToggleSelection = { onToggleFactSelection(fact.id) }
    )
}
```

```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/contact/persona/SelectableTagChip.kt
@Composable
fun SelectableTagChip(
    fact: Fact,
    isEditMode: Boolean,
    isSelected: Boolean,
    searchQuery: String,
    categoryColor: ComposeCategoryColor,
    onClick: () -> Unit,
    onLongClick: () -> Unit,
    onToggleSelection: () -> Unit,
    modifier: Modifier = Modifier
) {
    ...
    Text(
        text = buildHighlightedText(
            text = fact.value,
            query = searchQuery,
            highlightStyle = SpanStyle(
                fontWeight = FontWeight.Bold,
                background = MaterialTheme.colorScheme.tertiaryContainer
            )
        ),
        style = MaterialTheme.typography.bodyMedium,
        color = textColor
    )
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/contact/persona/DynamicCategoryCard.kt
@Composable
fun DynamicCategoryCard(
    category: FactCategory,
    isEditMode: Boolean,
    selectedFactIds: Set<String>,
    searchQuery: String,
    isDarkMode: Boolean,
    onToggleExpand: () -> Unit,
    onFactClick: (String) -> Unit,
    onFactLongClick: (String) -> Unit,
    onToggleFactSelection: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    val categoryColor = category.color.toComposeColor()
    val highlightStyle = createSearchHighlightStyle(
        isDarkTheme = isDarkMode,
        baseColor = categoryColor.titleColor
    )

    ...
    Text(
        text = buildHighlightedText(
            text = category.key,
            query = searchQuery,
            highlightStyle = highlightStyle
        ),
        style = MaterialTheme.typography.titleMedium,
        color = categoryColor.titleColor,
        modifier = Modifier.weight(1f)
    )
    ...
    SelectableTagChip(
        fact = fact,
        isEditMode = isEditMode,
        isSelected = selectedFactIds.contains(fact.id),
        searchQuery = searchQuery,
        categoryColor = categoryColor,
        highlightStyle = highlightStyle,
        onClick = { onFactClick(fact.id) },
        onLongClick = { onFactLongClick(fact.id) },
        onToggleSelection = { onToggleFactSelection(fact.id) }
    )
}
```

```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/contact/persona/SelectableTagChip.kt
@Composable
fun SelectableTagChip(
    fact: Fact,
    isEditMode: Boolean,
    isSelected: Boolean,
    searchQuery: String,
    categoryColor: ComposeCategoryColor,
    highlightStyle: SpanStyle,
    onClick: () -> Unit,
    onLongClick: () -> Unit,
    onToggleSelection: () -> Unit,
    modifier: Modifier = Modifier
) {
    ...
    Text(
        text = buildHighlightedText(
            text = fact.value,
            query = searchQuery,
            highlightStyle = highlightStyle
        ),
        style = MaterialTheme.typography.bodyMedium,
        color = textColor
    )
}
```

---

### å˜æ›´ 15ï¼šModernPersonaTab æœç´¢é«˜äº®ä¸æ— ç»“æœæç¤º

**ä¿®æ”¹åŸå› **ï¼š
1. ModernPersonaTab æœç´¢ä»…è¿‡æ»¤åˆ—è¡¨ï¼Œæ ‡ç­¾æ–‡æœ¬æ²¡æœ‰é«˜äº®åé¦ˆã€‚
2. æœç´¢æ— ç»“æœæ—¶ä»å±•ç¤ºâ€œæš‚æ— æ ‡ç­¾â€ï¼Œä¸å®é™…è¯­ä¹‰ä¸ç¬¦ã€‚
3. éœ€è¦ä¸å…¶ä»–æœç´¢åœºæ™¯ä¿æŒä¸€è‡´ä½“éªŒã€‚

**å½±å“åˆ†æ**ï¼š
- ä»…å½±å“ ModernPersonaTab ç»„ä»¶æ˜¾ç¤ºå±‚ã€‚
- æœç´¢è¿‡æ»¤é€»è¾‘ä¿æŒä¸å˜ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä»…ä¿ç•™è¿‡æ»¤ï¼Œä¸åŠ é«˜äº®ä¸æ— ç»“æœæç¤ºã€‚
- ä»…æ–°å¢æ— ç»“æœæç¤ºï¼Œå¿½ç•¥é«˜äº®ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/persona/ModernPersonaTab.kt
val filteredCategories = categories.map { category ->
    val filteredTags = if (searchQuery.isBlank()) {
        category.tags
    } else {
        category.tags.filter { it.contains(searchQuery, ignoreCase = true) }
    }
    category.copy(tags = filteredTags)
}.filter { it.tags.isNotEmpty() || searchQuery.isBlank() }

if (filteredCategories.isEmpty() || filteredCategories.all { it.tags.isEmpty() }) {
    EmptyPersonaPlaceholder(modifier = Modifier.weight(1f))
} else {
    LazyColumn { ... }
}

@Composable
fun ModernFolderCard(
    category: TagCategory,
    tags: List<String>,
    isExpanded: Boolean,
    onToggle: () -> Unit,
    onAddTag: () -> Unit,
    onTagClick: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    ...
    tags.forEach { tag ->
        MorandiTagChip(
            text = tag,
            category = category,
            onClick = { onTagClick(tag) }
        )
    }
}

@Composable
fun MorandiTagChip(
    text: String,
    category: TagCategory,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val colors = MorandiTagColors.getColors(category)
    Text(
        text = text,
        fontSize = 14.sp,
        color = colors.textColor,
        modifier = modifier
            .clip(RoundedCornerShape(16.dp))
            .background(colors.backgroundColor)
            .clickable(onClick = onClick)
            .padding(horizontal = 14.dp, vertical = 8.dp)
    )
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/persona/ModernPersonaTab.kt
val filteredCategories = categories.map { category ->
    val filteredTags = if (searchQuery.isBlank()) {
        category.tags
    } else {
        category.tags.filter { it.contains(searchQuery, ignoreCase = true) }
    }
    category.copy(tags = filteredTags)
}.filter { it.tags.isNotEmpty() || searchQuery.isBlank() }

val hasSearchQuery = searchQuery.isNotBlank()
if (filteredCategories.isEmpty() || filteredCategories.all { it.tags.isEmpty() }) {
    if (hasSearchQuery) {
        EmptyPersonaSearchResult(modifier = Modifier.weight(1f))
    } else {
        EmptyPersonaPlaceholder(modifier = Modifier.weight(1f))
    }
} else {
    LazyColumn { ... }
}

@Composable
fun ModernFolderCard(
    category: TagCategory,
    tags: List<String>,
    isExpanded: Boolean,
    searchQuery: String,
    onToggle: () -> Unit,
    onAddTag: () -> Unit,
    onTagClick: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    ...
    tags.forEach { tag ->
        MorandiTagChip(
            text = tag,
            category = category,
            highlightQuery = searchQuery,
            onClick = { onTagClick(tag) }
        )
    }
}

@Composable
fun MorandiTagChip(
    text: String,
    category: TagCategory,
    onClick: () -> Unit,
    highlightQuery: String = "",
    modifier: Modifier = Modifier
) {
    val colors = MorandiTagColors.getColors(category)
    val highlightStyle = createSearchHighlightStyle(
        isDarkTheme = isSystemInDarkTheme(),
        baseColor = colors.textColor
    )
    Text(
        text = buildHighlightedText(
            text = text,
            query = highlightQuery,
            highlightStyle = highlightStyle
        ),
        fontSize = 14.sp,
        color = colors.textColor,
        modifier = modifier
            .clip(RoundedCornerShape(16.dp))
            .background(colors.backgroundColor)
            .clickable(onClick = onClick)
            .padding(horizontal = 14.dp, vertical = 8.dp)
    )
}
```

---

### å˜æ›´ 16ï¼šModernPersonaTab åˆ†ç±»åç§°æœç´¢åŒ¹é…ä¸æ ‡é¢˜é«˜äº®

**ä¿®æ”¹åŸå› **ï¼š
1. ModernPersonaTab æç¤ºâ€œæœç´¢æ ‡ç­¾æˆ–åˆ†ç±»â€ï¼Œä½†åŸé€»è¾‘ä»…åŒ¹é…æ ‡ç­¾æ–‡æœ¬ã€‚
2. åˆ†ç±»åç§°ä¸å‚ä¸åŒ¹é…ä¼šé€ æˆâ€œæœ‰åˆ†ç±»ä½†æœä¸åˆ°â€çš„ä½“éªŒè½å·®ã€‚
3. åˆ†ç±»æ ‡é¢˜ç¼ºå°‘é«˜äº®åé¦ˆï¼Œä¸åˆ©äºå®šä½å‘½ä¸­ä½ç½®ã€‚

**å½±å“åˆ†æ**ï¼š
- ä»…å½±å“ ModernPersonaTab çš„è¿‡æ»¤é€»è¾‘ä¸åˆ†ç±»æ ‡é¢˜æ¸²æŸ“ã€‚
- æ ‡ç­¾è¿‡æ»¤é€»è¾‘ä¿æŒåŸæ ·ï¼Œæ–°å¢åˆ†ç±»å‘½ä¸­ä¿ç•™æ ‡ç­¾å†…å®¹ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ç»§ç»­åªåŒ¹é…æ ‡ç­¾ï¼Œå¿½ç•¥åˆ†ç±»åç§°ï¼ˆä¸æç¤ºæ–‡æ¡ˆä¸ä¸€è‡´ï¼‰ã€‚
- åˆ†ç±»å‘½ä¸­æ—¶ä»è¿‡æ»¤æ ‡ç­¾ï¼ˆå¯èƒ½å‡ºç°ç©ºåˆ†ç±»ï¼‰ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/persona/ModernPersonaTab.kt
val filteredCategories = categories.map { category ->
    val filteredTags = if (searchQuery.isBlank()) {
        category.tags
    } else {
        category.tags.filter { it.contains(searchQuery, ignoreCase = true) }
    }
    category.copy(tags = filteredTags)
}.filter { it.tags.isNotEmpty() || searchQuery.isBlank() }

Text(
    text = category.displayName,
    fontSize = 17.sp,
    fontWeight = FontWeight.SemiBold,
    color = iOSTextPrimary
)
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/persona/ModernPersonaTab.kt
val hasSearchQuery = searchQuery.isNotBlank()
val filteredCategories = categories.mapNotNull { category ->
    val categoryMatches = hasSearchQuery &&
        category.category.displayName.contains(searchQuery, ignoreCase = true)
    val filteredTags = when {
        !hasSearchQuery -> category.tags
        categoryMatches -> category.tags
        else -> category.tags.filter { it.contains(searchQuery, ignoreCase = true) }
    }
    if (!hasSearchQuery || categoryMatches || filteredTags.isNotEmpty()) {
        category.copy(tags = filteredTags)
    } else {
        null
    }
}

val highlightStyle = createSearchHighlightStyle(
    isDarkTheme = isSystemInDarkTheme(),
    baseColor = style.iconBackground
)
Text(
    text = buildHighlightedText(
        text = category.displayName,
        query = searchQuery,
        highlightStyle = highlightStyle
    ),
    fontSize = 17.sp,
    fontWeight = FontWeight.SemiBold,
    color = iOSTextPrimary
)
```

---

### å˜æ›´ 17ï¼šModernPersonaTab æœç´¢è‡ªåŠ¨å±•å¼€

**ä¿®æ”¹åŸå› **ï¼š
1. æœç´¢æ¨¡å¼ä¸‹è‹¥åˆ†ç±»è¢«æŠ˜å ï¼Œå‘½ä¸­æ ‡ç­¾ä¼šè¢«éšè—ï¼Œæœç´¢ä½“éªŒä¸å®Œæ•´ã€‚
2. æœç´¢é˜¶æ®µä¼˜å…ˆå±•ç¤ºç»“æœå¯è§æ€§ã€‚

**å½±å“åˆ†æ**ï¼š
- ä»…å½±å“ ModernPersonaTab æœç´¢æ¨¡å¼ä¸‹çš„å±•å¼€è¡Œä¸ºã€‚
- æœç´¢ç»“æŸåä»ä¿ç•™ç”¨æˆ·åŸæœ‰å±•å¼€çŠ¶æ€ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä¿æŒæŠ˜å çŠ¶æ€ï¼Œå…è®¸ç”¨æˆ·æ‰‹åŠ¨å±•å¼€ï¼ˆå‘½ä¸­ç»“æœå¯è§æ€§å·®ï¼‰ã€‚
- ä»…è‡ªåŠ¨å±•å¼€å‘½ä¸­åˆ†ç±»ï¼ˆéœ€é¢å¤–åŒ¹é…é€»è¾‘ï¼‰ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/persona/ModernPersonaTab.kt
ModernFolderCard(
    category = categoryData.category,
    tags = categoryData.tags,
    isExpanded = categoryData.category in expandedCategories,
    searchQuery = searchQuery,
    onToggle = { ... },
    onAddTag = { ... },
    onTagClick = { ... }
)
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/persona/ModernPersonaTab.kt
ModernFolderCard(
    category = categoryData.category,
    tags = categoryData.tags,
    isExpanded = hasSearchQuery || categoryData.category in expandedCategories,
    searchQuery = searchQuery,
    onToggle = { ... },
    onAddTag = { ... },
    onTagClick = { ... }
)
```

---

### å˜æ›´ 18ï¼šModernPersonaTab æ— ç»“æœæç¤ºæ˜¾ç¤ºå…³é”®è¯

**ä¿®æ”¹åŸå› **ï¼š
1. æ— ç»“æœæç¤ºæœªå±•ç¤ºå…³é”®è¯ï¼Œåé¦ˆä¸å¤Ÿæ˜ç¡®ã€‚
2. å…¶ä»–æœç´¢åœºæ™¯æ™®éä¼šæ˜¾ç¤ºæŸ¥è¯¢å†…å®¹ï¼Œä¿æŒä¸€è‡´æ€§æ›´å¥½ã€‚

**å½±å“åˆ†æ**ï¼š
- ä»…å½±å“ ModernPersonaTab çš„æ— ç»“æœå ä½æ–‡æ¡ˆã€‚
- ä¸å½±å“è¿‡æ»¤é€»è¾‘ã€‚

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä¿æŒé€šç”¨æç¤ºæ–‡æœ¬ã€‚
- æ˜¾ç¤ºå…³é”®è¯ä½†ä¸é«˜äº®ã€‚

**ä»£ç å˜æ›´**ï¼š

ä¿®æ”¹å‰ï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/persona/ModernPersonaTab.kt
if (hasSearchQuery) {
    EmptyPersonaSearchResult(modifier = Modifier.weight(1f))
}

@Composable
private fun EmptyPersonaSearchResult(modifier: Modifier = Modifier) {
    ...
    Text(
        text = "æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„æ ‡ç­¾",
        fontSize = 17.sp,
        color = iOSTextPrimary
    )
}
```

ä¿®æ”¹åï¼š
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/component/persona/ModernPersonaTab.kt
if (hasSearchQuery) {
    EmptyPersonaSearchResult(
        query = searchQuery,
        modifier = Modifier.weight(1f)
    )
}

@Composable
private fun EmptyPersonaSearchResult(
    query: String,
    modifier: Modifier = Modifier
) {
    val highlightStyle = createSearchHighlightStyle(
        isDarkTheme = isSystemInDarkTheme(),
        baseColor = iOSBlue
    )
    ...
    Text(
        text = buildHighlightedText(
            text = "æœªæ‰¾åˆ° \"$query\"",
            query = query,
            highlightStyle = highlightStyle
        ),
        fontSize = 17.sp,
        color = iOSTextPrimary
    )
}
```

---

## æµ‹è¯•æƒ…å†µ

- å•å…ƒæµ‹è¯•: è¿è¡Œ `:presentation:testDebugUnitTest --tests "com.empathy.ai.presentation.util.TextHighlightTest"` âœ…ï¼ˆæ–°å¢æ”¹åŠ¨åå†æ¬¡è¿è¡Œé€šè¿‡ï¼›ModernPersonaTab è‡ªåŠ¨å±•å¼€ä¸æ— ç»“æœæç¤ºæ”¹åŠ¨åæœªé‡æ–°æ‰§è¡Œï¼›å­˜åœ¨æ—¢æœ‰æ„å»º/æµ‹è¯•å‘Šè­¦ï¼ŒåŒ…æ‹¬ Kapt å…¼å®¹æç¤ºä¸å¤šä¸ª deprecationsï¼‰
- UI é¢„è§ˆ: æœªæ‰§è¡Œæ‰‹åŠ¨é¢„è§ˆéªŒè¯ã€‚
- å¤‡æ³¨: æœåŠ¡å•†/æ ‡ç­¾/ç”»åƒ/PersonaTabV2/ModernPersonaTab é«˜äº®è§†è§‰æ•ˆæœã€æ ‡ç­¾æœç´¢æ ä¸æ— ç»“æœæç¤ºã€æ·±è‰²æ¨¡å¼å¯¹æ¯”åº¦ã€ModernPersonaTab åˆ†ç±»åŒ¹é…/æœç´¢è‡ªåŠ¨å±•å¼€/å…³é”®è¯æç¤ºå‡æœªéªŒè¯ã€‚

---

## æˆæœæ¸…å•

### A ç±»ï¼ˆæ–‡æ¡£/æŠ¥å‘Šï¼‰
- æœ¬æŠ¥å‘Š: `æ–‡æ¡£/å¼€å‘æ–‡æ¡£/MA/FREE/FREE-20260112-contact-search-highlight.md`
- å†³ç­–æ—¥å¿—: `DECISION_JOURNAL.md`

### B ç±»ï¼ˆæµ‹è¯•ï¼‰
- `presentation/src/test/kotlin/com/empathy/ai/presentation/util/TextHighlightTest.kt`

### C ç±»ï¼ˆåŠŸèƒ½æ”¹åŠ¨ï¼‰
- æ–°å¢é€šç”¨é«˜äº®å·¥å…·å‡½æ•° `TextHighlight.kt`ã€‚
- è”ç³»äººåˆ—è¡¨æœç´¢ç»“æœé«˜äº®ã€‚
- AI å†›å¸ˆè”ç³»äººé€‰æ‹©é¡µæœç´¢é«˜äº®ã€‚
- AI é…ç½®æœåŠ¡å•†åˆ—è¡¨æœç´¢é«˜äº®ï¼ˆ`IOSProviderCard`/`AiConfigScreen`ï¼‰ã€‚
- æ ‡ç­¾ç®¡ç†åˆ—è¡¨æœç´¢é«˜äº®ï¼ˆ`TagChip`/`BrainTagScreen`ï¼‰ã€‚
- æ ‡ç­¾ç®¡ç†æœç´¢å…¥å£ï¼ˆ`TagSearchBar`/`BrainTagScreen`ï¼‰ã€‚
- æ ‡ç­¾æœç´¢æ— ç»“æœæç¤ºï¼ˆ`EmptyView.NoResults`ï¼‰ã€‚
- AI é…ç½®æœç´¢æ— ç»“æœæç¤ºï¼ˆ`EmptyView.NoResults`ï¼‰ã€‚
- æ ‡ç­¾æœç´¢æ  BackHandler å…³é—­ã€‚
- è”ç³»äººç”»åƒ PersonaTab æœç´¢é«˜äº®ï¼ˆç±»åˆ«æ ‡é¢˜ä¸æ ‡ç­¾å€¼ï¼‰ã€‚
- PersonaTabV2 æœç´¢é«˜äº®ï¼ˆåˆ†ç±»æ ‡é¢˜ä¸æ ‡ç­¾å€¼ï¼‰ã€‚
- ModernPersonaTab æœç´¢é«˜äº®ä¸æ— ç»“æœæç¤ºã€‚
- ModernPersonaTab åˆ†ç±»æœç´¢åŒ¹é…ä¸æ ‡é¢˜é«˜äº®ã€‚
- ModernPersonaTab æœç´¢è‡ªåŠ¨å±•å¼€ï¼ˆä¿è¯å‘½ä¸­ç»“æœå¯è§ï¼‰ã€‚
- ModernPersonaTab æ— ç»“æœæç¤ºæ˜¾ç¤ºå…³é”®è¯å¹¶é«˜äº®ã€‚
- SelectableTagChip å¤ç”¨é€šç”¨é«˜äº®ã€‚
- æŠ½å–é«˜äº®é€æ˜åº¦ä¸æ ·å¼ç”Ÿæˆå‡½æ•°ï¼ˆ`searchHighlightAlpha`/`createSearchHighlightStyle`ï¼‰ã€‚

### D ç±»ï¼ˆé‡æ„/ç»“æ„è°ƒæ•´ï¼‰
- å°† SelectableTagChip å†…éƒ¨é«˜äº®é€»è¾‘ç§»è‡³é€šç”¨å·¥å…·å‡½æ•°ã€‚

---

## åˆå¹¶å»ºè®®

**å»ºè®®çŠ¶æ€ï¼šğŸ“–ä»…å‚è€ƒ**

ç†ç”±ï¼š
1. ä»…é’ˆå¯¹ç‰¹å®šå•æµ‹æ‰§è¡ŒéªŒè¯ï¼Œæœªè¦†ç›– UI è§†è§‰éªŒè¯ã€‚
2. æ·±è‰²æ¨¡å¼ä¸ä¸åŒå­—ä½“å¤§å°ä¸‹çš„é«˜äº®å¯¹æ¯”åº¦æœªéªŒè¯ã€‚
3. æ–°å¢æœåŠ¡å•†/æ ‡ç­¾åˆ—è¡¨é«˜äº®æœªè¿›è¡Œé¢„è§ˆç¡®è®¤ã€‚
4. æ ‡ç­¾ç®¡ç†æœç´¢æ æ–°å¢æœªè¿›è¡Œäº¤äº’éªŒè¯ã€‚
5. æ ‡ç­¾æœç´¢æ— ç»“æœæç¤ºæœªè¿›è¡Œé¢„è§ˆç¡®è®¤ã€‚
6. é€‚åˆä½œä¸º UX æ–¹å‘æ¢ç´¢çš„å‚è€ƒå®ç°ï¼Œå»ºè®®åœ¨äººå·¥ä½“éªŒç¡®è®¤åå†åˆå¹¶ã€‚

---

## åç»­å·¥ä½œ

1. åœ¨æ·±è‰²æ¨¡å¼ä¸ä¸åŒå­—ä½“ç¼©æ”¾ä¸‹éªŒè¯é«˜äº®å¯è¯»æ€§ã€‚
2. åœ¨ AI é…ç½®ã€æ ‡ç­¾ç®¡ç†ã€è”ç³»äººç”»åƒã€PersonaTabV2ã€ModernPersonaTab é¡µé¢éªŒè¯æœç´¢é«˜äº®çš„å¯¹æ¯”åº¦ä¸å¯è¯»æ€§ã€‚
3. éªŒè¯æ ‡ç­¾ç®¡ç†é¡µæœç´¢æ å±•å¼€/å…³é—­äº¤äº’æ˜¯å¦ç¬¦åˆé¢„æœŸã€‚
4. éªŒè¯æ ‡ç­¾æœç´¢æ— ç»“æœæç¤ºçš„è§†è§‰ä¸å¸ƒå±€è¡¨ç°ã€‚
5. éªŒè¯ ModernPersonaTab åˆ†ç±»æœç´¢åŒ¹é…æ˜¯å¦ç¬¦åˆé¢„æœŸã€‚
6. éªŒè¯ ModernPersonaTab æœç´¢æ—¶åˆ†ç±»è‡ªåŠ¨å±•å¼€æ˜¯å¦ç¬¦åˆé¢„æœŸã€‚
7. éªŒè¯ ModernPersonaTab æ— ç»“æœæç¤ºæ˜¯å¦æ˜¾ç¤ºå…³é”®è¯ä¸”é«˜äº®æ­£ç¡®ã€‚
8. è¯„ä¼°æ˜¯å¦éœ€è¦åŠ å…¥â€œåŒ¹é…æ•°é‡æç¤ºâ€ï¼Œå¹¶ä¸äº§å“ç¡®è®¤å¸ƒå±€ã€‚
9. è‹¥åˆå¹¶ï¼Œè€ƒè™‘è¡¥å……æ›´å¤æ‚çš„å¤šè¯­ç§/è¡¨æƒ…ç¬¦å·åŒ¹é…æµ‹è¯•ã€‚

---

## æ¢ç´¢æ—¥å¿—

| æ—¶é—´ | å°è¯•å†…å®¹ | ç»“æœ |
|------|----------|------|
| 20:36 | å¤åˆ¶é«˜äº®é€»è¾‘åˆ° ContactListItem | âŒ æ”¾å¼ƒï¼ˆé‡å¤å®ç°ï¼‰ |
| 20:39 | æŠ½å– TextHighlight å·¥å…·å‡½æ•° | âœ… é‡‡ç”¨ |
| 20:41 | è”ç³»äººåˆ—è¡¨æœç´¢é«˜äº® | âœ… å®Œæˆ |
| 20:42 | è”ç³»äººé€‰æ‹©é¡µæœç´¢é«˜äº® | âœ… å®Œæˆ |
| 20:43 | æœç´¢ç»“æœè®¡æ•°æç¤º | âŒ æ”¾å¼ƒï¼ˆéœ€é¢å¤–è®¾è®¡ç¡®è®¤ï¼‰ |
| 20:54 | ç¼–å†™ TextHighlightTest | âœ… å®Œæˆ |
| 20:56 | è¿è¡Œ `:presentation:test --tests` | âŒ å‚æ•°ä¸æ”¯æŒ |
| 20:57 | è¿è¡Œ `:presentation:testDebugUnitTest` | âŒ è¶…æ—¶ |
| 21:00 | é‡è¯• `:presentation:testDebugUnitTest` | âœ… é€šè¿‡ |
| 21:03 | æ·±è‰²æ¨¡å¼é«˜äº®é€æ˜åº¦è°ƒæ•´ | âœ… å®Œæˆ |
| 21:08 | å†æ¬¡è¿è¡Œ `:presentation:testDebugUnitTest` | âŒ è¶…æ—¶ |
| 21:10 | é‡è¯• `:presentation:testDebugUnitTest` | âœ… é€šè¿‡ |
| 21:25 | æŠ½å–é«˜äº®æ ·å¼å‡½æ•° | âœ… å®Œæˆ |
| 21:29 | è¿è¡Œ `:presentation:testDebugUnitTest`ï¼ˆæ›´æ–°æ ·å¼ï¼‰ | âœ… é€šè¿‡ |
| 21:46 | æ‰©å±•é«˜äº®åˆ° AI é…ç½®æœåŠ¡å•†åˆ—è¡¨ | âœ… å®Œæˆ |
| 21:49 | æ‰©å±•é«˜äº®åˆ°æ ‡ç­¾ç®¡ç†åˆ—è¡¨ | âœ… å®Œæˆ |
| 22:01 | è¡¥é½æ ‡ç­¾ç®¡ç†æœç´¢å…¥å£ | âœ… å®Œæˆ |
| 22:06 | æ ‡ç­¾æœç´¢æ— ç»“æœæç¤º | âœ… å®Œæˆ |
| 22:08 | è¿è¡Œ `:presentation:testDebugUnitTest` | âŒ è¶…æ—¶ |
| 22:11 | é‡è¯• `:presentation:testDebugUnitTest` | âœ… é€šè¿‡ |
| 22:15 | AI é…ç½®æœç´¢æ— ç»“æœæç¤º | âœ… å®Œæˆ |
| 22:15 | BackHandler å…³é—­æ ‡ç­¾æœç´¢æ  | âœ… å®Œæˆ |
| 22:17 | è¿è¡Œ `:presentation:testDebugUnitTest`ï¼ˆæ–°æ”¹åŠ¨ï¼‰ | âœ… é€šè¿‡ |
| 22:32 | PersonaTab æœç´¢é«˜äº® | âœ… å®Œæˆ |
| 22:43 | PersonaTabV2 æœç´¢é«˜äº® | âœ… å®Œæˆ |
| 22:51 | ModernPersonaTab æœç´¢é«˜äº®ä¸æ— ç»“æœæç¤º | âœ… å®Œæˆ |
| 22:57 | ModernPersonaTab åˆ†ç±»æœç´¢åŒ¹é…ä¸æ ‡é¢˜é«˜äº® | âœ… å®Œæˆ |
| 23:05 | è¿è¡Œ `:presentation:testDebugUnitTest`ï¼ˆTextHighlightTestï¼‰ | âœ… é€šè¿‡ |
| 23:11 | ModernPersonaTab æœç´¢è‡ªåŠ¨å±•å¼€ | âœ… å®Œæˆ |
| 23:14 | ModernPersonaTab æ— ç»“æœæç¤ºæ˜¾ç¤ºå…³é”®è¯ | âœ… å®Œæˆ |

---

## æŠ¥å‘Šè´¨é‡è‡ªæ£€

### å­—æ•°æ£€æŸ¥
- [x] æ€»å­—æ•°è¾¾åˆ°æœ€ä½è¦æ±‚ï¼ˆçº¦ 3200+ å­—ï¼Œè¦æ±‚ 2000 å­—ï¼‰
- [x] ä»£ç è¡Œæ•°è¾¾åˆ°æœ€ä½è¦æ±‚ï¼ˆçº¦ 240+ è¡Œï¼Œè¦æ±‚ 50 è¡Œï¼‰

### å†…å®¹å®Œæ•´æ€§
- [x] æ‰€æœ‰å¿…é¡»ç« èŠ‚éƒ½å·²å¡«å†™
- [x] æ¯ä¸ªä»£ç å˜æ›´éƒ½åŒ…å«ä¿®æ”¹å‰+ä¿®æ”¹å
- [x] æ¢ç´¢è¿‡ç¨‹è®°å½•äº†å¤±è´¥å°è¯•

### è‡ªåŒ…å«æ£€æŸ¥
- [x] åˆ é™¤åˆ†æ”¯åï¼Œä»…å‡­æŠ¥å‘Šå¯ç†è§£å…¨éƒ¨å˜æ›´
- [x] ä»£ç ç‰‡æ®µå‡ä¸ºå®Œæ•´å‡½æ•°çº§åˆ«
- [x] æ‰€æœ‰ä»£ç ç‰‡æ®µæ ‡æ³¨æ–‡ä»¶è·¯å¾„

### å¯æ“ä½œæ€§æ£€æŸ¥
- [x] æˆæœæ¸…å•æŒ‰ A/B/C/D åˆ†ç±»
- [x] åˆå¹¶å»ºè®®æ˜ç¡®ç»™å‡ºç†ç”±
- [x] åç»­å·¥ä½œåŒ…å«å…·ä½“è¡ŒåŠ¨é¡¹
