
# 自由探索报告：AI军师会话草稿自动保存与恢复

## 基本信息

| 项目 | 内容 |
|------|------|
| 日期 | 2026-01-20 |
| 分支 | explore/free-20260119 |
| 状态 | ✅ 可合并（草稿恢复提示与清除入口已补齐；单测通过；仍需人工 UI 回归） |
| 探索者 | free-explorer (Codex) |
| 关联文档 | DECISION_JOURNAL.md；TE-00077-AI军师草稿自动保存测试用例.md |

---

## 探索主题

### 探索方向
聚焦 AI 军师对话体验的“中断成本”问题：输入草稿在会话/联系人切换时容易丢失，导致用户重复输入、上下文被打断。

### 创意来源
1. AI 军师输入框仅保存在 ViewModel 状态中，缺少持久化恢复能力。  
2. 其他模块已有“草稿保护”思路，但 AI 军师缺少一致体验。  
3. 会话/联系人切换是高频操作，草稿恢复与提示能直接提升用户信任感。

---

## 探索目标
本次探索目标是在不依赖历史 PRD 的前提下，为 AI 军师输入流程提供“会话级草稿自动保存与恢复”。具体目标包括：在用户输入过程中以低频持久化方式保存草稿，避免频繁写入；在会话切换或重新进入时恢复草稿，并在发送消息或清空输入后自动清理；在恢复草稿时给出可感知提示；在设置页提供“清除草稿”入口以提升可控性。所有实现需要遵循 Clean Architecture 依赖方向，并优先复用既有加密偏好存储方案。最终还要求补齐单元测试与测试用例文档，以便后续验证。

---

## 探索过程（含失败尝试）

### 尝试 1：仅使用内存状态保存草稿（未采用）
最初考虑在 `AiAdvisorChatViewModel` 中用内存字段保存草稿，不触及持久化层。该方案实现简单、风险小，但无法覆盖进程被系统回收或用户手动结束应用后的场景。对于高频对话场景，这种“偶尔有效”的体验会导致更大困惑，因此放弃。

### 尝试 2：仅保存“最后一次草稿”（未采用）
第二个思路是使用单一字段保存“最后一次输入”。虽然实现成本低，但多会话场景会导致草稿串会话：会话 A 的草稿会被会话 B 覆盖并错误恢复。此方案会误导用户，风险高，因此放弃。

### 尝试 3：按会话维度持久化草稿（采用）
最终方案是基于 `AiAdvisorPreferences` 使用加密偏好存储草稿，以 `sessionId` 为 key 保存，并引入索引列表与最大数量限制（避免存储膨胀）。在输入时使用 Debounce 写入，切换会话前强制 flush，发送消息后清理草稿。该方案保证了会话隔离与数据安全，且符合项目既有技术栈。

### 尝试 4：恢复提示与清除入口（采用）
草稿恢复完成后，我发现用户可能无法感知“草稿被恢复”。因此增加“已恢复上次草稿”的提示条，并提供点击关闭能力。同时在设置页数据管理中增加“清除 AI 军师草稿”入口，并添加确认弹窗，保障操作可控。

### 失败记录（测试命令探索）
在测试阶段，`./gradlew.bat :domain:testDebugUnitTest` 任务不存在，导致失败；Presentation 模块的 `:presentation:test --tests` 也不支持参数，需使用 `testDebugUnitTest`。这些失败已记录并反映到测试说明中。

---

## 实验结果

### 成功的实验
| 实验 | 结果 | 价值评估 |
|------|------|----------|
| 会话级草稿恢复 | 切换会话后输入框恢复正确草稿 | 高 |
| 发送后清除草稿 | 发送消息后草稿被清理 | 中 |
| 草稿 Debounce 写入 | 避免每字符写入偏好 | 中 |
| 草稿恢复提示 | 恢复草稿时展示提示条 | 中 |
| 设置页清除草稿 | 提供可控清除入口 | 中 |
| 单元测试覆盖 | 新增草稿提示/清除入口用例 | 中 |
| 删除会话清理草稿 | 会话删除时同步清理草稿 | 低 |
| 删除联系人清理草稿 | 联系人删除时同步清理草稿 | 低 |
| 清除所有设置清理偏好 | “清除所有设置”同步清理偏好 | 低 |

### 失败的实验
| 实验 | 失败原因 | 教训 |
|------|----------|------|
| `:domain:testDebugUnitTest` | 任务不存在 | 先用 `gradlew tasks` 或参考模块测试说明 |
| `:presentation:test --tests` | 任务不支持参数 | 使用 `testDebugUnitTest` 进行过滤 |

---

## 发现与结论
草稿持久化显著降低了 AI 军师的输入中断成本。通过会话级隔离与加密存储，用户可在切换会话或联系人后恢复未发送内容，不再需要重复输入。为了避免覆盖用户最新输入，恢复逻辑只在输入框为空时生效；并通过索引与上限限制控制存储膨胀。新增“草稿恢复提示”提高了可感知性，而设置页清除入口为用户提供了主动清理能力。测试表明相关逻辑稳定运行，但仍建议进行 UI 回归验证提示显示与关闭时机。

---
## 代码变更

### 1) 扩展偏好仓库接口（草稿 + 清除全部）

**修改前：**
```kotlin
// file: domain/src/main/kotlin/com/empathy/ai/domain/repository/AiAdvisorPreferencesRepository.kt
interface AiAdvisorPreferencesRepository {

    fun getLastContactId(): String?

    fun setLastContactId(contactId: String)

    fun getLastSessionId(): String?

    fun setLastSessionId(sessionId: String?)

    fun clear()
}
```

**修改后：**
```kotlin
// file: domain/src/main/kotlin/com/empathy/ai/domain/repository/AiAdvisorPreferencesRepository.kt
interface AiAdvisorPreferencesRepository {

    fun getLastContactId(): String?

    fun setLastContactId(contactId: String)

    fun getLastSessionId(): String?

    fun setLastSessionId(sessionId: String?)

    fun getDraft(sessionId: String): String?

    fun setDraft(sessionId: String, draft: String)

    fun clearDraft(sessionId: String)

    fun clearAllDrafts()

    fun clear()
}
```

**修改原因**：
1. 草稿存储属于偏好类数据，扩展现有接口能复用加密存储与 DI 绑定。  
2. `get/set/clearDraft` 提供会话级草稿语义，避免 ViewModel 直接操作存储。  
3. `clearAllDrafts` 为设置页清除入口提供统一 API，避免绕过架构层。  

**影响分析**：  
- 接口扩展需要同步实现类与测试构造，但不会影响运行时稳定性。  
- 新增方法仅在调用时触发，不改变现有行为，风险低。  

**替代方案**：  
- 新建独立 `DraftRepository`（会增加 DI 与类数量，探索成本偏高）。  

---
### 2) 偏好存储实现扩展草稿能力

**修改前：**
```kotlin
// file: data/src/main/kotlin/com/empathy/ai/data/local/AiAdvisorPreferences.kt
@Singleton
class AiAdvisorPreferences @Inject constructor(
    @ApplicationContext private val context: Context
) : AiAdvisorPreferencesRepository {
    companion object {
        private const val PREFS_NAME = "ai_advisor_preferences"
        private const val KEY_LAST_CONTACT_ID = "last_contact_id"
        private const val KEY_LAST_SESSION_ID = "last_session_id"
    }

    private val masterKey by lazy {
        MasterKey.Builder(context)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build()
    }

    private val prefs by lazy {
        EncryptedSharedPreferences.create(
            context,
            PREFS_NAME,
            masterKey,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
    }

    override fun getLastContactId(): String? {
        return prefs.getString(KEY_LAST_CONTACT_ID, null)
    }

    override fun setLastContactId(contactId: String) {
        prefs.edit().putString(KEY_LAST_CONTACT_ID, contactId).apply()
    }

    override fun getLastSessionId(): String? {
        return prefs.getString(KEY_LAST_SESSION_ID, null)
    }

    override fun setLastSessionId(sessionId: String?) {
        if (sessionId != null) {
            prefs.edit().putString(KEY_LAST_SESSION_ID, sessionId).apply()
        } else {
            prefs.edit().remove(KEY_LAST_SESSION_ID).apply()
        }
    }

    override fun clear() {
        prefs.edit().clear().apply()
    }
}
```

**修改后：**
```kotlin
// file: data/src/main/kotlin/com/empathy/ai/data/local/AiAdvisorPreferences.kt
@Singleton
class AiAdvisorPreferences @Inject constructor(
    @ApplicationContext private val context: Context
) : AiAdvisorPreferencesRepository {
    companion object {
        private const val PREFS_NAME = "ai_advisor_preferences"
        private const val KEY_LAST_CONTACT_ID = "last_contact_id"
        private const val KEY_LAST_SESSION_ID = "last_session_id"
        private const val KEY_DRAFTS = "drafts_by_session"
        private const val KEY_DRAFT_INDEX = "draft_session_index"
        private const val MAX_DRAFT_COUNT = 12
    }

    private val masterKey by lazy {
        MasterKey.Builder(context)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build()
    }

    private val prefs by lazy {
        EncryptedSharedPreferences.create(
            context,
            PREFS_NAME,
            masterKey,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
    }

    override fun getLastContactId(): String? {
        return prefs.getString(KEY_LAST_CONTACT_ID, null)
    }

    override fun setLastContactId(contactId: String) {
        prefs.edit().putString(KEY_LAST_CONTACT_ID, contactId).apply()
    }

    override fun getLastSessionId(): String? {
        return prefs.getString(KEY_LAST_SESSION_ID, null)
    }

    override fun setLastSessionId(sessionId: String?) {
        if (sessionId != null) {
            prefs.edit().putString(KEY_LAST_SESSION_ID, sessionId).apply()
        } else {
            prefs.edit().remove(KEY_LAST_SESSION_ID).apply()
        }
    }

    override fun getDraft(sessionId: String): String? {
        if (sessionId.isBlank()) return null
        val drafts = readDrafts()
        val draft = drafts.optString(sessionId, "")
        return draft.takeIf { it.isNotBlank() }
    }

    override fun setDraft(sessionId: String, draft: String) {
        if (sessionId.isBlank()) return
        if (draft.isBlank()) {
            clearDraft(sessionId)
            return
        }

        val drafts = readDrafts()
        drafts.put(sessionId, draft)

        val updatedIndex = buildList {
            add(sessionId)
            addAll(readDraftIndex().filterNot { it == sessionId })
        }
        val prunedIndex = updatedIndex.take(MAX_DRAFT_COUNT)
        val removedIds = updatedIndex.drop(MAX_DRAFT_COUNT)
        removedIds.forEach { drafts.remove(it) }

        writeDrafts(drafts)
        writeDraftIndex(prunedIndex)
    }

    override fun clearDraft(sessionId: String) {
        if (sessionId.isBlank()) return
        val drafts = readDrafts()
        drafts.remove(sessionId)
        writeDrafts(drafts)
        writeDraftIndex(readDraftIndex().filterNot { it == sessionId })
    }

    override fun clearAllDrafts() {
        prefs.edit()
            .remove(KEY_DRAFTS)
            .remove(KEY_DRAFT_INDEX)
            .apply()
    }

    override fun clear() {
        prefs.edit().clear().apply()
    }

    private fun readDrafts(): JSONObject {
        val raw = prefs.getString(KEY_DRAFTS, null) ?: return JSONObject()
        return try {
            JSONObject(raw)
        } catch (e: Exception) {
            JSONObject()
        }
    }

    private fun writeDrafts(drafts: JSONObject) {
        prefs.edit().putString(KEY_DRAFTS, drafts.toString()).apply()
    }

    private fun readDraftIndex(): List<String> {
        val raw = prefs.getString(KEY_DRAFT_INDEX, null) ?: return emptyList()
        return try {
            val array = JSONArray(raw)
            buildList {
                for (index in 0 until array.length()) {
                    val item = array.optString(index).trim()
                    if (item.isNotBlank()) {
                        add(item)
                    }
                }
            }
        } catch (e: Exception) {
            emptyList()
        }
    }

    private fun writeDraftIndex(index: List<String>) {
        val array = JSONArray()
        index.forEach { array.put(it) }
        prefs.edit().putString(KEY_DRAFT_INDEX, array.toString()).apply()
    }
}
```

**修改原因**：  
1. 复用 EncryptedSharedPreferences，保证草稿与偏好同级加密存储。  
2. 通过 `drafts_by_session` 映射实现会话隔离，避免草稿串会话。  
3. 使用索引列表 + 上限限制，避免草稿无限增长。  
4. `clearAllDrafts` 支持设置页一键清除。  

**影响分析**：  
- JSON 解析失败时回退为空，功能降级但不崩溃。  
- 上限为 12 条，旧草稿可能被淘汰，需要文档提示。  

**替代方案**：  
- 新建 Room 表存储草稿（需要迁移脚本与更多测试，探索成本过高）。  

---
### 3) 新增草稿 UseCase（领域层）

**修改前**：无（新增文件）

**修改后：**
```kotlin
// file: domain/src/main/kotlin/com/empathy/ai/domain/usecase/GetAdvisorDraftUseCase.kt
class GetAdvisorDraftUseCase @Inject constructor(
    private val preferences: AiAdvisorPreferencesRepository
) {
    suspend operator fun invoke(sessionId: String): Result<String?> {
        return runCatching { preferences.getDraft(sessionId) }
    }
}
```

```kotlin
// file: domain/src/main/kotlin/com/empathy/ai/domain/usecase/SaveAdvisorDraftUseCase.kt
class SaveAdvisorDraftUseCase @Inject constructor(
    private val preferences: AiAdvisorPreferencesRepository
) {
    suspend operator fun invoke(sessionId: String, draft: String): Result<Unit> {
        return runCatching { preferences.setDraft(sessionId, draft) }
    }
}
```

```kotlin
// file: domain/src/main/kotlin/com/empathy/ai/domain/usecase/ClearAdvisorDraftUseCase.kt
class ClearAdvisorDraftUseCase @Inject constructor(
    private val preferences: AiAdvisorPreferencesRepository
) {
    suspend operator fun invoke(sessionId: String): Result<Unit> {
        return runCatching { preferences.clearDraft(sessionId) }
    }
}
```

```kotlin
// file: domain/src/main/kotlin/com/empathy/ai/domain/usecase/ClearAllAdvisorDraftsUseCase.kt
class ClearAllAdvisorDraftsUseCase @Inject constructor(
    private val preferences: AiAdvisorPreferencesRepository
) {
    suspend operator fun invoke(): Result<Unit> {
        return runCatching { preferences.clearAllDrafts() }
    }
}
```

```kotlin
// file: domain/src/main/kotlin/com/empathy/ai/domain/usecase/ClearAdvisorPreferencesUseCase.kt
class ClearAdvisorPreferencesUseCase @Inject constructor(
    private val preferences: AiAdvisorPreferencesRepository
) {
    suspend operator fun invoke(): Result<Unit> {
        return runCatching { preferences.clear() }
    }
}
```

**修改原因**：  
1. 通过 UseCase 封装草稿读写，保持 ViewModel 与持久化解耦。  
2. 使用 `Result` 包装异常，避免上层崩溃。  
3. 便于单元测试覆盖成功/失败路径。  
4. 为设置页清除入口提供一致的用例层调用路径。  
5. 清除偏好 UseCase 统一“清除所有设置”路径的草稿与联系人偏好清理。  

**影响分析**：  
- 新增 5 个类，依赖关系清晰，风险低。  
- 不改变现有业务逻辑，仅提供能力封装。  

**替代方案**：  
- 直接在 ViewModel 调用 Repository（削弱架构隔离，弃用）。  

---
### 4) ViewModel 草稿生命周期与提示控制

#### 4.1 构造函数与字段扩展

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
@HiltViewModel
class AiAdvisorChatViewModel @Inject constructor(
    savedStateHandle: SavedStateHandle,
    private val getContactUseCase: GetContactUseCase,
    private val getAllContactsUseCase: GetAllContactsUseCase,
    private val createAdvisorSessionUseCase: CreateAdvisorSessionUseCase,
    private val getAdvisorSessionsUseCase: GetAdvisorSessionsUseCase,
    private val getAdvisorConversationsUseCase: GetAdvisorConversationsUseCase,
    private val sendAdvisorMessageUseCase: SendAdvisorMessageUseCase,
    private val sendAdvisorMessageStreamingUseCase: SendAdvisorMessageStreamingUseCase,
    private val deleteAdvisorConversationUseCase: DeleteAdvisorConversationUseCase,
    private val aiAdvisorRepository: AiAdvisorRepository
) : ViewModel() {

    companion object {
        private const val TAG = "AiAdvisorChatViewModel"
    }

    private val contactId: String = savedStateHandle[NavRoutes.AI_ADVISOR_CHAT_ARG_ID] ?: ""

    private val _uiState = MutableStateFlow(AiAdvisorChatUiState())
    val uiState: StateFlow<AiAdvisorChatUiState> = _uiState.asStateFlow()

    private var streamingJob: Job? = null
    private var conversationsJob: Job? = null
    private var useStreamingMode: Boolean = true
}
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
@HiltViewModel
class AiAdvisorChatViewModel @Inject constructor(
    savedStateHandle: SavedStateHandle,
    private val getContactUseCase: GetContactUseCase,
    private val getAllContactsUseCase: GetAllContactsUseCase,
    private val createAdvisorSessionUseCase: CreateAdvisorSessionUseCase,
    private val getAdvisorSessionsUseCase: GetAdvisorSessionsUseCase,
    private val getAdvisorConversationsUseCase: GetAdvisorConversationsUseCase,
    private val sendAdvisorMessageUseCase: SendAdvisorMessageUseCase,
    private val sendAdvisorMessageStreamingUseCase: SendAdvisorMessageStreamingUseCase,
    private val deleteAdvisorConversationUseCase: DeleteAdvisorConversationUseCase,
    private val getAdvisorDraftUseCase: GetAdvisorDraftUseCase,
    private val saveAdvisorDraftUseCase: SaveAdvisorDraftUseCase,
    private val clearAdvisorDraftUseCase: ClearAdvisorDraftUseCase,
    private val aiAdvisorRepository: AiAdvisorRepository
) : ViewModel() {

    companion object {
        private const val TAG = "AiAdvisorChatViewModel"
        private const val DRAFT_SAVE_DEBOUNCE_MS = 350L
        private val DRAFT_RESTORED_MESSAGE_RES_ID = R.string.advisor_draft_restored_message
    }

    private val contactId: String = savedStateHandle[NavRoutes.AI_ADVISOR_CHAT_ARG_ID] ?: ""

    private val _uiState = MutableStateFlow(AiAdvisorChatUiState())
    val uiState: StateFlow<AiAdvisorChatUiState> = _uiState.asStateFlow()

    private var streamingJob: Job? = null
    private var conversationsJob: Job? = null
    private var draftSaveJob: Job? = null
    private var useStreamingMode: Boolean = true
}
```

**修改原因**：  
1. 引入草稿 UseCase，避免 ViewModel 直接操作存储。  
2. 增加 Debounce 时间常量，统一管理写入节流策略。  
3. 提示文案使用常量便于维护，并与状态字段保持一致。  

**影响分析**：  
- 构造函数新增依赖需要更新测试构造。  
- 新增字段不影响既有行为，只增强草稿能力。  

**替代方案**：  
- 草稿逻辑直接写在 ViewModel 中（可用但更难测试）。  

---
#### 4.2 输入更新与草稿持久化

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
fun updateInput(text: String) {
    _uiState.update { it.copy(inputText = text) }
}
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
fun updateInput(text: String) {
    _uiState.update { it.copy(inputText = text, draftRestoredMessageResId = null) }
    queueDraftSave(text)
}

private fun queueDraftSave(text: String) {
    val sessionId = _uiState.value.currentSessionId ?: return
    draftSaveJob?.cancel()
    draftSaveJob = viewModelScope.launch {
        kotlinx.coroutines.delay(DRAFT_SAVE_DEBOUNCE_MS)
        persistDraft(sessionId, text)
    }
}

private fun flushDraftSave() {
    val sessionId = _uiState.value.currentSessionId ?: return
    val text = _uiState.value.inputText
    draftSaveJob?.cancel()
    draftSaveJob = null
    viewModelScope.launch {
        persistDraft(sessionId, text)
    }
}

private suspend fun persistDraft(sessionId: String, text: String) {
    if (_uiState.value.currentSessionId != sessionId) return
    if (text.isBlank()) {
        clearAdvisorDraftUseCase(sessionId)
            .onFailure { error -> android.util.Log.w(TAG, "clear draft failed", error) }
    } else {
        saveAdvisorDraftUseCase(sessionId, text)
            .onFailure { error -> android.util.Log.w(TAG, "save draft failed", error) }
    }
}
```

**修改原因**：  
1. 输入变化时启动 Debounce 保存，避免频繁写入偏好。  
2. 切换会话前通过 `flushDraftSave` 确保最新输入不丢失。  
3. 输入为空时自动清除草稿，避免误恢复。  

**影响分析**：  
- 增加协程任务，但生命周期与 ViewModel 同步，风险低。  
- 保存失败仅记录日志，不影响 UI 主流程。  

**替代方案**：  
- 每次输入立即写入（简单但性能差）。  

---
#### 4.3 草稿恢复与提示

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
private fun restoreDraftForSession(sessionId: String) {
    viewModelScope.launch {
        getAdvisorDraftUseCase(sessionId)
            .onSuccess { draft ->
                _uiState.update { state ->
                    if (state.currentSessionId != sessionId) {
                        state
                    } else if (state.inputText.isNotBlank()) {
                        state
                    } else {
                        state.copy(inputText = draft.orEmpty())
                    }
                }
            }
            .onFailure { error -> android.util.Log.w(TAG, "restore draft failed", error) }
    }
}
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
private fun restoreDraftForSession(sessionId: String) {
    viewModelScope.launch {
        getAdvisorDraftUseCase(sessionId)
            .onSuccess { draft ->
                val restoredDraft = draft?.takeIf { it.isNotBlank() } ?: return@onSuccess
                var shouldScheduleDismiss = false
                _uiState.update { state ->
                    if (state.currentSessionId != sessionId) {
                        state
                    } else if (state.inputText.isNotBlank()) {
                        state
                    } else {
                        shouldScheduleDismiss = true
                        state.copy(
                            inputText = restoredDraft,
                            draftRestoredMessageResId = DRAFT_RESTORED_MESSAGE_RES_ID
                        )
                    }
                }
                if (shouldScheduleDismiss) {
                    scheduleDraftRestoredMessageAutoDismiss(sessionId)
                }
            }
            .onFailure { error -> android.util.Log.w(TAG, "restore draft failed", error) }
    }
}
```

**修改原因**：  
1. 恢复草稿时增加提示条，提升可感知性。  
2. 草稿为空时不更新 UI，避免“空提示”。  
3. 输入非空时保持现状，避免覆盖用户输入。  
4. 恢复后安排自动关闭，避免提示条长期占位。  
5. 提示文案使用资源ID，便于统一管理。  

**影响分析**：  
- 提示条展示不影响核心流程。  
- 状态更新仅在正确会话中生效，避免跨会话污染。  

**替代方案**：  
- 通过 Toast 提示（不如页面内提示稳定）。  

---

#### 4.4 提示清理入口

**修改前**：无（方法不存在）  

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
fun clearDraftRestoredMessage() {
    draftRestoredMessageJob?.cancel()
    draftRestoredMessageJob = null
    _uiState.update { it.copy(draftRestoredMessageResId = null) }
}
```

**修改原因**：  
1. UI 点击提示条后需要显式清理状态。  
2. 取消自动关闭任务，避免重复更新。  
3. 与 `clearError` 模式一致，利于维护。  

**影响分析**：  
- 只影响提示状态，不触发持久化。  

**替代方案**：  
- 自动延迟清理（可能导致用户错过提示）。  

---

#### 4.5 提示自动收起

**修改前**：无（未自动清理）  

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
private fun scheduleDraftRestoredMessageAutoDismiss(sessionId: String) {
    draftRestoredMessageJob?.cancel()
    draftRestoredMessageJob = viewModelScope.launch {
        kotlinx.coroutines.delay(DRAFT_RESTORED_AUTO_DISMISS_MS)
        _uiState.update { state ->
            if (state.currentSessionId == sessionId) {
                state.copy(draftRestoredMessageResId = null)
            } else {
                state
            }
        }
    }
}
```

**修改原因**：  
1. 避免提示条长期占用页面空间。  
2. 通过 sessionId 校验避免跨会话误清理。  

**影响分析**：  
- 自动关闭仅影响提示文案，不影响草稿数据。  

**替代方案**：  
- 仅手动关闭（提示可能常驻）。  
#### 4.5 会话切换与导航入口的草稿保护

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
fun switchSession(sessionId: String) {
    stopGeneration()

    conversationsJob?.cancel()
    conversationsJob = null

    _uiState.update {
        it.copy(
            currentSessionId = sessionId,
            conversations = emptyList(),
            streamingContent = "",
            thinkingContent = "",
            thinkingElapsedMs = 0,
            inputText = "",
            error = null,
            hasLoadedConversations = false
        )
    }
    loadConversations(sessionId)
}

fun createNewSession(forContactId: String = contactId) {
    viewModelScope.launch {
        createAdvisorSessionUseCase(forContactId).onSuccess { session ->
            _uiState.update { currentState ->
                currentState.copy(
                    sessions = listOf(session) + currentState.sessions,
                    currentSessionId = session.id,
                    isLoading = false,
                    hasLoadedConversations = false,
                    inputText = ""
                )
            }
            loadConversations(session.id)
        }.onFailure { error ->
            _uiState.update {
                it.copy(error = error.message ?: "创建会话失败")
            }
        }
    }
}
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
fun switchSession(sessionId: String) {
    stopGeneration()

    flushDraftSave()
    conversationsJob?.cancel()
    conversationsJob = null

    _uiState.update {
        it.copy(
            currentSessionId = sessionId,
            conversations = emptyList(),
            streamingContent = "",
            thinkingContent = "",
            thinkingElapsedMs = 0,
            inputText = "",
            draftRestoredMessageResId = null,
            error = null,
            hasLoadedConversations = false
        )
    }
    restoreDraftForSession(sessionId)
    loadConversations(sessionId)
}

fun createNewSession(forContactId: String = contactId) {
    flushDraftSave()
    viewModelScope.launch {
        createAdvisorSessionUseCase(forContactId).onSuccess { session ->
            _uiState.update { currentState ->
                currentState.copy(
                    sessions = listOf(session) + currentState.sessions,
                    currentSessionId = session.id,
                    isLoading = false,
                    hasLoadedConversations = false,
                    inputText = "",
                    draftRestoredMessageResId = null
                )
            }
            restoreDraftForSession(session.id)
            loadConversations(session.id)
        }.onFailure { error ->
            _uiState.update {
                it.copy(error = error.message ?: "创建会话失败")
            }
        }
    }
}
```

**修改原因**：  
1. 切换会话前先 flush 草稿，降低输入丢失概率。  
2. 切换后恢复新会话草稿，确保输入框语义正确。  
3. 清理提示状态，避免跨会话残留提示。  

**影响分析**：  
- 会话切换会触发一次额外持久化，性能影响可忽略。  
- 恢复行为仅在输入为空时生效，避免覆盖。  

**替代方案**：  
- 仅在 `updateInput` 保存（无法覆盖切换瞬间丢失场景）。  

---

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
fun createNewSessionFromNavigation() {
    viewModelScope.launch {
        _uiState.update { currentState ->
            currentState.copy(
                conversations = emptyList(),
                currentSessionId = null,
                streamingContent = "",
                thinkingContent = "",
                currentStreamingMessageId = null,
                isLoading = true,
                hasLoadedConversations = false
            )
        }

        aiAdvisorRepository.getLatestEmptySession(contactId).onSuccess { emptySession ->
            if (emptySession != null) {
                _uiState.update { currentState ->
                    currentState.copy(
                        currentSessionId = emptySession.id,
                        isLoading = false,
                        hasLoadedConversations = false
                    )
                }
                loadSessions(contactId)
            } else {
                createAdvisorSessionUseCase(contactId).onSuccess { session ->
                    _uiState.update { currentState ->
                        currentState.copy(
                            sessions = listOf(session) + currentState.sessions,
                            currentSessionId = session.id,
                            isLoading = false,
                            hasLoadedConversations = false
                        )
                    }
                    loadConversations(session.id)
                }.onFailure { error ->
                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            error = error.message ?: "创建会话失败"
                        )
                    }
                }
            }
        }.onFailure { error ->
            createAdvisorSessionUseCase(contactId).onSuccess { session ->
                _uiState.update { currentState ->
                    currentState.copy(
                        sessions = listOf(session) + currentState.sessions,
                        currentSessionId = session.id,
                        isLoading = false
                    )
                }
                loadConversations(session.id)
            }.onFailure { createError ->
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        error = createError.message ?: "创建会话失败"
                    )
                }
            }
        }
    }
}

fun loadSessionById(sessionId: String) {
    viewModelScope.launch {
        _uiState.update { it.copy(isLoading = true) }

        aiAdvisorRepository.getSessionById(sessionId).onSuccess { session ->
            if (session != null) {
                _uiState.update { currentState ->
                    currentState.copy(
                        currentSessionId = session.id,
                        isLoading = false,
                        hasLoadedConversations = false
                    )
                }
                loadConversations(session.id)
                loadSessions(contactId)
            } else {
                _uiState.update {
                    it.copy(
                        error = "会话不存在或已被删除",
                        isLoading = false
                    )
                }
            }
        }.onFailure { error ->
            _uiState.update {
                it.copy(
                    error = error.message ?: "加载会话失败",
                    isLoading = false
                )
            }
        }
    }
}
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
fun createNewSessionFromNavigation() {
    flushDraftSave()
    viewModelScope.launch {
        _uiState.update { currentState ->
            currentState.copy(
                conversations = emptyList(),
                currentSessionId = null,
                streamingContent = "",
                thinkingContent = "",
                currentStreamingMessageId = null,
                isLoading = true,
                hasLoadedConversations = false,
                inputText = "",
                draftRestoredMessageResId = null
            )
        }

        aiAdvisorRepository.getLatestEmptySession(contactId).onSuccess { emptySession ->
            if (emptySession != null) {
                _uiState.update { currentState ->
                    currentState.copy(
                        currentSessionId = emptySession.id,
                        isLoading = false,
                        hasLoadedConversations = false,
                        inputText = "",
                        draftRestoredMessageResId = null
                    )
                }
                restoreDraftForSession(emptySession.id)
                loadSessions(contactId)
            } else {
                createAdvisorSessionUseCase(contactId).onSuccess { session ->
                    _uiState.update { currentState ->
                        currentState.copy(
                            sessions = listOf(session) + currentState.sessions,
                            currentSessionId = session.id,
                            isLoading = false,
                            hasLoadedConversations = false,
                            inputText = "",
                            draftRestoredMessageResId = null
                        )
                    }
                    restoreDraftForSession(session.id)
                    loadConversations(session.id)
                }.onFailure { error ->
                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            error = error.message ?: "创建会话失败"
                        )
                    }
                }
            }
        }.onFailure { error ->
            createAdvisorSessionUseCase(contactId).onSuccess { session ->
                _uiState.update { currentState ->
                    currentState.copy(
                        sessions = listOf(session) + currentState.sessions,
                        currentSessionId = session.id,
                        isLoading = false,
                        inputText = "",
                        draftRestoredMessageResId = null
                    )
                }
                restoreDraftForSession(session.id)
                loadConversations(session.id)
            }.onFailure { createError ->
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        error = createError.message ?: "创建会话失败"
                    )
                }
            }
        }
    }
}

fun loadSessionById(sessionId: String) {
    flushDraftSave()
    viewModelScope.launch {
        _uiState.update { it.copy(isLoading = true) }

        aiAdvisorRepository.getSessionById(sessionId).onSuccess { session ->
            if (session != null) {
                _uiState.update { currentState ->
                    currentState.copy(
                        currentSessionId = session.id,
                        isLoading = false,
                        hasLoadedConversations = false,
                        inputText = "",
                        draftRestoredMessageResId = null
                    )
                }
                restoreDraftForSession(session.id)
                loadConversations(session.id)
                loadSessions(contactId)
            } else {
                _uiState.update {
                    it.copy(
                        error = "会话不存在或已被删除",
                        isLoading = false
                    )
                }
            }
        }.onFailure { error ->
            _uiState.update {
                it.copy(
                    error = error.message ?: "加载会话失败",
                    isLoading = false
                )
            }
        }
    }
}
```

**修改原因**：  
1. 导航入口与会话切换同样存在草稿丢失风险，需要统一处理。  
2. “复用空会话”场景也应恢复草稿，保持体验一致。  
3. 清理提示状态避免跨会话残留。  

**影响分析**：  
- 新增 flush 与 restore 会增加一次 IO，但频率低。  
- 对无草稿场景无影响。  

**替代方案**：  
- 只处理 switchSession，不处理导航入口（覆盖不完整）。  

---
### 5) UI 状态扩展（草稿恢复提示）

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
 data class AiAdvisorChatUiState(
    val isLoading: Boolean = false,
    val isSending: Boolean = false,
    val isStreaming: Boolean = false,
    val isRegenerating: Boolean = false,
    val contactName: String = "",
    val inputText: String = "",
    val currentSessionId: String? = null,
    val sessions: List<AiAdvisorSession> = emptyList(),
    val conversations: List<AiAdvisorConversation> = emptyList(),
    val allContacts: List<ContactProfile> = emptyList(),
    val showContactSelector: Boolean = false,
    val showSwitchConfirmDialog: Boolean = false,
    val pendingContactId: String? = null,
    val shouldNavigateToContact: String? = null,
    val error: String? = null,
    val streamingContent: String = "",
    val thinkingContent: String = "",
    val thinkingElapsedMs: Long = 0,
    val currentStreamingMessageId: String? = null,
    val lastTokenUsage: TokenUsage? = null,
    val lastUserInput: String = "",
    val hasLoadedConversations: Boolean = false
)
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt
 data class AiAdvisorChatUiState(
    val isLoading: Boolean = false,
    val isSending: Boolean = false,
    val isStreaming: Boolean = false,
    val isRegenerating: Boolean = false,
    val contactName: String = "",
    val inputText: String = "",
    val currentSessionId: String? = null,
    val sessions: List<AiAdvisorSession> = emptyList(),
    val conversations: List<AiAdvisorConversation> = emptyList(),
    val allContacts: List<ContactProfile> = emptyList(),
    val showContactSelector: Boolean = false,
    val showSwitchConfirmDialog: Boolean = false,
    val pendingContactId: String? = null,
    val shouldNavigateToContact: String? = null,
    val error: String? = null,
    val streamingContent: String = "",
    val thinkingContent: String = "",
    val thinkingElapsedMs: Long = 0,
    val currentStreamingMessageId: String? = null,
    val lastTokenUsage: TokenUsage? = null,
    val lastUserInput: String = "",
    val hasLoadedConversations: Boolean = false,
    val draftRestoredMessageResId: Int? = null
)
```

**修改原因**：  
1. 提示条状态需要由 ViewModel 驱动，必须进入 UI State。  
2. 通过可空字符串区分“无提示”和“有提示”。  

**影响分析**：  
- 状态字段增加不会影响现有 UI 渲染。  
- 默认值为 null，保持向后兼容。  

**替代方案**：  
- 使用单独的事件流（复杂度更高且不必要）。  

---
### 6) 对话页提示条与设置入口（UI）

#### 6.1 AiAdvisorChatScreen 提示条接入

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/advisor/AiAdvisorChatScreen.kt
fun AiAdvisorChatScreen(
    createNew: Boolean = false,
    sessionId: String? = null,
    onNavigateBack: () -> Unit,
    onNavigateToContact: (String) -> Unit,
    onNavigateToSettings: () -> Unit,
    onNavigateToSessionHistory: () -> Unit = {},
    onNavigateToContactSelect: () -> Unit = {},
    viewModel: AiAdvisorChatViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val listState = rememberLazyListState()

    BackHandler {
        Log.d("AiAdvisorChatScreen", "BackHandler triggered")
        onNavigateBack()
    }

    LaunchedEffect(createNew, sessionId) {
        Log.d(
            "AiAdvisorChatScreen",
            "LaunchedEffect createNew=$createNew sessionId=$sessionId currentContact=${uiState.contactName}"
        )
        when {
            createNew -> {
                viewModel.createNewSessionFromNavigation()
            }
            sessionId != null -> {
                viewModel.loadSessionById(sessionId)
            }
            else -> {
                Log.d("AiAdvisorChatScreen", "LaunchedEffect use default session")
            }
        }
    }

    LaunchedEffect(uiState.shouldNavigateToContact) {
        uiState.shouldNavigateToContact?.let { contactId ->
            onNavigateToContact(contactId)
            viewModel.clearNavigationState()
        }
    }

    LaunchedEffect(uiState.conversations.size) {
        if (uiState.conversations.isNotEmpty()) {
            val lastVisibleIndex = listState.layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: 0
            val totalItems = uiState.conversations.size
            val isNearBottom = lastVisibleIndex >= totalItems - 2

            if (isNearBottom) {
                val targetIndex = (totalItems - 1).coerceAtLeast(0)
                listState.animateScrollToItem(targetIndex)
            }
        }
    }
    
    LaunchedEffect(uiState.isStreaming) {
        if (uiState.isStreaming && uiState.conversations.isNotEmpty()) {
            val targetIndex = uiState.conversations.size
            listState.animateScrollToItem(targetIndex.coerceAtLeast(0))
        }
    }

    Scaffold(
        containerColor = iOSBackground
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .background(iOSBackground)
                .imePadding()
        ) {
            IOSChatNavigationBar(
                contactName = uiState.contactName,
                onMenuClick = onNavigateToSessionHistory,
                onContactClick = onNavigateToContactSelect
            )

            Box(modifier = Modifier.weight(1f)) {
                when {
                    uiState.isLoading -> {
                        CircularProgressIndicator(
                            modifier = Modifier.align(Alignment.Center),
                            color = iOSBlue
                        )
                    }
                    uiState.conversations.isEmpty() && !uiState.isStreaming && uiState.hasLoadedConversations -> {
                        EmptyChatState(modifier = Modifier.align(Alignment.Center))
                    }
                    else -> {
                        LazyColumn(
                            state = listState,
                            contentPadding = PaddingValues(16.dp),
                            verticalArrangement = Arrangement.spacedBy(16.dp)
                        ) {
                            items(
                                items = uiState.conversations,
                                key = { it.id }
                            ) { conversation ->
                                ChatBubble(
                                    conversation = conversation,
                                    onRetry = { viewModel.retryMessage(conversation) },
                                    onDelete = { viewModel.deleteMessage(conversation.id) },
                                    onRegenerate = { viewModel.regenerateLastMessage() },
                                    isLastAiMessage = conversation == uiState.conversations.lastOrNull { it.messageType == MessageType.AI }
                                )
                            }

                            val messageAlreadyInList = uiState.currentStreamingMessageId?.let { messageId ->
                                uiState.conversations.any { conv ->
                                    conv.id == messageId && 
                                    (conv.content.isNotEmpty() || conv.sendStatus != SendStatus.PENDING)
                                }
                            } ?: false
                            
                            val shouldShowStreamingBubble = !messageAlreadyInList && (
                                uiState.isStreaming || 
                                (uiState.streamingContent.isNotEmpty() && uiState.currentStreamingMessageId != null)
                            )
                            
                            if (shouldShowStreamingBubble) {
                                item(key = "streaming_message") {
                                    StreamingMessageBubbleSimple(
                                        content = uiState.streamingContent,
                                        thinkingContent = uiState.thinkingContent,
                                        thinkingElapsedMs = uiState.thinkingElapsedMs,
                                        isStreaming = uiState.isStreaming,
                                        onStopGeneration = { viewModel.stopGeneration() },
                                        onRegenerate = { viewModel.regenerateLastMessage() }
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }

        // 错误提示
        uiState.error?.let { errorMessage ->
            ErrorBanner(
                message = errorMessage,
                onDismiss = { viewModel.clearError() }
            )
        }

        // 输入栏
        ChatInputBar(
            inputText = uiState.inputText,
            isSending = uiState.isSending,
            isStreaming = uiState.isStreaming,
            onInputChange = viewModel::updateInput,
            onSend = viewModel::sendMessage,
            onStopGeneration = viewModel::stopGeneration
        )
        }  // Column结束
    }  // Scaffold结束

    if (uiState.showContactSelector) {
        ContactSelectorDialog(
            contacts = uiState.allContacts,
            onSelect = viewModel::switchContact,
            onDismiss = viewModel::hideContactSelector
        )
    }

    if (uiState.showSwitchConfirmDialog) {
        SwitchConfirmDialog(
            onConfirm = viewModel::confirmSwitch,
            onDismiss = viewModel::cancelSwitch
        )
    }
}
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/advisor/AiAdvisorChatScreen.kt
fun AiAdvisorChatScreen(
    createNew: Boolean = false,
    sessionId: String? = null,
    onNavigateBack: () -> Unit,
    onNavigateToContact: (String) -> Unit,
    onNavigateToSettings: () -> Unit,
    onNavigateToSessionHistory: () -> Unit = {},
    onNavigateToContactSelect: () -> Unit = {},
    viewModel: AiAdvisorChatViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val listState = rememberLazyListState()

    BackHandler {
        Log.d("AiAdvisorChatScreen", "BackHandler triggered")
        onNavigateBack()
    }

    LaunchedEffect(createNew, sessionId) {
        Log.d(
            "AiAdvisorChatScreen",
            "LaunchedEffect createNew=$createNew sessionId=$sessionId currentContact=${uiState.contactName}"
        )
        when {
            createNew -> {
                viewModel.createNewSessionFromNavigation()
            }
            sessionId != null -> {
                viewModel.loadSessionById(sessionId)
            }
            else -> {
                Log.d("AiAdvisorChatScreen", "LaunchedEffect use default session")
            }
        }
    }

    LaunchedEffect(uiState.shouldNavigateToContact) {
        uiState.shouldNavigateToContact?.let { contactId ->
            onNavigateToContact(contactId)
            viewModel.clearNavigationState()
        }
    }

    LaunchedEffect(uiState.conversations.size) {
        if (uiState.conversations.isNotEmpty()) {
            val lastVisibleIndex = listState.layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: 0
            val totalItems = uiState.conversations.size
            val isNearBottom = lastVisibleIndex >= totalItems - 2

            if (isNearBottom) {
                val targetIndex = (totalItems - 1).coerceAtLeast(0)
                listState.animateScrollToItem(targetIndex)
            }
        }
    }
    
    LaunchedEffect(uiState.isStreaming) {
        if (uiState.isStreaming && uiState.conversations.isNotEmpty()) {
            val targetIndex = uiState.conversations.size
            listState.animateScrollToItem(targetIndex.coerceAtLeast(0))
        }
    }

    Scaffold(
        containerColor = iOSBackground
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .background(iOSBackground)
                .imePadding()
        ) {
            IOSChatNavigationBar(
                contactName = uiState.contactName,
                onMenuClick = onNavigateToSessionHistory,
                onContactClick = onNavigateToContactSelect
            )

            Box(modifier = Modifier.weight(1f)) {
                when {
                    uiState.isLoading -> {
                        CircularProgressIndicator(
                            modifier = Modifier.align(Alignment.Center),
                            color = iOSBlue
                        )
                    }
                    uiState.conversations.isEmpty() && !uiState.isStreaming && uiState.hasLoadedConversations -> {
                        EmptyChatState(modifier = Modifier.align(Alignment.Center))
                    }
                    else -> {
                        LazyColumn(
                            state = listState,
                            contentPadding = PaddingValues(16.dp),
                            verticalArrangement = Arrangement.spacedBy(16.dp)
                        ) {
                            items(
                                items = uiState.conversations,
                                key = { it.id }
                            ) { conversation ->
                                ChatBubble(
                                    conversation = conversation,
                                    onRetry = { viewModel.retryMessage(conversation) },
                                    onDelete = { viewModel.deleteMessage(conversation.id) },
                                    onRegenerate = { viewModel.regenerateLastMessage() },
                                    isLastAiMessage = conversation == uiState.conversations.lastOrNull { it.messageType == MessageType.AI }
                                )
                            }

                            val messageAlreadyInList = uiState.currentStreamingMessageId?.let { messageId ->
                                uiState.conversations.any { conv ->
                                    conv.id == messageId && 
                                    (conv.content.isNotEmpty() || conv.sendStatus != SendStatus.PENDING)
                                }
                            } ?: false
                            
                            val shouldShowStreamingBubble = !messageAlreadyInList && (
                                uiState.isStreaming || 
                                (uiState.streamingContent.isNotEmpty() && uiState.currentStreamingMessageId != null)
                            )
                            
                            if (shouldShowStreamingBubble) {
                                item(key = "streaming_message") {
                                    StreamingMessageBubbleSimple(
                                        content = uiState.streamingContent,
                                        thinkingContent = uiState.thinkingContent,
                                        thinkingElapsedMs = uiState.thinkingElapsedMs,
                                        isStreaming = uiState.isStreaming,
                                        onStopGeneration = { viewModel.stopGeneration() },
                                        onRegenerate = { viewModel.regenerateLastMessage() }
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }

        uiState.draftRestoredMessageResId?.let { messageResId ->
            DraftRestoredBanner(
                message = stringResource(messageResId),
                onDismiss = { viewModel.clearDraftRestoredMessage() }
            )
        }

        // 错误提示
        uiState.error?.let { errorMessage ->
            ErrorBanner(
                message = errorMessage,
                onDismiss = { viewModel.clearError() }
            )
        }

        // 输入栏
        ChatInputBar(
            inputText = uiState.inputText,
            isSending = uiState.isSending,
            isStreaming = uiState.isStreaming,
            onInputChange = viewModel::updateInput,
            onSend = viewModel::sendMessage,
            onStopGeneration = viewModel::stopGeneration
        )
        }  // Column结束
    }  // Scaffold结束

    if (uiState.showContactSelector) {
        ContactSelectorDialog(
            contacts = uiState.allContacts,
            onSelect = viewModel::switchContact,
            onDismiss = viewModel::hideContactSelector
        )
    }

    if (uiState.showSwitchConfirmDialog) {
        SwitchConfirmDialog(
            onConfirm = viewModel::confirmSwitch,
            onDismiss = viewModel::cancelSwitch
        )
    }
}
```

**修改原因**：  
1. 提示条显示在输入栏上方，用户可立即感知恢复状态。  
2. 点击提示条可关闭，避免长时间占据视线。  

**影响分析**：  
- UI 增加轻提示，不影响对话主流程。  

**替代方案**：  
- 自动延迟关闭（可能导致用户错过提示）。  

---
#### 6.2 新增 DraftRestoredBanner 组件

**修改前**：无（组件不存在）  

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/advisor/AiAdvisorChatScreen.kt
@Composable
private fun DraftRestoredBanner(
    message: String,
    onDismiss: () -> Unit
) {
    val dimensions = AdaptiveDimensions.current

    Surface(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onDismiss),
        color = iOSGreen.copy(alpha = 0.12f)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 10.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = message,
                modifier = Modifier.weight(1f),
                fontSize = dimensions.fontSizeBody,
                color = iOSGreen
            )
            Text(
                text = stringResource(R.string.advisor_draft_restored_ack),
                fontSize = dimensions.fontSizeBody,
                color = iOSBlue
            )
        }
    }
}
```

**修改原因**：  
1. 独立组件便于复用与样式统一。  
2. 与 ErrorBanner 交互一致，支持点击关闭。  
3. 文案通过资源文件统一管理，便于后续多语言扩展。  

**影响分析**：  
- 纯 UI 组件，无业务副作用。  

**替代方案**：  
- 复用 ErrorBanner 并换色（语义不够清晰）。  

---
### 7) 设置页清除草稿入口（ViewModel + UI）

#### 7.1 SettingsUiEvent 新增草稿事件

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/settings/SettingsUiEvent.kt
sealed interface SettingsUiEvent {
    data class SelectProvider(val provider: String) : SettingsUiEvent
    data object ShowProviderDialog : SettingsUiEvent
    data object HideProviderDialog : SettingsUiEvent
    data object ToggleDataMasking : SettingsUiEvent
    data object ToggleLocalFirstMode : SettingsUiEvent
    data class ChangeHistoryConversationCount(val count: Int) : SettingsUiEvent
    data object ShowClearDataDialog : SettingsUiEvent
    data object HideClearDataDialog : SettingsUiEvent
    data object ClearAllData : SettingsUiEvent
    data class ToggleFloatingWindow(val displayId: Int?) : SettingsUiEvent
    data object ToggleContinuousScreenshot : SettingsUiEvent
    data object ToggleScreenshotPermission : SettingsUiEvent
    data object RequestFloatingWindowPermission : SettingsUiEvent
    data object PermissionRequestHandled : SettingsUiEvent
    data object ScreenshotPermissionRequestHandled : SettingsUiEvent
    data object ShowPermissionDialog : SettingsUiEvent
    data object HidePermissionDialog : SettingsUiEvent
    data object CheckFloatingWindowPermission : SettingsUiEvent
    data object ClearError : SettingsUiEvent
    data object ClearSuccessMessage : SettingsUiEvent
    data object NavigateBack : SettingsUiEvent
}
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/settings/SettingsUiEvent.kt
sealed interface SettingsUiEvent {
    data class SelectProvider(val provider: String) : SettingsUiEvent
    data object ShowProviderDialog : SettingsUiEvent
    data object HideProviderDialog : SettingsUiEvent
    data object ToggleDataMasking : SettingsUiEvent
    data object ToggleLocalFirstMode : SettingsUiEvent
    data class ChangeHistoryConversationCount(val count: Int) : SettingsUiEvent
    data object ShowClearDataDialog : SettingsUiEvent
    data object HideClearDataDialog : SettingsUiEvent
    data object ClearAllData : SettingsUiEvent
    data object ShowClearAdvisorDraftsDialog : SettingsUiEvent
    data object HideClearAdvisorDraftsDialog : SettingsUiEvent
    data object ClearAdvisorDrafts : SettingsUiEvent
    data class ToggleFloatingWindow(val displayId: Int?) : SettingsUiEvent
    data object ToggleContinuousScreenshot : SettingsUiEvent
    data object ToggleScreenshotPermission : SettingsUiEvent
    data object RequestFloatingWindowPermission : SettingsUiEvent
    data object PermissionRequestHandled : SettingsUiEvent
    data object ScreenshotPermissionRequestHandled : SettingsUiEvent
    data object ShowPermissionDialog : SettingsUiEvent
    data object HidePermissionDialog : SettingsUiEvent
    data object CheckFloatingWindowPermission : SettingsUiEvent
    data object ClearError : SettingsUiEvent
    data object ClearSuccessMessage : SettingsUiEvent
    data object NavigateBack : SettingsUiEvent
}
```

**修改原因**：  
1. 需要新增“清除草稿”弹窗的显示/隐藏/执行事件。  
2. 与“清除所有设置”事件模式保持一致。  

**影响分析**：  
- 新事件不会影响原有事件处理。  

**替代方案**：  
- 复用 `ClearAllData` 弹窗（易误导用户）。  

---

#### 7.2 SettingsUiState 扩展弹窗状态

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/settings/SettingsUiState.kt
data class SettingsUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val successMessage: String? = null,
    val selectedProvider: String = "",
    val availableProviders: List<String> = emptyList(),
    val providersList: List<AiProvider> = emptyList(),
    val dataMaskingEnabled: Boolean = true,
    val localFirstMode: Boolean = true,
    val historyConversationCount: Int = 5,
    val historyCountOptions: List<HistoryCountOption> = listOf(
        HistoryCountOption(0, "不发送历史", "每次分析独立，不包含历史对话"),
        HistoryCountOption(5, "最近5条", "推荐，平衡上下文和Token消耗"),
        HistoryCountOption(10, "最近10条", "更完整的上下文，Token消耗较高")
    ),
    val appVersion: String = "1.0.0",
    val floatingWindowEnabled: Boolean = false,
    val hasFloatingWindowPermission: Boolean = false,
    val continuousScreenshotEnabled: Boolean = false,
    val hasScreenshotPermission: Boolean = false,
    val showProviderDialog: Boolean = false,
    val showClearDataDialog: Boolean = false,
    val showPermissionDialog: Boolean = false,
    val pendingPermissionRequest: Boolean = false,
    val pendingScreenshotPermissionRequest: Boolean = false
)
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/settings/SettingsUiState.kt
data class SettingsUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val successMessage: String? = null,
    val selectedProvider: String = "",
    val availableProviders: List<String> = emptyList(),
    val providersList: List<AiProvider> = emptyList(),
    val dataMaskingEnabled: Boolean = true,
    val localFirstMode: Boolean = true,
    val historyConversationCount: Int = 5,
    val historyCountOptions: List<HistoryCountOption> = listOf(
        HistoryCountOption(0, "不发送历史", "每次分析独立，不包含历史对话"),
        HistoryCountOption(5, "最近5条", "推荐，平衡上下文和Token消耗"),
        HistoryCountOption(10, "最近10条", "更完整的上下文，Token消耗较高")
    ),
    val appVersion: String = "1.0.0",
    val floatingWindowEnabled: Boolean = false,
    val hasFloatingWindowPermission: Boolean = false,
    val continuousScreenshotEnabled: Boolean = false,
    val hasScreenshotPermission: Boolean = false,
    val showProviderDialog: Boolean = false,
    val showClearDataDialog: Boolean = false,
    val showClearAdvisorDraftsDialog: Boolean = false,
    val showPermissionDialog: Boolean = false,
    val pendingPermissionRequest: Boolean = false,
    val pendingScreenshotPermissionRequest: Boolean = false
)
```

**修改原因**：  
1. 需要单独控制“清除草稿”弹窗状态。  
2. 避免与 `showClearDataDialog` 混用。  

**影响分析**：  
- 新增字段默认 false，不影响原有行为。  

**替代方案**：  
- 复用已有字段并通过文案区分（可读性差）。  

---
#### 7.3 SettingsViewModel 处理草稿清除

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/SettingsViewModel.kt
@HiltViewModel
class SettingsViewModel @Inject constructor(
    application: Application,
    private val settingsRepository: SettingsRepository,
    private val floatingWindowPreferencesRepository: FloatingWindowPreferencesRepository,
    private val aiProviderRepository: AiProviderRepository,
    private val floatingWindowManager: FloatingWindowManager
) : AndroidViewModel(application) {

    fun onEvent(event: SettingsUiEvent) {
        when (event) {
            is SettingsUiEvent.SelectProvider -> selectProvider(event.provider)
            is SettingsUiEvent.ShowProviderDialog -> showProviderDialog()
            is SettingsUiEvent.HideProviderDialog -> hideProviderDialog()
            is SettingsUiEvent.ToggleDataMasking -> toggleDataMasking()
            is SettingsUiEvent.ToggleLocalFirstMode -> toggleLocalFirstMode()
            is SettingsUiEvent.ChangeHistoryConversationCount -> changeHistoryConversationCount(event.count)
            is SettingsUiEvent.ShowClearDataDialog -> showClearDataDialog()
            is SettingsUiEvent.HideClearDataDialog -> hideClearDataDialog()
            is SettingsUiEvent.ClearAllData -> clearAllData()
            is SettingsUiEvent.ToggleFloatingWindow -> toggleFloatingWindow(event.displayId)
            is SettingsUiEvent.ToggleContinuousScreenshot -> toggleContinuousScreenshot()
            is SettingsUiEvent.ToggleScreenshotPermission -> toggleScreenshotPermission()
            is SettingsUiEvent.RequestFloatingWindowPermission -> requestFloatingWindowPermission()
            is SettingsUiEvent.PermissionRequestHandled -> clearPendingPermissionRequest()
            is SettingsUiEvent.ScreenshotPermissionRequestHandled -> clearPendingScreenshotPermissionRequest()
            is SettingsUiEvent.ShowPermissionDialog -> showPermissionDialog()
            is SettingsUiEvent.HidePermissionDialog -> hidePermissionDialog()
            is SettingsUiEvent.CheckFloatingWindowPermission -> checkFloatingWindowPermission()
            is SettingsUiEvent.ClearError -> clearError()
            is SettingsUiEvent.ClearSuccessMessage -> clearSuccessMessage()
            is SettingsUiEvent.NavigateBack -> {}
        }
    }
}
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/SettingsViewModel.kt
@HiltViewModel
class SettingsViewModel @Inject constructor(
    application: Application,
    private val settingsRepository: SettingsRepository,
    private val floatingWindowPreferencesRepository: FloatingWindowPreferencesRepository,
    private val aiProviderRepository: AiProviderRepository,
    private val clearAllAdvisorDraftsUseCase: ClearAllAdvisorDraftsUseCase,
    private val floatingWindowManager: FloatingWindowManager
) : AndroidViewModel(application) {

    fun onEvent(event: SettingsUiEvent) {
        when (event) {
            is SettingsUiEvent.SelectProvider -> selectProvider(event.provider)
            is SettingsUiEvent.ShowProviderDialog -> showProviderDialog()
            is SettingsUiEvent.HideProviderDialog -> hideProviderDialog()
            is SettingsUiEvent.ToggleDataMasking -> toggleDataMasking()
            is SettingsUiEvent.ToggleLocalFirstMode -> toggleLocalFirstMode()
            is SettingsUiEvent.ChangeHistoryConversationCount -> changeHistoryConversationCount(event.count)
            is SettingsUiEvent.ShowClearDataDialog -> showClearDataDialog()
            is SettingsUiEvent.HideClearDataDialog -> hideClearDataDialog()
            is SettingsUiEvent.ClearAllData -> clearAllData()
            is SettingsUiEvent.ShowClearAdvisorDraftsDialog -> showClearAdvisorDraftsDialog()
            is SettingsUiEvent.HideClearAdvisorDraftsDialog -> hideClearAdvisorDraftsDialog()
            is SettingsUiEvent.ClearAdvisorDrafts -> clearAdvisorDrafts()
            is SettingsUiEvent.ToggleFloatingWindow -> toggleFloatingWindow(event.displayId)
            is SettingsUiEvent.ToggleContinuousScreenshot -> toggleContinuousScreenshot()
            is SettingsUiEvent.ToggleScreenshotPermission -> toggleScreenshotPermission()
            is SettingsUiEvent.RequestFloatingWindowPermission -> requestFloatingWindowPermission()
            is SettingsUiEvent.PermissionRequestHandled -> clearPendingPermissionRequest()
            is SettingsUiEvent.ScreenshotPermissionRequestHandled -> clearPendingScreenshotPermissionRequest()
            is SettingsUiEvent.ShowPermissionDialog -> showPermissionDialog()
            is SettingsUiEvent.HidePermissionDialog -> hidePermissionDialog()
            is SettingsUiEvent.CheckFloatingWindowPermission -> checkFloatingWindowPermission()
            is SettingsUiEvent.ClearError -> clearError()
            is SettingsUiEvent.ClearSuccessMessage -> clearSuccessMessage()
            is SettingsUiEvent.NavigateBack -> {}
        }
    }
}
```

**修改原因**：  
1. 设置页需要注入清除草稿 UseCase 以保持用例层一致性。  
2. 增加事件处理，保持与“清除所有设置”一致的交互逻辑。  

**影响分析**：  
- 构造函数新增依赖，单测需补齐（已处理）。  
- 新增事件不影响既有路径。  

**替代方案**：  
- 直接在 ViewModel 注入 Repository 执行清除（已放弃，层级不一致）。  

---

**修改前**：无（方法不存在）  

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/SettingsViewModel.kt
private fun clearAdvisorDrafts() {
    viewModelScope.launch {
        clearAllAdvisorDraftsUseCase()
            .onSuccess {
                _uiState.update {
                    it.copy(
                        showClearAdvisorDraftsDialog = false,
                        successMessage = getApplication<Application>()
                            .getString(R.string.settings_clear_advisor_drafts_success)
                    )
                }
            }
                .onFailure { error ->
                    _uiState.update {
                        it.copy(
                            error = error.message
                                ?: getApplication<Application>()
                                    .getString(R.string.settings_clear_advisor_drafts_failed)
                        )
                    }
                }
    }
}
```

**修改原因**：  
1. 在确认弹窗后执行清除操作，并关闭弹窗。  
2. 通过 UseCase 返回 `Result`，成功与失败均给出明确反馈。  

**影响分析**：  
- 对话记录不受影响，仅清除草稿。  

**替代方案**：  
- ViewModel 直接 try/catch 调仓库（已放弃，层级不一致）。  

---
#### 7.4 清除所有设置时清理偏好并回退草稿

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/SettingsViewModel.kt
private fun clearAllData() {
    viewModelScope.launch {
        try {
            _uiState.update { it.copy(isLoading = true, error = null) }

            val providers = _uiState.value.providersList
            providers.forEach { provider ->
                aiProviderRepository.deleteProvider(provider.id)
            }

            settingsRepository.setDataMaskingEnabled(true)
            settingsRepository.setLocalFirstModeEnabled(true)

            floatingWindowPreferencesRepository.saveEnabled(false)
            floatingWindowPreferencesRepository.saveContinuousScreenshotEnabled(false)
            if (_uiState.value.floatingWindowEnabled) {
                floatingWindowManager.stopService()
            }

            _uiState.update {
                it.copy(
                    isLoading = false,
                    selectedProvider = "",
                    availableProviders = emptyList(),
                    providersList = emptyList(),
                    dataMaskingEnabled = true,
                    localFirstMode = true,
                    floatingWindowEnabled = false,
                    continuousScreenshotEnabled = false,
                    showClearDataDialog = false,
                    successMessage = "所有设置已清除"
                )
            }
        } catch (e: Exception) {
            android.util.Log.e("SettingsViewModel", "清除数据失败", e)
            _uiState.update {
                it.copy(
                    isLoading = false,
                    error = e.message ?: "清除数据失败"
                )
            }
        }
    }
}
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/SettingsViewModel.kt
private fun clearAllData() {
    viewModelScope.launch {
        try {
            _uiState.update { it.copy(isLoading = true, error = null) }

            val clearPreferencesResult = clearAdvisorPreferencesUseCase()
            if (clearPreferencesResult.isFailure) {
                android.util.Log.w(
                    "SettingsViewModel",
                    "清除偏好失败",
                    clearPreferencesResult.exceptionOrNull()
                )
                clearAllAdvisorDraftsUseCase()
                    .onFailure { error ->
                        android.util.Log.w("SettingsViewModel", "清除草稿失败", error)
                    }
            }

            val providers = _uiState.value.providersList
            providers.forEach { provider ->
                aiProviderRepository.deleteProvider(provider.id)
            }

            settingsRepository.setDataMaskingEnabled(true)
            settingsRepository.setLocalFirstModeEnabled(true)

            floatingWindowPreferencesRepository.saveEnabled(false)
            floatingWindowPreferencesRepository.saveContinuousScreenshotEnabled(false)
            if (_uiState.value.floatingWindowEnabled) {
                floatingWindowManager.stopService()
            }

            _uiState.update {
                it.copy(
                    isLoading = false,
                    selectedProvider = "",
                    availableProviders = emptyList(),
                    providersList = emptyList(),
                    dataMaskingEnabled = true,
                    localFirstMode = true,
                    floatingWindowEnabled = false,
                    continuousScreenshotEnabled = false,
                    showClearDataDialog = false,
                    successMessage = "所有设置已清除"
                )
            }
        } catch (e: Exception) {
            android.util.Log.e("SettingsViewModel", "清除数据失败", e)
            _uiState.update {
                it.copy(
                    isLoading = false,
                    error = e.message ?: "清除数据失败"
                )
            }
        }
    }
}
```

**修改原因**：  
1. “清除所有设置”属于强清理语义，应覆盖联系人偏好与草稿以避免残留。  
2. 偏好清理失败时回退到草稿清理，确保至少移除可恢复草稿。  
3. 清理失败不应阻断主流程，因此采用 best-effort。  

**影响分析**：  
- 额外调用偏好与草稿清理 UseCase；失败仅记录日志，不影响清理流程。  

**替代方案**：  
- 仅保留“清除草稿”入口（容易造成认知偏差）。  

---
#### 7.5 SettingsScreenContent 增加清除草稿入口与弹窗

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/settings/SettingsScreen.kt
private fun SettingsScreenContent(
    uiState: SettingsUiState,
    isDeveloperMode: Boolean,
    onEvent: (SettingsUiEvent) -> Unit,
    onVersionClick: () -> Unit,
    onNavigateBack: () -> Unit,
    onNavigateToAiConfig: () -> Unit,
    onNavigateToPromptEditor: (String) -> Unit,
    onNavigateToUserProfile: () -> Unit,
    onNavigateToSystemPromptList: () -> Unit,
    onNavigate: (String) -> Unit,
    onAddClick: () -> Unit,
    currentRoute: String,
    showBottomBar: Boolean,
    promptScenes: List<PromptScene>,
    modifier: Modifier = Modifier
) {
    val displayId = LocalView.current.display?.displayId

    Scaffold(
        modifier = modifier,
        containerColor = iOSBackground,
        bottomBar = {
            if (showBottomBar) {
                EmpathyBottomNavigation(
                    currentRoute = currentRoute,
                    onNavigate = onNavigate,
                    onAddClick = onAddClick
                )
            }
        },
        snackbarHost = {
            uiState.error?.let { error ->
                Snackbar(
                    action = {
                        TextButton(onClick = { onEvent(SettingsUiEvent.ClearError) }) {
                            Text("关闭")
                        }
                    }
                ) { Text(error) }
            }
            uiState.successMessage?.let { message ->
                Snackbar { Text(message) }
            }
        }
    ) { paddingValues ->
        val dimensions = AdaptiveDimensions.current
        
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .background(iOSBackground)
        ) {
            item {
                Text(
                    text = "设置",
                    fontSize = dimensions.fontSizeLargeTitle,
                    fontWeight = FontWeight.Bold,
                    color = iOSTextPrimary,
                    modifier = Modifier.padding(start = dimensions.spacingMedium, top = dimensions.spacingMedium, bottom = dimensions.spacingSmall)
                )
            }

            item {
                IOSSettingsSection(title = "AI 配置") {
                    IOSSettingsItem(
                        icon = Icons.Default.Settings,
                        iconBackgroundColor = iOSBlue,
                        title = "AI 服务商",
                        value = uiState.selectedProvider.ifEmpty { "未配置" },
                        onClick = onNavigateToAiConfig
                    )
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = iOSPurple,
                        title = "提示词设置",
                        showDivider = false,
                        onClick = {
                            onNavigateToPromptEditor(
                                PromptEditorRoutes.globalSceneWithSource(
                                    PromptScene.ANALYZE,
                                    NavRoutes.SOURCE_SETTINGS
                                )
                            )
                        }
                    )
                }
            }

            item {
                IOSSettingsSection(title = "悬浮窗") {
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = iOSGreen,
                        title = "启用悬浮窗",
                        subtitle = if (uiState.hasFloatingWindowPermission) null else "需要悬浮窗权限",
                        showArrow = false,
                        showDivider = true,
                        trailing = {
                            IOSSwitch(
                                checked = uiState.floatingWindowEnabled,
                                onCheckedChange = {
                                    android.util.Log.d(
                                        "SettingsScreen",
                                        "ToggleFloatingWindow displayId=$displayId"
                                    )
                                    onEvent(SettingsUiEvent.ToggleFloatingWindow(displayId))
                                },
                                enabled = uiState.hasFloatingWindowPermission || !uiState.floatingWindowEnabled
                            )
                        },
                        onClick = if (!uiState.hasFloatingWindowPermission) {
                            { onEvent(SettingsUiEvent.ShowPermissionDialog) }
                        } else null
                    )
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = iOSBlue,
                        title = "截图权限",
                        subtitle = if (uiState.hasScreenshotPermission) null else "需要截图权限",
                        showArrow = false,
                        showDivider = true,
                        trailing = {
                            IOSSwitch(
                                checked = uiState.hasScreenshotPermission,
                                onCheckedChange = { onEvent(SettingsUiEvent.ToggleScreenshotPermission) }
                            )
                        },
                        onClick = if (!uiState.hasScreenshotPermission) {
                            { onEvent(SettingsUiEvent.ToggleScreenshotPermission) }
                        } else null
                    )
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = iOSBlue,
                        title = "连续截屏",
                        subtitle = "1.5秒内可继续框选",
                        showArrow = false,
                        showDivider = false,
                        trailing = {
                            IOSSwitch(
                                checked = uiState.continuousScreenshotEnabled,
                                onCheckedChange = { onEvent(SettingsUiEvent.ToggleContinuousScreenshot) }
                            )
                        }
                    )
                }
            }

            item {
                IOSSettingsSection(title = "隐私保护") {
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = iOSBlue,
                        title = "数据掩码",
                        subtitle = "AI 分析前自动掩码敏感信息",
                        showArrow = false,
                        trailing = {
                            IOSSwitch(
                                checked = uiState.dataMaskingEnabled,
                                onCheckedChange = { onEvent(SettingsUiEvent.ToggleDataMasking) }
                            )
                        }
                    )
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = iOSGreen,
                        title = "本地优先模式",
                        subtitle = "优先使用本地规则，减少 AI 调用",
                        showArrow = false,
                        showDivider = false,
                        trailing = {
                            IOSSwitch(
                                checked = uiState.localFirstMode,
                                onCheckedChange = { onEvent(SettingsUiEvent.ToggleLocalFirstMode) }
                            )
                        }
                    )
                }
            }

            item {
                IOSSettingsSection(title = "个人画像") {
                    IOSSettingsItem(
                        icon = Icons.Default.Person,
                        iconBackgroundColor = iOSPurple,
                        title = "管理个人画像",
                        subtitle = "设置您的性格特点、价值观等",
                        showDivider = false,
                        onClick = onNavigateToUserProfile
                    )
                }
            }

            item {
                IOSSettingsSection(title = "数据管理") {
                    IOSSettingsItem(
                        icon = Icons.Default.Delete,
                        iconBackgroundColor = iOSRed,
                        title = "清除所有设置",
                        showDivider = false,
                        onClick = { onEvent(SettingsUiEvent.ShowClearDataDialog) }
                    )
                }
            }

            item {
                IOSSettingsSection(title = "关于") {
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = Color.Gray,
                        title = "版本",
                        value = uiState.appVersion,
                        showArrow = false,
                        showDivider = false,
                        onClick = onVersionClick
                    )
                }
            }

            if (isDeveloperMode) {
                item {
                    DeveloperOptionsSection(
                        onSystemPromptEditClick = onNavigateToSystemPromptList
                    )
                }
            }

            item { Spacer(modifier = Modifier.height(dimensions.spacingXLarge)) }
        }

        if (uiState.showProviderDialog) {
            ProviderSelectionDialog(
                selectedProvider = uiState.selectedProvider,
                availableProviders = uiState.availableProviders,
                onProviderSelected = { onEvent(SettingsUiEvent.SelectProvider(it)) },
                onDismiss = { onEvent(SettingsUiEvent.HideProviderDialog) }
            )
        }

        if (uiState.showClearDataDialog) {
            IOSAlertDialog(
                title = "清除所有设置",
                message = "确定要清除以下数据吗？\n\n将被清除：\n• AI服务商配置\n• 隐私保护设置\n• 悬浮窗设置\n\n不会清除：\n• 联系人数据\n• 标签数据\n\n此操作不可恢复！",
                confirmText = "确定清除",
                dismissText = "取消",
                onConfirm = { onEvent(SettingsUiEvent.ClearAllData) },
                onDismiss = { onEvent(SettingsUiEvent.HideClearDataDialog) },
                isDestructive = true,
                showDismissButton = true
            )
        }

        if (uiState.showPermissionDialog) {
            IOSPermissionRequestDialog(
                onConfirm = {
                    onEvent(SettingsUiEvent.HidePermissionDialog)
                    onEvent(SettingsUiEvent.RequestFloatingWindowPermission)
                },
                onDismiss = { onEvent(SettingsUiEvent.HidePermissionDialog) }
            )
        }
    }
}
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/settings/SettingsScreen.kt
private fun SettingsScreenContent(
    uiState: SettingsUiState,
    isDeveloperMode: Boolean,
    onEvent: (SettingsUiEvent) -> Unit,
    onVersionClick: () -> Unit,
    onNavigateBack: () -> Unit,
    onNavigateToAiConfig: () -> Unit,
    onNavigateToPromptEditor: (String) -> Unit,
    onNavigateToUserProfile: () -> Unit,
    onNavigateToSystemPromptList: () -> Unit,
    onNavigate: (String) -> Unit,
    onAddClick: () -> Unit,
    currentRoute: String,
    showBottomBar: Boolean,
    promptScenes: List<PromptScene>,
    modifier: Modifier = Modifier
) {
    val displayId = LocalView.current.display?.displayId

    Scaffold(
        modifier = modifier,
        containerColor = iOSBackground,
        bottomBar = {
            if (showBottomBar) {
                EmpathyBottomNavigation(
                    currentRoute = currentRoute,
                    onNavigate = onNavigate,
                    onAddClick = onAddClick
                )
            }
        },
        snackbarHost = {
            uiState.error?.let { error ->
                Snackbar(
                    action = {
                        TextButton(onClick = { onEvent(SettingsUiEvent.ClearError) }) {
                            Text("关闭")
                        }
                    }
                ) { Text(error) }
            }
            uiState.successMessage?.let { message ->
                Snackbar { Text(message) }
            }
        }
    ) { paddingValues ->
        val dimensions = AdaptiveDimensions.current
        
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .background(iOSBackground)
        ) {
            item {
                Text(
                    text = "设置",
                    fontSize = dimensions.fontSizeLargeTitle,
                    fontWeight = FontWeight.Bold,
                    color = iOSTextPrimary,
                    modifier = Modifier.padding(start = dimensions.spacingMedium, top = dimensions.spacingMedium, bottom = dimensions.spacingSmall)
                )
            }

            item {
                IOSSettingsSection(title = "AI 配置") {
                    IOSSettingsItem(
                        icon = Icons.Default.Settings,
                        iconBackgroundColor = iOSBlue,
                        title = "AI 服务商",
                        value = uiState.selectedProvider.ifEmpty { "未配置" },
                        onClick = onNavigateToAiConfig
                    )
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = iOSPurple,
                        title = "提示词设置",
                        showDivider = false,
                        onClick = {
                            onNavigateToPromptEditor(
                                PromptEditorRoutes.globalSceneWithSource(
                                    PromptScene.ANALYZE,
                                    NavRoutes.SOURCE_SETTINGS
                                )
                            )
                        }
                    )
                }
            }

            item {
                IOSSettingsSection(title = "悬浮窗") {
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = iOSGreen,
                        title = "启用悬浮窗",
                        subtitle = if (uiState.hasFloatingWindowPermission) null else "需要悬浮窗权限",
                        showArrow = false,
                        showDivider = true,
                        trailing = {
                            IOSSwitch(
                                checked = uiState.floatingWindowEnabled,
                                onCheckedChange = {
                                    android.util.Log.d(
                                        "SettingsScreen",
                                        "ToggleFloatingWindow displayId=$displayId"
                                    )
                                    onEvent(SettingsUiEvent.ToggleFloatingWindow(displayId))
                                },
                                enabled = uiState.hasFloatingWindowPermission || !uiState.floatingWindowEnabled
                            )
                        },
                        onClick = if (!uiState.hasFloatingWindowPermission) {
                            { onEvent(SettingsUiEvent.ShowPermissionDialog) }
                        } else null
                    )
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = iOSBlue,
                        title = "截图权限",
                        subtitle = if (uiState.hasScreenshotPermission) null else "需要截图权限",
                        showArrow = false,
                        showDivider = true,
                        trailing = {
                            IOSSwitch(
                                checked = uiState.hasScreenshotPermission,
                                onCheckedChange = { onEvent(SettingsUiEvent.ToggleScreenshotPermission) }
                            )
                        },
                        onClick = if (!uiState.hasScreenshotPermission) {
                            { onEvent(SettingsUiEvent.ToggleScreenshotPermission) }
                        } else null
                    )
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = iOSBlue,
                        title = "连续截屏",
                        subtitle = "1.5秒内可继续框选",
                        showArrow = false,
                        showDivider = false,
                        trailing = {
                            IOSSwitch(
                                checked = uiState.continuousScreenshotEnabled,
                                onCheckedChange = { onEvent(SettingsUiEvent.ToggleContinuousScreenshot) }
                            )
                        }
                    )
                }
            }

            item {
                IOSSettingsSection(title = "隐私保护") {
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = iOSBlue,
                        title = "数据掩码",
                        subtitle = "AI 分析前自动掩码敏感信息",
                        showArrow = false,
                        trailing = {
                            IOSSwitch(
                                checked = uiState.dataMaskingEnabled,
                                onCheckedChange = { onEvent(SettingsUiEvent.ToggleDataMasking) }
                            )
                        }
                    )
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = iOSGreen,
                        title = "本地优先模式",
                        subtitle = "优先使用本地规则，减少 AI 调用",
                        showArrow = false,
                        showDivider = false,
                        trailing = {
                            IOSSwitch(
                                checked = uiState.localFirstMode,
                                onCheckedChange = { onEvent(SettingsUiEvent.ToggleLocalFirstMode) }
                            )
                        }
                    )
                }
            }

            item {
                IOSSettingsSection(title = "个人画像") {
                    IOSSettingsItem(
                        icon = Icons.Default.Person,
                        iconBackgroundColor = iOSPurple,
                        title = "管理个人画像",
                        subtitle = "设置您的性格特点、价值观等",
                        showDivider = false,
                        onClick = onNavigateToUserProfile
                    )
                }
            }

            item {
                IOSSettingsSection(title = "数据管理") {
                    IOSSettingsItem(
                        icon = Icons.Default.Delete,
                        iconBackgroundColor = iOSPurple,
                        title = stringResource(R.string.settings_clear_advisor_drafts_title),
                        subtitle = stringResource(R.string.settings_clear_advisor_drafts_subtitle),
                        showDivider = true,
                        onClick = { onEvent(SettingsUiEvent.ShowClearAdvisorDraftsDialog) }
                    )
                    IOSSettingsItem(
                        icon = Icons.Default.Delete,
                        iconBackgroundColor = iOSRed,
                        title = "清除所有设置",
                        showDivider = false,
                        onClick = { onEvent(SettingsUiEvent.ShowClearDataDialog) }
                    )
                }
            }

            item {
                IOSSettingsSection(title = "关于") {
                    IOSSettingsItem(
                        icon = Icons.Default.Info,
                        iconBackgroundColor = Color.Gray,
                        title = "版本",
                        value = uiState.appVersion,
                        showArrow = false,
                        showDivider = false,
                        onClick = onVersionClick
                    )
                }
            }

            if (isDeveloperMode) {
                item {
                    DeveloperOptionsSection(
                        onSystemPromptEditClick = onNavigateToSystemPromptList
                    )
                }
            }

            item { Spacer(modifier = Modifier.height(dimensions.spacingXLarge)) }
        }

        if (uiState.showProviderDialog) {
            ProviderSelectionDialog(
                selectedProvider = uiState.selectedProvider,
                availableProviders = uiState.availableProviders,
                onProviderSelected = { onEvent(SettingsUiEvent.SelectProvider(it)) },
                onDismiss = { onEvent(SettingsUiEvent.HideProviderDialog) }
            )
        }

        if (uiState.showClearDataDialog) {
            IOSAlertDialog(
                title = "清除所有设置",
                message = "确定要清除以下数据吗？\n\n将被清除：\n• AI服务商配置\n• 隐私保护设置\n• 悬浮窗设置\n\n不会清除：\n• 联系人数据\n• 标签数据\n\n此操作不可恢复！",
                confirmText = "确定清除",
                dismissText = "取消",
                onConfirm = { onEvent(SettingsUiEvent.ClearAllData) },
                onDismiss = { onEvent(SettingsUiEvent.HideClearDataDialog) },
                isDestructive = true,
                showDismissButton = true
            )
        }

        if (uiState.showClearAdvisorDraftsDialog) {
            IOSAlertDialog(
                title = stringResource(R.string.settings_clear_advisor_drafts_title),
                message = stringResource(R.string.settings_clear_advisor_drafts_message),
                confirmText = stringResource(R.string.settings_clear_advisor_drafts_confirm),
                dismissText = stringResource(R.string.btn_cancel),
                onConfirm = { onEvent(SettingsUiEvent.ClearAdvisorDrafts) },
                onDismiss = { onEvent(SettingsUiEvent.HideClearAdvisorDraftsDialog) },
                isDestructive = true,
                showDismissButton = true
            )
        }

        if (uiState.showPermissionDialog) {
            IOSPermissionRequestDialog(
                onConfirm = {
                    onEvent(SettingsUiEvent.HidePermissionDialog)
                    onEvent(SettingsUiEvent.RequestFloatingWindowPermission)
                },
                onDismiss = { onEvent(SettingsUiEvent.HidePermissionDialog) }
            )
        }
    }
}
```

**修改原因**：  
1. 数据管理新增“清除草稿”入口，提升可控性。  
2. 通过确认弹窗降低误清风险。  
3. 清除草稿相关文案抽离为字符串资源，便于统一维护。  

**影响分析**：  
- 不影响其他设置项；清除仅作用于草稿。  

**替代方案**：  
- 在对话页提供入口（容易与发送操作混淆）。  

---
## 测试情况

### 已执行的测试命令
- ❌ `./gradlew.bat :domain:testDebugUnitTest --tests "*AdvisorDraft*"`：任务不存在  
- ✅ `./gradlew.bat :domain:test --tests "*AdvisorDraft*"`：通过（此前执行，含既有警告）  
- ❌ `./gradlew.bat :presentation:test --tests "*AiAdvisorChatDraftTest*"`：`--tests` 参数不支持  
- ✅ `./gradlew.bat :presentation:testDebugUnitTest --tests "*AiAdvisorChatDraftTest*"`：通过（构建耗时约 46 分钟，含既有 warning）  
- ✅ `./gradlew.bat :presentation:testDebugUnitTest --tests "*SettingsViewModelBug00070Test*"`：通过（约 45 秒）  

> 说明：构建日志包含若干已有 deprecated warning 与 Kotlin build report 提示，本次改动未新增新的编译错误。

---

---
### 8) 会话删除同步清理草稿

**修改前：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/SessionHistoryViewModel.kt
@HiltViewModel
class SessionHistoryViewModel @Inject constructor(
    private val aiAdvisorRepository: AiAdvisorRepository,
    private val contactRepository: ContactRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    fun deleteSession(sessionId: String) {
        viewModelScope.launch {
            aiAdvisorRepository.deleteSession(sessionId)
                .onSuccess {
                    loadSessions()
                }
                .onFailure { error ->
                    _uiState.update { it.copy(error = error.message ?: "删除失败") }
                }
        }
    }
}
```

**修改后：**
```kotlin
// file: presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/SessionHistoryViewModel.kt
@HiltViewModel
class SessionHistoryViewModel @Inject constructor(
    private val aiAdvisorRepository: AiAdvisorRepository,
    private val contactRepository: ContactRepository,
    private val clearAdvisorDraftUseCase: ClearAdvisorDraftUseCase,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    fun deleteSession(sessionId: String) {
        viewModelScope.launch {
            aiAdvisorRepository.deleteSession(sessionId)
                .onSuccess {
                    clearAdvisorDraftUseCase(sessionId)
                    loadSessions()
                }
                .onFailure { error ->
                    _uiState.update { it.copy(error = error.message ?: "删除失败") }
                }
        }
    }
}
```

**修改原因**：  
1. 删除会话后继续保留草稿会产生脏数据，且占用存储。  
2. 草稿生命周期应与会话一致，删除会话时同步清理更符合用户预期。  

**影响分析**：  
- 新增 UseCase 依赖，注入成本低；不会改变删除成功/失败流程。  

**替代方案**：  
- 在数据层监听会话删除事件清理草稿（复杂度更高）。  

---
---
### 9) 删除联系人同步清理草稿

**修改前：**
```kotlin
// file: domain/src/main/kotlin/com/empathy/ai/domain/usecase/DeleteContactUseCase.kt
class DeleteContactUseCase @Inject constructor(
    private val contactRepository: ContactRepository
) {
    suspend operator fun invoke(contactId: String): Result<Unit> {
        return try {
            if (contactId.isBlank()) {
                return Result.failure(IllegalArgumentException("联系人ID不能为空"))
            }

            contactRepository.deleteProfile(contactId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

**修改后：**
```kotlin
// file: domain/src/main/kotlin/com/empathy/ai/domain/usecase/DeleteContactUseCase.kt
class DeleteContactUseCase @Inject constructor(
    private val contactRepository: ContactRepository,
    private val aiAdvisorRepository: AiAdvisorRepository,
    private val clearAdvisorDraftUseCase: ClearAdvisorDraftUseCase
) {
    suspend operator fun invoke(contactId: String): Result<Unit> {
        return try {
            if (contactId.isBlank()) {
                return Result.failure(IllegalArgumentException("联系人ID不能为空"))
            }

            val sessions = aiAdvisorRepository.getSessions(contactId).getOrDefault(emptyList())
            val deleteResult = contactRepository.deleteProfile(contactId)
            if (deleteResult.isSuccess) {
                sessions.forEach { session -> clearAdvisorDraftUseCase(session.id) }
            }
            deleteResult
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

**修改原因**：  
1. 联系人删除会级联清理会话与对话，但草稿存储不在数据库中。  
2. 删除后保留草稿会形成不可见脏数据，需同步清理。  

**影响分析**：  
- 新增查询会话与草稿清理步骤，删除路径略有额外开销。  
- 清理失败不影响联系人删除结果（Best-effort）。  

**替代方案**：  
- 在数据层监听删除事件清理草稿（复杂度更高）。  

---
### 单元测试用例详述

#### TC-UT-001：获取草稿成功返回内容
**测试意图说明**：验证 UseCase 在正常读取偏好时能返回草稿内容，确保恢复逻辑的基础契约成立。该测试也验证 `Result.success` 的封装语义不被破坏。  
**边界情况说明**：使用短字符串草稿以避免长度造成误判，同时确保返回值非空。  
**我的判断**：✅ 建议保留  
**判断理由**：这是草稿恢复的核心路径，失败会直接破坏主要体验。测试稳定、低维护成本，收益高。  

**完整测试代码：**
```kotlin
// file: domain/src/test/kotlin/com/empathy/ai/domain/usecase/GetAdvisorDraftUseCaseTest.kt
@Test
fun `获取草稿成功返回内容`() = runTest {
    // Given
    val sessionId = "session-1"
    every { repository.getDraft(sessionId) } returns "draft"

    // When
    val result = useCase(sessionId)

    // Then
    assertTrue(result.isSuccess)
    assertEquals("draft", result.getOrNull())
}
```

#### TC-UT-002：获取草稿异常返回 failure
**测试意图说明**：验证偏好读取异常时 UseCase 能返回 `Result.failure`，避免异常向 UI 扩散。该测试确保异常路径可被识别。  
**边界情况说明**：通过模拟抛出异常覆盖最坏情况。  
**我的判断**：✅ 建议保留  
**判断理由**：异常路径容易被忽略，保留测试能防止后续改动移除错误处理。  

**完整测试代码：**
```kotlin
// file: domain/src/test/kotlin/com/empathy/ai/domain/usecase/GetAdvisorDraftUseCaseTest.kt
@Test
fun `获取草稿异常返回failure`() = runTest {
    // Given
    val sessionId = "session-1"
    val error = IllegalStateException("read failed")
    every { repository.getDraft(sessionId) } throws error

    // When
    val result = useCase(sessionId)

    // Then
    assertTrue(result.isFailure)
    assertEquals(error, result.exceptionOrNull())
}
```

#### TC-UT-003：保存草稿成功返回 success
**测试意图说明**：验证保存草稿成功路径，确保写入行为被正确封装。该测试保证“输入后保存”逻辑的基础可用性。  
**边界情况说明**：使用简短草稿即可覆盖路径，无需复杂输入。  
**我的判断**：✅ 建议保留  
**判断理由**：草稿保存是核心功能，测试简单稳定且能快速发现回归。  

**完整测试代码：**
```kotlin
// file: domain/src/test/kotlin/com/empathy/ai/domain/usecase/SaveAdvisorDraftUseCaseTest.kt
@Test
fun `保存草稿成功返回success`() = runTest {
    // Given
    val sessionId = "session-1"
    val draft = "draft"
    every { repository.setDraft(sessionId, draft) } returns Unit

    // When
    val result = useCase(sessionId, draft)

    // Then
    assertTrue(result.isSuccess)
}
```

#### TC-UT-004：保存草稿异常返回 failure
**测试意图说明**：验证保存草稿异常分支，确保异常不会导致崩溃。该用例覆盖存储失败场景。  
**边界情况说明**：模拟异常抛出即可覆盖失败路径。  
**我的判断**：✅ 建议保留  
**判断理由**：写入异常可能在真实设备上出现，必须被覆盖。  

**完整测试代码：**
```kotlin
// file: domain/src/test/kotlin/com/empathy/ai/domain/usecase/SaveAdvisorDraftUseCaseTest.kt
@Test
fun `保存草稿异常返回failure`() = runTest {
    // Given
    val sessionId = "session-1"
    val draft = "draft"
    val error = IllegalStateException("save failed")
    every { repository.setDraft(sessionId, draft) } throws error

    // When
    val result = useCase(sessionId, draft)

    // Then
    assertTrue(result.isFailure)
    assertEquals(error, result.exceptionOrNull())
}
```

#### TC-UT-005：清除草稿成功返回 success
**测试意图说明**：验证清除草稿的正常路径，保证“发送后清空”逻辑可落地。  
**边界情况说明**：清除逻辑输入简单，使用默认 sessionId 即可。  
**我的判断**：✅ 建议保留  
**判断理由**：清除失败会导致草稿误恢复，风险较高，需覆盖。  

**完整测试代码：**
```kotlin
// file: domain/src/test/kotlin/com/empathy/ai/domain/usecase/ClearAdvisorDraftUseCaseTest.kt
@Test
fun `清除草稿成功返回success`() = runTest {
    // Given
    val sessionId = "session-1"
    every { repository.clearDraft(sessionId) } returns Unit

    // When
    val result = useCase(sessionId)

    // Then
    assertTrue(result.isSuccess)
}
```

#### TC-UT-006：清除草稿异常返回 failure
**测试意图说明**：验证清除异常能被包装为 `Result.failure`，避免异常冒泡。  
**边界情况说明**：模拟异常抛出覆盖最坏场景。  
**我的判断**：✅ 建议保留  
**判断理由**：清除失败会导致草稿残留，存在误恢复风险。  

**完整测试代码：**
```kotlin
// file: domain/src/test/kotlin/com/empathy/ai/domain/usecase/ClearAdvisorDraftUseCaseTest.kt
@Test
fun `清除草稿异常返回failure`() = runTest {
    // Given
    val sessionId = "session-1"
    val error = IllegalStateException("clear failed")
    every { repository.clearDraft(sessionId) } throws error

    // When
    val result = useCase(sessionId)

    // Then
    assertTrue(result.isFailure)
    assertEquals(error, result.exceptionOrNull())
}
```

#### TC-UT-006a：清除全部草稿成功返回 success
**测试意图说明**：验证设置页一键清除草稿的正常路径，确保全量清除能力可用。  
**边界情况说明**：仅需模拟 `clearAllDrafts` 成功即可覆盖路径。  
**我的判断**：✅ 建议保留  
**判断理由**：清除全部草稿是破坏性操作，必须有明确的成功路径保障。  

**完整测试代码：**
```kotlin
// file: domain/src/test/kotlin/com/empathy/ai/domain/usecase/ClearAllAdvisorDraftsUseCaseTest.kt
@Test
fun `清除全部草稿成功返回success`() = runTest {
    // Given
    every { repository.clearAllDrafts() } returns Unit

    // When
    val result = useCase()

    // Then
    assertTrue(result.isSuccess)
}
```

#### TC-UT-006b：清除全部草稿异常返回 failure
**测试意图说明**：验证清除全部草稿失败时 UseCase 返回 `Result.failure`，避免异常上抛。  
**边界情况说明**：模拟异常抛出即可覆盖失败路径。  
**我的判断**：✅ 建议保留  
**判断理由**：全量清除失败需要明确反馈，否则会造成“误以为清除成功”的风险。  

**完整测试代码：**
```kotlin
// file: domain/src/test/kotlin/com/empathy/ai/domain/usecase/ClearAllAdvisorDraftsUseCaseTest.kt
@Test
fun `清除全部草稿异常返回failure`() = runTest {
    // Given
    val error = IllegalStateException("clear all failed")
    every { repository.clearAllDrafts() } throws error

    // When
    val result = useCase()

    // Then
    assertTrue(result.isFailure)
    assertEquals(error, result.exceptionOrNull())
}
```

#### TC-UT-006c：清除偏好成功返回 success
**测试意图说明**：验证清除偏好成功返回 success。  
**边界情况说明**：覆盖清除偏好调用成功路径。  
**我的判断**：✅ 建议保留  
**判断理由**：确保偏好清理用例在强清理入口可用。  

**完整测试代码：**
```kotlin
// file: domain/src/test/kotlin/com/empathy/ai/domain/usecase/ClearAdvisorPreferencesUseCaseTest.kt
@Test
fun `清除偏好成功返回success`() = runTest {
    // Given
    every { repository.clear() } returns Unit

    // When
    val result = useCase()

    // Then
    assertTrue(result.isSuccess)
}
```

#### TC-UT-006d：清除偏好异常返回 failure
**测试意图说明**：验证清除偏好异常时返回 failure。  
**边界情况说明**：覆盖异常传播。  
**我的判断**：✅ 建议保留  
**判断理由**：保证上层可处理偏好清理失败。  

**完整测试代码：**
```kotlin
// file: domain/src/test/kotlin/com/empathy/ai/domain/usecase/ClearAdvisorPreferencesUseCaseTest.kt
@Test
fun `清除偏好异常返回failure`() = runTest {
    // Given
    val error = IllegalStateException("clear failed")
    every { repository.clear() } throws error

    // When
    val result = useCase()

    // Then
    assertTrue(result.isFailure)
    assertEquals(error, result.exceptionOrNull())
}
```

#### TC-UT-007：updateInput 触发延迟保存草稿
**测试意图说明**：验证 Debounce 保存逻辑生效，确保输入更新后能持久化。该测试覆盖草稿保存链路关键路径。  
**边界情况说明**：通过 `advanceTimeBy` 快进时间避免真实等待。  
**我的判断**：✅ 建议保留  
**判断理由**：Debounce 是性能优化关键点，缺失会导致频繁写入。  

**完整测试代码：**
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatDraftTest.kt
@Test
fun `updateInput 触发延迟保存草稿`() = runTest {
    // Given
    val sessionId = "session-1"
    coEvery { getAdvisorDraftUseCase(sessionId) } returns Result.success(null)
    coEvery { saveAdvisorDraftUseCase(sessionId, "你好") } returns Result.success(Unit)

    val viewModel = createViewModel()

    // When
    viewModel.switchSession(sessionId)
    testDispatcher.scheduler.runCurrent()
    viewModel.updateInput("你好")
    advanceTimeBy(400)
    advanceUntilIdle()

    // Then
    coVerify { saveAdvisorDraftUseCase(sessionId, "你好") }
}
```

#### TC-UT-008：切换会话时恢复草稿
**测试意图说明**：验证会话切换触发草稿恢复，确保会话级恢复策略有效。  
**边界情况说明**：使用固定 sessionId 与草稿内容，避免调度干扰。  
**我的判断**：✅ 建议保留  
**判断理由**：恢复逻辑是核心体验，一旦失效用户立即感知。  

**完整测试代码：**
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatDraftTest.kt
@Test
fun `切换会话时恢复草稿`() = runTest {
    // Given
    val sessionId = "session-2"
    coEvery { getAdvisorDraftUseCase(sessionId) } returns Result.success("草稿内容")

    val viewModel = createViewModel()

    // When
    viewModel.switchSession(sessionId)
    testDispatcher.scheduler.runCurrent()

    // Then
    assertEquals("草稿内容", viewModel.uiState.value.inputText)
}
```

#### TC-UT-009：恢复草稿时显示提示
**测试意图说明**：验证恢复草稿时提示条被设置，保证可感知性。该用例覆盖新增提示逻辑。  
**边界情况说明**：使用非空草稿，确保提示触发条件成立。  
**我的判断**：✅ 建议保留  
**判断理由**：提示条是新的可视化反馈，必须有测试保护。  

**完整测试代码：**
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatDraftTest.kt
@Test
fun `切换会话恢复草稿时显示提示`() = runTest {
    // Given
    val sessionId = "session-3"
    coEvery { getAdvisorDraftUseCase(sessionId) } returns Result.success("草稿内容")

    val viewModel = createViewModel()

    // When
    viewModel.switchSession(sessionId)
    testDispatcher.scheduler.runCurrent()

    // Then
    assertEquals("草稿内容", viewModel.uiState.value.inputText)
    assertEquals(
        R.string.advisor_draft_restored_message,
        viewModel.uiState.value.draftRestoredMessageResId
    )
}
```

#### TC-UT-009a：草稿恢复提示自动关闭
**测试意图说明**：验证恢复提示在指定延迟后自动清理，避免提示条长期占位。  
**边界情况说明**：仅在恢复成功后推进时间，确保自动关闭逻辑可触达。  
**我的判断**：✅ 建议保留  
**判断理由**：自动收起是体验优化点，需避免回归。  

**完整测试代码：**
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatDraftTest.kt
@Test
fun `草稿恢复提示自动关闭`() = runTest {
    // Given
    val sessionId = "session-4"
    coEvery { getAdvisorDraftUseCase(sessionId) } returns Result.success("草稿内容")

    val viewModel = createViewModel()

    // When
    viewModel.switchSession(sessionId)
    testDispatcher.scheduler.runCurrent()

    // Then
    assertEquals(
        R.string.advisor_draft_restored_message,
        viewModel.uiState.value.draftRestoredMessageResId
    )
    advanceTimeBy(3000)
    testDispatcher.scheduler.runCurrent()
    assertNull(viewModel.uiState.value.draftRestoredMessageResId)
}
```

#### TC-UT-010：更新输入后清除提示
**测试意图说明**：验证用户继续输入时提示条被清理，避免长期占位。  
**边界情况说明**：先触发恢复，再输入新文本，覆盖“提示清理”路径。  
**我的判断**：✅ 建议保留  
**判断理由**：提示条若不清理会影响体验，需要保障。  

**完整测试代码：**
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatDraftTest.kt
@Test
fun `更新输入后清除草稿恢复提示`() = runTest {
    // Given
    val sessionId = "session-5"
    coEvery { getAdvisorDraftUseCase(sessionId) } returns Result.success("草稿内容")

    val viewModel = createViewModel()
    viewModel.switchSession(sessionId)
    testDispatcher.scheduler.runCurrent()

    // When
    viewModel.updateInput("新的输入")

    // Then
    assertNull(viewModel.uiState.value.draftRestoredMessageResId)
}
```

#### TC-UT-011：设置页清除草稿成功
**测试意图说明**：验证设置页触发清除草稿时，UseCase 被调用并提示成功消息。  
**边界情况说明**：不依赖真实存储，仅验证调用链和 UI 状态更新。  
**我的判断**：✅ 建议保留  
**判断理由**：清除入口涉及破坏性操作，必须确保逻辑正确。  

**完整测试代码：**
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/SettingsViewModelBug00070Test.kt
@Test
fun `clear advisor drafts should clear data and show success message`() = runTest {
    // Given
    coEvery { mockClearAllAdvisorDraftsUseCase() } returns Result.success(Unit)
    every {
        mockApplication.getString(R.string.settings_clear_advisor_drafts_success)
    } returns "AI 军师草稿已清除"
    val viewModel = createViewModel()

    // When
    viewModel.onEvent(SettingsUiEvent.ShowClearAdvisorDraftsDialog)
    viewModel.onEvent(SettingsUiEvent.ClearAdvisorDrafts)
    testDispatcher.scheduler.advanceUntilIdle()

    // Then
    coVerify { mockClearAllAdvisorDraftsUseCase() }
    assertFalse(viewModel.uiState.value.showClearAdvisorDraftsDialog)
    assertEquals("AI 军师草稿已清除", viewModel.uiState.value.successMessage)
}
```

#### TC-UT-011b：设置页清除草稿失败提示
**测试意图说明**：验证清除草稿失败时显示资源化错误提示，确保异常不被吞没。  
**边界情况说明**：异常不包含 message，触发资源兜底文案。  
**我的判断**：✅ 建议保留  
**判断理由**：失败提示是破坏性操作的必要反馈，避免误以为清除成功。  

**完整测试代码：**
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/SettingsViewModelBug00070Test.kt
@Test
fun `clear advisor drafts failure should show error message`() = runTest {
    // Given
    val error = IllegalStateException()
    coEvery { mockClearAllAdvisorDraftsUseCase() } returns Result.failure(error)
    every {
        mockApplication.getString(R.string.settings_clear_advisor_drafts_failed)
    } returns "清除草稿失败"
    val viewModel = createViewModel()

    // When
    viewModel.onEvent(SettingsUiEvent.ShowClearAdvisorDraftsDialog)
    viewModel.onEvent(SettingsUiEvent.ClearAdvisorDrafts)
    testDispatcher.scheduler.advanceUntilIdle()

    // Then
    coVerify { mockClearAllAdvisorDraftsUseCase() }
    assertEquals("清除草稿失败", viewModel.uiState.value.error)
}
```

#### TC-UT-011c：设置页清除草稿失败空消息兜底
**测试意图说明**：验证失败异常 message 为空时仍能使用资源兜底文案。  
**边界情况说明**：构造 `IllegalStateException("")` 覆盖空字符串路径。  
**我的判断**：✅ 建议保留  
**判断理由**：避免空文案导致用户无感知失败。  

**完整测试代码：**
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/SettingsViewModelBug00070Test.kt
@Test
fun `clear advisor drafts failure should fallback when error message is blank`() = runTest {
    // Given
    val error = IllegalStateException("")
    coEvery { mockClearAllAdvisorDraftsUseCase() } returns Result.failure(error)
    every {
        mockApplication.getString(R.string.settings_clear_advisor_drafts_failed)
    } returns "清除草稿失败"
    val viewModel = createViewModel()

    // When
    viewModel.onEvent(SettingsUiEvent.ShowClearAdvisorDraftsDialog)
    viewModel.onEvent(SettingsUiEvent.ClearAdvisorDrafts)
    testDispatcher.scheduler.advanceUntilIdle()

    // Then
    assertEquals("清除草稿失败", viewModel.uiState.value.error)
}
```

#### TC-UT-012：清除所有设置时清理偏好
**测试意图说明**：验证“清除所有设置”时清理偏好（含草稿与最近联系人）。  
**边界情况说明**：偏好清理失败可回退草稿清理。  
**我的判断**：✅ 建议保留  
**判断理由**：强清理入口需覆盖可恢复偏好。  

**完整测试代码：**
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/SettingsViewModelBug00070Test.kt
@Test
fun `clear all data should clear advisor preferences`() = runTest {
    // Given
    coEvery { mockClearAdvisorPreferencesUseCase() } returns Result.success(Unit)
    coEvery { mockSettingsRepository.setDataMaskingEnabled(true) } returns Result.success(Unit)
    coEvery { mockSettingsRepository.setLocalFirstModeEnabled(true) } returns Result.success(Unit)
    every { mockPreferencesRepository.saveEnabled(false) } just Runs
    every { mockPreferencesRepository.saveContinuousScreenshotEnabled(false) } just Runs
    val viewModel = createViewModel()

    // When
    viewModel.onEvent(SettingsUiEvent.ClearAllData)
    testDispatcher.scheduler.advanceUntilIdle()

    // Then
    coVerify { mockClearAdvisorPreferencesUseCase() }
    assertEquals("所有设置已清除", viewModel.uiState.value.successMessage)
}
```

#### TC-UT-013：清除所有设置偏好失败回退清草稿
**测试意图说明**：验证偏好清理失败时回退执行草稿清理。  
**边界情况说明**：偏好清理失败不影响成功提示。  
**我的判断**：✅ 建议保留  
**判断理由**：偏好失败时仍需尽量清理草稿。  

**完整测试代码：**
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/SettingsViewModelBug00070Test.kt
@Test
fun `clear all data should fallback to clear drafts when preferences fail`() = runTest {
    // Given
    coEvery { mockClearAdvisorPreferencesUseCase() } returns Result.failure(IllegalStateException("prefs fail"))
    coEvery { mockClearAllAdvisorDraftsUseCase() } returns Result.success(Unit)
    coEvery { mockSettingsRepository.setDataMaskingEnabled(true) } returns Result.success(Unit)
    coEvery { mockSettingsRepository.setLocalFirstModeEnabled(true) } returns Result.success(Unit)
    every { mockPreferencesRepository.saveEnabled(false) } just Runs
    every { mockPreferencesRepository.saveContinuousScreenshotEnabled(false) } just Runs
    val viewModel = createViewModel()

    // When
    viewModel.onEvent(SettingsUiEvent.ClearAllData)
    testDispatcher.scheduler.advanceUntilIdle()

    // Then
    coVerify { mockClearAdvisorPreferencesUseCase() }
    coVerify { mockClearAllAdvisorDraftsUseCase() }
    assertEquals("所有设置已清除", viewModel.uiState.value.successMessage)
}
```

#### TC-UT-014：清除所有设置时草稿清理失败不影响结果
**测试意图说明**：验证草稿清理失败不影响“清除所有设置”结果。  
**边界情况说明**：草稿清理返回 failure 仍需成功提示。  
**我的判断**：✅ 建议保留  
**判断理由**：草稿清理是附属流程，应保持主流程稳定。  

**完整测试代码：**
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/SettingsViewModelBug00070Test.kt
@Test
fun `clear all data should succeed even when clear drafts fails`() = runTest {
    // Given
    coEvery { mockClearAdvisorPreferencesUseCase() } returns Result.failure(IllegalStateException("prefs fail"))
    coEvery { mockClearAllAdvisorDraftsUseCase() } returns Result.failure(IllegalStateException("draft fail"))
    coEvery { mockSettingsRepository.setDataMaskingEnabled(true) } returns Result.success(Unit)
    coEvery { mockSettingsRepository.setLocalFirstModeEnabled(true) } returns Result.success(Unit)
    every { mockPreferencesRepository.saveEnabled(false) } just Runs
    every { mockPreferencesRepository.saveContinuousScreenshotEnabled(false) } just Runs
    val viewModel = createViewModel()

    // When
    viewModel.onEvent(SettingsUiEvent.ClearAllData)
    testDispatcher.scheduler.advanceUntilIdle()

    // Then
    coVerify { mockClearAdvisorPreferencesUseCase() }
    coVerify { mockClearAllAdvisorDraftsUseCase() }
    assertEquals("所有设置已清除", viewModel.uiState.value.successMessage)
}
```

#### TC-UT-015：删除会话时清除草稿
**测试意图说明**：验证删除会话后同步清理草稿，避免残留草稿占用存储。  
**边界情况说明**：会话删除成功但草稿清理失败不应阻断删除流程。  
**我的判断**：✅ 建议保留  
**判断理由**：草稿与会话生命周期一致，删除时清理可以避免脏数据堆积。  

**完整测试代码：**
```kotlin
// file: presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/SessionHistoryViewModelDraftTest.kt
@Test
fun `delete session should clear draft`() = runTest {
    // Given
    val sessionId = "session-1"
    coEvery { aiAdvisorRepository.deleteSession(sessionId) } returns Result.success(Unit)
    coEvery { clearAdvisorDraftUseCase(sessionId) } returns Result.success(Unit)
    val viewModel = createViewModel()

    // When
    viewModel.deleteSession(sessionId)
    advanceUntilIdle()

    // Then
    coVerify { clearAdvisorDraftUseCase(sessionId) }
}
```

#### TC-UT-016：删除联系人清理会话草稿
**测试意图说明**：验证联系人删除成功后同步清理其会话草稿。  
**边界情况说明**：会话列表获取失败时仍允许删除联系人。  
**我的判断**：✅ 建议保留  
**判断理由**：联系人级删除是草稿清理的最后防线。  

**完整测试代码：**
```kotlin
// file: domain/src/test/kotlin/com/empathy/ai/domain/usecase/DeleteContactUseCaseTest.kt
@Test
fun `删除联系人成功后清理会话草稿`() = runTest {
    // Given
    val contactId = "contact-1"
    val sessions = listOf(
        AiAdvisorSession(
            id = "session-1",
            contactId = contactId,
            title = "s1",
            messageCount = 0,
            createdAt = 1L,
            updatedAt = 1L
        )
    )
    coEvery { aiAdvisorRepository.getSessions(contactId) } returns Result.success(sessions)
    coEvery { contactRepository.deleteProfile(contactId) } returns Result.success(Unit)
    coEvery { clearAdvisorDraftUseCase(any()) } returns Result.success(Unit)
    val result = useCase(contactId)

    // Then
    assertTrue(result.isSuccess)
    coVerify { clearAdvisorDraftUseCase("session-1") }
}
```

#### TC-UT-017：清理草稿失败不影响联系人删除
**测试意图说明**：验证草稿清理失败时不影响联系人删除结果。  
**边界情况说明**：草稿清理返回 failure 仍应保持删除成功。  
**我的判断**：✅ 建议保留  
**判断理由**：草稿清理是附属流程，不应影响核心删除路径。  

**完整测试代码：**
```kotlin
// file: domain/src/test/kotlin/com/empathy/ai/domain/usecase/DeleteContactUseCaseTest.kt
@Test
fun `清理草稿失败不影响联系人删除结果`() = runTest {
    // Given
    val contactId = "contact-1"
    val sessions = listOf(
        AiAdvisorSession(
            id = "session-1",
            contactId = contactId,
            title = "s1",
            messageCount = 0,
            createdAt = 1L,
            updatedAt = 1L
        )
    )
    coEvery { aiAdvisorRepository.getSessions(contactId) } returns Result.success(sessions)
    coEvery { contactRepository.deleteProfile(contactId) } returns Result.success(Unit)
    coEvery { clearAdvisorDraftUseCase(any()) } returns Result.failure(Exception("draft failed"))

    // When
    val result = useCase(contactId)

    // Then
    assertTrue(result.isSuccess)
    coVerify { clearAdvisorDraftUseCase("session-1") }
}
```

---
## 验证记录

- `./gradlew.bat :domain:test --tests "*AdvisorDraft*"` -> `BUILD SUCCESSFUL`
- `./gradlew.bat :presentation:testDebugUnitTest --tests "*AiAdvisorChatDraftTest*"` -> `BUILD SUCCESSFUL`
- `./gradlew.bat :presentation:testDebugUnitTest --tests "*SettingsViewModelBug00070Test*"` -> `BUILD SUCCESSFUL`
- `./gradlew.bat :presentation:testDebugUnitTest --tests "*SettingsViewModelBug00070Test*"` -> `BUILD SUCCESSFUL`（新增失败路径用例后复跑）
- `./gradlew.bat :presentation:testDebugUnitTest --tests "*SettingsViewModelBug00070Test*"` -> `BUILD SUCCESSFUL`（03:20 复跑）
- 首次运行 `./gradlew.bat :presentation:testDebugUnitTest --tests "*SessionHistoryViewModelDraftTest*"` 编译失败：`SessionHistoryViewModelTest` 缺少 `clearAdvisorDraftUseCase` 参数；已补齐后复跑通过。
- `./gradlew.bat :presentation:testDebugUnitTest --tests "*SessionHistoryViewModelDraftTest*"` -> `BUILD SUCCESSFUL`（03:40 复跑）
- `./gradlew.bat :domain:test --tests "*DeleteContactUseCaseTest*"` -> `BUILD SUCCESSFUL`（03:53 复跑）
- `./gradlew.bat :domain:test --tests "*DeleteContactUseCaseTest*"` -> `BUILD SUCCESSFUL`（03:57 复跑，新增草稿清理失败用例）
- `./gradlew.bat :presentation:testDebugUnitTest --tests "*SettingsViewModelBug00070Test*"` -> `BUILD SUCCESSFUL`（04:13 复跑，新增清除设置清理草稿用例）
- `./gradlew.bat :presentation:testDebugUnitTest --tests "*SettingsViewModelBug00070Test*"` -> `BUILD SUCCESSFUL`（04:18 复跑，新增清除设置失败兜底用例）
- `./gradlew.bat :domain:test --tests "*ClearAdvisorPreferencesUseCaseTest*"` -> `BUILD SUCCESSFUL`（04:30 复跑）
- `./gradlew.bat :presentation:testDebugUnitTest --tests "*SettingsViewModelBug00070Test*"` -> `BUILD SUCCESSFUL`（04:36 复跑，新增清理偏好回退用例）
- 观察到的编译/测试警告（非本次改动引入）：
  - `CheckDraftUseCase.kt` 与 `SystemPrompts.kt` 存在 deprecated 枚举提示（历史遗留）。
  - `ContextBuilder.kt` 的 `PromptTemplates` deprecated 提示（历史遗留）。
  - `AiResultTest.kt`、`MinimizeErrorTest.kt`、`PromptErrorTest.kt`、`SystemPromptsTest.kt` 出现 “Check for instance is always 'true'” 警告。
  - presentation 测试中存在既有 “Check for instance is always 'true'” 及 Windows 文件名警告（历史遗留）。
  - presentation 编译提示 `Icons.Filled.Sort/ArrowBack` 已废弃，建议后续替换 `Icons.AutoMirrored.*`（历史遗留）。

---
## 成果清单

### A类：文档/报告（直接合并）
- [x] `文档/开发文档/MA/FREE/FREE-20260119-AI军师草稿自动保存与恢复.md`
- [x] `文档/开发文档/TE/TE-00077-AI军师草稿自动保存测试用例.md`

### B类：测试用例（建议保留）
| 测试文件 | 新增用例数 | 我的判断 | 理由 |
|---------|------------|---------|------|
| GetAdvisorDraftUseCaseTest.kt | 2 | ✅ 建议保留 | 覆盖读取成功/失败 |
| SaveAdvisorDraftUseCaseTest.kt | 2 | ✅ 建议保留 | 覆盖写入成功/失败 |
| ClearAdvisorDraftUseCaseTest.kt | 2 | ✅ 建议保留 | 覆盖清除成功/失败 |
| ClearAllAdvisorDraftsUseCaseTest.kt | 2 | ✅ 建议保留 | 覆盖清除全部成功/失败 |
| ClearAdvisorPreferencesUseCaseTest.kt | 2 | ✅ 建议保留 | 覆盖清除偏好成功/失败 |
| AiAdvisorChatDraftTest.kt | 5 | ✅ 建议保留 | 覆盖保存、恢复、提示清理 |
| SettingsViewModelBug00070Test.kt | 6 | ✅ 建议保留 | 覆盖清除草稿与清空设置 |
| SessionHistoryViewModelDraftTest.kt | 1 | ✅ 建议保留 | 覆盖删除会话清理草稿 |
| DeleteContactUseCaseTest.kt | 5 | ✅ 建议保留 | 覆盖删除联系人后清理草稿 |

### C类：功能实现（建议合并）
| 文件 | 修改内容 | 风险等级 |
|------|----------|---------|
| AiAdvisorPreferencesRepository.kt | 草稿接口 + clearAllDrafts | 低 |
| AiAdvisorPreferences.kt | 草稿持久化与清除逻辑 | 中 |
| Get/Save/Clear/ClearAllAdvisorDraftUseCase.kt | 草稿用例封装 | 低 |
| ClearAdvisorPreferencesUseCase.kt | 清除偏好用例封装 | 低 |
| AiAdvisorChatViewModel.kt | 草稿保存/恢复/提示 | 中 |
| AiAdvisorChatScreen.kt | 草稿恢复提示条 | 低 |
| strings.xml | 草稿提示/清除文案资源化 | 低 |
| SettingsUiEvent.kt | 草稿清除事件 | 低 |
| SettingsUiState.kt | 清除弹窗状态 | 低 |
| SettingsViewModel.kt | 草稿清除逻辑 + 清除设置清理偏好 | 中 |
| SettingsScreen.kt | 清除草稿入口与弹窗 | 低 |
| SessionHistoryViewModel.kt | 删除会话同步清理草稿 | 低 |
| DeleteContactUseCase.kt | 删除联系人同步清理草稿 | 低 |

### D类：重构（需详细审查）
- 无

---

## 合并建议
**建议合并** ✅  
草稿自动保存/恢复显著改善 AI 军师多会话切换体验，并且新增提示条与设置页清除入口增强了可感知性与可控性。改动集中在偏好存储与 ViewModel/UI 逻辑，未引入新的存储层或迁移，风险可控。单元测试已覆盖草稿读写、恢复提示、清除入口等关键路径。建议在合并前进行一次人工 UI 回归，验证提示条显示时机与弹窗流程。

---

## 后续工作
1. 将设置页其他历史硬编码文案逐步迁移到字符串资源，保持文案统一入口。
2. 评估自动关闭时长是否合适（当前 3 秒），根据反馈调整。
3. 根据真实使用情况调整 `MAX_DRAFT_COUNT` 与 Debounce 时间。

---

## 报告质量自检

### 字数检查
- [x] 总字数达到最低要求（约 4000+ 字，要求 2000 字）
- [x] 代码行数达到最低要求（约 400+ 行，要求 50 行）

### 内容完整性
- [x] 所有必须章节都已填写
- [x] 每个代码变更包含修改前 + 修改后
- [x] 每个测试包含完整代码与判断理由
- [x] 探索过程记录了所有尝试（包含失败）

### 自包含检查
- [x] 删除分支后，仅凭报告能理解全部变更
- [x] 所有代码片段均标注文件路径

### 可操作性检查
- [x] 成果清单按 A/B/C/D 分类
- [x] 合并建议与后续工作明确
