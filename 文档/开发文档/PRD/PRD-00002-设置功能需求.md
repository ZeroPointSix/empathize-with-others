# PRD-00002-设置功能需求

## 文档信息

- **文档编号**: PRD-00002
- **文档版本**: v2.0
- **创建日期**: 2024-12-12
- **最后更新**: 2024-12-12
- **状态**: 已优化 - 待评审
- **负责人**: Claude (文档编写) / Kiro (代码实现) / Roo (代码审查)

---

## 1. 需求概述

### 1.1 背景

共情AI助手已经实现了核心的AI分析、联系人管理、标签系统等功能。目前设置页面的基础框架已经完成，包括：
- ✅ AI服务商选择和管理
- ✅ 隐私保护设置（数据掩码、本地优先模式）
- ✅ 悬浮窗功能控制
- ✅ 基本的关于信息

### 1.2 目标

本次需求旨在**完善和优化现有设置功能**，确保MVP阶段的设置功能完整、易用、稳定。

### 1.3 MVP范围

**本次实现范围**：
- ✅ 优化现有AI服务商配置体验
- ✅ 完善隐私保护设置的持久化存储
- ✅ 优化悬浮窗设置的用户体验
- ✅ 补充关于信息的完整内容

**明确不包含**（后续版本）：
- ❌ 主题设置（深色/浅色模式）
- ❌ 字体大小调节
- ❌ 通知设置
- ❌ 数据导入导出
- ❌ 多语言支持

---

## 2. 用户故事

### 2.1 首次使用配置

**作为** 新用户  
**我想要** 在首次打开应用时被引导配置AI服务商  
**以便** 能立即开始使用AI功能

**验收标准**：
- [ ] 未配置服务商时，设置页面显示明显的提示卡片
- [ ] 提示卡片包含"管理AI服务商"按钮
- [ ] 点击按钮能正确跳转到AI服务商配置页面
- [ ] 配置完成后返回设置页面，显示已选择的服务商

### 2.2 切换AI服务商

**作为** 已配置多个服务商的用户  
**我想要** 快速切换默认使用的AI服务商  
**以便** 根据不同场景选择合适的AI模型

**验收标准**：
- [ ] 能看到当前默认服务商的名称
- [ ] 点击服务商卡片弹出选择对话框
- [ ] 对话框显示所有已配置的服务商列表
- [ ] 选择后立即生效，显示成功提示
- [ ] 切换后的服务商在AI分析时被使用

### 2.3 隐私保护控制

**作为** 注重隐私的用户  
**我想要** 控制数据掩码和本地优先模式  
**以便** 保护我的敏感信息不被发送到云端

**验收标准**：
- [ ] 能清楚看到"数据掩码"和"本地优先模式"两个开关
- [ ] 每个开关都有清晰的说明文字
- [ ] 开关状态能正确保存和恢复
- [ ] 数据掩码开启时，AI分析前会自动脱敏
- [ ] 本地优先模式开启时，优先使用本地规则

### 2.4 悬浮窗管理

**作为** 用户  
**我想要** 方便地启用或禁用悬浮窗功能  
**以便** 根据需要控制悬浮窗的显示

**验收标准**：
- [ ] 能看到悬浮窗权限状态（已授权/未授权）
- [ ] 未授权时，点击开关显示权限说明对话框
- [ ] 对话框提供跳转到系统设置的引导
- [ ] 已授权时，开关能正常启动/停止悬浮窗服务
- [ ] 应用重启后能恢复上次的悬浮窗状态

---

## 3. 功能需求

### 3.1 AI服务商配置

**重要说明**：API Key管理已在AI服务商配置模块中统一实现，设置页面仅提供服务商切换和管理入口。

#### 3.1.1 当前状态显示

**需求描述**：
- 显示当前默认AI服务商的名称
- 显示服务商配置状态（已配置/未配置）
- 提供跳转到服务商管理页面的入口

**交互设计**：
```
┌─────────────────────────────────┐
│ AI 服务商                        │
├─────────────────────────────────┤
│ ┌─────────────────────────────┐ │
│ │ 当前服务商                   │ │
│ │ DeepSeek              [>]   │ │
│ └─────────────────────────────┘ │
│                                 │
│ [管理 AI 服务商]                │
│                                 │
│ 提示：您可以添加多个 AI 服务商， │
│ 每个服务商有独立的 API Key 和   │
│ 模型配置                        │
└─────────────────────────────────┘
```

**技术实现**：
- 从`AiProviderRepository`加载所有服务商
- 查找`isDefault=true`的服务商作为当前选择
- 使用`StateFlow`管理服务商列表状态
- API Key存储在`AiProviderEntity`中，使用`EncryptedSharedPreferences`加密

#### 3.1.2 服务商切换

**需求描述**：
- 点击服务商卡片弹出选择对话框
- 对话框显示所有已配置的服务商
- 使用单选按钮选择服务商
- 选择后立即生效

**交互设计**：
```
┌─────────────────────────────────┐
│ 选择 AI 服务商                   │
├─────────────────────────────────┤
│ ○ OpenAI                        │
│   gpt-4-turbo                   │
│                                 │
│ ● DeepSeek                      │
│   deepseek-chat                 │
│                                 │
│ ○ Claude                        │
│   claude-3-opus                 │
├─────────────────────────────────┤
│                        [关闭]   │
└─────────────────────────────────┘
```

**技术实现流程**：

1. **加载服务商列表**：
```kotlin
// 在 SettingsViewModel 中
private fun loadProviders() {
    viewModelScope.launch {
        aiProviderRepository.getAllProviders().collect { providers ->
            val providerNames = providers.map { it.name }
            val defaultProvider = providers.find { it.isDefault }
            
            _uiState.update {
                it.copy(
                    availableProviders = providerNames,
                    providersList = providers,
                    selectedProvider = defaultProvider?.name ?: ""
                )
            }
        }
    }
}
```

2. **切换默认服务商**：
```kotlin
// 在 SettingsViewModel 中
private fun selectProvider(providerName: String) {
    viewModelScope.launch {
        // 从已加载的列表中查找服务商
        val provider = _uiState.value.providersList.find { it.name == providerName }
        
        if (provider == null) {
            _uiState.update { it.copy(error = "服务商不存在") }
            return@launch
        }
        
        // 设置为默认服务商
        aiProviderRepository.setDefaultProvider(provider.id).onSuccess {
            _uiState.update {
                it.copy(
                    selectedProvider = providerName,
                    showProviderDialog = false,
                    successMessage = "AI 服务商已切换为 $providerName"
                )
            }
        }.onFailure { error ->
            _uiState.update { it.copy(error = "切换失败: ${error.message}") }
        }
    }
}
```

3. **跳转到服务商管理**：
```kotlin
// 在 SettingsScreen 中
OutlinedButton(
    onClick = onNavigateToAiConfig,  // 导航到 AiConfigScreen
    modifier = Modifier.fillMaxWidth()
) {
    Icon(imageVector = Icons.Default.Settings, contentDescription = null)
    Spacer(modifier = Modifier.width(8.dp))
    Text("管理 AI 服务商")
}
```

**注意事项**：
- API Key的添加、编辑、删除都在`AiConfigScreen`中完成
- 设置页面只负责切换默认服务商
- 服务商数据使用`Flow`实时同步，无需手动刷新

#### 3.1.3 未配置提示

**需求描述**：
- 当没有配置任何服务商时显示提示卡片
- 提供跳转到服务商管理的按钮

**交互设计**：
```
┌─────────────────────────────────┐
│ AI 服务商                        │
├─────────────────────────────────┤
│ ┌─────────────────────────────┐ │
│ │ ℹ️ 尚未配置 AI 服务商        │ │
│ │ 请先添加至少一个 AI 服务商   │ │
│ │ 才能使用 AI 功能             │ │
│ └─────────────────────────────┘ │
│                                 │
│ [管理 AI 服务商]                │
└─────────────────────────────────┘
```

### 3.2 隐私保护设置

#### 3.2.1 数据掩码开关

**需求描述**：
- 控制是否在AI分析前自动掩码敏感信息
- 默认开启
- 状态持久化保存到SharedPreferences

**功能说明**：
- 开启时：手机号、身份证号、邮箱等敏感信息会被替换为占位符
- 关闭时：原始数据直接发送给AI（不推荐）

**持久化实现细节**：

1. **存储方案**：
   - 使用`SharedPreferences`存储（非敏感配置）
   - 文件名：`privacy_settings`
   - 键名：`privacy_data_masking_enabled`
   - 默认值：`true`

2. **Repository层实现**：
```kotlin
// 在 SettingsRepositoryImpl 中添加方法
suspend fun getDataMaskingEnabled(): Result<Boolean> {
    return try {
        val prefs = context.getSharedPreferences("privacy_settings", Context.MODE_PRIVATE)
        Result.success(prefs.getBoolean("privacy_data_masking_enabled", true))
    } catch (e: Exception) {
        Result.failure(e)
    }
}

suspend fun setDataMaskingEnabled(enabled: Boolean): Result<Unit> {
    return try {
        context.getSharedPreferences("privacy_settings", Context.MODE_PRIVATE)
            .edit()
            .putBoolean("privacy_data_masking_enabled", enabled)
            .apply()
        Result.success(Unit)
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

3. **ViewModel层调用**：
```kotlin
// 在 SettingsViewModel 中
private fun loadSettings() {
    viewModelScope.launch {
        settingsRepository.getDataMaskingEnabled().onSuccess { enabled ->
            _uiState.update { it.copy(dataMaskingEnabled = enabled) }
        }
    }
}

private fun toggleDataMasking() {
    viewModelScope.launch {
        val newValue = !_uiState.value.dataMaskingEnabled
        settingsRepository.setDataMaskingEnabled(newValue).onSuccess {
            _uiState.update { it.copy(dataMaskingEnabled = newValue) }
        }.onFailure { error ->
            _uiState.update { it.copy(error = "保存设置失败: ${error.message}") }
        }
    }
}
```

4. **业务逻辑集成**：
```kotlin
// 在 PrivacyEngine 中读取设置
class PrivacyEngine @Inject constructor(
    private val settingsRepository: SettingsRepository
) {
    suspend fun maskSensitiveData(text: String): String {
        val enabled = settingsRepository.getDataMaskingEnabled().getOrDefault(true)
        if (!enabled) {
            return text  // 未启用，直接返回原文
        }
        // 执行掩码逻辑
        return applyMasking(text)
    }
}
```

#### 3.2.2 本地优先模式

**需求描述**：
- 控制是否优先使用本地规则引擎
- 默认开启
- 状态持久化保存到SharedPreferences

**功能说明**：
- 开启时：安全检查优先使用本地关键词匹配，减少AI调用
- 关闭时：所有检查都通过AI进行（更准确但更慢）

**持久化实现细节**：

1. **存储方案**：
   - 使用`SharedPreferences`存储
   - 文件名：`privacy_settings`（与数据掩码共用）
   - 键名：`privacy_local_first_mode_enabled`
   - 默认值：`true`

2. **Repository层实现**：
```kotlin
// 在 SettingsRepositoryImpl 中添加方法
suspend fun getLocalFirstModeEnabled(): Result<Boolean> {
    return try {
        val prefs = context.getSharedPreferences("privacy_settings", Context.MODE_PRIVATE)
        Result.success(prefs.getBoolean("privacy_local_first_mode_enabled", true))
    } catch (e: Exception) {
        Result.failure(e)
    }
}

suspend fun setLocalFirstModeEnabled(enabled: Boolean): Result<Unit> {
    return try {
        context.getSharedPreferences("privacy_settings", Context.MODE_PRIVATE)
            .edit()
            .putBoolean("privacy_local_first_mode_enabled", enabled)
            .apply()
        Result.success(Unit)
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

3. **ViewModel层调用**：
```kotlin
// 在 SettingsViewModel 中
private fun loadSettings() {
    viewModelScope.launch {
        settingsRepository.getLocalFirstModeEnabled().onSuccess { enabled ->
            _uiState.update { it.copy(localFirstMode = enabled) }
        }
    }
}

private fun toggleLocalFirstMode() {
    viewModelScope.launch {
        val newValue = !_uiState.value.localFirstMode
        settingsRepository.setLocalFirstModeEnabled(newValue).onSuccess {
            _uiState.update { it.copy(localFirstMode = newValue) }
        }.onFailure { error ->
            _uiState.update { it.copy(error = "保存设置失败: ${error.message}") }
        }
    }
}
```

4. **业务逻辑集成**：
```kotlin
// 在 CheckDraftUseCase 中读取设置
class CheckDraftUseCase @Inject constructor(
    private val settingsRepository: SettingsRepository,
    private val aiRepository: AiRepository,
    private val ruleEngine: RuleEngine
) {
    suspend operator fun invoke(draft: String): Result<SafetyCheckResult> {
        val localFirstEnabled = settingsRepository.getLocalFirstModeEnabled().getOrDefault(true)
        
        if (localFirstEnabled) {
            // 先使用本地规则检查
            val localResult = ruleEngine.checkSafety(draft)
            if (localResult.isSafe) {
                return Result.success(localResult)
            }
        }
        
        // 使用AI检查
        return aiRepository.checkDraftSafety(draft)
    }
}
```

**设置变更通知机制**：
- 设置变更后立即保存到SharedPreferences
- 业务逻辑在使用时实时读取最新设置
- 无需额外的观察者模式或事件总线
- 保证设置变更立即生效

### 3.3 悬浮窗设置

#### 3.3.1 权限检测

**需求描述**：
- 自动检测悬浮窗权限状态
- 显示权限状态提示
- 权限状态变化时实时更新UI

**技术实现**：
```kotlin
// 在 SettingsViewModel 中
fun checkFloatingWindowPermission() {
    viewModelScope.launch {
        val permissionResult = FloatingWindowManager.hasPermission(getApplication())
        val hasPermission = when (permissionResult) {
            is FloatingWindowManager.PermissionResult.Granted -> true
            is FloatingWindowManager.PermissionResult.Denied -> {
                Log.w("SettingsViewModel", "悬浮窗权限被拒绝: ${permissionResult.message}")
                false
            }
            is FloatingWindowManager.PermissionResult.Error -> {
                Log.e("SettingsViewModel", "检查权限出错: ${permissionResult.message}")
                false
            }
        }
        
        _uiState.update {
            it.copy(
                hasFloatingWindowPermission = hasPermission,
                error = if (permissionResult is FloatingWindowManager.PermissionResult.Error) {
                    permissionResult.message
                } else null
            )
        }
    }
}
```

**检测时机**：
- `SettingsViewModel.init()`中自动检测
- 页面`onResume`时重新检测（用户从系统设置返回后）
- 用户点击开关时检测

#### 3.3.2 权限引导（含错误处理）

**需求描述**：
- 未授权时显示权限说明对话框
- 提供跳转到系统设置的按钮
- 处理用户拒绝授权的情况

**对话框内容**：
```
┌─────────────────────────────────┐
│ 需要悬浮窗权限                   │
├─────────────────────────────────┤
│ 悬浮窗功能需要"在其他应用上层   │
│ 显示"权限。                     │
│                                 │
│ 此权限用于：                    │
│ • 在聊天应用上显示快捷按钮      │
│ • 快速访问 AI 助手功能          │
│                                 │
│ 我们承诺：                      │
│ • 不会滥用此权限                │
│ • 不会收集您的屏幕内容          │
├─────────────────────────────────┤
│              [取消]  [去授权]   │
└─────────────────────────────────┘
```

**错误处理流程**：

1. **权限被拒绝**：
```kotlin
// 用户点击"取消"或从系统设置返回未授权
if (!hasPermission) {
    _uiState.update {
        it.copy(
            floatingWindowEnabled = false,
            showPermissionDialog = false,
            error = "悬浮窗功能需要权限才能使用"
        )
    }
}
```

2. **系统不支持**：
```kotlin
// Android 6.0以下或特殊ROM
when (permissionResult) {
    is FloatingWindowManager.PermissionResult.Error -> {
        _uiState.update {
            it.copy(
                error = "您的设备不支持悬浮窗功能",
                floatingWindowEnabled = false
            )
        }
    }
}
```

3. **权限申请失败**：
```kotlin
// 跳转系统设置失败
try {
    FloatingWindowManager.requestPermission(activity)
} catch (e: Exception) {
    _uiState.update {
        it.copy(error = "无法打开权限设置页面，请手动前往系统设置")
    }
}
```

**用户引导策略**：
- 首次点击开关：显示权限说明对话框
- 第二次拒绝：显示更详细的引导说明
- 多次拒绝：提供手动设置路径说明

#### 3.3.3 服务控制（含异常处理）

**需求描述**：
- 开关控制悬浮窗服务的启动和停止
- 状态持久化保存
- 应用重启后恢复状态
- 处理服务启动失败的情况

**技术实现**：

1. **启动服务**：
```kotlin
private fun startFloatingWindowService() {
    viewModelScope.launch {
        _uiState.update { it.copy(isLoading = true, error = null) }
        
        val startResult = FloatingWindowManager.startService(getApplication())
        
        when (startResult) {
            is FloatingWindowManager.ServiceStartResult.Success -> {
                // 保存启用状态
                floatingWindowPreferences.saveEnabled(true)
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        floatingWindowEnabled = true,
                        successMessage = "悬浮窗服务已启动"
                    )
                }
            }
            is FloatingWindowManager.ServiceStartResult.PermissionDenied -> {
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        floatingWindowEnabled = false,
                        error = "权限不足，无法启动悬浮窗服务"
                    )
                }
            }
            is FloatingWindowManager.ServiceStartResult.Error -> {
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        floatingWindowEnabled = false,
                        error = "启动失败: ${startResult.message}"
                    )
                }
            }
        }
    }
}
```

2. **停止服务**：
```kotlin
private fun stopFloatingWindowService() {
    viewModelScope.launch {
        _uiState.update { it.copy(isLoading = true, error = null) }
        
        val stopResult = FloatingWindowManager.stopService(getApplication())
        
        when (stopResult) {
            is FloatingWindowManager.ServiceStopResult.Success -> {
                floatingWindowPreferences.saveEnabled(false)
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        floatingWindowEnabled = false,
                        successMessage = "悬浮窗服务已停止"
                    )
                }
            }
            is FloatingWindowManager.ServiceStopResult.NotRunning -> {
                // 服务未运行，但仍然更新状态
                floatingWindowPreferences.saveEnabled(false)
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        floatingWindowEnabled = false
                    )
                }
            }
            is FloatingWindowManager.ServiceStopResult.Error -> {
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        error = "停止失败: ${stopResult.message}"
                    )
                }
            }
        }
    }
}
```

3. **状态恢复**：
```kotlin
// 在 SettingsViewModel.init() 中
private fun loadFloatingWindowState() {
    val state = floatingWindowPreferences.loadState()
    _uiState.update {
        it.copy(floatingWindowEnabled = state.isEnabled)
    }
    
    // 如果上次是启用状态，尝试重新启动服务
    if (state.isEnabled && hasFloatingWindowPermission) {
        startFloatingWindowService()
    }
}
```

**异常处理策略**：

| 异常情况 | 处理方式 | 用户提示 |
|---------|---------|---------|
| 权限不足 | 关闭开关，显示权限引导 | "需要悬浮窗权限才能使用" |
| 服务启动失败 | 关闭开关，记录日志 | "启动失败，请稍后重试" |
| 服务崩溃 | 自动重启（最多3次） | "服务异常，正在重启" |
| 内存不足 | 停止服务，清理资源 | "内存不足，已停止悬浮窗" |
| 系统限制 | 禁用功能，显示说明 | "您的设备不支持此功能" |

**重试机制**：
- 服务启动失败后，延迟3秒自动重试
- 最多重试3次
- 重试失败后显示错误提示，不再自动重试

### 3.4 关于信息

#### 3.4.1 应用信息

**需求描述**：
- 显示应用版本号
- 显示应用名称和简介

**显示内容**：
```
应用版本：1.0.0
共情 AI 助手
隐私优先的社交沟通助手
```

**技术实现**：
- 从`BuildConfig.VERSION_NAME`读取版本号
- 硬编码应用名称和简介

#### 3.4.2 数据管理功能

**需求描述**：
- 提供清除数据的功能入口
- 显示数据使用情况（可选）

**MVP范围**：
- 仅提供"清除所有数据"按钮
- 后续版本可添加数据导入导出功能

#### 3.4.3 清除数据功能（明确范围）

**需求描述**：
- 提供清除应用数据的功能
- 明确清除范围，避免用户误操作
- 提供二次确认机制

**清除范围定义**：

**MVP阶段清除范围**：
```
清除所有数据包括：
✓ AI服务商配置（API Key、模型设置）
✓ 隐私保护设置（数据掩码、本地优先模式）
✓ 悬浮窗设置（启用状态、位置信息）
✗ 不清除：联系人数据
✗ 不清除：标签数据
✗ 不清除：聊天历史
```

**交互设计**：

1. **清除按钮**：
```
┌─────────────────────────────────┐
│ 数据管理                        │
├─────────────────────────────────┤
│ [清除所有设置]                  │
│                                 │
│ 注意：此操作将清除所有设置数据， │
│ 但不会删除联系人和标签          │
└─────────────────────────────────┘
```

2. **确认对话框**：
```
┌─────────────────────────────────┐
│ 清除所有设置                    │
├─────────────────────────────────┤
│ 确定要清除以下数据吗？          │
│                                 │
│ 将被清除：                      │
│ • AI服务商配置                  │
│ • 隐私保护设置                  │
│ • 悬浮窗设置                    │
│                                 │
│ 不会清除：                      │
│ • 联系人数据                    │
│ • 标签数据                      │
│                                 │
│ 此操作不可恢复！                │
├─────────────────────────────────┤
│              [取消]  [确定清除] │
└─────────────────────────────────┘
```

**技术实现**：

```kotlin
// 在 SettingsViewModel 中
private fun clearAllData() {
    viewModelScope.launch {
        try {
            _uiState.update { it.copy(isLoading = true, error = null) }
            
            // 1. 清除AI服务商数据
            val providers = _uiState.value.providersList
            providers.forEach { provider ->
                aiProviderRepository.deleteProvider(provider.id)
            }
            
            // 2. 清除隐私设置
            settingsRepository.setDataMaskingEnabled(true)  // 恢复默认值
            settingsRepository.setLocalFirstModeEnabled(true)
            
            // 3. 清除悬浮窗设置
            floatingWindowPreferences.saveEnabled(false)
            FloatingWindowManager.stopService(getApplication())
            
            // 4. 清除其他设置（如果有）
            // ...
            
            _uiState.update {
                it.copy(
                    isLoading = false,
                    selectedProvider = "",
                    availableProviders = emptyList(),
                    providersList = emptyList(),
                    dataMaskingEnabled = true,
                    localFirstMode = true,
                    floatingWindowEnabled = false,
                    showClearDataDialog = false,
                    successMessage = "所有设置已清除"
                )
            }
        } catch (e: Exception) {
            _uiState.update {
                it.copy(
                    isLoading = false,
                    error = "清除数据失败: ${e.message}"
                )
            }
        }
    }
}
```

**清除后的状态**：
- 应用恢复到首次安装后的状态
- 所有设置恢复为默认值
- 用户需要重新配置AI服务商
- 联系人和标签数据保持不变

**后续版本扩展**：
- 提供选择性清除（如只清除服务商配置）
- 提供数据导出功能（清除前备份）
- 提供数据导入功能（从备份恢复）

#### 3.4.4 开源许可（后续版本）

**需求描述**：
- 提供查看开源许可的入口
- 显示使用的开源库列表

**实现方式**：
- 点击后跳转到新页面或对话框
- 列出主要开源库及其许可证

**注意**：此功能不在MVP范围内，后续版本实现

---

## 4. 非功能需求

### 4.1 性能要求

- **页面加载**: 设置页面加载时间 < 500ms
- **开关响应**: 开关切换响应时间 < 100ms
- **服务启动**: 悬浮窗服务启动时间 < 1s
- **内存占用**: 设置页面内存占用 < 50MB

### 4.2 兼容性要求

- **Android版本**: 支持Android 7.0（API 24）及以上
- **屏幕尺寸**: 支持4.5寸到12寸屏幕
- **横竖屏**: 支持横竖屏切换，状态不丢失

### 4.3 安全要求

- **数据加密**: 敏感设置使用`EncryptedSharedPreferences`
- **权限控制**: 悬浮窗权限需要明确的用户授权
- **数据隔离**: 不同用户的设置数据完全隔离

### 4.4 可用性要求

- **易用性**: 所有设置项都有清晰的说明文字
- **反馈**: 设置变更后提供明确的成功/失败反馈
- **容错**: 设置失败时不影响应用正常使用
- **一致性**: UI风格与应用其他页面保持一致

---

## 5. 技术约束

### 5.1 架构约束

- 必须遵循Clean Architecture架构
- 必须使用MVVM模式
- 必须使用Hilt进行依赖注入
- 必须使用StateFlow管理状态

### 5.2 UI约束

- 必须使用Jetpack Compose构建UI
- 必须使用Material Design 3组件
- 必须支持深色模式（系统级）
- 必须支持无障碍功能

### 5.3 数据存储约束

- 敏感数据使用`EncryptedSharedPreferences`
- 普通设置使用`SharedPreferences`
- 不使用Room数据库存储设置

---

## 6. 实现细节

### 6.1 隐私设置持久化实现

**解决方案**：在`SettingsRepositoryImpl`中统一管理所有设置

**实现方式**：

1. **在SettingsRepository接口中添加方法**：
```kotlin
interface SettingsRepository {
    // 现有方法...
    
    // 隐私设置
    suspend fun getDataMaskingEnabled(): Result<Boolean>
    suspend fun setDataMaskingEnabled(enabled: Boolean): Result<Unit>
    suspend fun getLocalFirstModeEnabled(): Result<Boolean>
    suspend fun setLocalFirstModeEnabled(enabled: Boolean): Result<Unit>
}
```

2. **在SettingsRepositoryImpl中实现**：
```kotlin
class SettingsRepositoryImpl @Inject constructor(
    @ApplicationContext private val context: Context
) : SettingsRepository {
    
    private val privacyPrefs by lazy {
        context.getSharedPreferences("privacy_settings", Context.MODE_PRIVATE)
    }
    
    override suspend fun getDataMaskingEnabled(): Result<Boolean> {
        return try {
            Result.success(privacyPrefs.getBoolean("privacy_data_masking_enabled", true))
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun setDataMaskingEnabled(enabled: Boolean): Result<Unit> {
        return try {
            privacyPrefs.edit().putBoolean("privacy_data_masking_enabled", enabled).apply()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    // 本地优先模式的实现类似...
}
```

**默认值**：
- **数据掩码**: `true`（默认开启，保护隐私）
- **本地优先模式**: `true`（默认开启，减少AI调用）

**优势**：
- 统一管理所有设置，便于维护
- 符合Repository模式，保持架构一致性
- 便于后续添加新的设置项

### 6.2 设置变更生效机制

**解决方案**：业务逻辑在使用时实时读取设置

**实现方式**：

1. **在PrivacyEngine中读取**：
```kotlin
class PrivacyEngine @Inject constructor(
    private val settingsRepository: SettingsRepository
) {
    suspend fun maskSensitiveData(text: String): String {
        val enabled = settingsRepository.getDataMaskingEnabled().getOrDefault(true)
        if (!enabled) return text
        return applyMasking(text)
    }
}
```

2. **在CheckDraftUseCase中读取**：
```kotlin
class CheckDraftUseCase @Inject constructor(
    private val settingsRepository: SettingsRepository,
    private val aiRepository: AiRepository,
    private val ruleEngine: RuleEngine
) {
    suspend operator fun invoke(draft: String): Result<SafetyCheckResult> {
        val localFirstEnabled = settingsRepository.getLocalFirstModeEnabled().getOrDefault(true)
        
        if (localFirstEnabled) {
            val localResult = ruleEngine.checkSafety(draft)
            if (localResult.isSafe) return Result.success(localResult)
        }
        
        return aiRepository.checkDraftSafety(draft)
    }
}
```

**优势**：
- 设置变更立即生效，无需重启
- 无需复杂的观察者模式
- 代码简单，易于理解和维护

**性能考虑**：
- SharedPreferences读取很快（< 1ms）
- 使用`lazy`缓存SharedPreferences实例
- 不会影响用户体验

### 6.3 清除数据范围定义

**MVP阶段方案**：只清除设置数据，不清除用户数据

**清除范围**：
```
✓ 清除：AI服务商配置
✓ 清除：隐私保护设置
✓ 清除：悬浮窗设置
✗ 保留：联系人数据
✗ 保留：标签数据
✗ 保留：聊天历史
```

**理由**：
1. 用户数据（联系人、标签）是核心资产，误删除影响严重
2. MVP阶段功能简单，只清除设置即可
3. 后续版本可添加选择性清除功能

**后续版本扩展**：
- 提供"清除设置"和"清除所有数据"两个选项
- 清除前提供数据导出功能
- 提供数据恢复功能（从备份）

**是否需要重启应用**：
- **不需要**：清除后应用状态自动重置
- 所有ViewModel使用Flow观察数据变化
- 数据清除后Flow自动触发UI更新

### 6.4 关于信息内容定义

**MVP阶段方案**：只显示基本信息

**包含内容**：
- ✅ 应用版本号（从BuildConfig读取）
- ✅ 应用名称和简介
- ✅ 数据管理功能（清除数据）

**不包含内容**（后续版本）：
- ❌ 开源许可查看
- ❌ 隐私政策链接
- ❌ 用户协议链接
- ❌ 反馈入口

**理由**：
1. MVP阶段聚焦核心功能
2. 开源许可等内容需要法务审核
3. 反馈功能需要后端支持

**后续版本规划**：
- v1.1: 添加开源许可查看
- v1.2: 添加隐私政策和用户协议
- v1.3: 添加反馈入口（邮件或表单）

---

## 7. 验收标准

### 7.1 功能验收

**AI服务商配置**：
- [ ] 能正确显示当前默认服务商名称
- [ ] 能从服务商列表中选择并切换默认服务商
- [ ] 切换后立即生效，无需重启应用
- [ ] 未配置服务商时显示友好提示
- [ ] 点击"管理AI服务商"能正确跳转到AiConfigScreen
- [ ] 服务商数据使用Flow实时同步

**隐私保护设置**：
- [ ] 数据掩码开关能正常切换，默认开启
- [ ] 本地优先模式开关能正常切换，默认开启
- [ ] 设置变更后立即保存到SharedPreferences
- [ ] 应用重启后能恢复上次的设置状态
- [ ] PrivacyEngine能正确读取数据掩码设置
- [ ] CheckDraftUseCase能正确读取本地优先设置
- [ ] 设置关闭时相应功能被跳过

**悬浮窗设置**：
- [ ] 能正确检测悬浮窗权限状态
- [ ] 未授权时点击开关显示权限说明对话框
- [ ] 已授权时能正常启动/停止悬浮窗服务
- [ ] 服务状态与开关状态保持同步
- [ ] 应用重启后能恢复上次的悬浮窗状态
- [ ] 权限被拒绝时显示友好提示
- [ ] 服务启动失败时能自动重试（最多3次）

**关于信息**：
- [ ] 能正确显示应用版本号（从BuildConfig读取）
- [ ] 显示应用名称和简介
- [ ] 清除数据功能能正常工作
- [ ] 清除数据前显示二次确认对话框
- [ ] 清除后应用恢复到初始状态

**数据持久化**：
- [ ] 所有设置都能正确保存到本地存储
- [ ] 应用重启后所有设置状态保持不变
- [ ] 设置保存失败时显示错误提示
- [ ] 设置读取失败时使用默认值

### 7.2 体验验收

**性能体验**：
- [ ] 设置页面加载时间 < 500ms
- [ ] 开关切换响应时间 < 100ms
- [ ] 悬浮窗服务启动时间 < 1s
- [ ] 页面滚动流畅，无卡顿
- [ ] 内存占用 < 50MB

**交互体验**：
- [ ] 所有按钮点击有视觉反馈
- [ ] 所有开关切换有动画效果
- [ ] 加载状态有明确的指示器
- [ ] 成功操作有Toast提示
- [ ] 失败操作有错误对话框

**文案体验**：
- [ ] 所有设置项都有清晰的说明文字
- [ ] 错误提示友好且有指导意义
- [ ] 确认对话框内容详细明确
- [ ] 无错别字和语法错误

**视觉体验**：
- [ ] UI布局合理，符合Material Design 3规范
- [ ] 颜色对比度符合WCAG 2.1 AA标准
- [ ] 支持系统深色模式
- [ ] 支持不同屏幕尺寸（4.5-12寸）
- [ ] 支持横竖屏切换

**无障碍体验**：
- [ ] 所有UI元素都有contentDescription
- [ ] TalkBack能正确朗读所有内容
- [ ] 触摸目标不小于48dp
- [ ] 支持系统字体大小设置

### 7.3 质量验收

**代码质量**：
- [ ] 遵循Clean Architecture架构
- [ ] 正确使用MVVM模式
- [ ] 正确使用Hilt依赖注入
- [ ] 所有类和方法都有完整注释
- [ ] 代码通过Lint检查
- [ ] 代码通过Code Review

**测试覆盖**：
- [ ] 单元测试覆盖率 > 80%
- [ ] PrivacyPreferences有完整的单元测试
- [ ] SettingsViewModel有完整的单元测试
- [ ] SettingsRepositoryImpl有完整的单元测试
- [ ] UI测试覆盖所有关键交互
- [ ] 所有测试都能通过

**错误处理**：
- [ ] 所有异常都被正确捕获和处理
- [ ] 网络异常有降级方案
- [ ] 权限异常有友好提示
- [ ] 服务异常有重试机制
- [ ] 不因设置问题导致应用崩溃

**兼容性**：
- [ ] 在Android 7.0（API 24）上正常运行
- [ ] 在Android 12+（API 31+）上正常运行
- [ ] 在小米、华为、OPPO等主流ROM上正常运行
- [ ] 在不同屏幕尺寸上正常显示
- [ ] 支持横竖屏切换

**安全性**：
- [ ] API Key使用EncryptedSharedPreferences存储
- [ ] 普通设置使用SharedPreferences存储
- [ ] 权限申请有明确说明
- [ ] 没有硬编码的密钥或密码
- [ ] 敏感操作有日志记录

**文档完整性**：
- [ ] PRD文档完整准确
- [ ] FD文档完整准确（待创建）
- [ ] TDD文档完整准确（待创建）
- [ ] 代码注释完整
- [ ] README更新

---

## 8. 附录

### 8.1 相关文档

- [FD-00002-设置功能设计](../FD/FD-00002-设置功能设计.md)（待创建）
- [TDD-00002-设置架构设计](../TDD/TDD-00002-设置架构设计.md)（待创建）
- [PRD-00001-悬浮窗功能需求](./PRD-00001-悬浮窗功能需求.md)

### 8.2 术语表

- **数据掩码**: 在发送到AI前自动替换敏感信息（如手机号、身份证号）
- **本地优先模式**: 优先使用本地规则引擎，减少AI API调用
- **悬浮窗**: 系统级悬浮窗口，可在其他应用上层显示
- **EncryptedSharedPreferences**: Android提供的加密存储方案

### 8.3 变更记录

| 版本 | 日期 | 变更内容 | 变更人 |
|------|------|----------|--------|
| v1.0 | 2024-12-12 | 初始版本，待讨论 | Claude |
| v2.0 | 2024-12-12 | 优化文档：<br>1. 明确API Key管理架构<br>2. 补充隐私设置持久化实现细节<br>3. 完善错误处理策略<br>4. 明确数据清除范围<br>5. 增强非功能需求（含测试环境）<br>6. 将"待讨论问题"改为"实现细节"并提供解决方案<br>7. 完善验收标准 | Claude |
