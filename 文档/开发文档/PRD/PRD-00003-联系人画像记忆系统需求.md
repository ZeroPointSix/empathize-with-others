# PRD-00003-联系人画像记忆系统需求

## 文档信息

- **文档编号**: PRD-00003
- **文档版本**: v1.1
- **创建日期**: 2025-12-14
- **最后更新**: 2025-12-14
- **状态**: 草稿 - 待评审
- **负责人**: Claude (文档编写) / Kiro (代码实现) / Roo (代码审查)

---

## 1. 需求概述

### 1.1 背景

共情AI助手已经实现了基础的联系人管理功能，包括：
- ✅ 联系人基本信息存储（name, targetGoal, contextDepth）
- ✅ 简单的facts字段（Map<String, String>）
- ✅ BrainTag标签系统（雷区/策略）
- ✅ AI分析功能（AnalyzeChatUseCase）

**当前痛点**：
1. **缺乏记忆能力**：每次AI分析都是独立的，无法记住历史互动
2. **facts结构简单**：无时间戳，无法追踪关系变化
3. **上下文混乱**：所有facts一股脑发给AI，干扰判断
4. **关系静态**：无法量化和追踪关系进展

### 1.2 目标

本次需求旨在**构建完整的联系人画像记忆系统**，让AI能够：
- 记住每次互动的内容和结果
- 自动总结和提炼关键信息
- 追踪关系变化趋势
- 提供更精准的沟通建议

### 1.3 MVP范围

**本次实现范围**：
- ✅ 对话记录自动存储
- ✅ 每日总结生成（AI驱动）
- ✅ Facts结构增强（带时间戳和来源）
- ✅ 关系分数系统（0-100分）
- ✅ 智能上下文构建（分层筛选）
- ✅ AI Prompt优化（使用记忆数据）

**明确不包含**（后续版本）：
- ❌ Facts的手动编辑UI
- ❌ 对话记录的详细查看界面
- ❌ 向量搜索（MVP用时间排序）
- ❌ 记忆重要性评分系统
- ❌ 记忆可视化（时间线、关系图）

---

## 2. 核心概念

### 2.1 记忆分层架构

借鉴人类记忆机制，设计三层记忆系统：

```
┌─────────────────────────────────────┐
│  短期记忆（对话记录）                │
│  - 每次用户发起的分析请求            │
│  - 保留原始对话内容                  │
│  - 用于生成每日总结                  │
└─────────────────────────────────────┘
           ↓ 每日总结
┌─────────────────────────────────────┐
│  中期记忆（每日总结）                │
│  - AI生成的每日互动摘要              │
│  - 提取关键事件和发现                │
│  - 用于更新长期记忆                  │
└─────────────────────────────────────┘
           ↓ 提炼更新
┌─────────────────────────────────────┐
│  长期记忆（联系人画像）              │
│  - Facts：事实性信息                 │
│  - BrainTag：策略性标签              │
│  - RelationshipScore：关系分数       │
└─────────────────────────────────────┘
```

### 2.2 数据流设计

```
用户发起分析
     ↓
保存对话记录 → 构建上下文 → AI分析 → 保存AI回复
     ↓
（次日首次打开App）
     ↓
查询昨日对话 → AI生成总结 → 更新Facts/Tags/Score
     ↓
标记为已总结
```


---

## 3. 用户故事

### 3.1 自动记录互动

**作为** 用户  
**我想要** 系统自动记录每次与联系人的互动  
**以便** AI能够记住历史对话，提供更精准的建议

**验收标准**：
- [ ] 每次发起AI分析时，自动保存用户输入到数据库
- [ ] AI回复后，自动保存回复内容到数据库
- [ ] 对话记录包含时间戳，按时间排序
- [ ] 对话记录与联系人关联，支持按联系人查询
- [ ] 即使AI分析失败，用户输入也会被保存

### 3.2 每日自动总结

**作为** 用户  
**我想要** 系统每天自动总结我与联系人的互动  
**以便** 不需要手动整理，AI能自动提炼关键信息

**验收标准**：
- [ ] 新一天首次打开App时，自动触发总结流程
- [ ] 总结包含昨日所有对话的关键事件
- [ ] 总结能自动发现新的facts并更新
- [ ] 总结能自动调整BrainTag标签
- [ ] 总结能自动更新关系分数
- [ ] 总结失败时保留未总结状态，下次继续尝试

### 3.3 关系进展追踪

**作为** 用户  
**我想要** 看到与联系人的关系分数变化  
**以便** 了解沟通策略是否有效

**验收标准**：
- [ ] 联系人详情页显示关系分数（0-100）
- [ ] 关系分数以进度条形式展示
- [ ] 显示最后互动日期
- [ ] 每日总结后关系分数自动更新
- [ ] 关系分数变化范围：-10到+10/天

### 3.4 智能上下文构建

**作为** 用户  
**我想要** AI分析时只使用相关的历史信息  
**以便** 避免信息过载，提高分析准确性

**验收标准**：
- [ ] AI分析时自动筛选相关facts
- [ ] 优先使用最近7天的facts
- [ ] 7-30天的facts只保留手动添加的
- [ ] 30天以上的facts只保留核心的
- [ ] Facts总数控制在20条以内
- [ ] 所有BrainTag标签都会被使用

---

## 4. 数据模型设计

### 4.1 Fact数据结构（增强）

**当前结构**：
```kotlin
// ContactProfile.facts: Map<String, String>
```

**新结构**：
```kotlin
data class Fact(
    val key: String,           // 字段名，如"性格"、"爱好"
    val value: String,         // 字段值
    val timestamp: Long,       // 创建/更新时间（自动记录）
    val source: FactSource     // 来源：MANUAL 或 AI_INFERRED
)

enum class FactSource {
    MANUAL,        // 用户手动添加
    AI_INFERRED    // AI推断
}

// ContactProfile.facts: List<Fact>
```

**预定义字段**（推荐，非强制）：
```kotlin
object FactKeys {
    const val PERSONALITY = "性格特点"
    const val INTERESTS = "兴趣爱好"
    const val TABOOS = "沟通雷区"
    const val PREFERENCES = "喜好偏好"
    const val FAMILY = "家庭情况"
    const val WORK = "工作情况"
    const val HEALTH = "健康状况"
    const val HABITS = "生活习惯"
}
```

**数据库存储**：
```json
// ContactProfileEntity.factsJson
[
  {
    "key": "性格特点",
    "value": "急性子但讨厌被push",
    "timestamp": 1702540800000,
    "source": "MANUAL"
  },
  {
    "key": "兴趣爱好",
    "value": "钓鱼",
    "timestamp": 1702627200000,
    "source": "AI_INFERRED"
  }
]
```

### 4.2 ContactProfile扩展

**新增字段**：
```kotlin
data class ContactProfile(
    val id: String,
    val name: String,
    val targetGoal: String,
    val contextDepth: Int = 10,
    val facts: List<Fact> = emptyList(),           // 修改：从Map改为List
    val relationshipScore: Int = 50,               // 新增：关系分数 0-100
    val lastInteractionDate: String? = null        // 新增：最后互动日期 "2024-12-14"
)
```

**数据库Entity**：
```kotlin
@Entity(tableName = "profiles")
data class ContactProfileEntity(
    @PrimaryKey
    @ColumnInfo(name = "id")
    val id: String,
    
    @ColumnInfo(name = "name")
    val name: String,
    
    @ColumnInfo(name = "target_goal")
    val targetGoal: String,
    
    @ColumnInfo(name = "context_depth")
    val contextDepth: Int = 10,
    
    @ColumnInfo(name = "facts_json")
    val factsJson: String = "[]",                  // 修改：存储List<Fact>的JSON
    
    @ColumnInfo(name = "relationship_score")
    val relationshipScore: Int = 50,               // 新增
    
    @ColumnInfo(name = "last_interaction_date")
    val lastInteractionDate: String? = null        // 新增
)
```


### 4.3 ConversationLog（对话记录）

**新增表**：
```kotlin
@Entity(tableName = "conversation_logs")
data class ConversationLogEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0,
    
    @ColumnInfo(name = "contact_id")
    val contactId: String,           // 关联联系人
    
    @ColumnInfo(name = "user_input")
    val userInput: String,           // 用户发送的聊天记录
    
    @ColumnInfo(name = "ai_response")
    val aiResponse: String?,         // AI的分析回复（可能为空）
    
    @ColumnInfo(name = "timestamp")
    val timestamp: Long,             // 记录时间
    
    @ColumnInfo(name = "is_summarized")
    val isSummarized: Boolean = false // 是否已被总结处理
)
```

**索引**：
```sql
CREATE INDEX idx_conversation_contact ON conversation_logs(contact_id);
CREATE INDEX idx_conversation_date ON conversation_logs(timestamp);
CREATE INDEX idx_conversation_summarized ON conversation_logs(is_summarized);
```

**Domain模型**：
```kotlin
data class ConversationLog(
    val id: Long = 0,
    val contactId: String,
    val userInput: String,
    val aiResponse: String?,
    val timestamp: Long,
    val isSummarized: Boolean = false
)
```

### 4.4 DailySummary（每日总结）

**新增表**：
```kotlin
@Entity(tableName = "daily_summaries")
data class DailySummaryEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0,
    
    @ColumnInfo(name = "contact_id")
    val contactId: String,
    
    @ColumnInfo(name = "summary_date")
    val summaryDate: String,         // 格式: "2024-12-14"
    
    @ColumnInfo(name = "content")
    val content: String,             // AI生成的总结内容
    
    @ColumnInfo(name = "key_events_json")
    val keyEventsJson: String,       // 关键事件列表 JSON
    
    @ColumnInfo(name = "relationship_score")
    val relationshipScore: Int,      // 总结后的关系分数
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long
)
```

**索引**：
```sql
CREATE INDEX idx_summary_contact ON daily_summaries(contact_id);
CREATE INDEX idx_summary_date ON daily_summaries(summary_date);
CREATE UNIQUE INDEX idx_summary_contact_date ON daily_summaries(contact_id, summary_date);
```

**Domain模型**：
```kotlin
data class DailySummary(
    val id: Long = 0,
    val contactId: String,
    val summaryDate: String,
    val content: String,
    val keyEvents: List<KeyEvent>,
    val newFacts: List<Fact>,
    val updatedTags: List<TagUpdate>,
    val relationshipScoreChange: Int,  // -10到+10
    val relationshipTrend: RelationshipTrend
)

data class KeyEvent(
    val event: String,
    val importance: Int  // 1-10
)

data class TagUpdate(
    val action: String,  // "ADD" | "REMOVE"
    val type: String,    // "RISK_RED" | "STRATEGY_GREEN"
    val content: String
)

enum class RelationshipTrend {
    IMPROVING,   // 改善中
    STABLE,      // 稳定
    DECLINING    // 下降中
}
```

---

## 5. 核心流程设计

### 5.1 对话记录流程

```
用户粘贴聊天记录 → 点击"分析"按钮
         ↓
┌─────────────────────────────┐
│  1. 保存用户输入             │
│  - contactId                │
│  - userInput                │
│  - timestamp                │
│  - isSummarized = false     │
└─────────────────────────────┘
         ↓
┌─────────────────────────────┐
│  2. 构建分析上下文           │
│  - 联系人基本信息            │
│  - 筛选相关facts            │
│  - 所有BrainTag标签         │
│  - 关系分数                 │
└─────────────────────────────┘
         ↓
┌─────────────────────────────┐
│  3. 调用AI分析              │
└─────────────────────────────┘
         ↓
┌─────────────────────────────┐
│  4. 更新对话记录             │
│  - 保存aiResponse           │
└─────────────────────────────┘
         ↓
    展示分析结果给用户
```

**关键点**：
- 用户输入立即保存，不等AI响应
- AI分析失败时，对话记录仍然保留
- 对话记录用于后续的每日总结

### 5.2 每日总结流程

**触发时机**：新一天首次打开App时

```
检测到新一天 + 有未总结的对话
         ↓
┌─────────────────────────────┐
│  1. 查询昨日对话记录         │
│  WHERE date = yesterday     │
│  AND is_summarized = false  │
└─────────────────────────────┘
         ↓
┌─────────────────────────────┐
│  2. 按contact_id分组        │
└─────────────────────────────┘
         ↓
    对每个联系人执行：
         ↓
┌─────────────────────────────┐
│  3. 获取联系人当前状态       │
│  - facts                    │
│  - BrainTag标签             │
│  - relationshipScore        │
└─────────────────────────────┘
         ↓
┌─────────────────────────────┐
│  4. 构建总结Prompt          │
│  - 昨日所有对话              │
│  - 当前facts和标签          │
│  - 当前关系分数             │
└─────────────────────────────┘
         ↓
┌─────────────────────────────┐
│  5. AI生成总结              │
│  返回JSON:                  │
│  - summary                  │
│  - keyEvents                │
│  - newFacts                 │
│  - updatedTags              │
│  - relationshipScoreChange  │
└─────────────────────────────┘
         ↓
┌─────────────────────────────┐
│  6. 更新数据                │
│  - 保存到daily_summaries    │
│  - 更新ContactProfile.facts │
│  - 更新/新增BrainTag        │
│  - 更新relationshipScore    │
│  - 标记对话为已总结          │
└─────────────────────────────┘
         ↓
    后台静默完成，用户无感知
```

**失败处理**（方案B + 降级方案）：

**主方案（AI总结）**：
- AI调用失败时，保留`isSummarized = false`状态
- 下次打开App时继续尝试总结
- 最多保留7天未总结的对话
- 7天后自动标记为已总结（避免无限重试）

**降级方案（本地统计）**：

当AI调用连续失败3次后，启用本地降级方案：

```kotlin
// 本地降级总结
private suspend fun fallbackSummary(
    contactId: String,
    logs: List<ConversationLog>,
    date: String
): DailySummary {
    val contact = contactRepository.getProfile(contactId).getOrNull()
        ?: throw IllegalStateException("Contact not found")
    
    // 1. 生成简单总结
    val summary = "昨日共${logs.size}次互动（AI总结暂时不可用，已使用本地统计）"
    
    // 2. 提取关键事件（基于对话长度）
    val keyEvents = logs.map { log ->
        KeyEvent(
            event = "互动记录（${log.timestamp.formatTime()}）",
            importance = (log.userInput.length / 100).coerceIn(1, 5)
        )
    }.take(3)
    
    // 3. 关系分数简单调整
    val scoreChange = when {
        logs.size >= 3 -> +2  // 多次互动，略微加分
        logs.size == 2 -> +1  // 正常互动
        else -> 0             // 单次互动，不变
    }
    
    // 4. 关系趋势判断
    val trend = when {
        scoreChange > 0 -> RelationshipTrend.IMPROVING
        scoreChange < 0 -> RelationshipTrend.DECLINING
        else -> RelationshipTrend.STABLE
    }
    
    return DailySummary(
        contactId = contactId,
        summaryDate = date,
        content = summary,
        keyEvents = keyEvents,
        newFacts = emptyList(),  // 降级方案不提取新事实
        updatedTags = emptyList(),  // 降级方案不更新标签
        relationshipScoreChange = scoreChange,
        relationshipTrend = trend
    )
}
```

**降级触发条件**：
1. AI服务不可用（网络错误、API额度用完）
2. AI返回格式错误（连续3次解析失败）
3. AI响应超时（超过60秒）

**降级方案特点**：
- 保证基本功能可用
- 不依赖AI服务
- 数据质量降低但不丢失
- 用户可以看到降级提示

**恢复机制**：
- 下次AI服务恢复后，自动切回AI总结
- 降级期间的数据保留，可以后续补充AI分析


### 5.3 智能上下文构建流程

**目标**：从大量facts中筛选出最相关的信息，避免干扰AI判断

```
用户发起分析请求
         ↓
┌─────────────────────────────┐
│  第一层：必选信息            │
│  - name, targetGoal         │
│  - relationshipScore        │
│  - 所有BrainTag（雷区/策略） │
└─────────────────────────────┘
         ↓
┌─────────────────────────────┐
│  第二层：时间分层筛选        │
│  - 最近7天的facts（全部）    │
│  - 7-30天的facts（手动的）   │
│  - 30天以上的facts（手动的） │
└─────────────────────────────┘
         ↓
┌─────────────────────────────┐
│  第三层：数量控制            │
│  - 按时间倒序排序            │
│  - 最多保留20条facts        │
└─────────────────────────────┘
         ↓
    构建最终Prompt发送给AI
```

**筛选规则**：

| 时间范围 | 筛选策略 | 理由 |
|---------|---------|------|
| 最近7天 | 全部保留 | 最新信息最相关 |
| 7-30天 | 只保留MANUAL | AI推断的可能过时 |
| 30天以上 | 只保留MANUAL | 只保留核心事实 |

**数量限制**：
- 最多20条facts
- 超过则按时间倒序截断
- BrainTag标签不限数量（通常不会太多）

---

## 6. AI Prompt设计

### 6.1 分析请求Prompt

**完整Prompt模板**：

```
你是一个专业的社交沟通顾问，帮助用户分析聊天内容并给出建议。

【联系人信息】
姓名：{name}
目标：{targetGoal}
关系分数：{relationshipScore}/100（0-30:陌生/冷淡，31-60:普通，61-80:熟悉，81-100:亲密）

【雷区标签】（绝对不能触碰的话题）
{RISK_RED标签列表，每行一个，如：
- 不要提他前妻
- 忌讳迟到
}

【策略标签】（建议的沟通切入点）
{STRATEGY_GREEN标签列表，每行一个，如：
- 多夸他衣品好
- 聊家庭话题
}

【已知事实】（按时间倒序）
{facts列表，格式：
- 性格特点：急性子但讨厌被push（2025-12-10，手动添加）
- 兴趣爱好：钓鱼（2025-12-08，AI推断）
}

【用户提供的聊天记录】
{userInput}

请仔细分析这段对话，并严格按照以下JSON格式返回（不要添加任何其他文字）：
{
  "riskLevel": "SAFE|WARNING|DANGER",
  "analysis": "对当前对话的详细分析（100-200字）",
  "suggestions": ["具体建议1", "具体建议2", "具体建议3"],
  "detectedRisks": ["检测到的风险点1", "风险点2"],
  "recommendedReply": "推荐的回复内容（自然、符合关系分数的语气）"
}

分析要点：
1. 雷区检查：优先检查是否触碰雷区标签，触碰则riskLevel设为DANGER
2. 策略应用：参考策略标签，给出针对性建议
3. 事实结合：结合已知事实，提供个性化分析
4. 关系适配：根据关系分数调整建议的激进程度和语气
   - 0-30分：谨慎保守，避免过度亲密
   - 31-60分：友好但保持距离
   - 61-80分：可以适度开玩笑
   - 81-100分：可以更随意自然
5. 目标导向：所有建议都应朝着targetGoal方向推进

输出要求：
- 必须是有效的JSON格式
- suggestions必须是3个具体可执行的建议
- detectedRisks为空时返回空数组[]
- recommendedReply要自然流畅，不要生硬
```

**Prompt测试用例**：

| 测试场景 | 输入 | 期望输出 |
|---------|------|---------|
| 触碰雷区 | 聊天中提到前妻 | riskLevel=DANGER, detectedRisks包含相关雷区 |
| 正常对话 | 普通工作交流 | riskLevel=SAFE, 给出3条建议 |
| 关系冷淡 | score=20，用户想约见面 | 建议保守，不要太激进 |
| 关系亲密 | score=85，日常闲聊 | 建议可以更随意 |
| 无雷区无策略 | 新联系人，无标签 | 基于facts和目标给建议 |

### 6.2 每日总结Prompt

**完整Prompt模板**：

```
你是一个专业的社交关系分析师，负责总结用户与联系人的每日互动，提炼关键信息。

【联系人信息】
姓名：{name}
目标：{targetGoal}
当前关系分数：{relationshipScore}/100

【当前已知事实】
{现有facts列表，格式：
- 性格特点：急性子（2025-12-10）
- 兴趣爱好：钓鱼（2025-12-08）
}

【当前标签】
雷区：{RISK_RED标签列表}
策略：{STRATEGY_GREEN标签列表}

【昨日对话记录】（{date}）
{昨日所有conversation_logs，格式：
[对话1]
用户输入：...
AI分析：...

[对话2]
用户输入：...
AI分析：...
}

请仔细分析昨日所有互动，提炼关键信息，并严格按照以下JSON格式返回（不要添加任何其他文字）：
{
  "summary": "昨日互动总结（50-100字，概括主要内容和整体感受）",
  "keyEvents": [
    {"event": "具体事件描述", "importance": 1-10}
  ],
  "newFacts": [
    {"key": "字段名", "value": "字段值", "source": "AI_INFERRED"}
  ],
  "updatedTags": [
    {"action": "ADD|REMOVE", "type": "RISK_RED|STRATEGY_GREEN", "content": "标签内容"}
  ],
  "relationshipScoreChange": -10到+10的整数,
  "relationshipTrend": "IMPROVING|STABLE|DECLINING"
}

分析要点：

1. 关键事件提取（keyEvents）：
   - 只记录真正重要的事件（如：达成共识、发生冲突、新发现）
   - importance评分标准：
     * 1-3分：日常闲聊
     * 4-6分：有价值的信息交换
     * 7-8分：关系进展的关键节点
     * 9-10分：重大突破或严重冲突
   - 最多记录5个事件

2. 新事实发现（newFacts）：
   - 只添加明确的新发现，不要重复现有facts
   - 使用预定义字段名：性格特点、兴趣爱好、沟通雷区、喜好偏好、家庭情况、工作情况、健康状况、生活习惯
   - 如果不属于预定义字段，可以自定义字段名
   - 事实要具体，避免模糊（好：喜欢钓鱼；差：有爱好）
   - source固定为"AI_INFERRED"

3. 标签更新（updatedTags）：
   - 只在有明确证据时才建议修改
   - ADD：发现新的雷区或有效策略
   - REMOVE：原有标签被证明不准确
   - 标签内容要简洁明确（10字以内）

4. 关系分数变化（relationshipScoreChange）：
   - 基于互动质量和频率综合判断
   - 评分标准：
     * +7到+10：重大突破，关系显著改善
     * +4到+6：互动顺畅，有明显进展
     * +1到+3：正常互动，略有进展
     * 0：无明显变化
     * -1到-3：互动不畅，略有倒退
     * -4到-6：出现矛盾，关系受损
     * -7到-10：严重冲突，关系恶化
   - 考虑因素：
     * 互动频率（多次互动 +1到+3）
     * 互动质量（深入交流 +2到+5）
     * 目标进展（接近目标 +3到+7）
     * 冲突情况（出现冲突 -3到-10）
     * 冷淡回应（被忽视 -1到-5）

5. 关系趋势（relationshipTrend）：
   - IMPROVING：分数变化≥+3，或有明显积极信号
   - STABLE：分数变化在-2到+2之间
   - DECLINING：分数变化≤-3，或有明显消极信号

输出要求：
- 必须是有效的JSON格式
- 所有数组为空时返回[]，不要省略
- 分数变化必须在-10到+10范围内
- 如果昨日无互动或互动无价值，summary说明情况，其他字段返回空/0
```

**Prompt测试用例**：

| 测试场景 | 输入 | 期望输出 |
|---------|------|---------|
| 顺畅互动 | 3次对话，都很顺利 | scoreChange=+4到+6, trend=IMPROVING |
| 发现雷区 | 对话中触碰敏感话题 | updatedTags包含ADD雷区 |
| 关系突破 | 达成重要共识 | scoreChange=+7到+10, importance=9-10 |
| 出现冲突 | 对话不愉快 | scoreChange=-5到-8, trend=DECLINING |
| 无价值互动 | 只有简单问候 | scoreChange=0, keyEvents=[] |
| 发现新事实 | 聊到家庭情况 | newFacts包含家庭情况 |

### 6.3 安全检查Prompt（增强版）

**完整Prompt模板**：

```
你是一个专业的沟通安全顾问，帮助用户检查准备发送的消息是否安全。

【联系人信息】
姓名：{name}
关系分数：{relationshipScore}/100（0-30:陌生/冷淡，31-60:普通，61-80:熟悉，81-100:亲密）

【已知雷区】（绝对不能触碰的话题）
{RISK_RED标签列表，每行一个，如：
- 不要提他前妻
- 忌讳迟到
}

【用户准备发送的消息】
{draft}

请仔细检查这条消息，并严格按照以下JSON格式返回（不要添加任何其他文字）：
{
  "isSafe": true|false,
  "riskLevel": "SAFE|WARNING|DANGER",
  "triggeredRisks": ["触发的雷区1", "雷区2"],
  "reason": "判断理由（50-100字）",
  "suggestion": "修改建议（如果不安全，给出具体的改写方案）"
}

检查要点：

1. 雷区检查（最高优先级）：
   - 直接提及雷区话题 → DANGER
   - 间接涉及雷区话题 → WARNING
   - 完全不涉及雷区 → SAFE

2. 关系分数适配：
   - 0-30分：语气过于亲密 → WARNING
   - 31-60分：开玩笑或调侃 → WARNING
   - 61-80分：过度随意 → WARNING
   - 81-100分：过于生疏 → 提示可以更自然

3. 语气检查：
   - 攻击性语言 → DANGER
   - 负面情绪过重 → WARNING
   - 可能引起误解 → WARNING

4. 时机检查：
   - 关系分数低但要求过多 → WARNING
   - 刚发生冲突就提要求 → WARNING

判断标准：
- SAFE：完全没问题，可以发送
- WARNING：有潜在风险，建议修改
- DANGER：严重问题，强烈建议不要发送

输出要求：
- 必须是有效的JSON格式
- triggeredRisks为空时返回[]
- suggestion在isSafe=true时可以为空字符串
- reason要具体说明问题所在
```

**Prompt测试用例**：

| 测试场景 | 输入 | 期望输出 |
|---------|------|---------|
| 触碰雷区 | 提到前妻 | isSafe=false, riskLevel=DANGER |
| 关系不够亲密 | score=20，语气很随意 | riskLevel=WARNING |
| 完全安全 | 普通工作交流 | isSafe=true, riskLevel=SAFE |
| 间接涉及雷区 | 隐晦提到敏感话题 | riskLevel=WARNING |
| 负面情绪 | 抱怨或指责 | riskLevel=WARNING |

### 6.4 Prompt测试方案

**测试目标**：确保AI Prompt能够稳定输出符合预期的结果

**测试环境**：
- 测试AI服务商：DeepSeek（成本低，适合测试）
- 测试数据集：10个典型场景
- 测试次数：每个场景测试5次
- 成功标准：5次中至少4次输出正确

**测试用例设计**：

#### 测试用例1：分析请求 - 触碰雷区

```yaml
场景: 用户聊天中提到联系人的前妻
输入:
  name: 王总
  targetGoal: 拿下合同
  relationshipScore: 45
  riskTags:
    - 不要提他前妻
  strategyTags:
    - 多聊工作话题
  facts:
    - key: 性格特点
      value: 直爽但敏感
  userInput: |
    我：王总，听说您之前的太太也是做这行的？
    王总：...（沉默）

期望输出:
  riskLevel: DANGER
  detectedRisks: ["触碰雷区：不要提他前妻"]
  analysis: 包含"触碰敏感话题"等关键词
  suggestions: 包含"立即转移话题"等建议

验证点:
  - riskLevel必须是DANGER
  - detectedRisks不能为空
  - suggestions必须包含补救措施
```

#### 测试用例2：每日总结 - 关系突破

```yaml
场景: 昨日多次顺畅互动，达成重要共识
输入:
  name: 李总
  targetGoal: 建立长期合作
  relationshipScore: 55
  facts:
    - key: 性格特点
      value: 谨慎保守
  logs:
    - userInput: 讨论合作细节，对方很认真
      aiResponse: 建议继续深入
    - userInput: 达成初步共识，对方很满意
      aiResponse: 关系有明显进展
    - userInput: 约定下次见面时间
      aiResponse: 目标推进顺利

期望输出:
  relationshipScoreChange: 5-8
  relationshipTrend: IMPROVING
  keyEvents: 至少2个，importance≥7
  newFacts: 可能包含新发现的事实

验证点:
  - scoreChange必须为正数且≥5
  - trend必须是IMPROVING
  - keyEvents不能为空
  - summary要体现"进展顺利"
```

#### 测试用例3：安全检查 - 关系不够亲密

```yaml
场景: 关系分数低但语气过于随意
输入:
  name: 张经理
  relationshipScore: 25
  riskTags: []
  draft: "老张，咱们啥时候喝一杯？我请客！"

期望输出:
  isSafe: false
  riskLevel: WARNING
  reason: 包含"关系不够亲密"、"语气过于随意"
  suggestion: 包含更正式的表达方式

验证点:
  - isSafe必须是false
  - riskLevel必须是WARNING
  - suggestion必须提供具体改写
```

**自动化测试脚本**：

```kotlin
// test/prompt/PromptTestSuite.kt
class PromptTestSuite {
    
    @Test
    fun testAnalysisPrompt_触碰雷区() = runTest {
        // 准备测试数据
        val testCase = loadTestCase("analysis_risk_trigger.yaml")
        
        // 执行5次测试
        val results = (1..5).map {
            aiRepository.analyzeChat(testCase.buildPrompt())
        }
        
        // 验证结果
        val successCount = results.count { result ->
            result.riskLevel == "DANGER" &&
            result.detectedRisks.isNotEmpty() &&
            result.analysis.contains("敏感")
        }
        
        assertTrue(successCount >= 4, "5次测试中至少4次成功")
    }
    
    @Test
    fun testSummaryPrompt_关系突破() = runTest {
        val testCase = loadTestCase("summary_breakthrough.yaml")
        
        val results = (1..5).map {
            aiRepository.generateSummary(testCase.buildPrompt())
        }
        
        val successCount = results.count { result ->
            result.relationshipScoreChange >= 5 &&
            result.relationshipTrend == "IMPROVING" &&
            result.keyEvents.isNotEmpty()
        }
        
        assertTrue(successCount >= 4)
    }
    
    @Test
    fun testSafetyPrompt_关系不够亲密() = runTest {
        val testCase = loadTestCase("safety_too_casual.yaml")
        
        val results = (1..5).map {
            aiRepository.checkSafety(testCase.buildPrompt())
        }
        
        val successCount = results.count { result ->
            !result.isSafe &&
            result.riskLevel == "WARNING" &&
            result.suggestion.isNotBlank()
        }
        
        assertTrue(successCount >= 4)
    }
}
```

**测试报告模板**：

```markdown
# AI Prompt测试报告

## 测试概况
- 测试日期：2025-12-14
- 测试服务商：DeepSeek
- 测试用例数：10个
- 总测试次数：50次（每个用例5次）

## 测试结果

| 用例编号 | 场景描述 | 成功次数 | 成功率 | 状态 |
|---------|---------|---------|--------|------|
| TC-001 | 分析-触碰雷区 | 5/5 | 100% | ✅ 通过 |
| TC-002 | 分析-正常对话 | 4/5 | 80% | ✅ 通过 |
| TC-003 | 总结-关系突破 | 5/5 | 100% | ✅ 通过 |
| TC-004 | 总结-出现冲突 | 3/5 | 60% | ❌ 失败 |
| TC-005 | 安全-关系不够 | 4/5 | 80% | ✅ 通过 |

## 问题分析

### TC-004失败原因
- 问题：AI对冲突严重程度判断不准确
- 表现：scoreChange应该是-7，但有2次输出-3
- 原因：Prompt中对"严重冲突"的定义不够明确
- 解决方案：增加冲突严重程度的判断标准

## 优化建议

1. 在总结Prompt中增加冲突严重程度的量化标准
2. 提供更多示例帮助AI理解评分规则
3. 考虑使用few-shot learning提高准确性
```

**持续优化流程**：

```
测试发现问题
     ↓
分析失败原因
     ↓
优化Prompt设计
     ↓
重新测试验证
     ↓
更新测试用例
     ↓
记录优化历史
```

---

## 7. 功能需求

### 7.1 对话记录功能

#### 7.1.1 自动记录

**需求描述**：
- 用户发起AI分析时，自动保存用户输入
- AI回复后，自动保存回复内容
- 记录失败不影响AI分析流程

**技术实现**：
```kotlin
// 在 AnalyzeChatUseCase 中
suspend operator fun invoke(
    contactId: String,
    chatHistory: String
): Result<AnalysisResult> {
    // 1. 先保存用户输入
    conversationRepository.saveUserInput(
        contactId = contactId,
        userInput = chatHistory,
        timestamp = System.currentTimeMillis()
    )
    
    // 2. 构建上下文并分析
    val context = contextBuilder.buildAnalysisContext(...)
    val analysisResult = aiRepository.analyzeChat(context)
    
    // 3. 保存AI回复
    analysisResult.onSuccess { result ->
        conversationRepository.saveAiResponse(
            contactId = contactId,
            aiResponse = result.toJsonString()
        )
    }
    
    return analysisResult
}
```

#### 7.1.2 数据清理

**需求描述**：
- 自动清理超过30天的已总结对话
- 保留未总结的对话（最多7天）
- 提供手动清理接口

**清理策略**：
- 每周自动清理一次
- 已总结且超过30天的对话删除
- 未总结但超过7天的对话标记为已总结后删除

### 7.2 每日总结功能

#### 7.2.1 自动触发

**需求描述**：
- 新一天首次打开App时自动触发
- 后台静默执行，不阻塞UI
- 总结完成后无需通知用户

**触发检测**：
```kotlin
// 在 EmpathyApplication.onCreate() 中
class EmpathyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        
        // 检查是否需要执行每日总结
        lifecycleScope.launch {
            val lastSummaryDate = preferences.getLastSummaryDate()
            val today = getCurrentDateString()
            
            if (lastSummaryDate != today) {
                // 执行每日总结
                summarizeDailyConversationsUseCase()
                preferences.setLastSummaryDate(today)
            }
        }
    }
}
```

#### 7.2.2 失败重试

**需求描述**：
- AI调用失败时保留未总结状态
- 下次打开App时继续尝试
- 超过7天自动放弃

**重试逻辑**：
```kotlin
// 在 SummarizeDailyConversationsUseCase 中
suspend operator fun invoke(): Result<Unit> {
    // 查询未总结的对话（最多7天前）
    val sevenDaysAgo = System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000
    val unsummarizedLogs = conversationRepository
        .getUnsummarizedLogs(sinceTimestamp = sevenDaysAgo)
    
    // 按日期和联系人分组
    val groupedLogs = unsummarizedLogs
        .groupBy { it.getDateString() }
        .flatMap { (date, logs) -> 
            logs.groupBy { it.contactId }.map { (contactId, contactLogs) ->
                Triple(date, contactId, contactLogs)
            }
        }
    
    // 对每组执行总结
    groupedLogs.forEach { (date, contactId, logs) ->
        try {
            summarizeForContact(contactId, logs, date)
        } catch (e: Exception) {
            Log.e("Summary", "Failed to summarize for $contactId on $date", e)
            // 失败时不标记为已总结，下次继续尝试
        }
    }
    
    return Result.success(Unit)
}
```


### 7.3 关系分数功能

#### 7.3.1 分数计算

**需求描述**：
- 初始分数：50分（中性）
- 每日变化：-10到+10
- 分数范围：0-100
- AI自动推断变化

**计算规则**：
```kotlin
// 在 SummarizeDailyConversationsUseCase 中
private fun updateRelationshipScore(
    currentScore: Int,
    scoreChange: Int
): Int {
    val newScore = currentScore + scoreChange
    return newScore.coerceIn(0, 100)
}
```

**AI推断依据**：
- 互动频率（多次互动 +1到+3）
- 互动质量（顺畅沟通 +2到+5）
- 目标进展（接近目标 +3到+7）
- 冲突情况（出现冲突 -3到-10）
- 冷淡回应（被忽视 -1到-5）

#### 7.3.2 分数展示

**需求描述**：
- 联系人详情页显示关系分数
- 使用进度条可视化
- 显示最后互动日期
- 显示关系趋势（改善/稳定/下降）

**UI设计**：
```
┌─────────────────────────────────┐
│ 王总                            │
├─────────────────────────────────┤
│ 关系分数：65/100                │
│ ████████████████░░░░░░░░        │
│                                 │
│ 最后互动：2024-12-13            │
│ 趋势：改善中 ↗                  │
└─────────────────────────────────┘
```

### 7.4 智能上下文构建

#### 7.4.1 Facts筛选

**需求描述**：
- 按时间分层筛选facts
- 控制总数不超过20条
- 优先保留手动添加的facts

**实现代码**：
```kotlin
// domain/util/ContextBuilder.kt
class ContextBuilder {
    fun selectRelevantFacts(facts: List<Fact>): List<Fact> {
        val now = System.currentTimeMillis()
        val sevenDaysAgo = now - 7 * 24 * 60 * 60 * 1000
        val thirtyDaysAgo = now - 30 * 24 * 60 * 60 * 1000
        
        // 分层筛选
        val recentFacts = facts.filter { it.timestamp >= sevenDaysAgo }
        val mediumFacts = facts.filter { 
            it.timestamp < sevenDaysAgo && 
            it.timestamp >= thirtyDaysAgo &&
            it.source == FactSource.MANUAL
        }
        val oldFacts = facts.filter { 
            it.timestamp < thirtyDaysAgo &&
            it.source == FactSource.MANUAL
        }
        
        // 合并并限制数量
        return (recentFacts + mediumFacts + oldFacts)
            .sortedByDescending { it.timestamp }
            .take(20)
    }
}
```

#### 7.4.2 Prompt构建

**需求描述**：
- 结构化组织上下文信息
- 清晰标注各部分内容
- 控制总长度在合理范围

**实现代码**：
```kotlin
fun buildAnalysisContext(
    contact: ContactProfile,
    tags: List<BrainTag>,
    userInput: String
): String {
    val sb = StringBuilder()
    
    // 基本信息
    sb.appendLine("【联系人信息】")
    sb.appendLine("姓名：${contact.name}")
    sb.appendLine("目标：${contact.targetGoal}")
    sb.appendLine("关系分数：${contact.relationshipScore}/100")
    sb.appendLine()
    
    // 雷区标签
    val riskTags = tags.filter { it.type == TagType.RISK_RED }
    if (riskTags.isNotEmpty()) {
        sb.appendLine("【雷区标签】")
        riskTags.forEach { sb.appendLine("- ${it.content}") }
        sb.appendLine()
    }
    
    // 策略标签
    val strategyTags = tags.filter { it.type == TagType.STRATEGY_GREEN }
    if (strategyTags.isNotEmpty()) {
        sb.appendLine("【策略标签】")
        strategyTags.forEach { sb.appendLine("- ${it.content}") }
        sb.appendLine()
    }
    
    // 筛选facts
    val relevantFacts = selectRelevantFacts(contact.facts)
    if (relevantFacts.isNotEmpty()) {
        sb.appendLine("【已知事实】")
        relevantFacts.forEach { fact ->
            val dateStr = formatDate(fact.timestamp)
            sb.appendLine("- ${fact.key}：${fact.value} ($dateStr)")
        }
        sb.appendLine()
    }
    
    // 用户输入
    sb.appendLine("【用户提供的聊天记录】")
    sb.appendLine(userInput)
    
    return sb.toString()
}
```

---

## 8. 非功能需求

### 8.1 性能要求

- **对话记录保存**: < 100ms
- **每日总结执行**: < 30秒（后台执行，不阻塞UI）
- **上下文构建**: < 200ms
- **数据库查询**: < 50ms
- **内存占用**: 总结过程 < 100MB

### 8.2 数据量要求

- **单个联系人对话记录**: 最多保留30天
- **单个联系人facts数量**: 建议不超过50条
- **单个联系人BrainTag数量**: 建议不超过20条
- **每日总结记录**: 永久保留（数据量小）

### 8.3 可靠性要求

- **对话记录成功率**: > 99.9%
- **每日总结成功率**: > 95%（允许重试）
- **数据一致性**: 强一致性（使用事务）
- **数据恢复**: 支持从每日总结恢复facts

### 8.4 兼容性要求

- **数据库版本**: 从v3升级到v4
- **数据迁移**: 自动迁移现有ContactProfile数据
- **向后兼容**: 旧版本数据能正常读取

---

## 9. 技术实现要点

### 9.1 数据库迁移

**当前数据库版本**：v3

**目标版本**：v4

**迁移策略**：
- MVP阶段：直接卸载重装（数据量小，用户可接受）
- 正式版本：提供完整的Migration脚本

**Migration脚本（v3→v4）**：

```kotlin
// data/local/DatabaseModule.kt
val MIGRATION_3_4 = object : Migration(3, 4) {
    override fun migrate(database: SupportSQLiteDatabase) {
        try {
            // 1. 创建conversation_logs表
            database.execSQL("""
                CREATE TABLE IF NOT EXISTS conversation_logs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                    contact_id TEXT NOT NULL,
                    user_input TEXT NOT NULL,
                    ai_response TEXT,
                    timestamp INTEGER NOT NULL,
                    is_summarized INTEGER NOT NULL DEFAULT 0,
                    FOREIGN KEY(contact_id) REFERENCES profiles(id) ON DELETE CASCADE
                )
            """)
            
            // 2. 创建daily_summaries表
            database.execSQL("""
                CREATE TABLE IF NOT EXISTS daily_summaries (
                    id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                    contact_id TEXT NOT NULL,
                    summary_date TEXT NOT NULL,
                    content TEXT NOT NULL,
                    key_events_json TEXT NOT NULL,
                    relationship_score INTEGER NOT NULL,
                    created_at INTEGER NOT NULL,
                    FOREIGN KEY(contact_id) REFERENCES profiles(id) ON DELETE CASCADE
                )
            """)
            
            // 3. 为profiles表添加新列
            database.execSQL("""
                ALTER TABLE profiles 
                ADD COLUMN relationship_score INTEGER NOT NULL DEFAULT 50
            """)
            
            database.execSQL("""
                ALTER TABLE profiles 
                ADD COLUMN last_interaction_date TEXT
            """)
            
            // 4. 创建索引
            database.execSQL("""
                CREATE INDEX IF NOT EXISTS idx_conversation_contact 
                ON conversation_logs(contact_id)
            """)
            
            database.execSQL("""
                CREATE INDEX IF NOT EXISTS idx_conversation_date 
                ON conversation_logs(timestamp)
            """)
            
            database.execSQL("""
                CREATE INDEX IF NOT EXISTS idx_conversation_summarized 
                ON conversation_logs(is_summarized)
            """)
            
            database.execSQL("""
                CREATE INDEX IF NOT EXISTS idx_summary_contact 
                ON daily_summaries(contact_id)
            """)
            
            database.execSQL("""
                CREATE INDEX IF NOT EXISTS idx_summary_date 
                ON daily_summaries(summary_date)
            """)
            
            database.execSQL("""
                CREATE UNIQUE INDEX IF NOT EXISTS idx_summary_contact_date 
                ON daily_summaries(contact_id, summary_date)
            """)
            
            // 5. 迁移facts数据（从Map<String, String>到List<Fact>）
            migrateFacts(database)
            
        } catch (e: Exception) {
            Log.e("Migration", "Failed to migrate from v3 to v4", e)
            throw e
        }
    }
    
    private fun migrateFacts(database: SupportSQLiteDatabase) {
        // 读取所有profiles
        val cursor = database.query("SELECT id, facts_json FROM profiles")
        val updates = mutableListOf<Pair<String, String>>()
        
        while (cursor.moveToNext()) {
            val id = cursor.getString(0)
            val oldFactsJson = cursor.getString(1)
            
            // 转换格式
            val newFactsJson = convertFactsFormat(oldFactsJson)
            updates.add(id to newFactsJson)
        }
        cursor.close()
        
        // 批量更新
        updates.forEach { (id, newFactsJson) ->
            database.execSQL(
                "UPDATE profiles SET facts_json = ? WHERE id = ?",
                arrayOf(newFactsJson, id)
            )
        }
    }
    
    private fun convertFactsFormat(oldJson: String): String {
        return try {
            val gson = Gson()
            val type = object : TypeToken<Map<String, String>>() {}.type
            val map: Map<String, String> = gson.fromJson(oldJson, type) ?: emptyMap()
            
            val facts = map.map { (key, value) ->
                mapOf(
                    "key" to key,
                    "value" to value,
                    "timestamp" to System.currentTimeMillis(),
                    "source" to "MANUAL"
                )
            }
            
            gson.toJson(facts)
        } catch (e: Exception) {
            "[]"  // 失败时返回空列表
        }
    }
}

// 在DatabaseModule中注册Migration
@Provides
@Singleton
fun provideAppDatabase(
    @ApplicationContext context: Context
): AppDatabase {
    return Room.databaseBuilder(
        context,
        AppDatabase::class.java,
        "empathy_database"
    )
    .addMigrations(MIGRATION_3_4)  // 注册迁移脚本
    .fallbackToDestructiveMigration()  // MVP阶段允许破坏性迁移
    .build()
}
```

**迁移测试**：
```kotlin
@Test
fun testMigration3To4() {
    // 创建v3数据库
    val helper = MigrationTestHelper(
        InstrumentationRegistry.getInstrumentation(),
        AppDatabase::class.java
    )
    
    val db = helper.createDatabase(TEST_DB, 3).apply {
        // 插入v3格式的测试数据
        execSQL("""
            INSERT INTO profiles (id, name, target_goal, context_depth, facts_json)
            VALUES ('test-id', '测试', '测试目标', 10, '{"性格":"急性子"}')
        """)
        close()
    }
    
    // 执行迁移
    helper.runMigrationsAndValidate(TEST_DB, 4, true, MIGRATION_3_4)
    
    // 验证迁移结果
    val migratedDb = helper.runMigrationsAndValidate(TEST_DB, 4, true)
    val cursor = migratedDb.query("SELECT * FROM profiles WHERE id = 'test-id'")
    
    assertTrue(cursor.moveToFirst())
    assertEquals(50, cursor.getInt(cursor.getColumnIndex("relationship_score")))
    assertNotNull(cursor.getString(cursor.getColumnIndex("facts_json")))
    
    cursor.close()
    migratedDb.close()
}
```

### 9.2 TypeConverter更新

```kotlin
class RoomTypeConverters {
    private val gson = Gson()
    
    // 新增：Fact列表转换
    @TypeConverter
    fun fromFactList(facts: List<Fact>): String {
        return gson.toJson(facts)
    }
    
    @TypeConverter
    fun toFactList(json: String): List<Fact> {
        val type = object : TypeToken<List<Fact>>() {}.type
        return try {
            gson.fromJson(json, type) ?: emptyList()
        } catch (e: Exception) {
            // 兼容旧版本Map格式
            migrateFromMapFormat(json)
        }
    }
    
    // 兼容旧版本数据
    private fun migrateFromMapFormat(json: String): List<Fact> {
        return try {
            val type = object : TypeToken<Map<String, String>>() {}.type
            val map: Map<String, String> = gson.fromJson(json, type) ?: emptyMap()
            map.map { (key, value) ->
                Fact(
                    key = key,
                    value = value,
                    timestamp = System.currentTimeMillis(),
                    source = FactSource.MANUAL
                )
            }
        } catch (e: Exception) {
            emptyList()
        }
    }
}
```

### 9.3 Repository接口扩展

```kotlin
// domain/repository/ConversationRepository.kt
interface ConversationRepository {
    // 保存用户输入
    suspend fun saveUserInput(
        contactId: String,
        userInput: String,
        timestamp: Long
    ): Result<Long>  // 返回记录ID
    
    // 保存AI回复
    suspend fun saveAiResponse(
        logId: Long,
        aiResponse: String
    ): Result<Unit>
    
    // 查询未总结的对话
    suspend fun getUnsummarizedLogs(
        sinceTimestamp: Long
    ): Result<List<ConversationLog>>
    
    // 标记为已总结
    suspend fun markAsSummarized(
        logIds: List<Long>
    ): Result<Unit>
    
    // 保存每日总结
    suspend fun saveDailySummary(
        summary: DailySummary
    ): Result<Unit>
    
    // 查询每日总结
    suspend fun getDailySummaries(
        contactId: String,
        limit: Int = 30
    ): Flow<List<DailySummary>>
    
    // 清理旧对话
    suspend fun cleanOldLogs(
        beforeTimestamp: Long
    ): Result<Int>  // 返回删除数量
}
```


### 9.4 UseCase实现

```kotlin
// domain/usecase/SummarizeDailyConversationsUseCase.kt
@Singleton
class SummarizeDailyConversationsUseCase @Inject constructor(
    private val conversationRepository: ConversationRepository,
    private val contactRepository: ContactRepository,
    private val brainTagRepository: BrainTagRepository,
    private val aiRepository: AiRepository,
    private val contextBuilder: ContextBuilder
) {
    suspend operator fun invoke(): Result<Unit> {
        return try {
            // 1. 获取未总结的对话（最多7天前）
            val sevenDaysAgo = System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000
            val unsummarizedLogs = conversationRepository
                .getUnsummarizedLogs(sevenDaysAgo)
                .getOrThrow()
            
            if (unsummarizedLogs.isEmpty()) {
                return Result.success(Unit)
            }
            
            // 2. 按日期和联系人分组
            val groupedLogs = unsummarizedLogs
                .groupBy { it.getDateString() }
                .flatMap { (date, logs) -> 
                    logs.groupBy { it.contactId }.map { (contactId, contactLogs) ->
                        Triple(date, contactId, contactLogs)
                    }
                }
            
            // 3. 对每组执行总结
            groupedLogs.forEach { (date, contactId, logs) ->
                try {
                    summarizeForContact(contactId, logs, date)
                } catch (e: Exception) {
                    Log.e("Summary", "Failed for $contactId on $date", e)
                    // 失败时不标记为已总结，下次继续尝试
                }
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun summarizeForContact(
        contactId: String,
        logs: List<ConversationLog>,
        date: String
    ) {
        // 1. 获取联系人信息
        val contact = contactRepository.getProfile(contactId).getOrNull() ?: return
        val tags = brainTagRepository.getTagsByContact(contactId).first()
        
        // 2. 构建总结Prompt
        val prompt = contextBuilder.buildSummaryPrompt(contact, tags, logs)
        
        // 3. 调用AI生成总结
        val summaryJson = aiRepository.generateSummary(prompt).getOrNull() ?: return
        
        // 4. 解析AI返回的JSON
        val summary = parseSummaryResponse(summaryJson, contactId, date)
        
        // 5. 更新数据（使用事务）
        updateContactData(contactId, contact, summary, date)
        
        // 6. 标记对话为已总结
        conversationRepository.markAsSummarized(logs.map { it.id })
    }
    
    private suspend fun updateContactData(
        contactId: String,
        contact: ContactProfile,
        summary: DailySummary,
        date: String
    ) {
        // 更新facts
        val updatedFacts = contact.facts.toMutableList()
        summary.newFacts.forEach { newFact ->
            val existingIndex = updatedFacts.indexOfFirst { it.key == newFact.key }
            if (existingIndex >= 0) {
                updatedFacts[existingIndex] = newFact
            } else {
                updatedFacts.add(newFact)
            }
        }
        
        // 更新关系分数
        val newScore = (contact.relationshipScore + summary.relationshipScoreChange)
            .coerceIn(0, 100)
        
        // 保存更新后的联系人信息
        val updatedContact = contact.copy(
            facts = updatedFacts,
            relationshipScore = newScore,
            lastInteractionDate = date
        )
        contactRepository.insertProfile(updatedContact)
        
        // 更新标签
        summary.updatedTags.forEach { tagUpdate ->
            when (tagUpdate.action) {
                "ADD" -> {
                    val newTag = BrainTag(
                        contactId = contactId,
                        content = tagUpdate.content,
                        type = TagType.valueOf(tagUpdate.type),
                        source = "AI_INFERRED"
                    )
                    brainTagRepository.insertTag(newTag)
                }
                "REMOVE" -> {
                    brainTagRepository.deleteTagByContent(contactId, tagUpdate.content)
                }
            }
        }
        
        // 保存每日总结记录
        conversationRepository.saveDailySummary(summary)
    }
}
```

### 9.5 UI调整

**ContactDetailScreen增强**：

```kotlin
// 显示关系分数
@Composable
fun RelationshipScoreSection(
    score: Int,
    lastInteractionDate: String?,
    trend: RelationshipTrend?
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant
        )
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "关系分数",
                style = MaterialTheme.typography.titleMedium
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // 分数和进度条
            Row(
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "$score/100",
                    style = MaterialTheme.typography.headlineMedium,
                    fontWeight = FontWeight.Bold
                )
                
                Spacer(modifier = Modifier.width(16.dp))
                
                LinearProgressIndicator(
                    progress = score / 100f,
                    modifier = Modifier
                        .weight(1f)
                        .height(8.dp)
                        .clip(RoundedCornerShape(4.dp))
                )
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // 最后互动日期和趋势
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                if (lastInteractionDate != null) {
                    Text(
                        text = "最后互动：$lastInteractionDate",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                
                if (trend != null) {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Text(
                            text = when (trend) {
                                RelationshipTrend.IMPROVING -> "改善中"
                                RelationshipTrend.STABLE -> "稳定"
                                RelationshipTrend.DECLINING -> "下降中"
                            },
                            style = MaterialTheme.typography.bodySmall,
                            color = when (trend) {
                                RelationshipTrend.IMPROVING -> Color(0xFF4CAF50)
                                RelationshipTrend.STABLE -> Color(0xFF2196F3)
                                RelationshipTrend.DECLINING -> Color(0xFFF44336)
                            }
                        )
                        Icon(
                            imageVector = when (trend) {
                                RelationshipTrend.IMPROVING -> Icons.Default.TrendingUp
                                RelationshipTrend.STABLE -> Icons.Default.TrendingFlat
                                RelationshipTrend.DECLINING -> Icons.Default.TrendingDown
                            },
                            contentDescription = null,
                            tint = when (trend) {
                                RelationshipTrend.IMPROVING -> Color(0xFF4CAF50)
                                RelationshipTrend.STABLE -> Color(0xFF2196F3)
                                RelationshipTrend.DECLINING -> Color(0xFFF44336)
                            },
                            modifier = Modifier.size(16.dp)
                        )
                    }
                }
            }
        }
    }
}

// Facts列表显示时间戳
@Composable
fun FactItem(fact: Fact) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = fact.key,
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.Medium
            )
            Text(
                text = fact.value,
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
        
        Column(horizontalAlignment = Alignment.End) {
            Text(
                text = formatDate(fact.timestamp),
                style = MaterialTheme.typography.labelSmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            if (fact.source == FactSource.AI_INFERRED) {
                Text(
                    text = "AI推断",
                    style = MaterialTheme.typography.labelSmall,
                    color = MaterialTheme.colorScheme.primary
                )
            }
        }
    }
}
```

---

## 10. 错误处理和降级方案

### 10.1 AI调用失败处理

**失败类型和处理策略**：

| 失败类型 | 检测方式 | 处理策略 | 用户提示 |
|---------|---------|---------|---------|
| 网络错误 | IOException | 重试3次，失败后降级 | "网络连接失败，已使用本地统计" |
| API额度用完 | HTTP 429 | 立即降级，不重试 | "API额度不足，已使用本地统计" |
| API密钥无效 | HTTP 401 | 立即降级，提示配置 | "API密钥无效，请检查配置" |
| 响应超时 | TimeoutException | 重试1次，失败后降级 | "AI响应超时，已使用本地统计" |
| JSON解析失败 | JsonException | 重试3次，失败后降级 | "AI响应格式错误，已使用本地统计" |
| 服务不可用 | HTTP 5xx | 重试3次，失败后降级 | "AI服务暂时不可用" |

**重试策略**：

```kotlin
// domain/util/RetryPolicy.kt
class RetryPolicy {
    companion object {
        const val MAX_RETRIES = 3
        const val INITIAL_DELAY = 1000L  // 1秒
        const val MAX_DELAY = 10000L     // 10秒
        const val MULTIPLIER = 2.0       // 指数退避
    }
    
    suspend fun <T> executeWithRetry(
        maxRetries: Int = MAX_RETRIES,
        shouldRetry: (Throwable) -> Boolean = { true },
        block: suspend () -> T
    ): Result<T> {
        var currentDelay = INITIAL_DELAY
        var lastException: Throwable? = null
        
        repeat(maxRetries) { attempt ->
            try {
                return Result.success(block())
            } catch (e: Exception) {
                lastException = e
                
                // 判断是否应该重试
                if (!shouldRetry(e) || attempt == maxRetries - 1) {
                    return Result.failure(e)
                }
                
                // 指数退避
                delay(currentDelay)
                currentDelay = (currentDelay * MULTIPLIER).toLong()
                    .coerceAtMost(MAX_DELAY)
                
                Log.w("RetryPolicy", "Retry attempt ${attempt + 1}/$maxRetries", e)
            }
        }
        
        return Result.failure(lastException ?: Exception("Unknown error"))
    }
}

// 使用示例
suspend fun generateSummary(prompt: String): Result<String> {
    return retryPolicy.executeWithRetry(
        shouldRetry = { e ->
            // 只重试网络错误和超时，不重试认证错误
            e is IOException || e is TimeoutException
        }
    ) {
        aiRepository.generateSummary(prompt).getOrThrow()
    }
}
```

### 10.2 数据一致性保证

**事务处理**：

```kotlin
// 使用Room事务保证数据一致性
@Transaction
suspend fun updateContactData(
    contactId: String,
    contact: ContactProfile,
    summary: DailySummary,
    date: String
) {
    try {
        // 1. 更新联系人信息
        contactRepository.insertProfile(updatedContact)
        
        // 2. 更新标签
        summary.updatedTags.forEach { tagUpdate ->
            when (tagUpdate.action) {
                "ADD" -> brainTagRepository.insertTag(newTag)
                "REMOVE" -> brainTagRepository.deleteTagByContent(contactId, tagUpdate.content)
            }
        }
        
        // 3. 保存每日总结
        conversationRepository.saveDailySummary(summary)
        
        // 4. 标记对话为已总结
        conversationRepository.markAsSummarized(logIds)
        
    } catch (e: Exception) {
        // 事务失败，所有操作回滚
        Log.e("UpdateData", "Transaction failed, rolling back", e)
        throw e
    }
}
```

**数据校验**：

```kotlin
// 保存前校验数据有效性
private fun validateSummary(summary: DailySummary): Result<Unit> {
    return try {
        // 1. 检查必填字段
        require(summary.contactId.isNotBlank()) { "contactId不能为空" }
        require(summary.summaryDate.isNotBlank()) { "summaryDate不能为空" }
        require(summary.content.isNotBlank()) { "content不能为空" }
        
        // 2. 检查分数范围
        require(summary.relationshipScoreChange in -10..10) {
            "relationshipScoreChange必须在-10到10之间"
        }
        
        // 3. 检查日期格式
        require(summary.summaryDate.matches(Regex("\\d{4}-\\d{2}-\\d{2}"))) {
            "summaryDate格式必须为yyyy-MM-dd"
        }
        
        // 4. 检查newFacts格式
        summary.newFacts.forEach { fact ->
            require(fact.key.isNotBlank()) { "fact.key不能为空" }
            require(fact.value.isNotBlank()) { "fact.value不能为空" }
        }
        
        Result.success(Unit)
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

### 10.3 异常监控和日志

**日志级别**：

```kotlin
// 关键操作日志
Log.i("Memory", "开始每日总结，日期：$date，联系人数：${contacts.size}")
Log.i("Memory", "总结完成，成功：$successCount，失败：$failCount")

// 警告日志
Log.w("Memory", "AI调用失败，启用降级方案，原因：${e.message}")
Log.w("Memory", "数据校验失败，跳过此条记录，原因：${e.message}")

// 错误日志
Log.e("Memory", "数据库迁移失败", e)
Log.e("Memory", "事务回滚失败", e)
```

**性能监控**：

```kotlin
// 记录关键操作耗时
val startTime = System.currentTimeMillis()
summarizeDailyConversations()
val duration = System.currentTimeMillis() - startTime
Log.i("Performance", "每日总结耗时：${duration}ms")

// 记录数据量
Log.i("Performance", "处理对话记录：${logs.size}条")
Log.i("Performance", "更新facts：${newFacts.size}条")
```

### 10.4 用户反馈机制

**错误提示**：

```kotlin
// 在UI层显示友好的错误提示
when (error) {
    is NetworkException -> "网络连接失败，请检查网络设置"
    is ApiKeyException -> "API密钥无效，请前往设置页面配置"
    is QuotaException -> "API额度不足，请充值或更换服务商"
    is TimeoutException -> "AI响应超时，请稍后重试"
    is ParseException -> "AI响应格式错误，已使用本地统计"
    else -> "操作失败：${error.message}"
}
```

**降级提示**：

```kotlin
// 使用降级方案时显示提示
if (usedFallback) {
    Snackbar.make(
        view,
        "AI服务暂时不可用，已使用本地统计",
        Snackbar.LENGTH_LONG
    ).setAction("了解详情") {
        // 显示详细说明
    }.show()
}
```

---

## 11. 验收标准

### 11.1 功能验收

**对话记录功能**：
- [ ] 用户发起分析时，自动保存用户输入到数据库
- [ ] AI回复后，自动保存回复内容到数据库
- [ ] 对话记录包含完整的时间戳和联系人关联
- [ ] 即使AI分析失败，用户输入也会被保存
- [ ] 对话记录能按联系人和时间查询

**每日总结功能**：
- [ ] 新一天首次打开App时自动触发总结
- [ ] 总结能正确提取昨日所有对话
- [ ] 总结能自动发现并添加新的facts
- [ ] 总结能自动调整BrainTag标签
- [ ] 总结能自动更新关系分数（-10到+10）
- [ ] 总结失败时保留未总结状态，下次继续尝试
- [ ] 超过7天的未总结对话自动放弃
- [ ] AI调用失败3次后启用本地降级方案

**Facts功能**：
- [ ] Facts结构包含key、value、timestamp、source
- [ ] Facts能正确保存到数据库（JSON格式）
- [ ] Facts能正确从数据库读取并解析
- [ ] 旧版本Map格式的facts能自动迁移

**AI Prompt功能**：
- [ ] 分析请求Prompt能正确识别雷区（测试通过率≥80%）
- [ ] 每日总结Prompt能准确评估关系变化（测试通过率≥80%）
- [ ] 安全检查Prompt能正确判断风险等级（测试通过率≥80%）
- [ ] 所有Prompt输出的JSON格式正确（解析成功率≥95%）
- [ ] Prompt测试用例覆盖所有典型场景（至少10个）
- [ ] Prompt测试报告完整记录测试结果和优化历史

**错误处理功能**：
- [ ] 网络错误能正确重试（最多3次）
- [ ] API额度用完能立即降级
- [ ] 响应超时能正确处理
- [ ] JSON解析失败能正确重试
- [ ] 降级方案能正常工作
- [ ] 所有异常都有友好的用户提示
- [ ] Facts在UI上显示时间戳和来源标记

**关系分数功能**：
- [ ] 新联系人默认分数为50
- [ ] 关系分数在0-100范围内
- [ ] 每日总结后分数能正确更新
- [ ] 分数变化范围为-10到+10
- [ ] 联系人详情页正确显示分数和进度条
- [ ] 显示最后互动日期
- [ ] 显示关系趋势（改善/稳定/下降）

**上下文构建功能**：
- [ ] 能正确筛选最近7天的所有facts
- [ ] 能正确筛选7-30天的手动facts
- [ ] 能正确筛选30天以上的手动facts
- [ ] Facts总数控制在20条以内
- [ ] 所有BrainTag标签都会被包含
- [ ] 构建的Prompt结构清晰，格式正确

**数据迁移功能**：
- [ ] 数据库能从v3正确升级到v4
- [ ] 旧版本的facts数据能正确迁移
- [ ] 新增的表和索引能正确创建
- [ ] 迁移后应用能正常运行
- [ ] 迁移失败时有明确的错误提示

### 10.2 性能验收

- [ ] 对话记录保存时间 < 100ms
- [ ] 每日总结执行时间 < 30秒（后台执行）
- [ ] 上下文构建时间 < 200ms
- [ ] 数据库查询时间 < 50ms
- [ ] 总结过程内存占用 < 100MB
- [ ] 不阻塞UI线程
- [ ] 不影响应用启动速度

### 10.3 可靠性验收

- [ ] 对话记录保存成功率 > 99.9%
- [ ] 每日总结成功率 > 95%
- [ ] AI调用失败时能正确重试
- [ ] 数据更新使用事务，保证一致性
- [ ] 异常情况不导致应用崩溃
- [ ] 数据损坏时能自动恢复

### 10.4 兼容性验收

- [ ] 在Android 7.0（API 24）上正常运行
- [ ] 在Android 14（API 34）上正常运行
- [ ] 旧版本数据能正确迁移
- [ ] 新旧版本数据格式兼容
- [ ] 不同设备上表现一致

### 10.5 用户体验验收

- [ ] 对话记录过程用户无感知
- [ ] 每日总结过程用户无感知
- [ ] 关系分数展示直观易懂
- [ ] Facts列表清晰易读
- [ ] 时间戳格式友好
- [ ] 来源标记清晰明确

---

## 11. 风险评估

### 11.1 技术风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| AI总结质量不稳定 | 高 | 中 | 优化Prompt，增加示例，设置质量检查 |
| 数据迁移失败 | 高 | 低 | 充分测试，提供回滚机制 |
| 性能问题（大量对话） | 中 | 中 | 分页查询，限制数据量，定期清理 |
| 内存占用过高 | 中 | 低 | 流式处理，及时释放资源 |
| 并发问题 | 中 | 低 | 使用事务，加锁保护 |

### 11.2 产品风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| 用户不理解关系分数 | 中 | 中 | 提供说明文档，增加引导 |
| AI推断的facts不准确 | 中 | 中 | 标记来源，允许用户删除 |
| 每日总结消耗API额度 | 中 | 高 | 提供开关，允许用户控制 |
| 隐私担忧（对话记录） | 高 | 低 | 强调本地存储，提供清除功能 |

### 11.3 成本风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| API调用成本增加 | 中 | 高 | 批量处理，优化Prompt长度 |
| 存储空间占用 | 低 | 中 | 定期清理，压缩存储 |

---

## 12. 后续版本规划

### v1.1 - 记忆管理增强

- [ ] Facts手动编辑UI
- [ ] 对话记录查看界面
- [ ] 每日总结手动触发
- [ ] 每日总结查看界面

### v1.2 - 智能化提升

- [ ] Facts重要性评分系统
- [ ] 向量搜索（语义检索）
- [ ] 记忆遗忘机制
- [ ] 智能推荐相关facts

### v1.3 - 可视化增强

- [ ] 关系进展时间线
- [ ] 互动频率统计
- [ ] 关系热力图
- [ ] Facts关联图谱

### v2.0 - 高级功能

- [ ] 多人关系网络
- [ ] 群组记忆
- [ ] 记忆导入导出
- [ ] 记忆分享

---

## 13. 附录

### 13.1 相关文档

- [FD-00003-联系人画像记忆系统设计](../FD/FD-00003-联系人画像记忆系统设计.md)（待创建）
- [TDD-00003-记忆系统架构设计](../TDD/TDD-00003-记忆系统架构设计.md)（待创建）
- [PRD-00001-悬浮窗功能需求](./PRD-00001-悬浮窗功能需求.md)
- [PRD-00002-设置功能需求](./PRD-00002-设置功能需求.md)

### 13.2 术语表

- **短期记忆**: 对话记录，保留原始互动内容
- **中期记忆**: 每日总结，AI生成的互动摘要
- **长期记忆**: 联系人画像，包含facts、标签、关系分数
- **Fact**: 事实性信息，包含key、value、timestamp、source
- **关系分数**: 0-100的量化指标，表示关系亲密程度
- **上下文构建**: 从大量信息中筛选相关内容的过程
- **每日总结**: AI自动生成的每日互动摘要和分析

### 13.3 参考资料

- [ATRI记忆系统开发方案](../../../记忆方案.md) - 借鉴的记忆系统设计
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Room数据库文档](https://developer.android.com/training/data-storage/room)
- [Kotlin Coroutines文档](https://kotlinlang.org/docs/coroutines-overview.html)

### 13.4 变更记录

| 版本 | 日期 | 变更内容 | 变更人 |
|------|------|----------|--------|
| v1.0 | 2025-12-14 | 初始版本，完整PRD文档 | Claude |
| v1.1 | 2025-12-14 | 优化更新：<br>1. 修正日期错误（2024→2025）<br>2. 确认数据库版本（v3→v4）<br>3. 增强AI Prompt设计（详细评分标准和测试用例）<br>4. 补充错误处理章节（重试策略、降级方案、数据一致性）<br>5. 完善数据库迁移脚本（包含测试代码）<br>6. 添加AI调用失败的本地降级方案 | Claude |

---

## 14. 总结

本PRD定义了联系人画像记忆系统的完整需求，核心创新点包括：

1. **三层记忆架构**：短期（对话记录）→ 中期（每日总结）→ 长期（联系人画像）
2. **AI驱动的自动化**：自动记录、自动总结、自动更新
3. **关系量化追踪**：0-100分的关系分数系统
4. **智能上下文构建**：分层筛选，避免信息过载
5. **本地化适配**：完全本地存储，保护隐私

MVP阶段聚焦核心功能，后续版本逐步增强智能化和可视化能力。

**关键成功因素**：
- AI Prompt质量（决定总结准确性）
- 数据迁移稳定性（影响用户升级体验）
- 性能优化（确保不影响用户体验）
- 隐私保护（建立用户信任）

**下一步行动**：
1. 评审并确认PRD
2. 创建FD（功能设计）文档
3. 创建TDD（技术设计）文档
4. 开始实现开发

