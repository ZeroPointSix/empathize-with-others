# PRD-00008 输入内容身份识别与双向对话历史需求

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档编号 | PRD-00008 |
| 创建日期 | 2025-12-17 |
| 更新日期 | 2025-12-17 |
| 状态 | 草稿 |
| 关联文档 | PRD-00007（对话上下文连续性增强） |

---

## 1. 背景与目标

### 1.1 背景

当前 AI 分析功能存在一个核心问题：**AI 无法区分输入框里的文字是"对方发来的"还是"我想回复的"**，导致分析结果可能错乱。

**问题场景示例**：
- 用户粘贴对方的消息"你怎么才回消息？"，点击【帮我分析】
- AI 应该分析"对方为什么这么说"，给出回复建议
- 但如果 AI 误以为这是用户要发的内容，就会给出完全错误的建议

**根本原因**：系统没有告诉 AI 输入内容的"身份"（是对方说的，还是我要说的）。

### 1.2 目标

构建一个智能的身份识别系统，实现：

1. **自动身份标识**：根据用户点击的功能按钮，自动为输入内容添加身份前缀
2. **双向对话历史**：区分存储"对方说的"和"我回复的"内容
3. **AI 角色隔离**：确保 AI 始终以"第三人称军师"视角分析，不混淆身份
4. **无感体验**：用户无需手动标记，系统自动处理

---

## 2. 核心设计理念

### 2.1 功能按钮作为"身份判定器"

用户不需要手动告诉 AI 谁在说话，而是通过点击不同的按钮，系统在后台自动拼接身份标识。

| 功能按钮 | 输入内容身份 | 身份前缀 |
|---------|-------------|---------|
| 【帮我分析】 | 对方说的 | `【对方说】：` |
| 【帮我检查】 | 我要发的草稿 | `【我正在回复】：` |
| 【帮我润色】（未来） | 我要发的草稿 | `【我正在回复】：` |

### 2.2 Prompt 世界观设定

在系统级提示词中明确"世界观"，让 AI 理解身份标识的含义：

```
你是一个辅助聊天的 AI 军师。

【重要】关于输入内容的身份识别：
- 如果内容以【对方说】开头，表示这是对方发给用户的消息，你需要站在用户的角度分析对方的意图
- 如果内容以【我正在回复】开头，表示这是用户打算发送的内容，你需要帮助检查风险或润色

你永远站在用户这边，帮助用户更好地沟通。
```

### 2.3 双向对话历史

通过身份前缀，在历史记录中区分"对方说的"和"我回复的"：

```
【历史对话】(最近3条)
[历史记录 - 08:30]: 【对方说】：你怎么才回消息？
[历史记录 - 08:35]: 【我正在回复】：刚才在开会，抱歉让你久等了
[历史记录 - 09:00]: 【对方说】：好吧，下次记得提前说一声
```

---

## 3. 功能需求

### 3.1 输入内容身份标识

#### 3.1.1 自动添加身份前缀

**触发时机**：用户点击功能按钮时

**处理逻辑**：

```kotlin
// 伪代码
fun processInput(userInput: String, actionType: ActionType): String {
    val prefix = when (actionType) {
        ActionType.ANALYZE -> "【对方说】："
        ActionType.CHECK -> "【我正在回复】："
        ActionType.POLISH -> "【我正在回复】："  // 未来功能
    }
    return "$prefix$userInput"
}
```

**示例**：

| 用户输入 | 点击按钮 | 发送给 AI 的内容 |
|---------|---------|-----------------|
| 你怎么才回消息？ | 帮我分析 | 【对方说】：你怎么才回消息？ |
| 刚才在忙 | 帮我检查 | 【我正在回复】：刚才在忙 |

#### 3.1.2 多行输入处理

如果用户粘贴的是多行对话，整体添加前缀：

```
用户输入：
你怎么才回消息？
我等了你好久

发送给 AI：
【对方说】：
你怎么才回消息？
我等了你好久
```

### 3.2 对话历史存储

#### 3.2.1 存储规则

| 功能 | 是否存储历史 | 存储内容 |
|-----|-------------|---------|
| 帮我分析 | ✅ 是 | `【对方说】：{用户输入}` |
| 帮我检查 | ❌ 否 | 不存储（只是预检查，用户可能修改） |
| 帮我润色（未来） | ✅ 是（用户复制后） | `【我正在回复】：{润色结果}` |

**设计理由**：
- 【帮我分析】存储对方的话，因为这是真实发生的对话
- 【帮我检查】不存储，因为只是草稿预检查，用户可能修改后再发
- 【帮我润色】存储润色结果（而非原始草稿），因为这通常是用户最终发出去的版本

#### 3.2.2 数据结构

**复用现有 `conversation_logs` 表**，不新增字段：

```kotlin
// 现有结构
data class ConversationLog(
    val id: Long,
    val contactId: String,
    val userInput: String,      // 存储带身份前缀的内容
    val aiResponse: String?,
    val timestamp: Long,
    val isSummarized: Boolean
)

// 存储示例
ConversationLog(
    userInput = "【对方说】：你怎么才回消息？",
    // ...
)
```

### 3.3 历史上下文构建

#### 3.3.1 历史回放格式

在构建历史上下文时，保留身份前缀：

```
【历史对话】(最近3条)

--- [2025-12-17] ---
[历史记录 - 08:30]: 【对方说】：早安
[历史记录 - 08:32]: 【我正在回复】：早呀，今天天气真好

--- (对话暂停了 2 小时) ---
[历史记录 - 10:30]: 【对方说】：你在干嘛呢
```

#### 3.3.2 身份前缀解析

`ConversationContextBuilder` 需要识别并保留历史记录中的身份前缀：

```kotlin
// 如果历史记录已有身份前缀，直接使用
// 如果没有（旧数据），按现有逻辑处理
fun parseIdentityPrefix(content: String): Pair<String, String> {
    return when {
        content.startsWith("【对方说】：") -> 
            "【对方说】" to content.removePrefix("【对方说】：")
        content.startsWith("【我正在回复】：") -> 
            "【我正在回复】" to content.removePrefix("【我正在回复】：")
        else -> 
            "" to content  // 旧数据，无前缀
    }
}
```

### 3.4 系统提示词增强

#### 3.4.1 ANALYZE 场景提示词

修改 `SystemPrompts.ANALYZE_HEADER`：

```kotlin
private const val ANALYZE_HEADER = """你是一个专业的社交沟通分析助手（AI军师）。

【重要】关于输入内容的身份识别：
- 如果内容以【对方说】开头，表示这是对方发给用户的消息
- 如果内容以【我正在回复】开头，表示这是用户打算发送的内容
- 你需要始终站在用户的角度，帮助用户分析对方的意图并给出回复建议

你的职责是：
1. 分析聊天上下文和联系人画像
2. 识别对方的情绪状态和沟通意图
3. 发现潜在的沟通风险点
4. 提供具体可行的回复建议

重要原则：
- 保持客观中立，不做道德评判
- 建议应该具体可执行，而非泛泛而谈
- 尊重用户的沟通目标和关系定位
- 永远不要模仿对方说话，而是分析对方的话
- 回复时请直接输出分析结果或建议内容，不要重复输入内容，也不要自行添加任何【】格式的角色前缀"""
```

#### 3.4.2 CHECK 场景提示词

修改 `SystemPrompts.CHECK_HEADER`：

```kotlin
private const val CHECK_HEADER = """你是一个社交沟通安全检查助手。

【重要】关于输入内容的身份识别：
- 输入内容以【我正在回复】开头，表示这是用户打算发送的草稿
- 你需要帮助用户检查这段草稿是否存在风险

你的职责是：
1. 检查用户草稿是否触及敏感话题
2. 识别可能引起误解的表达
3. 评估语气是否合适
4. 提供修改建议

重要原则：
- 基于已知的雷区信息进行检查
- 宁可多提醒，不可漏检
- 给出具体的修改建议
- 回复时请直接输出检查结果，不要重复输入内容，也不要自行添加任何【】格式的角色前缀"""
```

### 3.5 历史记录缺口问题（已知限制）

#### 3.5.1 问题场景

```
1. 用户写了"刚才在忙"，点【帮我检查】
2. AI 说"没问题"
3. 用户把这句话发给了对方
4. 此时，系统历史里没有这句话
5. 当对方回"好吧"时，用户再点【帮我分析】
6. AI 看到的历史是断层的（只有对方上一句，没有我这一句）
```

#### 3.5.2 MVP 阶段处理方案

**接受现状**：MVP 阶段偶尔会有历史缺失，这是可接受的。

**产品引导**：
- 未来引导用户使用【帮我润色】作为最终发送出口
- 润色功能会自动存档用户发送的内容

#### 3.5.3 后续优化方向

| 方案 | 描述 | 复杂度 |
|-----|------|-------|
| 润色存档 | 用户复制润色结果时自动存档 | 中 |
| 手动补录 | 用户可在事实流界面手动添加"我发送的"记录 | 低 |
| 剪贴板监听 | 监听用户复制行为，智能判断是否存档 | 高 |

### 3.6 润色结果存档（未来功能预留）

#### 3.5.1 触发条件

当用户复制 AI 润色后的结果时，静默自动保存到历史记录。

#### 3.5.2 技术方案

监听剪贴板变化（Android 10+ 有限制，需要前台服务或其他方案）：

```kotlin
// 方案1：在悬浮窗中提供"复制"按钮，点击时同时保存
fun onCopyPolishedResult(result: String, contactId: String) {
    // 复制到剪贴板
    clipboardManager.setPrimaryClip(ClipData.newPlainText("polished", result))
    
    // 静默保存到历史
    conversationRepository.saveUserInput(
        contactId = contactId,
        userInput = "【我正在回复】：$result"
    )
}
```

#### 3.5.3 MVP 阶段

本次 MVP 不实现润色功能，仅预留接口设计。

---

## 4. 技术实现要点

### 4.1 修改 AnalyzeChatUseCase

```kotlin
class AnalyzeChatUseCase @Inject constructor(...) {
    
    companion object {
        const val IDENTITY_PREFIX_CONTACT = "【对方说】："
    }
    
    suspend operator fun invoke(
        contactId: String,
        rawScreenContext: List<String>
    ): Result<AnalysisResult> {
        // ... 现有逻辑 ...
        
        // 【新增】保存时添加身份前缀
        val userInputText = cleanedContext.joinToString("\n")
        val prefixedInput = "$IDENTITY_PREFIX_CONTACT$userInputText"
        conversationLogId = saveUserInput(contactId, prefixedInput)
        
        // 【新增】发送给 AI 时也添加前缀
        val prefixedContext = maskedContext.map { "$IDENTITY_PREFIX_CONTACT$it" }
        
        // ... 后续逻辑 ...
    }
}
```

### 4.2 修改 CheckDraftUseCase

```kotlin
class CheckDraftUseCase @Inject constructor(...) {
    
    companion object {
        const val IDENTITY_PREFIX_USER = "【我正在回复】："
    }
    
    suspend operator fun invoke(
        contactId: String,
        draftSnapshot: String,
        enableDeepCheck: Boolean = false
    ): Result<SafetyCheckResult> {
        // ... 现有逻辑 ...
        
        // 【新增】发送给 AI 时添加身份前缀
        val prefixedDraft = "$IDENTITY_PREFIX_USER$maskedDraft"
        
        // 【注意】检查功能不保存历史记录
        
        // ... 后续逻辑 ...
    }
}
```

### 4.3 修改 ConversationContextBuilder

```kotlin
@Singleton
class ConversationContextBuilder @Inject constructor() {
    
    companion object {
        const val PREFIX_CONTACT = "【对方说】："
        const val PREFIX_USER = "【我正在回复】："
    }
    
    /**
     * 解析身份前缀
     */
    fun parseIdentityPrefix(content: String): Pair<String, String> {
        return when {
            content.startsWith(PREFIX_CONTACT) -> 
                "对方" to content.removePrefix(PREFIX_CONTACT)
            content.startsWith(PREFIX_USER) -> 
                "我" to content.removePrefix(PREFIX_USER)
            else -> 
                "历史" to content  // 旧数据兼容
        }
    }
    
    /**
     * 构建历史上下文（保留身份前缀）
     */
    fun buildHistoryContext(
        messages: List<TimestampedMessage>,
        config: ConversationContextConfig = ConversationContextConfig()
    ): String {
        // ... 现有逻辑 ...
        
        messages.forEach { message ->
            // 保留原始内容（包含身份前缀）
            appendLine("[历史记录 - ${message.getFormattedTime()}]: ${message.content}")
        }
    }
}
```

### 4.4 修改 SystemPrompts

在 `SystemPrompts.kt` 中更新提示词，加入身份识别说明。

---

## 5. 数据兼容性

### 5.1 旧数据处理

现有 `conversation_logs` 表中的数据没有身份前缀，需要兼容处理：

| 数据类型 | 处理方式 |
|---------|---------|
| 旧数据（无前缀） | 按现有逻辑处理，显示为 `[历史记录]` |
| 新数据（有前缀） | 解析前缀，显示为 `【对方说】` 或 `【我正在回复】` |

### 5.2 数据库迁移

**无需数据库迁移**，身份前缀直接存储在 `userInput` 字段中。

---

## 6. 用户界面

### 6.1 悬浮窗按钮

**本次不修改**，保持现有的【帮我分析】【帮我检查】按钮。

### 6.2 事实流界面（UI 渲染优化）

#### 6.2.1 设计原则

**存储层**：带身份前缀（`【对方说】：xxx`）
**展示层**：解析前缀，以自然对话流形式展示

#### 6.2.2 UI 渲染规则

| 身份前缀 | UI 渲染方式 |
|---------|------------|
| `【对方说】：` | 气泡靠左，浅灰色背景，显示"对方"标签 |
| `【我正在回复】：` | 气泡靠右，主题色背景，显示"我"标签 |
| 无前缀（旧数据） | 居中显示，中性背景 |

#### 6.2.3 UI 示例

```
┌─────────────────────────────────────┐
│ 📅 2025-12-17                       │
│                                     │
│ ┌──────────────────┐                │
│ │ 对方 · 08:30     │                │
│ │ 你怎么才回消息？  │                │
│ └──────────────────┘                │
│                                     │
│                ┌──────────────────┐ │
│                │ 我 · 08:35       │ │
│                │ 刚才在开会        │ │
│                └──────────────────┘ │
└─────────────────────────────────────┘
```

#### 6.2.4 技术实现

在 `ConversationCard` 或类似组件中解析身份前缀：

```kotlin
@Composable
fun ConversationCard(log: ConversationLog) {
    val (sender, content) = parseIdentityPrefix(log.userInput)
    
    val alignment = when (sender) {
        "对方" -> Alignment.Start
        "我" -> Alignment.End
        else -> Alignment.CenterHorizontally
    }
    
    val backgroundColor = when (sender) {
        "对方" -> MaterialTheme.colorScheme.surfaceVariant
        "我" -> MaterialTheme.colorScheme.primaryContainer
        else -> MaterialTheme.colorScheme.surface
    }
    
    // 渲染气泡...
}
```

### 6.3 编辑对话

用户可以在事实流界面编辑整条对话记录。编辑时显示原始内容（包含前缀），保存后重新解析渲染。

---

## 7. 非功能需求

### 7.1 性能要求

- 身份前缀添加：< 1ms（纯字符串拼接）
- 身份前缀解析：< 1ms
- 不增加额外的数据库查询

### 7.2 兼容性要求

- 向后兼容：旧数据正常显示
- 向前兼容：新数据在旧版本中显示为普通文本

---

## 8. 不包含的功能（后续版本）

- [ ] 【帮我润色】功能及其存档逻辑
- [ ] 悬浮窗按钮优化（深度解读、帮我回复、帮我润色）
- [ ] 自动识别用户输入中的对话格式（如"我：xxx"）
- [ ] 剪贴板监听自动存档

---

## 9. 验收标准

### 9.1 功能验收

- [ ] 点击【帮我分析】时，发送给 AI 的内容自动添加 `【对方说】：` 前缀
- [ ] 点击【帮我检查】时，发送给 AI 的内容自动添加 `【我正在回复】：` 前缀
- [ ] 【帮我分析】的输入内容正确保存到历史记录（带前缀）
- [ ] 【帮我检查】的输入内容不保存到历史记录
- [ ] 历史上下文构建时正确保留身份前缀
- [ ] AI 能正确理解身份前缀的含义
- [ ] 旧数据（无前缀）正常显示和处理

### 9.2 AI 行为验收

- [ ] AI 分析时能正确识别"对方说的"内容
- [ ] AI 检查时能正确识别"我要发的"内容
- [ ] AI 始终以"军师"视角回复，不混淆身份
- [ ] AI 回复不包含【】格式的角色前缀（防回声）
- [ ] AI 回复不重复输入内容

### 9.3 用户体验验收

- [ ] 用户无需手动标记身份
- [ ] 事实流界面以自然对话流形式展示（左右气泡）
- [ ] UI 不显示原始的【】前缀
- [ ] "对方"消息靠左显示，"我"的消息靠右显示
- [ ] 编辑对话功能正常

---

## 10. 风险评估

| 风险 | 等级 | 缓解措施 |
|-----|------|---------|
| AI 不理解身份前缀 | 低 | 在系统提示词中明确说明 |
| AI 回声问题（复读前缀） | 中 | 在提示词中加入"防回声"规则 |
| 旧数据兼容问题 | 低 | 无前缀数据按现有逻辑处理 |
| 用户误解前缀含义 | 低 | UI 层隐藏前缀，以自然对话流展示 |
| Token 消耗增加 | 极低 | 每条消息仅增加几个字符 |
| 历史记录缺口（检查后发送） | 中 | MVP 接受现状，后续通过润色功能补全 |

---

## 11. 实现计划

### 阶段1：核心逻辑（预计0.5天）
1. 定义身份前缀常量
2. 修改 `AnalyzeChatUseCase`，添加身份前缀
3. 修改 `CheckDraftUseCase`，添加身份前缀（不保存历史）

### 阶段2：提示词优化（预计0.5天）
1. 修改 `SystemPrompts.ANALYZE_HEADER`，加入身份识别说明和防回声规则
2. 修改 `SystemPrompts.CHECK_HEADER`，加入身份识别说明和防回声规则
3. 验证 AI 理解效果

### 阶段3：历史上下文适配（预计0.5天）
1. 修改 `ConversationContextBuilder`，支持身份前缀解析
2. 确保历史回放时保留前缀
3. 旧数据兼容处理

### 阶段4：UI 渲染优化（预计0.5天）
1. 修改 `ConversationCard`，解析身份前缀
2. 实现左右气泡布局
3. 添加"对方"/"我"标签显示

### 阶段5：测试（预计0.5天）
1. 单元测试：身份前缀添加和解析
2. 集成测试：完整流程验证
3. AI 行为测试：验证 AI 理解效果和防回声效果
4. UI 测试：验证气泡渲染正确

**总预计工作量**：2.5天

---

## 12. 相关文档

- [PRD-00007-对话上下文连续性增强需求](./PRD-00007-对话上下文连续性增强需求.md)
- [AnalyzeChatUseCase.kt](../../../app/src/main/java/com/empathy/ai/domain/usecase/AnalyzeChatUseCase.kt)
- [CheckDraftUseCase.kt](../../../app/src/main/java/com/empathy/ai/domain/usecase/CheckDraftUseCase.kt)
- [SystemPrompts.kt](../../../app/src/main/java/com/empathy/ai/domain/util/SystemPrompts.kt)
- [ConversationContextBuilder.kt](../../../app/src/main/java/com/empathy/ai/domain/util/ConversationContextBuilder.kt)
