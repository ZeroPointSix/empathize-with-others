# TDD-00000-快捷回复模板功能技术设计

> 版本: v1.0 | 创建日期: 2025-12-22 | 关联文档: PRD-00000, FD-00000

## 1. 技术概述

本文档描述快捷回复模板功能的技术实现方案，遵循项目Clean Architecture + MVVM架构规范。

## 2. 架构设计

### 2.1 模块依赖关系

```
┌─────────────────────────────────────────────────────────────┐
│                      Presentation Layer                      │
│  ┌───────────────────┐  ┌───────────────────────────────┐   │
│  │TemplateListScreen │  │    FloatingViewV2 (修改)      │   │
│  │TemplateListVM     │  │    + QuickTemplateButton      │   │
│  └─────────┬─────────┘  └───────────────┬───────────────┘   │
│            │                            │                    │
│            └────────────┬───────────────┘                    │
│                         ↓                                    │
├─────────────────────────────────────────────────────────────┤
│                       Domain Layer                           │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              ReplyTemplateUseCase                    │    │
│  │  + GetTemplatesUseCase                              │    │
│  │  + SaveTemplateUseCase                              │    │
│  │  + DeleteTemplateUseCase                            │    │
│  │  + IncrementUsageUseCase                            │    │
│  └─────────────────────┬───────────────────────────────┘    │
│                        ↓                                     │
│  ┌─────────────────────────────────────────────────────┐    │
│  │           ReplyTemplateRepository (接口)             │    │
│  └─────────────────────┬───────────────────────────────┘    │
│                        ↓                                     │
├─────────────────────────────────────────────────────────────┤
│                        Data Layer                            │
│  ┌─────────────────────────────────────────────────────┐    │
│  │          ReplyTemplateRepositoryImpl                 │    │
│  └─────────────────────┬───────────────────────────────┘    │
│                        ↓                                     │
│  ┌───────────────────┐  ┌───────────────────────────┐       │
│  │ ReplyTemplateDao  │  │  ReplyTemplateEntity      │       │
│  └───────────────────┘  └───────────────────────────┘       │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 新增文件清单

| 层级 | 文件路径 | 说明 |
|------|----------|------|
| Domain | `domain/model/ReplyTemplate.kt` | 领域模型 |
| Domain | `domain/repository/ReplyTemplateRepository.kt` | 仓库接口 |
| Domain | `domain/usecase/GetTemplatesUseCase.kt` | 获取模板用例 |
| Domain | `domain/usecase/SaveTemplateUseCase.kt` | 保存模板用例 |
| Domain | `domain/usecase/DeleteTemplateUseCase.kt` | 删除模板用例 |
| Domain | `domain/usecase/IncrementTemplateUsageUseCase.kt` | 增加使用次数用例 |
| Data | `data/local/entity/ReplyTemplateEntity.kt` | 数据库实体 |
| Data | `data/local/dao/ReplyTemplateDao.kt` | DAO接口 |
| Data | `data/repository/ReplyTemplateRepositoryImpl.kt` | 仓库实现 |
| Presentation | `presentation/ui/screen/template/TemplateListScreen.kt` | 模板列表页 |
| Presentation | `presentation/ui/screen/template/TemplateListUiState.kt` | UI状态 |
| Presentation | `presentation/ui/screen/template/TemplateListUiEvent.kt` | UI事件 |
| Presentation | `presentation/viewmodel/TemplateListViewModel.kt` | ViewModel |
| Presentation | `presentation/ui/component/floating/QuickTemplateButton.kt` | 快捷按钮组件 |
| Presentation | `presentation/ui/component/dialog/TemplateEditDialog.kt` | 编辑对话框 |
| Presentation | `presentation/ui/component/dialog/TemplateSelectDialog.kt` | 选择对话框 |
| DI | `di/TemplateModule.kt` | 依赖注入模块 |
| Test | `test/.../ReplyTemplateRepositoryImplTest.kt` | 仓库测试 |
| Test | `test/.../GetTemplatesUseCaseTest.kt` | 用例测试 |
| Test | `test/.../TemplateListViewModelTest.kt` | ViewModel测试 |

### 2.3 修改文件清单

| 文件路径 | 修改内容 |
|----------|----------|
| `data/local/AppDatabase.kt` | 添加ReplyTemplateEntity和Dao |
| `presentation/ui/screen/settings/SettingsScreen.kt` | 添加模板管理入口 |
| `presentation/ui/component/floating/FloatingViewV2.kt` | 添加快捷模板按钮 |
| `presentation/navigation/NavGraph.kt` | 添加模板列表路由 |
| `presentation/navigation/NavRoutes.kt` | 添加路由常量 |

## 3. 详细设计

### 3.1 Domain Layer

#### 3.1.1 ReplyTemplate 模型

```kotlin
// domain/model/ReplyTemplate.kt
data class ReplyTemplate(
    val id: Long = 0,
    val title: String,
    val content: String,
    val usageCount: Int = 0,
    val createdAt: Long = System.currentTimeMillis(),
    val updatedAt: Long = System.currentTimeMillis()
) {
    companion object {
        const val MAX_TITLE_LENGTH = 20
        const val MAX_CONTENT_LENGTH = 500
        const val MAX_TEMPLATE_COUNT = 20
    }
    
    fun validate(): Result<Unit> {
        return when {
            title.isBlank() -> Result.failure(IllegalArgumentException("标题不能为空"))
            title.length > MAX_TITLE_LENGTH -> Result.failure(IllegalArgumentException("标题不能超过${MAX_TITLE_LENGTH}字符"))
            content.isBlank() -> Result.failure(IllegalArgumentException("内容不能为空"))
            content.length > MAX_CONTENT_LENGTH -> Result.failure(IllegalArgumentException("内容不能超过${MAX_CONTENT_LENGTH}字符"))
            else -> Result.success(Unit)
        }
    }
}
```

#### 3.1.2 Repository 接口

```kotlin
// domain/repository/ReplyTemplateRepository.kt
interface ReplyTemplateRepository {
    fun getAllTemplates(): Flow<List<ReplyTemplate>>
    fun getTopTemplates(limit: Int): Flow<List<ReplyTemplate>>
    suspend fun getTemplateById(id: Long): ReplyTemplate?
    suspend fun saveTemplate(template: ReplyTemplate): Result<Long>
    suspend fun deleteTemplate(id: Long): Result<Unit>
    suspend fun incrementUsage(id: Long): Result<Unit>
    suspend fun getTemplateCount(): Int
}
```

#### 3.1.3 UseCase 实现

```kotlin
// domain/usecase/GetTemplatesUseCase.kt
class GetTemplatesUseCase @Inject constructor(
    private val repository: ReplyTemplateRepository
) {
    operator fun invoke(): Flow<List<ReplyTemplate>> {
        return repository.getAllTemplates()
    }
    
    fun getTopTemplates(limit: Int = 5): Flow<List<ReplyTemplate>> {
        return repository.getTopTemplates(limit)
    }
}

// domain/usecase/SaveTemplateUseCase.kt
class SaveTemplateUseCase @Inject constructor(
    private val repository: ReplyTemplateRepository
) {
    suspend operator fun invoke(template: ReplyTemplate): Result<Long> {
        // 验证模板
        template.validate().onFailure { return Result.failure(it) }
        
        // 检查数量限制（新增时）
        if (template.id == 0L) {
            val count = repository.getTemplateCount()
            if (count >= ReplyTemplate.MAX_TEMPLATE_COUNT) {
                return Result.failure(IllegalStateException("模板数量已达上限"))
            }
        }
        
        return repository.saveTemplate(template)
    }
}

// domain/usecase/DeleteTemplateUseCase.kt
class DeleteTemplateUseCase @Inject constructor(
    private val repository: ReplyTemplateRepository
) {
    suspend operator fun invoke(id: Long): Result<Unit> {
        return repository.deleteTemplate(id)
    }
}

// domain/usecase/IncrementTemplateUsageUseCase.kt
class IncrementTemplateUsageUseCase @Inject constructor(
    private val repository: ReplyTemplateRepository
) {
    suspend operator fun invoke(id: Long): Result<Unit> {
        return repository.incrementUsage(id)
    }
}
```

### 3.2 Data Layer

#### 3.2.1 Entity 定义

```kotlin
// data/local/entity/ReplyTemplateEntity.kt
@Entity(tableName = "reply_templates")
data class ReplyTemplateEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0,
    
    @ColumnInfo(name = "title")
    val title: String,
    
    @ColumnInfo(name = "content")
    val content: String,
    
    @ColumnInfo(name = "usage_count")
    val usageCount: Int = 0,
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long,
    
    @ColumnInfo(name = "updated_at")
    val updatedAt: Long
) {
    fun toDomain(): ReplyTemplate = ReplyTemplate(
        id = id,
        title = title,
        content = content,
        usageCount = usageCount,
        createdAt = createdAt,
        updatedAt = updatedAt
    )
    
    companion object {
        fun fromDomain(domain: ReplyTemplate): ReplyTemplateEntity = ReplyTemplateEntity(
            id = domain.id,
            title = domain.title,
            content = domain.content,
            usageCount = domain.usageCount,
            createdAt = domain.createdAt,
            updatedAt = domain.updatedAt
        )
    }
}
```

#### 3.2.2 DAO 接口

```kotlin
// data/local/dao/ReplyTemplateDao.kt
@Dao
interface ReplyTemplateDao {
    @Query("SELECT * FROM reply_templates ORDER BY usage_count DESC, created_at DESC")
    fun getAllTemplates(): Flow<List<ReplyTemplateEntity>>
    
    @Query("SELECT * FROM reply_templates ORDER BY usage_count DESC, created_at DESC LIMIT :limit")
    fun getTopTemplates(limit: Int): Flow<List<ReplyTemplateEntity>>
    
    @Query("SELECT * FROM reply_templates WHERE id = :id")
    suspend fun getTemplateById(id: Long): ReplyTemplateEntity?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTemplate(template: ReplyTemplateEntity): Long
    
    @Query("DELETE FROM reply_templates WHERE id = :id")
    suspend fun deleteTemplate(id: Long)
    
    @Query("UPDATE reply_templates SET usage_count = usage_count + 1, updated_at = :updatedAt WHERE id = :id")
    suspend fun incrementUsage(id: Long, updatedAt: Long = System.currentTimeMillis())
    
    @Query("SELECT COUNT(*) FROM reply_templates")
    suspend fun getTemplateCount(): Int
}
```

#### 3.2.3 Repository 实现

```kotlin
// data/repository/ReplyTemplateRepositoryImpl.kt
class ReplyTemplateRepositoryImpl @Inject constructor(
    private val dao: ReplyTemplateDao
) : ReplyTemplateRepository {
    
    override fun getAllTemplates(): Flow<List<ReplyTemplate>> {
        return dao.getAllTemplates().map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    override fun getTopTemplates(limit: Int): Flow<List<ReplyTemplate>> {
        return dao.getTopTemplates(limit).map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    override suspend fun getTemplateById(id: Long): ReplyTemplate? {
        return dao.getTemplateById(id)?.toDomain()
    }
    
    override suspend fun saveTemplate(template: ReplyTemplate): Result<Long> {
        return try {
            val entity = ReplyTemplateEntity.fromDomain(
                template.copy(updatedAt = System.currentTimeMillis())
            )
            val id = dao.insertTemplate(entity)
            Result.success(id)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun deleteTemplate(id: Long): Result<Unit> {
        return try {
            dao.deleteTemplate(id)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun incrementUsage(id: Long): Result<Unit> {
        return try {
            dao.incrementUsage(id)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun getTemplateCount(): Int {
        return dao.getTemplateCount()
    }
}
```

### 3.3 Presentation Layer

#### 3.3.1 UiState & UiEvent

```kotlin
// presentation/ui/screen/template/TemplateListUiState.kt
data class TemplateListUiState(
    val templates: List<ReplyTemplate> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null,
    val editingTemplate: ReplyTemplate? = null,
    val showEditDialog: Boolean = false,
    val showDeleteConfirm: Boolean = false,
    val templateToDelete: ReplyTemplate? = null,
    val canAddMore: Boolean = true
)

// presentation/ui/screen/template/TemplateListUiEvent.kt
sealed class TemplateListUiEvent {
    object AddTemplate : TemplateListUiEvent()
    data class EditTemplate(val template: ReplyTemplate) : TemplateListUiEvent()
    data class DeleteTemplate(val template: ReplyTemplate) : TemplateListUiEvent()
    object ConfirmDelete : TemplateListUiEvent()
    object DismissDelete : TemplateListUiEvent()
    data class SaveTemplate(val title: String, val content: String) : TemplateListUiEvent()
    object DismissEdit : TemplateListUiEvent()
    object ClearError : TemplateListUiEvent()
}
```

#### 3.3.2 ViewModel

```kotlin
// presentation/viewmodel/TemplateListViewModel.kt
@HiltViewModel
class TemplateListViewModel @Inject constructor(
    private val getTemplatesUseCase: GetTemplatesUseCase,
    private val saveTemplateUseCase: SaveTemplateUseCase,
    private val deleteTemplateUseCase: DeleteTemplateUseCase
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(TemplateListUiState())
    val uiState: StateFlow<TemplateListUiState> = _uiState.asStateFlow()
    
    init {
        loadTemplates()
    }
    
    private fun loadTemplates() {
        viewModelScope.launch {
            getTemplatesUseCase()
                .catch { e -> _uiState.update { it.copy(error = e.message) } }
                .collect { templates ->
                    _uiState.update { 
                        it.copy(
                            templates = templates,
                            canAddMore = templates.size < ReplyTemplate.MAX_TEMPLATE_COUNT
                        )
                    }
                }
        }
    }
    
    fun onEvent(event: TemplateListUiEvent) {
        when (event) {
            is TemplateListUiEvent.AddTemplate -> {
                _uiState.update { it.copy(editingTemplate = null, showEditDialog = true) }
            }
            is TemplateListUiEvent.EditTemplate -> {
                _uiState.update { it.copy(editingTemplate = event.template, showEditDialog = true) }
            }
            is TemplateListUiEvent.DeleteTemplate -> {
                _uiState.update { it.copy(templateToDelete = event.template, showDeleteConfirm = true) }
            }
            is TemplateListUiEvent.ConfirmDelete -> {
                deleteTemplate()
            }
            is TemplateListUiEvent.DismissDelete -> {
                _uiState.update { it.copy(templateToDelete = null, showDeleteConfirm = false) }
            }
            is TemplateListUiEvent.SaveTemplate -> {
                saveTemplate(event.title, event.content)
            }
            is TemplateListUiEvent.DismissEdit -> {
                _uiState.update { it.copy(editingTemplate = null, showEditDialog = false) }
            }
            is TemplateListUiEvent.ClearError -> {
                _uiState.update { it.copy(error = null) }
            }
        }
    }
    
    private fun saveTemplate(title: String, content: String) {
        viewModelScope.launch {
            val template = _uiState.value.editingTemplate?.copy(
                title = title,
                content = content
            ) ?: ReplyTemplate(title = title, content = content)
            
            saveTemplateUseCase(template)
                .onSuccess {
                    _uiState.update { it.copy(showEditDialog = false, editingTemplate = null) }
                }
                .onFailure { e ->
                    _uiState.update { it.copy(error = e.message) }
                }
        }
    }
    
    private fun deleteTemplate() {
        val template = _uiState.value.templateToDelete ?: return
        viewModelScope.launch {
            deleteTemplateUseCase(template.id)
                .onSuccess {
                    _uiState.update { it.copy(templateToDelete = null, showDeleteConfirm = false) }
                }
                .onFailure { e ->
                    _uiState.update { it.copy(error = e.message) }
                }
        }
    }
}
```

### 3.4 DI Module

```kotlin
// di/TemplateModule.kt
@Module
@InstallIn(SingletonComponent::class)
object TemplateModule {
    
    @Provides
    fun provideReplyTemplateDao(database: AppDatabase): ReplyTemplateDao {
        return database.replyTemplateDao()
    }
    
    @Provides
    @Singleton
    fun provideReplyTemplateRepository(
        dao: ReplyTemplateDao
    ): ReplyTemplateRepository {
        return ReplyTemplateRepositoryImpl(dao)
    }
}
```

### 3.5 数据库迁移

```kotlin
// data/local/AppDatabase.kt 修改
@Database(
    entities = [
        // ... 现有实体
        ReplyTemplateEntity::class  // 新增
    ],
    version = 11,  // 版本升级
    exportSchema = true
)
abstract class AppDatabase : RoomDatabase() {
    // ... 现有DAO
    abstract fun replyTemplateDao(): ReplyTemplateDao  // 新增
    
    companion object {
        // 新增迁移
        val MIGRATION_10_11 = object : Migration(10, 11) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL("""
                    CREATE TABLE IF NOT EXISTS reply_templates (
                        id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                        title TEXT NOT NULL,
                        content TEXT NOT NULL,
                        usage_count INTEGER NOT NULL DEFAULT 0,
                        created_at INTEGER NOT NULL,
                        updated_at INTEGER NOT NULL
                    )
                """)
            }
        }
    }
}
```

## 4. 接口设计

### 4.1 悬浮窗集成接口

```kotlin
// 在FloatingViewV2中添加的回调接口
interface QuickTemplateCallback {
    fun onTemplateSelected(content: String)
    fun onManageTemplates()
}
```

### 4.2 导航路由

```kotlin
// presentation/navigation/NavRoutes.kt 新增
object NavRoutes {
    // ... 现有路由
    const val TEMPLATE_LIST = "template_list"
}
```

## 5. 性能考虑

| 指标 | 目标 | 实现方式 |
|------|------|----------|
| 模板列表加载 | < 100ms | Room Flow + 索引优化 |
| 模板选择弹窗 | < 50ms | 限制显示5条 + 缓存 |
| 保存模板 | < 200ms | 异步写入 |

### 5.1 数据库索引

```sql
CREATE INDEX idx_reply_templates_usage ON reply_templates(usage_count DESC, created_at DESC);
```

## 6. 测试策略

### 6.1 单元测试

| 测试类 | 覆盖内容 |
|--------|----------|
| `ReplyTemplateTest` | 模型验证逻辑 |
| `GetTemplatesUseCaseTest` | 获取模板用例 |
| `SaveTemplateUseCaseTest` | 保存模板用例（含边界） |
| `DeleteTemplateUseCaseTest` | 删除模板用例 |
| `ReplyTemplateRepositoryImplTest` | 仓库实现 |
| `TemplateListViewModelTest` | ViewModel状态管理 |

### 6.2 测试用例示例

```kotlin
// test/.../SaveTemplateUseCaseTest.kt
class SaveTemplateUseCaseTest {
    @Test
    fun `保存有效模板应返回成功`() = runTest {
        // Given
        val template = ReplyTemplate(title = "测试", content = "测试内容")
        coEvery { repository.getTemplateCount() } returns 0
        coEvery { repository.saveTemplate(any()) } returns Result.success(1L)
        
        // When
        val result = useCase(template)
        
        // Then
        assertTrue(result.isSuccess)
    }
    
    @Test
    fun `模板数量达上限时应返回失败`() = runTest {
        // Given
        val template = ReplyTemplate(title = "测试", content = "测试内容")
        coEvery { repository.getTemplateCount() } returns 20
        
        // When
        val result = useCase(template)
        
        // Then
        assertTrue(result.isFailure)
    }
    
    @Test
    fun `标题为空时应返回验证失败`() = runTest {
        // Given
        val template = ReplyTemplate(title = "", content = "测试内容")
        
        // When
        val result = useCase(template)
        
        // Then
        assertTrue(result.isFailure)
    }
}
```

## 7. 风险评估

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 数据库迁移失败 | 高 | 完整迁移测试 + Schema导出 |
| 悬浮窗集成冲突 | 中 | 独立组件设计，最小化修改 |
| 性能问题 | 低 | 限制模板数量 + 索引优化 |

## 8. 实现顺序

1. **Phase 1**: Domain层（模型 + 接口 + 用例）
2. **Phase 2**: Data层（Entity + DAO + Repository实现 + 迁移）
3. **Phase 3**: DI配置
4. **Phase 4**: Presentation层（ViewModel + Screen）
5. **Phase 5**: 悬浮窗集成
6. **Phase 6**: 单元测试
