# TDD-00003-联系人画像记忆系统架构设计

## 1. 文档信息

| 项目 | 内容 |
|------|------|
| 文档类型 | TDD (Technical Design Document) |
| 文档编号 | TDD-00003 |
| 功能名称 | 联系人画像记忆系统架构设计 |
| 版本 | 1.0 |
| 创建日期 | 2025-12-14 |
| 作者 | Claude |
| 审核人 | 待定 |
| 关联文档 | PRD-00003, FD-00003 |

## 2. 架构概述

### 2.1 架构目标

联系人画像记忆系统采用Clean Architecture + MVVM架构模式，通过三层记忆架构（短期对话记录→中期每日总结→长期联系人画像）实现AI的持久化记忆能力。架构设计遵循以下原则：

- **自动化优先**: 对话记录和每日总结自动执行，用户无感知
- **智能筛选**: 上下文构建时智能筛选相关信息，避免信息过载
- **渐进增强**: 关系分数和标签随互动自动更新，越用越准
- **容错降级**: AI服务不可用时自动降级到本地统计
- **隐私保护**: 所有数据本地存储，不上传到服务器
- **关注点分离**: 业务逻辑与UI逻辑分离
- **依赖注入**: 使用Hilt进行依赖管理
- **单一职责**: 每个类职责明确单一

### 2.2 技术栈选择

| 技术领域 | 技术选择 | 版本要求 | 用途 |
|---------|----------|----------|------|
| 开发语言 | Kotlin | 2.0.21 | 主要开发语言 |
| UI框架 | Jetpack Compose | 2024.12.01 | 声明式UI |
| 架构模式 | Clean Architecture + MVVM | - | 架构模式 |
| 依赖注入 | Hilt | 2.52 | 依赖管理 |
| 数据库 | Room | 2.6.1 | 本地数据存储 |
| JSON解析 | Moshi | 1.15.1 | JSON序列化 |
| 异步处理 | Kotlin Coroutines | 1.9.0 | 异步操作 |
| 状态管理 | StateFlow | 1.9.0 | UI状态管理 |
| 本地存储 | SharedPreferences | - | 配置存储 |

### 2.3 MVP范围

**本次实现**：
- ✅ 对话记录自动存储
- ✅ 每日总结生成（AI驱动）
- ✅ Facts结构增强（带时间戳和来源）
- ✅ 关系分数系统（0-100分）
- ✅ 智能上下文构建（分层筛选）
- ✅ 关系分数UI展示

**明确不包含**：
- ❌ Facts手动编辑UI
- ❌ 对话记录详细查看界面
- ❌ 向量搜索
- ❌ 记忆可视化


## 3. 整体架构设计

### 3.1 分层架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │ ChatScreen   │  │ContactDetail │  │RelationshipScore │  │
│  │              │  │Screen        │  │Section           │  │
│  └──────┬───────┘  └──────┬───────┘  └──────────────────┘  │
│         │                 │                                  │
│  ┌──────▼─────────────────▼──────────────────────────────┐ │
│  │              ViewModels                                │ │
│  │  - ChatViewModel                                       │ │
│  │  - ContactDetailViewModel                              │ │
│  │  - 状态管理 (StateFlow)                               │ │
│  │  - 事件处理                                            │ │
│  └──────┬─────────────────────────────────────────────────┘ │
└─────────┼──────────────────────────────────────────────────┘
          │
┌─────────▼──────────────────────────────────────────────────┐
│                     Domain Layer                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                  Use Cases                            │  │
│  │  - AnalyzeChatUseCase                                │  │
│  │  - SummarizeDailyConversationsUseCase                │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              Repository Interfaces                    │  │
│  │  - ConversationRepository                            │  │
│  │  - ContactRepository                                 │  │
│  │  - DailySummaryRepository                            │  │
│  │  - BrainTagRepository                                │  │
│  │  - AiRepository                                      │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                 Domain Models                         │  │
│  │  - Fact, ConversationLog, DailySummary               │  │
│  │  - ContactProfile, BrainTag                          │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                 Domain Services                       │  │
│  │  - ContextBuilder                                    │  │
│  │  - RetryPolicy                                       │  │
│  │  - ErrorRecoveryManager                              │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────┬───────────────────────────────────────────────────┘
          │
┌─────────▼──────────────────────────────────────────────────┐
│                      Data Layer                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │          Repository Implementations                   │  │
│  │  - ConversationRepositoryImpl                        │  │
│  │  - ContactRepositoryImpl                             │  │
│  │  - DailySummaryRepositoryImpl                        │  │
│  └──────┬───────────────────────────────────────────────┘  │
│         │                                                   │
│  ┌──────▼──────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │ Local Storage   │  │   Database   │  │  Preferences │ │
│  │ - DAO           │  │   - Room     │  │  - Memory    │ │
│  │ - Entity        │  │   - v4       │  │  - Settings  │ │
│  │ - Converter     │  │   - Migration│  │              │ │
│  └─────────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 数据流向图

```
┌─────────────────────────────────────────────────────────────┐
│                    实时分析数据流                            │
└─────────────────────────────────────────────────────────────┘
用户输入聊天记录
    ↓
ChatScreen.onAnalyze()
    ↓
ChatViewModel.analyzeChat()
    ↓
┌─────────────────────────────────────────────────────────────┐
│ 1. 保存对话记录                                             │
│    ConversationRepository.saveUserInput()                   │
│    - 立即保存到数据库                                       │
│    - 不等待AI响应                                           │
└─────────────┬───────────────────────────────────────────────┘
              ↓
┌─────────────▼───────────────────────────────────────────────┐
│ 2. 构建分析上下文                                           │
│    ContextBuilder.buildAnalysisContext()                    │
│    - 获取联系人信息                                         │
│    - 筛选相关Facts（最多20条）                              │
│    - 获取所有BrainTag标签                                   │
│    - 组装Prompt                                             │
└─────────────┬───────────────────────────────────────────────┘
              ↓
┌─────────────▼───────────────────────────────────────────────┐
│ 3. 调用AI分析                                               │
│    AiRepository.analyzeChat()                               │
│    - 发送Prompt到AI服务                                     │
│    - 解析JSON响应                                           │
│    - 处理错误和重试                                         │
└─────────────┬───────────────────────────────────────────────┘
              ↓
┌─────────────▼───────────────────────────────────────────────┐
│ 4. 更新对话记录                                             │
│    ConversationRepository.updateAiResponse()                │
│    - 保存AI回复                                             │
└─────────────┬───────────────────────────────────────────────┘
              ↓
展示分析结果给用户

┌─────────────────────────────────────────────────────────────┐
│                    每日总结数据流                            │
└─────────────────────────────────────────────────────────────┘
App启动 / 从后台恢复
    ↓
EmpathyApplication.onCreate()
    ↓
检查是否需要执行每日总结
    ↓
┌─────────────▼───────────────────────────────────────────────┐
│ 1. 查询未总结对话                                           │
│    ConversationRepository.getUnsummarizedLogs()             │
│    - 查询最近7天未总结的对话                                │
│    - 按联系人和日期分组                                     │
└─────────────┬───────────────────────────────────────────────┘
              ↓
┌─────────────▼───────────────────────────────────────────────┐
│ 2. 对每个联系人执行总结                                     │
│    SummarizeDailyConversationsUseCase.summarizeForContact() │
│    - 获取联系人当前状态                                     │
│    - 构建总结Prompt                                         │
│    - 调用AI生成总结                                         │
│    - 失败时使用降级方案                                     │
└─────────────┬───────────────────────────────────────────────┘
              ↓
┌─────────────▼───────────────────────────────────────────────┐
│ 3. 更新联系人数据（事务）                                   │
│    - 合并新Facts                                            │
│    - 更新/新增BrainTag                                      │
│    - 更新关系分数                                           │
│    - 保存每日总结                                           │
│    - 标记对话为已总结                                       │
└─────────────┬───────────────────────────────────────────────┘
              ↓
完成，用户无感知
```


## 4. 核心类设计

### 4.1 Domain层核心类

#### 4.1.1 Fact领域模型

```kotlin
/**
 * 事实领域模型
 *
 * 纯Kotlin类，无Android依赖
 * 表示联系人的一条事实信息
 */
data class Fact(
    val key: String,           // 字段名，如"性格特点"、"兴趣爱好"
    val value: String,         // 字段值
    val timestamp: Long,       // 创建/更新时间（毫秒）
    val source: FactSource     // 来源：MANUAL 或 AI_INFERRED
) {
    init {
        require(key.isNotBlank()) { "Fact的key不能为空" }
        require(value.isNotBlank()) { "Fact的value不能为空" }
        require(timestamp > 0) { "Fact的timestamp必须大于0" }
    }
    
    /**
     * 判断是否过期（超过90天）
     */
    fun isExpired(now: Long = System.currentTimeMillis()): Boolean {
        val ninetyDaysAgo = now - 90 * 24 * 60 * 60 * 1000L
        return timestamp < ninetyDaysAgo
    }
    
    /**
     * 判断是否为最近的（7天内）
     */
    fun isRecent(now: Long = System.currentTimeMillis()): Boolean {
        val sevenDaysAgo = now - 7 * 24 * 60 * 60 * 1000L
        return timestamp >= sevenDaysAgo
    }
}

/**
 * 事实来源枚举
 */
enum class FactSource {
    MANUAL,        // 用户手动添加
    AI_INFERRED    // AI推断
}

/**
 * 预定义的Fact字段
 */
object FactKeys {
    const val PERSONALITY = "性格特点"
    const val INTERESTS = "兴趣爱好"
    const val TABOOS = "沟通雷区"
    const val PREFERENCES = "喜好偏好"
    const val FAMILY = "家庭情况"
    const val WORK = "工作情况"
    const val HEALTH = "健康状况"
    const val HABITS = "生活习惯"
    
    val ALL = listOf(
        PERSONALITY, INTERESTS, TABOOS, PREFERENCES,
        FAMILY, WORK, HEALTH, HABITS
    )
}
```

#### 4.1.2 ConversationLog领域模型

```kotlin
/**
 * 对话记录领域模型
 *
 * 表示一次用户与AI的对话
 */
data class ConversationLog(
    val id: Long = 0,
    val contactId: String,
    val userInput: String,
    val aiResponse: String?,
    val timestamp: Long,
    val isSummarized: Boolean = false
) {
    init {
        require(contactId.isNotBlank()) { "contactId不能为空" }
        require(userInput.isNotBlank()) { "userInput不能为空" }
        require(timestamp > 0) { "timestamp必须大于0" }
    }
    
    /**
     * 获取日期字符串（yyyy-MM-dd）
     */
    fun getDateString(): String {
        val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        return sdf.format(Date(timestamp))
    }
    
    /**
     * 判断是否完整（有AI回复）
     */
    fun isComplete(): Boolean = aiResponse != null
    
    /**
     * 获取对话长度
     */
    fun getTotalLength(): Int {
        return userInput.length + (aiResponse?.length ?: 0)
    }
}
```

#### 4.1.3 DailySummary领域模型

```kotlin
/**
 * 每日总结领域模型
 *
 * 表示某个联系人某一天的互动总结
 */
data class DailySummary(
    val id: Long = 0,
    val contactId: String,
    val summaryDate: String,              // 格式: "yyyy-MM-dd"
    val content: String,                  // 总结内容
    val keyEvents: List<KeyEvent>,        // 关键事件
    val newFacts: List<Fact>,             // 新发现的事实
    val updatedTags: List<TagUpdate>,     // 标签更新
    val relationshipScoreChange: Int,     // 关系分数变化 -10到+10
    val relationshipTrend: RelationshipTrend  // 关系趋势
) {
    init {
        require(contactId.isNotBlank()) { "contactId不能为空" }
        require(summaryDate.matches(Regex("\\d{4}-\\d{2}-\\d{2}"))) {
            "summaryDate格式必须为yyyy-MM-dd"
        }
        require(relationshipScoreChange in -10..10) {
            "relationshipScoreChange必须在-10到10之间"
        }
    }
    
    /**
     * 判断是否有实质性内容
     */
    fun hasSubstantialContent(): Boolean {
        return keyEvents.isNotEmpty() || newFacts.isNotEmpty() || updatedTags.isNotEmpty()
    }
}

/**
 * 关键事件
 */
data class KeyEvent(
    val event: String,
    val importance: Int  // 1-10
) {
    init {
        require(event.isNotBlank()) { "event不能为空" }
        require(importance in 1..10) { "importance必须在1到10之间" }
    }
}

/**
 * 标签更新
 */
data class TagUpdate(
    val action: String,  // "ADD" | "REMOVE"
    val type: String,    // "RISK_RED" | "STRATEGY_GREEN"
    val content: String
) {
    init {
        require(action in listOf("ADD", "REMOVE")) { "action必须是ADD或REMOVE" }
        require(type in listOf("RISK_RED", "STRATEGY_GREEN")) {
            "type必须是RISK_RED或STRATEGY_GREEN"
        }
        require(content.isNotBlank()) { "content不能为空" }
    }
}

/**
 * 关系趋势枚举
 */
enum class RelationshipTrend {
    IMPROVING,   // 改善中
    STABLE,      // 稳定
    DECLINING    // 下降中
}
```

#### 4.1.4 ContactProfile扩展

```kotlin
/**
 * 联系人画像领域模型（扩展版）
 */
data class ContactProfile(
    val id: String,
    val name: String,
    val targetGoal: String,
    val contextDepth: Int = 10,
    val facts: List<Fact> = emptyList(),           // 修改：从Map改为List
    val relationshipScore: Int = 50,               // 新增：关系分数 0-100
    val lastInteractionDate: String? = null        // 新增：最后互动日期
) {
    init {
        require(id.isNotBlank()) { "id不能为空" }
        require(name.isNotBlank()) { "name不能为空" }
        require(contextDepth > 0) { "contextDepth必须大于0" }
        require(relationshipScore in 0..100) { "relationshipScore必须在0到100之间" }
    }
    
    /**
     * 获取最近的Facts（7天内）
     */
    fun getRecentFacts(): List<Fact> {
        val sevenDaysAgo = System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000L
        return facts.filter { it.timestamp >= sevenDaysAgo }
    }
    
    /**
     * 获取手动添加的Facts
     */
    fun getManualFacts(): List<Fact> {
        return facts.filter { it.source == FactSource.MANUAL }
    }
    
    /**
     * 判断关系等级
     */
    fun getRelationshipLevel(): RelationshipLevel {
        return when (relationshipScore) {
            in 0..30 -> RelationshipLevel.STRANGER
            in 31..60 -> RelationshipLevel.ACQUAINTANCE
            in 61..80 -> RelationshipLevel.FAMILIAR
            else -> RelationshipLevel.CLOSE
        }
    }
}

/**
 * 关系等级枚举
 */
enum class RelationshipLevel {
    STRANGER,       // 陌生/冷淡 (0-30)
    ACQUAINTANCE,   // 普通 (31-60)
    FAMILIAR,       // 熟悉 (61-80)
    CLOSE           // 亲密 (81-100)
}
```

### 4.2 Domain层Repository接口

#### 4.2.1 ConversationRepository接口

```kotlin
/**
 * 对话记录仓库接口
 *
 * 定义对话记录的数据访问接口
 */
interface ConversationRepository {
    
    /**
     * 保存用户输入
     *
     * @param contactId 联系人ID
     * @param userInput 用户输入的聊天记录
     * @param timestamp 时间戳（毫秒）
     * @return 保存的对话记录ID
     */
    suspend fun saveUserInput(
        contactId: String,
        userInput: String,
        timestamp: Long = System.currentTimeMillis()
    ): Result<Long>
    
    /**
     * 更新AI回复
     *
     * @param logId 对话记录ID
     * @param aiResponse AI的分析回复
     * @return 操作结果
     */
    suspend fun updateAiResponse(
        logId: Long,
        aiResponse: String
    ): Result<Unit>
    
    /**
     * 获取未总结的对话记录
     *
     * @param sinceTimestamp 起始时间戳（只获取此时间之后的记录）
     * @return 未总结的对话记录列表
     */
    suspend fun getUnsummarizedLogs(
        sinceTimestamp: Long
    ): Result<List<ConversationLog>>
    
    /**
     * 获取指定联系人在指定日期的对话记录
     *
     * @param contactId 联系人ID
     * @param date 日期字符串，格式"yyyy-MM-dd"
     * @return 对话记录列表
     */
    suspend fun getLogsByContactAndDate(
        contactId: String,
        date: String
    ): Result<List<ConversationLog>>
    
    /**
     * 标记对话为已总结
     *
     * @param logIds 对话记录ID列表
     * @return 操作结果
     */
    suspend fun markAsSummarized(
        logIds: List<Long>
    ): Result<Unit>
    
    /**
     * 删除指定联系人的所有对话记录
     *
     * @param contactId 联系人ID
     * @return 删除的记录数
     */
    suspend fun deleteByContactId(
        contactId: String
    ): Result<Int>
    
    /**
     * 清理过期的已总结对话
     *
     * @param beforeTimestamp 此时间之前的已总结对话将被删除
     * @return 删除的记录数
     */
    suspend fun cleanupOldSummarizedLogs(
        beforeTimestamp: Long
    ): Result<Int>
}
```

#### 4.2.2 DailySummaryRepository接口

```kotlin
/**
 * 每日总结仓库接口
 *
 * 定义每日总结的数据访问接口
 */
interface DailySummaryRepository {
    
    /**
     * 保存每日总结
     *
     * @param summary 每日总结对象
     * @return 保存的总结ID
     */
    suspend fun saveSummary(
        summary: DailySummary
    ): Result<Long>
    
    /**
     * 获取指定联系人的所有总结
     *
     * @param contactId 联系人ID
     * @return 总结列表，按日期倒序
     */
    suspend fun getSummariesByContact(
        contactId: String
    ): Result<List<DailySummary>>
    
    /**
     * 获取指定日期的总结
     *
     * @param contactId 联系人ID
     * @param date 日期字符串
     * @return 总结对象，不存在则返回null
     */
    suspend fun getSummaryByDate(
        contactId: String,
        date: String
    ): Result<DailySummary?>
    
    /**
     * 检查指定日期是否已有总结
     *
     * @param contactId 联系人ID
     * @param date 日期字符串
     * @return 是否存在
     */
    suspend fun hasSummaryForDate(
        contactId: String,
        date: String
    ): Result<Boolean>
}
```

#### 4.2.3 ContactRepository扩展

```kotlin
/**
 * ContactRepository扩展接口
 *
 * 为记忆系统添加的新方法
 */
interface ContactRepository {
    // ... 现有方法 ...
    
    /**
     * 更新联系人的关系分数
     *
     * @param contactId 联系人ID
     * @param newScore 新的关系分数（0-100）
     * @return 操作结果
     */
    suspend fun updateRelationshipScore(
        contactId: String,
        newScore: Int
    ): Result<Unit>
    
    /**
     * 更新联系人的Facts
     *
     * @param contactId 联系人ID
     * @param facts 新的Facts列表
     * @return 操作结果
     */
    suspend fun updateFacts(
        contactId: String,
        facts: List<Fact>
    ): Result<Unit>
    
    /**
     * 添加单个Fact
     *
     * @param contactId 联系人ID
     * @param fact 要添加的Fact
     * @return 操作结果
     */
    suspend fun addFact(
        contactId: String,
        fact: Fact
    ): Result<Unit>
    
    /**
     * 更新最后互动日期
     *
     * @param contactId 联系人ID
     * @param date 日期字符串，格式"yyyy-MM-dd"
     * @return 操作结果
     */
    suspend fun updateLastInteractionDate(
        contactId: String,
        date: String
    ): Result<Unit>
    
    /**
     * 批量更新联系人数据（事务）
     *
     * @param contactId 联系人ID
     * @param facts 新的Facts列表（可选）
     * @param relationshipScore 新的关系分数（可选）
     * @param lastInteractionDate 最后互动日期（可选）
     * @return 操作结果
     */
    suspend fun updateContactData(
        contactId: String,
        facts: List<Fact>? = null,
        relationshipScore: Int? = null,
        lastInteractionDate: String? = null
    ): Result<Unit>
}
```

### 4.3 Domain层Use Cases

#### 4.3.1 AnalyzeChatUseCase扩展

```kotlin
/**
 * 分析聊天用例（扩展版）
 *
 * 集成对话记录保存功能
 */
@Singleton
class AnalyzeChatUseCase @Inject constructor(
    private val contactRepository: ContactRepository,
    private val brainTagRepository: BrainTagRepository,
    private val aiRepository: AiRepository,
    private val conversationRepository: ConversationRepository,  // 新增
    private val contextBuilder: ContextBuilder,                  // 新增
    private val privacyEngine: PrivacyEngine
) {
    /**
     * 执行聊天分析
     *
     * @param contactId 联系人ID
     * @param chatHistory 聊天记录
     * @return 分析结果
     */
    suspend operator fun invoke(
        contactId: String,
        chatHistory: String
    ): Result<AnalysisResult> {
        return withContext(Dispatchers.IO) {
            try {
                // 1. 保存用户输入（立即保存，不等待AI响应）
                val logId = conversationRepository.saveUserInput(
                    contactId = contactId,
                    userInput = chatHistory
                ).getOrThrow()
                
                // 2. 获取联系人信息
                val contact = contactRepository.getProfile(contactId).getOrThrow()
                val tags = brainTagRepository.getTagsByContact(contactId).getOrThrow()
                
                // 3. 构建分析上下文
                val context = contextBuilder.buildAnalysisContext(
                    contact = contact,
                    tags = tags,
                    userInput = chatHistory
                )
                
                // 4. 数据掩码
                val maskedContext = privacyEngine.maskSensitiveData(context)
                
                // 5. 调用AI分析
                val analysisResult = aiRepository.analyzeChat(maskedContext).getOrThrow()
                
                // 6. 保存AI回复
                conversationRepository.updateAiResponse(
                    logId = logId,
                    aiResponse = analysisResult.toJsonString()
                )
                
                Result.success(analysisResult)
            } catch (e: Exception) {
                Log.e("AnalyzeChatUseCase", "分析失败", e)
                Result.failure(e)
            }
        }
    }
}
```

#### 4.3.2 SummarizeDailyConversationsUseCase

```kotlin
/**
 * 每日对话总结用例
 *
 * 在新一天首次打开App时执行，总结昨日对话并更新联系人数据
 */
@Singleton
class SummarizeDailyConversationsUseCase @Inject constructor(
    private val conversationRepository: ConversationRepository,
    private val contactRepository: ContactRepository,
    private val brainTagRepository: BrainTagRepository,
    private val dailySummaryRepository: DailySummaryRepository,
    private val aiRepository: AiRepository,
    private val memoryPreferences: MemoryPreferences
) {
    companion object {
        const val MAX_RETRY_DAYS = 7
        const val MAX_AI_RETRIES = 3
    }
    
    /**
     * 执行每日总结
     *
     * @return 总结结果，包含成功和失败的联系人数量
     */
    suspend operator fun invoke(): Result<SummaryResult> {
        return withContext(Dispatchers.IO) {
            try {
                // 1. 检查是否需要执行
                val lastSummaryDate = memoryPreferences.getLastSummaryDate()
                val today = getCurrentDateString()
                
                if (lastSummaryDate == today) {
                    return@withContext Result.success(SummaryResult(skipped = true))
                }
                
                // 2. 获取未总结的对话（最多7天前）
                val sevenDaysAgo = System.currentTimeMillis() - MAX_RETRY_DAYS * 24 * 60 * 60 * 1000L
                val unsummarizedLogs = conversationRepository
                    .getUnsummarizedLogs(sevenDaysAgo)
                    .getOrThrow()
                
                if (unsummarizedLogs.isEmpty()) {
                    memoryPreferences.setLastSummaryDate(today)
                    return@withContext Result.success(SummaryResult(noData = true))
                }
                
                // 3. 按联系人和日期分组
                val groupedLogs = unsummarizedLogs
                    .groupBy { it.contactId }
                    .flatMap { (contactId, logs) ->
                        logs.groupBy { it.getDateString() }
                            .map { (date, dateLogs) -> Triple(contactId, date, dateLogs) }
                    }
                
                // 4. 对每组执行总结
                var successCount = 0
                var failedCount = 0
                var usedFallback = false
                
                groupedLogs.forEach { (contactId, date, logs) ->
                    try {
                        val result = summarizeForContact(contactId, logs, date)
                        if (result.usedFallback) usedFallback = true
                        successCount++
                    } catch (e: Exception) {
                        Log.e("DailySummary", "Failed for $contactId on $date", e)
                        failedCount++
                    }
                }
                
                // 5. 更新最后总结日期
                memoryPreferences.setLastSummaryDate(today)
                
                Result.success(SummaryResult(
                    successCount = successCount,
                    failedCount = failedCount,
                    usedFallback = usedFallback
                ))
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
    
    // 私有方法实现...
}

/**
 * 总结结果
 */
data class SummaryResult(
    val skipped: Boolean = false,
    val noData: Boolean = false,
    val successCount: Int = 0,
    val failedCount: Int = 0,
    val usedFallback: Boolean = false
)
```

### 4.4 Domain层Services

#### 4.4.1 ContextBuilder

```kotlin
/**
 * 上下文构建器
 *
 * 负责从联系人数据中筛选相关信息，构建AI分析所需的上下文
 */
@Singleton
class ContextBuilder @Inject constructor() {
    
    companion object {
        const val MAX_FACTS_COUNT = 20
        const val RECENT_DAYS = 7
        const val MEDIUM_DAYS = 30
    }
    
    /**
     * 构建分析上下文
     *
     * @param contact 联系人信息
     * @param tags 联系人标签列表
     * @param userInput 用户输入的聊天记录
     * @return 构建好的Prompt字符串
     */
    fun buildAnalysisContext(
        contact: ContactProfile,
        tags: List<BrainTag>,
        userInput: String
    ): String {
        val sb = StringBuilder()
        
        // 1. 基本信息（必选）
        sb.appendLine("【联系人信息】")
        sb.appendLine("姓名：${contact.name}")
        sb.appendLine("目标：${contact.targetGoal}")
        sb.appendLine("关系分数：${contact.relationshipScore}/100")
        sb.appendLine()
        
        // 2. 雷区标签（必选）
        val riskTags = tags.filter { it.type == TagType.RISK_RED }
        if (riskTags.isNotEmpty()) {
            sb.appendLine("【雷区标签】")
            riskTags.forEach { sb.appendLine("- ${it.content}") }
            sb.appendLine()
        }
        
        // 3. 策略标签（必选）
        val strategyTags = tags.filter { it.type == TagType.STRATEGY_GREEN }
        if (strategyTags.isNotEmpty()) {
            sb.appendLine("【策略标签】")
            strategyTags.forEach { sb.appendLine("- ${it.content}") }
            sb.appendLine()
        }
        
        // 4. 筛选后的Facts
        val relevantFacts = selectRelevantFacts(contact.facts)
        if (relevantFacts.isNotEmpty()) {
            sb.appendLine("【已知事实】")
            relevantFacts.forEach { fact ->
                val dateStr = formatDate(fact.timestamp)
                val sourceStr = if (fact.source == FactSource.MANUAL) "手动" else "AI推断"
                sb.appendLine("- ${fact.key}：${fact.value} ($dateStr, $sourceStr)")
            }
            sb.appendLine()
        }
        
        // 5. 用户输入
        sb.appendLine("【用户提供的聊天记录】")
        sb.appendLine(userInput)
        
        return sb.toString()
    }
    
    /**
     * 筛选相关Facts
     *
     * 筛选规则：
     * 1. 最近7天：全部保留
     * 2. 7-30天：只保留MANUAL来源
     * 3. 30天以上：只保留MANUAL来源
     * 4. 按时间倒序排序
     * 5. 最多保留20条
     */
    fun selectRelevantFacts(facts: List<Fact>): List<Fact> {
        val now = System.currentTimeMillis()
        val sevenDaysAgo = now - RECENT_DAYS * 24 * 60 * 60 * 1000L
        val thirtyDaysAgo = now - MEDIUM_DAYS * 24 * 60 * 60 * 1000L
        
        // 分层筛选
        val recentFacts = facts.filter { it.timestamp >= sevenDaysAgo }
        val mediumFacts = facts.filter { 
            it.timestamp < sevenDaysAgo && 
            it.timestamp >= thirtyDaysAgo &&
            it.source == FactSource.MANUAL
        }
        val oldFacts = facts.filter { 
            it.timestamp < thirtyDaysAgo &&
            it.source == FactSource.MANUAL
        }
        
        // 合并并限制数量
        return (recentFacts + mediumFacts + oldFacts)
            .sortedByDescending { it.timestamp }
            .take(MAX_FACTS_COUNT)
    }
    
    private fun formatDate(timestamp: Long): String {
        val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        return sdf.format(Date(timestamp))
    }
}
```


## 5. Data层设计

### 5.1 Repository实现类

#### 5.1.1 ConversationRepositoryImpl

```kotlin
/**
 * 对话记录仓库实现类
 *
 * 负责对话记录的数据访问
 */
@Singleton
class ConversationRepositoryImpl @Inject constructor(
    private val conversationLogDao: ConversationLogDao
) : ConversationRepository {
    
    override suspend fun saveUserInput(
        contactId: String,
        userInput: String,
        timestamp: Long
    ): Result<Long> {
        return withContext(Dispatchers.IO) {
            try {
                val entity = ConversationLogEntity(
                    contactId = contactId,
                    userInput = userInput,
                    aiResponse = null,
                    timestamp = timestamp,
                    isSummarized = false
                )
                val id = conversationLogDao.insert(entity)
                Result.success(id)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "保存用户输入失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun updateAiResponse(
        logId: Long,
        aiResponse: String
    ): Result<Unit> {
        return withContext(Dispatchers.IO) {
            try {
                conversationLogDao.updateAiResponse(logId, aiResponse)
                Result.success(Unit)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "更新AI回复失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun getUnsummarizedLogs(
        sinceTimestamp: Long
    ): Result<List<ConversationLog>> {
        return withContext(Dispatchers.IO) {
            try {
                val entities = conversationLogDao.getUnsummarizedLogs(sinceTimestamp)
                val logs = entities.map { it.toDomainModel() }
                Result.success(logs)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "获取未总结对话失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun getLogsByContactAndDate(
        contactId: String,
        date: String
    ): Result<List<ConversationLog>> {
        return withContext(Dispatchers.IO) {
            try {
                val entities = conversationLogDao.getLogsByContactAndDate(contactId, date)
                val logs = entities.map { it.toDomainModel() }
                Result.success(logs)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "获取对话记录失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun markAsSummarized(
        logIds: List<Long>
    ): Result<Unit> {
        return withContext(Dispatchers.IO) {
            try {
                conversationLogDao.markAsSummarized(logIds)
                Result.success(Unit)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "标记已总结失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun deleteByContactId(
        contactId: String
    ): Result<Int> {
        return withContext(Dispatchers.IO) {
            try {
                val count = conversationLogDao.deleteByContactId(contactId)
                Result.success(count)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "删除对话记录失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun cleanupOldSummarizedLogs(
        beforeTimestamp: Long
    ): Result<Int> {
        return withContext(Dispatchers.IO) {
            try {
                val count = conversationLogDao.cleanupOldSummarizedLogs(beforeTimestamp)
                Result.success(count)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "清理旧对话失败", e)
                Result.failure(e)
            }
        }
    }
}
```

#### 5.1.2 DailySummaryRepositoryImpl

```kotlin
/**
 * 每日总结仓库实现类
 */
@Singleton
class DailySummaryRepositoryImpl @Inject constructor(
    private val dailySummaryDao: DailySummaryDao,
    private val moshi: Moshi
) : DailySummaryRepository {
    
    override suspend fun saveSummary(
        summary: DailySummary
    ): Result<Long> {
        return withContext(Dispatchers.IO) {
            try {
                val entity = summary.toEntity(moshi)
                val id = dailySummaryDao.insert(entity)
                Result.success(id)
            } catch (e: Exception) {
                Log.e("DailySummaryRepo", "保存总结失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun getSummariesByContact(
        contactId: String
    ): Result<List<DailySummary>> {
        return withContext(Dispatchers.IO) {
            try {
                val entities = dailySummaryDao.getSummariesByContact(contactId)
                val summaries = entities.map { it.toDomainModel(moshi) }
                Result.success(summaries)
            } catch (e: Exception) {
                Log.e("DailySummaryRepo", "获取总结列表失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun getSummaryByDate(
        contactId: String,
        date: String
    ): Result<DailySummary?> {
        return withContext(Dispatchers.IO) {
            try {
                val entity = dailySummaryDao.getSummaryByDate(contactId, date)
                val summary = entity?.toDomainModel(moshi)
                Result.success(summary)
            } catch (e: Exception) {
                Log.e("DailySummaryRepo", "获取总结失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun hasSummaryForDate(
        contactId: String,
        date: String
    ): Result<Boolean> {
        return withContext(Dispatchers.IO) {
            try {
                val exists = dailySummaryDao.hasSummaryForDate(contactId, date)
                Result.success(exists)
            } catch (e: Exception) {
                Log.e("DailySummaryRepo", "检查总结存在失败", e)
                Result.failure(e)
            }
        }
    }
}
```

### 5.2 DAO接口设计

#### 5.2.1 ConversationLogDao

```kotlin
/**
 * 对话记录DAO
 */
@Dao
interface ConversationLogDao {
    
    /**
     * 插入对话记录
     */
    @Insert
    suspend fun insert(log: ConversationLogEntity): Long
    
    /**
     * 更新AI回复
     */
    @Query("UPDATE conversation_logs SET ai_response = :aiResponse WHERE id = :logId")
    suspend fun updateAiResponse(logId: Long, aiResponse: String)
    
    /**
     * 获取未总结的对话记录
     */
    @Query("""
        SELECT * FROM conversation_logs 
        WHERE is_summarized = 0 AND timestamp >= :sinceTimestamp
        ORDER BY timestamp ASC
    """)
    suspend fun getUnsummarizedLogs(sinceTimestamp: Long): List<ConversationLogEntity>
    
    /**
     * 获取指定联系人在指定日期的对话记录
     */
    @Query("""
        SELECT * FROM conversation_logs 
        WHERE contact_id = :contactId 
        AND date(timestamp/1000, 'unixepoch', 'localtime') = :date
        ORDER BY timestamp ASC
    """)
    suspend fun getLogsByContactAndDate(
        contactId: String, 
        date: String
    ): List<ConversationLogEntity>
    
    /**
     * 标记对话为已总结
     */
    @Query("UPDATE conversation_logs SET is_summarized = 1 WHERE id IN (:logIds)")
    suspend fun markAsSummarized(logIds: List<Long>)
    
    /**
     * 删除指定联系人的所有对话记录
     */
    @Query("DELETE FROM conversation_logs WHERE contact_id = :contactId")
    suspend fun deleteByContactId(contactId: String): Int
    
    /**
     * 清理过期的已总结对话
     */
    @Query("""
        DELETE FROM conversation_logs 
        WHERE is_summarized = 1 AND timestamp < :beforeTimestamp
    """)
    suspend fun cleanupOldSummarizedLogs(beforeTimestamp: Long): Int
}
```

#### 5.2.2 DailySummaryDao

```kotlin
/**
 * 每日总结DAO
 */
@Dao
interface DailySummaryDao {
    
    /**
     * 插入每日总结（如果已存在则替换）
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(summary: DailySummaryEntity): Long
    
    /**
     * 获取指定联系人的所有总结
     */
    @Query("""
        SELECT * FROM daily_summaries 
        WHERE contact_id = :contactId 
        ORDER BY summary_date DESC
    """)
    suspend fun getSummariesByContact(contactId: String): List<DailySummaryEntity>
    
    /**
     * 获取指定日期的总结
     */
    @Query("""
        SELECT * FROM daily_summaries 
        WHERE contact_id = :contactId AND summary_date = :date
    """)
    suspend fun getSummaryByDate(contactId: String, date: String): DailySummaryEntity?
    
    /**
     * 检查指定日期是否已有总结
     */
    @Query("""
        SELECT EXISTS(
            SELECT 1 FROM daily_summaries 
            WHERE contact_id = :contactId AND summary_date = :date
        )
    """)
    suspend fun hasSummaryForDate(contactId: String, date: String): Boolean
}
```

### 5.3 Entity设计

#### 5.3.1 ConversationLogEntity

```kotlin
/**
 * 对话记录Entity
 */
@Entity(
    tableName = "conversation_logs",
    foreignKeys = [
        ForeignKey(
            entity = ContactProfileEntity::class,
            parentColumns = ["id"],
            childColumns = ["contact_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["contact_id"]),
        Index(value = ["timestamp"]),
        Index(value = ["is_summarized"])
    ]
)
data class ConversationLogEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0,
    
    @ColumnInfo(name = "contact_id")
    val contactId: String,
    
    @ColumnInfo(name = "user_input")
    val userInput: String,
    
    @ColumnInfo(name = "ai_response")
    val aiResponse: String?,
    
    @ColumnInfo(name = "timestamp")
    val timestamp: Long,
    
    @ColumnInfo(name = "is_summarized")
    val isSummarized: Boolean = false
) {
    /**
     * 转换为领域模型
     */
    fun toDomainModel(): ConversationLog {
        return ConversationLog(
            id = id,
            contactId = contactId,
            userInput = userInput,
            aiResponse = aiResponse,
            timestamp = timestamp,
            isSummarized = isSummarized
        )
    }
}
```

#### 5.3.2 DailySummaryEntity

```kotlin
/**
 * 每日总结Entity
 */
@Entity(
    tableName = "daily_summaries",
    foreignKeys = [
        ForeignKey(
            entity = ContactProfileEntity::class,
            parentColumns = ["id"],
            childColumns = ["contact_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["contact_id"]),
        Index(value = ["summary_date"]),
        Index(value = ["contact_id", "summary_date"], unique = true)
    ]
)
data class DailySummaryEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0,
    
    @ColumnInfo(name = "contact_id")
    val contactId: String,
    
    @ColumnInfo(name = "summary_date")
    val summaryDate: String,
    
    @ColumnInfo(name = "content")
    val content: String,
    
    @ColumnInfo(name = "key_events_json")
    val keyEventsJson: String,
    
    @ColumnInfo(name = "relationship_score")
    val relationshipScore: Int,
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long
) {
    /**
     * 转换为领域模型
     */
    fun toDomainModel(moshi: Moshi): DailySummary {
        // 解析JSON字段
        val keyEventsAdapter = moshi.adapter<List<KeyEvent>>(
            Types.newParameterizedType(List::class.java, KeyEvent::class.java)
        )
        val keyEvents = keyEventsAdapter.fromJson(keyEventsJson) ?: emptyList()
        
        return DailySummary(
            id = id,
            contactId = contactId,
            summaryDate = summaryDate,
            content = content,
            keyEvents = keyEvents,
            newFacts = emptyList(),  // 从content中解析
            updatedTags = emptyList(),  // 从content中解析
            relationshipScoreChange = 0,  // 需要计算
            relationshipTrend = RelationshipTrend.STABLE  // 需要计算
        )
    }
}

/**
 * DailySummary扩展方法
 */
fun DailySummary.toEntity(moshi: Moshi): DailySummaryEntity {
    val keyEventsAdapter = moshi.adapter<List<KeyEvent>>(
        Types.newParameterizedType(List::class.java, KeyEvent::class.java)
    )
    val keyEventsJson = keyEventsAdapter.toJson(keyEvents)
    
    return DailySummaryEntity(
        id = id,
        contactId = contactId,
        summaryDate = summaryDate,
        content = content,
        keyEventsJson = keyEventsJson,
        relationshipScore = relationshipScoreChange,
        createdAt = System.currentTimeMillis()
    )
}
```

#### 5.3.3 ContactProfileEntity扩展

```kotlin
/**
 * 联系人画像Entity（扩展版）
 */
@Entity(tableName = "profiles")
data class ContactProfileEntity(
    @PrimaryKey
    @ColumnInfo(name = "id")
    val id: String,
    
    @ColumnInfo(name = "name")
    val name: String,
    
    @ColumnInfo(name = "target_goal")
    val targetGoal: String,
    
    @ColumnInfo(name = "context_depth")
    val contextDepth: Int = 10,
    
    @ColumnInfo(name = "facts_json")
    val factsJson: String = "[]",  // 修改：存储List<Fact>的JSON
    
    @ColumnInfo(name = "relationship_score")
    val relationshipScore: Int = 50,  // 新增
    
    @ColumnInfo(name = "last_interaction_date")
    val lastInteractionDate: String? = null  // 新增
)
```

### 5.4 TypeConverter设计

#### 5.4.1 FactListConverter

```kotlin
/**
 * Fact列表类型转换器
 *
 * 负责List<Fact>与JSON字符串的相互转换
 */
class FactListConverter {
    private val moshi = Moshi.Builder().build()
    
    @TypeConverter
    fun fromFactList(facts: List<Fact>?): String {
        if (facts == null) return "[]"
        val adapter = moshi.adapter<List<Fact>>(
            Types.newParameterizedType(List::class.java, Fact::class.java)
        )
        return adapter.toJson(facts)
    }
    
    @TypeConverter
    fun toFactList(json: String?): List<Fact> {
        if (json.isNullOrBlank()) return emptyList()
        
        return try {
            // 尝试解析为List<Fact>
            val listAdapter = moshi.adapter<List<Fact>>(
                Types.newParameterizedType(List::class.java, Fact::class.java)
            )
            listAdapter.fromJson(json) ?: emptyList()
        } catch (e: Exception) {
            // 降级：尝试解析为旧格式Map<String, String>
            try {
                val mapAdapter = moshi.adapter<Map<String, String>>(
                    Types.newParameterizedType(
                        Map::class.java, 
                        String::class.java, 
                        String::class.java
                    )
                )
                val oldMap = mapAdapter.fromJson(json) ?: emptyMap()
                val now = System.currentTimeMillis()
                oldMap.map { (key, value) ->
                    Fact(
                        key = key, 
                        value = value, 
                        timestamp = now, 
                        source = FactSource.MANUAL
                    )
                }
            } catch (e2: Exception) {
                Log.e("FactListConverter", "解析Facts失败", e2)
                emptyList()
            }
        }
    }
}
```

### 5.5 数据库Migration

#### 5.5.1 Migration 3→4

```kotlin
/**
 * 数据库迁移：v3 → v4
 *
 * 变更内容：
 * 1. 新增conversation_logs表
 * 2. 新增daily_summaries表
 * 3. profiles表添加relationship_score、last_interaction_date字段
 * 4. profiles表的facts_json格式从Map改为List<Fact>
 */
val MIGRATION_3_4 = object : Migration(3, 4) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // 1. 创建conversation_logs表
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS conversation_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                contact_id TEXT NOT NULL,
                user_input TEXT NOT NULL,
                ai_response TEXT,
                timestamp INTEGER NOT NULL,
                is_summarized INTEGER NOT NULL DEFAULT 0,
                FOREIGN KEY(contact_id) REFERENCES profiles(id) ON DELETE CASCADE
            )
        """)
        
        // 2. 创建conversation_logs索引
        database.execSQL(
            "CREATE INDEX idx_conv_contact ON conversation_logs(contact_id)"
        )
        database.execSQL(
            "CREATE INDEX idx_conv_timestamp ON conversation_logs(timestamp)"
        )
        database.execSQL(
            "CREATE INDEX idx_conv_summarized ON conversation_logs(is_summarized)"
        )
        
        // 3. 创建daily_summaries表
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS daily_summaries (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                contact_id TEXT NOT NULL,
                summary_date TEXT NOT NULL,
                content TEXT NOT NULL,
                key_events_json TEXT NOT NULL,
                relationship_score INTEGER NOT NULL,
                created_at INTEGER NOT NULL,
                FOREIGN KEY(contact_id) REFERENCES profiles(id) ON DELETE CASCADE
            )
        """)
        
        // 4. 创建daily_summaries索引
        database.execSQL(
            "CREATE INDEX idx_summary_contact ON daily_summaries(contact_id)"
        )
        database.execSQL(
            "CREATE INDEX idx_summary_date ON daily_summaries(summary_date)"
        )
        database.execSQL(
            "CREATE UNIQUE INDEX idx_summary_contact_date ON daily_summaries(contact_id, summary_date)"
        )
        
        // 5. 添加profiles新字段
        database.execSQL(
            "ALTER TABLE profiles ADD COLUMN relationship_score INTEGER NOT NULL DEFAULT 50"
        )
        database.execSQL(
            "ALTER TABLE profiles ADD COLUMN last_interaction_date TEXT"
        )
        
        // 6. 迁移facts_json格式（Map → List<Fact>）
        migrateFactsFormat(database)
    }
    
    private fun migrateFactsFormat(database: SupportSQLiteDatabase) {
        val cursor = database.query("SELECT id, facts_json FROM profiles")
        cursor.use {
            while (it.moveToNext()) {
                val id = it.getString(0)
                val oldFactsJson = it.getString(1)
                val newFactsJson = convertMapToFactList(oldFactsJson)
                database.execSQL(
                    "UPDATE profiles SET facts_json = ? WHERE id = ?",
                    arrayOf(newFactsJson, id)
                )
            }
        }
    }
    
    private fun convertMapToFactList(oldJson: String): String {
        if (oldJson.isBlank() || oldJson == "{}") return "[]"
        
        return try {
            val moshi = Moshi.Builder().build()
            val mapAdapter = moshi.adapter<Map<String, String>>(
                Types.newParameterizedType(
                    Map::class.java, 
                    String::class.java, 
                    String::class.java
                )
            )
            val oldMap = mapAdapter.fromJson(oldJson) ?: emptyMap()
            
            val now = System.currentTimeMillis()
            val factList = oldMap.map { (key, value) ->
                Fact(
                    key = key, 
                    value = value, 
                    timestamp = now, 
                    source = FactSource.MANUAL
                )
            }
            
            val listAdapter = moshi.adapter<List<Fact>>(
                Types.newParameterizedType(List::class.java, Fact::class.java)
            )
            listAdapter.toJson(factList)
        } catch (e: Exception) {
            Log.e("Migration", "转换Facts格式失败", e)
            "[]"
        }
    }
}
```

### 5.6 本地存储设计

#### 5.6.1 MemoryPreferences

```kotlin
/**
 * 记忆系统配置存储
 *
 * 使用SharedPreferences存储记忆系统的配置信息
 */
@Singleton
class MemoryPreferences @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val prefs = context.getSharedPreferences(
        "memory_settings", 
        Context.MODE_PRIVATE
    )
    
    companion object {
        private const val KEY_LAST_SUMMARY_DATE = "last_summary_date"
        private const val KEY_FAILED_TASKS = "failed_summary_tasks"
    }
    
    /**
     * 获取最后总结日期
     */
    fun getLastSummaryDate(): String? {
        return prefs.getString(KEY_LAST_SUMMARY_DATE, null)
    }
    
    /**
     * 设置最后总结日期
     */
    fun setLastSummaryDate(date: String) {
        prefs.edit().putString(KEY_LAST_SUMMARY_DATE, date).apply()
    }
    
    /**
     * 获取失败的总结任务
     */
    fun getFailedSummaryTasks(): List<FailedSummaryTask> {
        val json = prefs.getString(KEY_FAILED_TASKS, "[]") ?: "[]"
        return try {
            val moshi = Moshi.Builder().build()
            val adapter = moshi.adapter<List<FailedSummaryTask>>(
                Types.newParameterizedType(
                    List::class.java, 
                    FailedSummaryTask::class.java
                )
            )
            adapter.fromJson(json) ?: emptyList()
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * 设置失败的总结任务
     */
    fun setFailedSummaryTasks(tasks: List<FailedSummaryTask>) {
        val moshi = Moshi.Builder().build()
        val adapter = moshi.adapter<List<FailedSummaryTask>>(
            Types.newParameterizedType(
                List::class.java, 
                FailedSummaryTask::class.java
            )
        )
        val json = adapter.toJson(tasks)
        prefs.edit().putString(KEY_FAILED_TASKS, json).apply()
    }
}

/**
 * 失败的总结任务
 */
data class FailedSummaryTask(
    val contactId: String,
    val date: String,
    val timestamp: Long,
    val errorMessage: String?
)
```


## 6. Presentation层设计（续）

### 6.3 Compose组件设计（续）

#### 6.3.2 FactItem（续）

```kotlin
                Text(
                    text = if (fact.source == FactSource.MANUAL) "手动添加" else "AI推断",
                    style = MaterialTheme.typography.labelSmall,
                    color = if (fact.source == FactSource.MANUAL)
                        MaterialTheme.colorScheme.onSurfaceVariant
                    else
                        MaterialTheme.colorScheme.primary
                )
            }
        }
    }
}

@Composable
private fun formatDate(timestamp: Long): String {
    val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
    return sdf.format(Date(timestamp))
}
```

#### 6.3.3 TrendIcon

```kotlin
/**
 * 关系趋势图标组件
 */
@Composable
fun TrendIcon(
    trend: RelationshipTrend,
    modifier: Modifier = Modifier
) {
    val (icon, color, text) = when (trend) {
        RelationshipTrend.IMPROVING -> Triple(
            Icons.Default.TrendingUp,
            MaterialTheme.colorScheme.primary,
            "改善中"
        )
        RelationshipTrend.STABLE -> Triple(
            Icons.Default.TrendingFlat,
            MaterialTheme.colorScheme.onSurfaceVariant,
            "稳定"
        )
        RelationshipTrend.DECLINING -> Triple(
            Icons.Default.TrendingDown,
            MaterialTheme.colorScheme.error,
            "下降中"
        )
    }
    
    Row(
        modifier = modifier,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Icon(
            imageVector = icon,
            contentDescription = text,
            tint = color,
            modifier = Modifier.size(20.dp)
        )
        Spacer(modifier = Modifier.width(4.dp))
        Text(
            text = text,
            style = MaterialTheme.typography.labelMedium,
            color = color
        )
    }
}
```


## 7. 依赖注入设计

### 7.1 Module配置

#### 7.1.1 MemoryModule

```kotlin
/**
 * 记忆系统模块
 * 提供记忆系统相关的依赖
 */
@Module
@InstallIn(SingletonComponent::class)
object MemoryModule {
    
    @Provides
    @Singleton
    fun provideConversationRepository(
        conversationLogDao: ConversationLogDao
    ): ConversationRepository {
        return ConversationRepositoryImpl(conversationLogDao)
    }
    
    @Provides
    @Singleton
    fun provideDailySummaryRepository(
        dailySummaryDao: DailySummaryDao,
        moshi: Moshi
    ): DailySummaryRepository {
        return DailySummaryRepositoryImpl(dailySummaryDao, moshi)
    }
    
    @Provides
    @Singleton
    fun provideMemoryPreferences(
        @ApplicationContext context: Context
    ): MemoryPreferences {
        return MemoryPreferences(context)
    }
    
    @Provides
    @Singleton
    fun provideContextBuilder(): ContextBuilder {
        return ContextBuilder()
    }
    
    @Provides
    @Singleton
    fun provideMoshi(): Moshi {
        return Moshi.Builder()
            .add(KotlinJsonAdapterFactory())
            .build()
    }
}
```


#### 7.1.2 DatabaseModule扩展

```kotlin
/**
 * 数据库模块（扩展版）
 */
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    @Provides
    @Singleton
    fun provideAppDatabase(
        @ApplicationContext context: Context
    ): AppDatabase {
        return Room.databaseBuilder(
            context.applicationContext,
            AppDatabase::class.java,
            "empathy_database"
        )
        .addMigrations(MIGRATION_3_4)
        .fallbackToDestructiveMigration()
        .build()
    }
    
    @Provides
    fun provideConversationLogDao(database: AppDatabase): ConversationLogDao {
        return database.conversationLogDao()
    }
    
    @Provides
    fun provideDailySummaryDao(database: AppDatabase): DailySummaryDao {
        return database.dailySummaryDao()
    }
}
```

### 7.2 依赖关系图

```
Application层
    └── SummarizeDailyConversationsUseCase

Presentation层
    ├── ChatViewModel
    │   ├── AnalyzeChatUseCase
    │   └── ContactRepository
    └── ContactDetailViewModel
        ├── ContactRepository
        ├── BrainTagRepository
        └── DailySummaryRepository

Domain层
    ├── AnalyzeChatUseCase
    │   ├── ConversationRepository
    │   ├── ContactRepository
    │   ├── BrainTagRepository
    │   ├── AiRepository
    │   └── ContextBuilder
    └── SummarizeDailyConversationsUseCase
        ├── ConversationRepository
        ├── ContactRepository
        ├── BrainTagRepository
        ├── DailySummaryRepository
        ├── AiRepository
        └── MemoryPreferences

Data层
    ├── ConversationRepositoryImpl → ConversationLogDao
    ├── DailySummaryRepositoryImpl → DailySummaryDao + Moshi
    └── MemoryPreferences → SharedPreferences

Storage层
    └── AppDatabase (Room)
```

### 7.3 作用域说明

| 组件 | 作用域 | 生命周期 |
|------|--------|---------|
| Repository | Singleton | 应用生命周期 |
| UseCase | Singleton | 应用生命周期 |
| ViewModel | ViewModelScoped | ViewModel生命周期 |
| MemoryPreferences | Singleton | 应用生命周期 |
| ContextBuilder | Singleton | 应用生命周期 |
| AppDatabase | Singleton | 应用生命周期 |


## 8. 错误处理设计

### 8.1 错误分类

```kotlin
sealed class MemoryError : Exception() {
    data class DatabaseError(
        override val message: String,
        override val cause: Throwable? = null
    ) : MemoryError()
    
    data class AiServiceError(
        override val message: String,
        override val cause: Throwable? = null
    ) : MemoryError()
    
    data class ParseError(
        override val message: String,
        val json: String? = null
    ) : MemoryError()
}
```

### 8.2 错误处理策略

| 错误类型 | 处理策略 | 用户反馈 |
|---------|---------|---------|
| 对话保存失败 | 重试1次 | 无（静默） |
| AI调用失败 | 重试3次 | Toast提示 |
| JSON解析失败 | 降级方案 | 无（静默） |
| 数据库迁移失败 | 破坏性迁移 | 提示数据清空 |

### 8.3 重试策略

```kotlin
object RetryPolicy {
    const val MAX_RETRIES = 3
    const val INITIAL_DELAY_MS = 1000L
    
    fun calculateDelay(retryCount: Int): Long {
        return INITIAL_DELAY_MS * (2.0.pow(retryCount.toDouble())).toLong()
    }
}
```


## 9. 性能优化设计

### 9.1 数据库优化

- 使用索引加速查询
- 批量操作使用事务
- 使用Flow实现响应式查询

### 9.2 异步操作优化

- 使用IO调度器执行IO操作
- 并发执行独立任务
- 使用Flow避免阻塞


## 10. 测试策略

### 10.1 测试覆盖率要求

| 层级 | 覆盖率 | 重点 |
|------|--------|------|
| Repository | >90% | 数据读写、错误处理 |
| UseCase | >85% | 业务逻辑、数据转换 |
| ViewModel | >80% | 状态管理、事件处理 |


## 11. 部署配置

### 11.1 ProGuard规则

```proguard
-keep class com.empathy.ai.domain.model.Fact { *; }
-keep class com.empathy.ai.domain.model.ConversationLog { *; }
-keep class com.empathy.ai.domain.model.DailySummary { *; }
```


## 12. 监控和日志

### 12.1 日志策略

```kotlin
object MemoryLogger {
    fun logConversationSaved(contactId: String, logId: Long) {
        Log.i("Memory", "对话记录已保存: $contactId, $logId")
    }
}
```


## 13. 附录

### 13.1 术语表

| 术语 | 说明 |
|------|------|
| Fact | 联系人的事实性信息 |
| ConversationLog | 对话记录 |
| DailySummary | 每日总结 |
| RelationshipScore | 关系分数(0-100) |

### 13.2 参考文档

- PRD-00003-联系人画像记忆系统需求
- FD-00003-联系人画像记忆系统设计
- Clean Architecture原则
- MVVM架构模式

---

**文档完成日期**: 2025-12-14  
**文档状态**: 已完成  
**下一步**: 开始实现开发
