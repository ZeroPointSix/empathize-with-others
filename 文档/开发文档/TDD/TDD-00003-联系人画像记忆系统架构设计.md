# TDD-00003-联系人画像记忆系统架构设计

## 1. 文档信息

| 项目 | 内容 |
|------|------|
| 文档类型 | TDD (Technical Design Document) |
| 文档编号 | TDD-00003 |
| 功能名称 | 联系人画像记忆系统架构设计 |
| 版本 | 1.0 |
| 创建日期 | 2025-12-14 |
| 作者 | Claude |
| 审核人 | 待定 |
| 关联文档 | PRD-00003, FD-00003 |

## 2. 架构概述

### 2.1 架构目标

联系人画像记忆系统采用Clean Architecture + MVVM架构模式，通过三层记忆架构（短期对话记录→中期每日总结→长期联系人画像）实现AI的持久化记忆能力。架构设计遵循以下原则：

- **自动化优先**: 对话记录和每日总结自动执行，用户无感知
- **智能筛选**: 上下文构建时智能筛选相关信息，避免信息过载
- **渐进增强**: 关系分数和标签随互动自动更新，越用越准
- **容错降级**: AI服务不可用时自动降级到本地统计
- **隐私保护**: 所有数据本地存储，不上传到服务器
- **关注点分离**: 业务逻辑与UI逻辑分离
- **依赖注入**: 使用Hilt进行依赖管理
- **单一职责**: 每个类职责明确单一

### 2.2 技术栈选择

| 技术领域 | 技术选择 | 版本要求 | 用途 |
|---------|----------|----------|------|
| 开发语言 | Kotlin | 2.0.21 | 主要开发语言 |
| UI框架 | Jetpack Compose | 2024.12.01 | 声明式UI |
| 架构模式 | Clean Architecture + MVVM | - | 架构模式 |
| 依赖注入 | Hilt | 2.52 | 依赖管理 |
| 数据库 | Room | 2.6.1 | 本地数据存储 |
| JSON解析 | Moshi | 1.15.1 | JSON序列化 |
| 异步处理 | Kotlin Coroutines | 1.9.0 | 异步操作 |
| 状态管理 | StateFlow | 1.9.0 | UI状态管理 |
| 本地存储 | SharedPreferences | - | 配置存储 |

### 2.3 MVP范围

**本次实现**：
- ✅ 对话记录自动存储
- ✅ 每日总结生成（AI驱动）
- ✅ Facts结构增强（带时间戳和来源）
- ✅ 关系分数系统（0-100分）
- ✅ 智能上下文构建（分层筛选）
- ✅ 关系分数UI展示

**明确不包含**：
- ❌ Facts手动编辑UI
- ❌ 对话记录详细查看界面
- ❌ 向量搜索
- ❌ 记忆可视化


## 3. 整体架构设计

### 3.1 分层架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │ ChatScreen   │  │ContactDetail │  │RelationshipScore │  │
│  │              │  │Screen        │  │Section           │  │
│  └──────┬───────┘  └──────┬───────┘  └──────────────────┘  │
│         │                 │                                  │
│  ┌──────▼─────────────────▼──────────────────────────────┐ │
│  │              ViewModels                                │ │
│  │  - ChatViewModel                                       │ │
│  │  - ContactDetailViewModel                              │ │
│  │  - 状态管理 (StateFlow)                               │ │
│  │  - 事件处理                                            │ │
│  └──────┬─────────────────────────────────────────────────┘ │
└─────────┼──────────────────────────────────────────────────┘
          │
┌─────────▼──────────────────────────────────────────────────┐
│                     Domain Layer                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                  Use Cases                            │  │
│  │  - AnalyzeChatUseCase                                │  │
│  │  - SummarizeDailyConversationsUseCase                │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              Repository Interfaces                    │  │
│  │  - ConversationRepository                            │  │
│  │  - ContactRepository                                 │  │
│  │  - DailySummaryRepository                            │  │
│  │  - BrainTagRepository                                │  │
│  │  - AiRepository                                      │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                 Domain Models                         │  │
│  │  - Fact, ConversationLog, DailySummary               │  │
│  │  - ContactProfile, BrainTag                          │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                 Domain Services                       │  │
│  │  - ContextBuilder                                    │  │
│  │  - RetryPolicy                                       │  │
│  │  - ErrorRecoveryManager                              │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────┬───────────────────────────────────────────────────┘
          │
┌─────────▼──────────────────────────────────────────────────┐
│                      Data Layer                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │          Repository Implementations                   │  │
│  │  - ConversationRepositoryImpl                        │  │
│  │  - ContactRepositoryImpl                             │  │
│  │  - DailySummaryRepositoryImpl                        │  │
│  └──────┬───────────────────────────────────────────────┘  │
│         │                                                   │
│  ┌──────▼──────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │ Local Storage   │  │   Database   │  │  Preferences │ │
│  │ - DAO           │  │   - Room     │  │  - Memory    │ │
│  │ - Entity        │  │   - v4       │  │  - Settings  │ │
│  │ - Converter     │  │   - Migration│  │              │ │
│  └─────────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 数据流向图

```
┌─────────────────────────────────────────────────────────────┐
│                    实时分析数据流                            │
└─────────────────────────────────────────────────────────────┘
用户输入聊天记录
    ↓
ChatScreen.onAnalyze()
    ↓
ChatViewModel.analyzeChat()
    ↓
┌─────────────────────────────────────────────────────────────┐
│ 1. 保存对话记录                                             │
│    ConversationRepository.saveUserInput()                   │
│    - 立即保存到数据库                                       │
│    - 不等待AI响应                                           │
└─────────────┬───────────────────────────────────────────────┘
              ↓
┌─────────────▼───────────────────────────────────────────────┐
│ 2. 构建分析上下文                                           │
│    ContextBuilder.buildAnalysisContext()                    │
│    - 获取联系人信息                                         │
│    - 筛选相关Facts（最多20条）                              │
│    - 获取所有BrainTag标签                                   │
│    - 组装Prompt                                             │
└─────────────┬───────────────────────────────────────────────┘
              ↓
┌─────────────▼───────────────────────────────────────────────┐
│ 3. 调用AI分析                                               │
│    AiRepository.analyzeChat()                               │
│    - 发送Prompt到AI服务                                     │
│    - 解析JSON响应                                           │
│    - 处理错误和重试                                         │
└─────────────┬───────────────────────────────────────────────┘
              ↓
┌─────────────▼───────────────────────────────────────────────┐
│ 4. 更新对话记录                                             │
│    ConversationRepository.updateAiResponse()                │
│    - 保存AI回复                                             │
└─────────────┬───────────────────────────────────────────────┘
              ↓
展示分析结果给用户

┌─────────────────────────────────────────────────────────────┐
│                    每日总结数据流                            │
└─────────────────────────────────────────────────────────────┘
App启动 / 从后台恢复
    ↓
EmpathyApplication.onCreate()
    ↓
检查是否需要执行每日总结
    ↓
┌─────────────▼───────────────────────────────────────────────┐
│ 1. 查询未总结对话                                           │
│    ConversationRepository.getUnsummarizedLogs()             │
│    - 查询最近7天未总结的对话                                │
│    - 按联系人和日期分组                                     │
└─────────────┬───────────────────────────────────────────────┘
              ↓
┌─────────────▼───────────────────────────────────────────────┐
│ 2. 对每个联系人执行总结                                     │
│    SummarizeDailyConversationsUseCase.summarizeForContact() │
│    - 获取联系人当前状态                                     │
│    - 构建总结Prompt                                         │
│    - 调用AI生成总结                                         │
│    - 失败时使用降级方案                                     │
└─────────────┬───────────────────────────────────────────────┘
              ↓
┌─────────────▼───────────────────────────────────────────────┐
│ 3. 更新联系人数据（事务）                                   │
│    - 合并新Facts                                            │
│    - 更新/新增BrainTag                                      │
│    - 更新关系分数                                           │
│    - 保存每日总结                                           │
│    - 标记对话为已总结                                       │
└─────────────┬───────────────────────────────────────────────┘
              ↓
完成，用户无感知
```


## 4. 核心类设计

### 4.1 Domain层核心类

#### 4.1.1 Fact领域模型

```kotlin
/**
 * 事实领域模型
 *
 * 纯Kotlin类，无Android依赖
 * 表示联系人的一条事实信息
 */
data class Fact(
    val key: String,           // 字段名，如"性格特点"、"兴趣爱好"
    val value: String,         // 字段值
    val timestamp: Long,       // 创建/更新时间（毫秒）
    val source: FactSource     // 来源：MANUAL 或 AI_INFERRED
) {
    init {
        require(key.isNotBlank()) { "Fact的key不能为空" }
        require(value.isNotBlank()) { "Fact的value不能为空" }
        require(timestamp > 0) { "Fact的timestamp必须大于0" }
    }
    
    /**
     * 判断是否过期（超过90天）
     */
    fun isExpired(now: Long = System.currentTimeMillis()): Boolean {
        val ninetyDaysAgo = now - 90 * 24 * 60 * 60 * 1000L
        return timestamp < ninetyDaysAgo
    }
    
    /**
     * 判断是否为最近的（7天内）
     */
    fun isRecent(now: Long = System.currentTimeMillis()): Boolean {
        val sevenDaysAgo = now - 7 * 24 * 60 * 60 * 1000L
        return timestamp >= sevenDaysAgo
    }
}

/**
 * 事实来源枚举
 */
enum class FactSource {
    MANUAL,        // 用户手动添加
    AI_INFERRED    // AI推断
}

/**
 * 预定义的Fact字段
 */
object FactKeys {
    const val PERSONALITY = "性格特点"
    const val INTERESTS = "兴趣爱好"
    const val TABOOS = "沟通雷区"
    const val PREFERENCES = "喜好偏好"
    const val FAMILY = "家庭情况"
    const val WORK = "工作情况"
    const val HEALTH = "健康状况"
    const val HABITS = "生活习惯"
    
    val ALL = listOf(
        PERSONALITY, INTERESTS, TABOOS, PREFERENCES,
        FAMILY, WORK, HEALTH, HABITS
    )
}
```

#### 4.1.2 ConversationLog领域模型

```kotlin
/**
 * 对话记录领域模型
 *
 * 表示一次用户与AI的对话
 */
data class ConversationLog(
    val id: Long = 0,
    val contactId: String,
    val userInput: String,
    val aiResponse: String?,
    val timestamp: Long,
    val isSummarized: Boolean = false
) {
    init {
        require(contactId.isNotBlank()) { "contactId不能为空" }
        require(userInput.isNotBlank()) { "userInput不能为空" }
        require(timestamp > 0) { "timestamp必须大于0" }
    }
    
    /**
     * 获取日期字符串（yyyy-MM-dd）
     */
    fun getDateString(): String {
        val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        return sdf.format(Date(timestamp))
    }
    
    /**
     * 判断是否完整（有AI回复）
     */
    fun isComplete(): Boolean = aiResponse != null
    
    /**
     * 获取对话长度
     */
    fun getTotalLength(): Int {
        return userInput.length + (aiResponse?.length ?: 0)
    }
}
```

#### 4.1.3 DailySummary领域模型

```kotlin
/**
 * 每日总结领域模型
 *
 * 表示某个联系人某一天的互动总结
 */
data class DailySummary(
    val id: Long = 0,
    val contactId: String,
    val summaryDate: String,              // 格式: "yyyy-MM-dd"
    val content: String,                  // 总结内容
    val keyEvents: List<KeyEvent>,        // 关键事件
    val newFacts: List<Fact>,             // 新发现的事实
    val updatedTags: List<TagUpdate>,     // 标签更新
    val relationshipScoreChange: Int,     // 关系分数变化 -10到+10
    val relationshipTrend: RelationshipTrend  // 关系趋势
) {
    init {
        require(contactId.isNotBlank()) { "contactId不能为空" }
        require(summaryDate.matches(Regex("\\d{4}-\\d{2}-\\d{2}"))) {
            "summaryDate格式必须为yyyy-MM-dd"
        }
        require(relationshipScoreChange in -10..10) {
            "relationshipScoreChange必须在-10到10之间"
        }
    }
    
    /**
     * 判断是否有实质性内容
     */
    fun hasSubstantialContent(): Boolean {
        return keyEvents.isNotEmpty() || newFacts.isNotEmpty() || updatedTags.isNotEmpty()
    }
}

/**
 * 关键事件
 */
data class KeyEvent(
    val event: String,
    val importance: Int  // 1-10
) {
    init {
        require(event.isNotBlank()) { "event不能为空" }
        require(importance in 1..10) { "importance必须在1到10之间" }
    }
}

/**
 * 标签更新
 */
data class TagUpdate(
    val action: String,  // "ADD" | "REMOVE"
    val type: String,    // "RISK_RED" | "STRATEGY_GREEN"
    val content: String
) {
    init {
        require(action in listOf("ADD", "REMOVE")) { "action必须是ADD或REMOVE" }
        require(type in listOf("RISK_RED", "STRATEGY_GREEN")) {
            "type必须是RISK_RED或STRATEGY_GREEN"
        }
        require(content.isNotBlank()) { "content不能为空" }
    }
}

/**
 * 关系趋势枚举
 */
enum class RelationshipTrend {
    IMPROVING,   // 改善中
    STABLE,      // 稳定
    DECLINING    // 下降中
}
```

#### 4.1.4 ContactProfile扩展

```kotlin
/**
 * 联系人画像领域模型（扩展版）
 */
data class ContactProfile(
    val id: String,
    val name: String,
    val targetGoal: String,
    val contextDepth: Int = 10,
    val facts: List<Fact> = emptyList(),           // 修改：从Map改为List
    val relationshipScore: Int = 50,               // 新增：关系分数 0-100
    val lastInteractionDate: String? = null        // 新增：最后互动日期
) {
    init {
        require(id.isNotBlank()) { "id不能为空" }
        require(name.isNotBlank()) { "name不能为空" }
        require(contextDepth > 0) { "contextDepth必须大于0" }
        require(relationshipScore in 0..100) { "relationshipScore必须在0到100之间" }
    }
    
    /**
     * 获取最近的Facts（7天内）
     */
    fun getRecentFacts(): List<Fact> {
        val sevenDaysAgo = System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000L
        return facts.filter { it.timestamp >= sevenDaysAgo }
    }
    
    /**
     * 获取手动添加的Facts
     */
    fun getManualFacts(): List<Fact> {
        return facts.filter { it.source == FactSource.MANUAL }
    }
    
    /**
     * 判断关系等级
     */
    fun getRelationshipLevel(): RelationshipLevel {
        return when (relationshipScore) {
            in 0..30 -> RelationshipLevel.STRANGER
            in 31..60 -> RelationshipLevel.ACQUAINTANCE
            in 61..80 -> RelationshipLevel.FAMILIAR
            else -> RelationshipLevel.CLOSE
        }
    }
}

/**
 * 关系等级枚举
 */
enum class RelationshipLevel {
    STRANGER,       // 陌生/冷淡 (0-30)
    ACQUAINTANCE,   // 普通 (31-60)
    FAMILIAR,       // 熟悉 (61-80)
    CLOSE           // 亲密 (81-100)
}
```

### 4.2 Domain层Repository接口

#### 4.2.1 ConversationRepository接口

```kotlin
/**
 * 对话记录仓库接口
 *
 * 定义对话记录的数据访问接口
 */
interface ConversationRepository {
    
    /**
     * 保存用户输入
     *
     * @param contactId 联系人ID
     * @param userInput 用户输入的聊天记录
     * @param timestamp 时间戳（毫秒）
     * @return 保存的对话记录ID
     */
    suspend fun saveUserInput(
        contactId: String,
        userInput: String,
        timestamp: Long = System.currentTimeMillis()
    ): Result<Long>
    
    /**
     * 更新AI回复
     *
     * @param logId 对话记录ID
     * @param aiResponse AI的分析回复
     * @return 操作结果
     */
    suspend fun updateAiResponse(
        logId: Long,
        aiResponse: String
    ): Result<Unit>
    
    /**
     * 获取未总结的对话记录
     *
     * @param sinceTimestamp 起始时间戳（只获取此时间之后的记录）
     * @return 未总结的对话记录列表
     */
    suspend fun getUnsummarizedLogs(
        sinceTimestamp: Long
    ): Result<List<ConversationLog>>
    
    /**
     * 获取指定联系人在指定日期的对话记录
     *
     * @param contactId 联系人ID
     * @param date 日期字符串，格式"yyyy-MM-dd"
     * @return 对话记录列表
     */
    suspend fun getLogsByContactAndDate(
        contactId: String,
        date: String
    ): Result<List<ConversationLog>>
    
    /**
     * 标记对话为已总结
     *
     * @param logIds 对话记录ID列表
     * @return 操作结果
     */
    suspend fun markAsSummarized(
        logIds: List<Long>
    ): Result<Unit>
    
    /**
     * 删除指定联系人的所有对话记录
     *
     * @param contactId 联系人ID
     * @return 删除的记录数
     */
    suspend fun deleteByContactId(
        contactId: String
    ): Result<Int>
    
    /**
     * 清理过期的已总结对话
     *
     * @param beforeTimestamp 此时间之前的已总结对话将被删除
     * @return 删除的记录数
     */
    suspend fun cleanupOldSummarizedLogs(
        beforeTimestamp: Long
    ): Result<Int>
}
```

#### 4.2.2 DailySummaryRepository接口

```kotlin
/**
 * 每日总结仓库接口
 *
 * 定义每日总结的数据访问接口
 */
interface DailySummaryRepository {
    
    /**
     * 保存每日总结
     *
     * @param summary 每日总结对象
     * @return 保存的总结ID
     */
    suspend fun saveSummary(
        summary: DailySummary
    ): Result<Long>
    
    /**
     * 获取指定联系人的所有总结
     *
     * @param contactId 联系人ID
     * @return 总结列表，按日期倒序
     */
    suspend fun getSummariesByContact(
        contactId: String
    ): Result<List<DailySummary>>
    
    /**
     * 获取指定日期的总结
     *
     * @param contactId 联系人ID
     * @param date 日期字符串
     * @return 总结对象，不存在则返回null
     */
    suspend fun getSummaryByDate(
        contactId: String,
        date: String
    ): Result<DailySummary?>
    
    /**
     * 检查指定日期是否已有总结
     *
     * @param contactId 联系人ID
     * @param date 日期字符串
     * @return 是否存在
     */
    suspend fun hasSummaryForDate(
        contactId: String,
        date: String
    ): Result<Boolean>
}
```

#### 4.2.3 ContactRepository扩展

```kotlin
/**
 * ContactRepository扩展接口
 *
 * 为记忆系统添加的新方法
 */
interface ContactRepository {
    // ... 现有方法 ...
    
    /**
     * 更新联系人的关系分数
     *
     * @param contactId 联系人ID
     * @param newScore 新的关系分数（0-100）
     * @return 操作结果
     */
    suspend fun updateRelationshipScore(
        contactId: String,
        newScore: Int
    ): Result<Unit>
    
    /**
     * 更新联系人的Facts
     *
     * @param contactId 联系人ID
     * @param facts 新的Facts列表
     * @return 操作结果
     */
    suspend fun updateFacts(
        contactId: String,
        facts: List<Fact>
    ): Result<Unit>
    
    /**
     * 添加单个Fact
     *
     * @param contactId 联系人ID
     * @param fact 要添加的Fact
     * @return 操作结果
     */
    suspend fun addFact(
        contactId: String,
        fact: Fact
    ): Result<Unit>
    
    /**
     * 更新最后互动日期
     *
     * @param contactId 联系人ID
     * @param date 日期字符串，格式"yyyy-MM-dd"
     * @return 操作结果
     */
    suspend fun updateLastInteractionDate(
        contactId: String,
        date: String
    ): Result<Unit>
    
    /**
     * 批量更新联系人数据（事务）
     *
     * @param contactId 联系人ID
     * @param facts 新的Facts列表（可选）
     * @param relationshipScore 新的关系分数（可选）
     * @param lastInteractionDate 最后互动日期（可选）
     * @return 操作结果
     */
    suspend fun updateContactData(
        contactId: String,
        facts: List<Fact>? = null,
        relationshipScore: Int? = null,
        lastInteractionDate: String? = null
    ): Result<Unit>
}
```

### 4.3 Domain层Use Cases

#### 4.3.1 AnalyzeChatUseCase扩展

```kotlin
/**
 * 分析聊天用例（扩展版）
 *
 * 集成对话记录保存功能
 */
@Singleton
class AnalyzeChatUseCase @Inject constructor(
    private val contactRepository: ContactRepository,
    private val brainTagRepository: BrainTagRepository,
    private val aiRepository: AiRepository,
    private val conversationRepository: ConversationRepository,  // 新增
    private val contextBuilder: ContextBuilder,                  // 新增
    private val privacyEngine: PrivacyEngine
) {
    /**
     * 执行聊天分析
     *
     * @param contactId 联系人ID
     * @param chatHistory 聊天记录
     * @return 分析结果
     */
    suspend operator fun invoke(
        contactId: String,
        chatHistory: String
    ): Result<AnalysisResult> {
        return withContext(Dispatchers.IO) {
            try {
                // 1. 保存用户输入（立即保存，不等待AI响应）
                val logId = conversationRepository.saveUserInput(
                    contactId = contactId,
                    userInput = chatHistory
                ).getOrThrow()
                
                // 2. 获取联系人信息
                val contact = contactRepository.getProfile(contactId).getOrThrow()
                val tags = brainTagRepository.getTagsByContact(contactId).getOrThrow()
                
                // 3. 构建分析上下文
                val context = contextBuilder.buildAnalysisContext(
                    contact = contact,
                    tags = tags,
                    userInput = chatHistory
                )
                
                // 4. 数据掩码
                val maskedContext = privacyEngine.maskSensitiveData(context)
                
                // 5. 调用AI分析
                val analysisResult = aiRepository.analyzeChat(maskedContext).getOrThrow()
                
                // 6. 保存AI回复
                conversationRepository.updateAiResponse(
                    logId = logId,
                    aiResponse = analysisResult.toJsonString()
                )
                
                Result.success(analysisResult)
            } catch (e: Exception) {
                Log.e("AnalyzeChatUseCase", "分析失败", e)
                Result.failure(e)
            }
        }
    }
}
```

#### 4.3.2 SummarizeDailyConversationsUseCase

```kotlin
/**
 * 每日对话总结用例
 *
 * 在新一天首次打开App时执行，总结昨日对话并更新联系人数据
 */
@Singleton
class SummarizeDailyConversationsUseCase @Inject constructor(
    private val conversationRepository: ConversationRepository,
    private val contactRepository: ContactRepository,
    private val brainTagRepository: BrainTagRepository,
    private val dailySummaryRepository: DailySummaryRepository,
    private val aiRepository: AiRepository,
    private val memoryPreferences: MemoryPreferences
) {
    companion object {
        const val MAX_RETRY_DAYS = 7
        const val MAX_AI_RETRIES = 3
    }
    
    /**
     * 执行每日总结
     *
     * @return 总结结果，包含成功和失败的联系人数量
     */
    suspend operator fun invoke(): Result<SummaryResult> {
        return withContext(Dispatchers.IO) {
            try {
                // 1. 检查是否需要执行
                val lastSummaryDate = memoryPreferences.getLastSummaryDate()
                val today = getCurrentDateString()
                
                if (lastSummaryDate == today) {
                    return@withContext Result.success(SummaryResult(skipped = true))
                }
                
                // 2. 获取未总结的对话（最多7天前）
                val sevenDaysAgo = System.currentTimeMillis() - MAX_RETRY_DAYS * 24 * 60 * 60 * 1000L
                val unsummarizedLogs = conversationRepository
                    .getUnsummarizedLogs(sevenDaysAgo)
                    .getOrThrow()
                
                if (unsummarizedLogs.isEmpty()) {
                    memoryPreferences.setLastSummaryDate(today)
                    return@withContext Result.success(SummaryResult(noData = true))
                }
                
                // 3. 按联系人和日期分组
                val groupedLogs = unsummarizedLogs
                    .groupBy { it.contactId }
                    .flatMap { (contactId, logs) ->
                        logs.groupBy { it.getDateString() }
                            .map { (date, dateLogs) -> Triple(contactId, date, dateLogs) }
                    }
                
                // 4. 对每组执行总结
                var successCount = 0
                var failedCount = 0
                var usedFallback = false
                
                groupedLogs.forEach { (contactId, date, logs) ->
                    try {
                        val result = summarizeForContact(contactId, logs, date)
                        if (result.usedFallback) usedFallback = true
                        successCount++
                    } catch (e: Exception) {
                        Log.e("DailySummary", "Failed for $contactId on $date", e)
                        failedCount++
                    }
                }
                
                // 5. 更新最后总结日期
                memoryPreferences.setLastSummaryDate(today)
                
                Result.success(SummaryResult(
                    successCount = successCount,
                    failedCount = failedCount,
                    usedFallback = usedFallback
                ))
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
    
    // 私有方法实现...
}

/**
 * 总结结果
 */
data class SummaryResult(
    val skipped: Boolean = false,
    val noData: Boolean = false,
    val successCount: Int = 0,
    val failedCount: Int = 0,
    val usedFallback: Boolean = false
)
```

### 4.4 Domain层Services

#### 4.4.1 ContextBuilder

```kotlin
/**
 * 上下文构建器
 *
 * 负责从联系人数据中筛选相关信息，构建AI分析所需的上下文
 */
@Singleton
class ContextBuilder @Inject constructor() {
    
    companion object {
        const val MAX_FACTS_COUNT = 20
        const val RECENT_DAYS = 7
        const val MEDIUM_DAYS = 30
    }
    
    /**
     * 构建分析上下文
     *
     * @param contact 联系人信息
     * @param tags 联系人标签列表
     * @param userInput 用户输入的聊天记录
     * @return 构建好的Prompt字符串
     */
    fun buildAnalysisContext(
        contact: ContactProfile,
        tags: List<BrainTag>,
        userInput: String
    ): String {
        val sb = StringBuilder()
        
        // 1. 基本信息（必选）
        sb.appendLine("【联系人信息】")
        sb.appendLine("姓名：${contact.name}")
        sb.appendLine("目标：${contact.targetGoal}")
        sb.appendLine("关系分数：${contact.relationshipScore}/100")
        sb.appendLine()
        
        // 2. 雷区标签（必选）
        val riskTags = tags.filter { it.type == TagType.RISK_RED }
        if (riskTags.isNotEmpty()) {
            sb.appendLine("【雷区标签】")
            riskTags.forEach { sb.appendLine("- ${it.content}") }
            sb.appendLine()
        }
        
        // 3. 策略标签（必选）
        val strategyTags = tags.filter { it.type == TagType.STRATEGY_GREEN }
        if (strategyTags.isNotEmpty()) {
            sb.appendLine("【策略标签】")
            strategyTags.forEach { sb.appendLine("- ${it.content}") }
            sb.appendLine()
        }
        
        // 4. 筛选后的Facts
        val relevantFacts = selectRelevantFacts(contact.facts)
        if (relevantFacts.isNotEmpty()) {
            sb.appendLine("【已知事实】")
            relevantFacts.forEach { fact ->
                val dateStr = formatDate(fact.timestamp)
                val sourceStr = if (fact.source == FactSource.MANUAL) "手动" else "AI推断"
                sb.appendLine("- ${fact.key}：${fact.value} ($dateStr, $sourceStr)")
            }
            sb.appendLine()
        }
        
        // 5. 用户输入
        sb.appendLine("【用户提供的聊天记录】")
        sb.appendLine(userInput)
        
        return sb.toString()
    }
    
    /**
     * 筛选相关Facts
     *
     * 筛选规则：
     * 1. 最近7天：全部保留
     * 2. 7-30天：只保留MANUAL来源
     * 3. 30天以上：只保留MANUAL来源
     * 4. 按时间倒序排序
     * 5. 最多保留20条
     */
    fun selectRelevantFacts(facts: List<Fact>): List<Fact> {
        val now = System.currentTimeMillis()
        val sevenDaysAgo = now - RECENT_DAYS * 24 * 60 * 60 * 1000L
        val thirtyDaysAgo = now - MEDIUM_DAYS * 24 * 60 * 60 * 1000L
        
        // 分层筛选
        val recentFacts = facts.filter { it.timestamp >= sevenDaysAgo }
        val mediumFacts = facts.filter { 
            it.timestamp < sevenDaysAgo && 
            it.timestamp >= thirtyDaysAgo &&
            it.source == FactSource.MANUAL
        }
        val oldFacts = facts.filter { 
            it.timestamp < thirtyDaysAgo &&
            it.source == FactSource.MANUAL
        }
        
        // 合并并限制数量
        return (recentFacts + mediumFacts + oldFacts)
            .sortedByDescending { it.timestamp }
            .take(MAX_FACTS_COUNT)
    }
    
    private fun formatDate(timestamp: Long): String {
        val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        return sdf.format(Date(timestamp))
    }
}
```


## 5. Data层设计

### 5.1 Repository实现类

#### 5.1.1 ConversationRepositoryImpl

```kotlin
/**
 * 对话记录仓库实现类
 *
 * 负责对话记录的数据访问
 */
@Singleton
class ConversationRepositoryImpl @Inject constructor(
    private val conversationLogDao: ConversationLogDao
) : ConversationRepository {
    
    override suspend fun saveUserInput(
        contactId: String,
        userInput: String,
        timestamp: Long
    ): Result<Long> {
        return withContext(Dispatchers.IO) {
            try {
                val entity = ConversationLogEntity(
                    contactId = contactId,
                    userInput = userInput,
                    aiResponse = null,
                    timestamp = timestamp,
                    isSummarized = false
                )
                val id = conversationLogDao.insert(entity)
                Result.success(id)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "保存用户输入失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun updateAiResponse(
        logId: Long,
        aiResponse: String
    ): Result<Unit> {
        return withContext(Dispatchers.IO) {
            try {
                conversationLogDao.updateAiResponse(logId, aiResponse)
                Result.success(Unit)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "更新AI回复失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun getUnsummarizedLogs(
        sinceTimestamp: Long
    ): Result<List<ConversationLog>> {
        return withContext(Dispatchers.IO) {
            try {
                val entities = conversationLogDao.getUnsummarizedLogs(sinceTimestamp)
                val logs = entities.map { it.toDomainModel() }
                Result.success(logs)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "获取未总结对话失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun getLogsByContactAndDate(
        contactId: String,
        date: String
    ): Result<List<ConversationLog>> {
        return withContext(Dispatchers.IO) {
            try {
                val entities = conversationLogDao.getLogsByContactAndDate(contactId, date)
                val logs = entities.map { it.toDomainModel() }
                Result.success(logs)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "获取对话记录失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun markAsSummarized(
        logIds: List<Long>
    ): Result<Unit> {
        return withContext(Dispatchers.IO) {
            try {
                conversationLogDao.markAsSummarized(logIds)
                Result.success(Unit)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "标记已总结失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun deleteByContactId(
        contactId: String
    ): Result<Int> {
        return withContext(Dispatchers.IO) {
            try {
                val count = conversationLogDao.deleteByContactId(contactId)
                Result.success(count)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "删除对话记录失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun cleanupOldSummarizedLogs(
        beforeTimestamp: Long
    ): Result<Int> {
        return withContext(Dispatchers.IO) {
            try {
                val count = conversationLogDao.cleanupOldSummarizedLogs(beforeTimestamp)
                Result.success(count)
            } catch (e: Exception) {
                Log.e("ConversationRepo", "清理旧对话失败", e)
                Result.failure(e)
            }
        }
    }
}
```

#### 5.1.2 DailySummaryRepositoryImpl

```kotlin
/**
 * 每日总结仓库实现类
 */
@Singleton
class DailySummaryRepositoryImpl @Inject constructor(
    private val dailySummaryDao: DailySummaryDao,
    private val moshi: Moshi
) : DailySummaryRepository {
    
    override suspend fun saveSummary(
        summary: DailySummary
    ): Result<Long> {
        return withContext(Dispatchers.IO) {
            try {
                val entity = summary.toEntity(moshi)
                val id = dailySummaryDao.insert(entity)
                Result.success(id)
            } catch (e: Exception) {
                Log.e("DailySummaryRepo", "保存总结失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun getSummariesByContact(
        contactId: String
    ): Result<List<DailySummary>> {
        return withContext(Dispatchers.IO) {
            try {
                val entities = dailySummaryDao.getSummariesByContact(contactId)
                val summaries = entities.map { it.toDomainModel(moshi) }
                Result.success(summaries)
            } catch (e: Exception) {
                Log.e("DailySummaryRepo", "获取总结列表失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun getSummaryByDate(
        contactId: String,
        date: String
    ): Result<DailySummary?> {
        return withContext(Dispatchers.IO) {
            try {
                val entity = dailySummaryDao.getSummaryByDate(contactId, date)
                val summary = entity?.toDomainModel(moshi)
                Result.success(summary)
            } catch (e: Exception) {
                Log.e("DailySummaryRepo", "获取总结失败", e)
                Result.failure(e)
            }
        }
    }
    
    override suspend fun hasSummaryForDate(
        contactId: String,
        date: String
    ): Result<Boolean> {
        return withContext(Dispatchers.IO) {
            try {
                val exists = dailySummaryDao.hasSummaryForDate(contactId, date)
                Result.success(exists)
            } catch (e: Exception) {
                Log.e("DailySummaryRepo", "检查总结存在失败", e)
                Result.failure(e)
            }
        }
    }
}
```

### 5.2 DAO接口设计

#### 5.2.1 ConversationLogDao

```kotlin
/**
 * 对话记录DAO
 */
@Dao
interface ConversationLogDao {
    
    /**
     * 插入对话记录
     */
    @Insert
    suspend fun insert(log: ConversationLogEntity): Long
    
    /**
     * 更新AI回复
     */
    @Query("UPDATE conversation_logs SET ai_response = :aiResponse WHERE id = :logId")
    suspend fun updateAiResponse(logId: Long, aiResponse: String)
    
    /**
     * 获取未总结的对话记录
     */
    @Query("""
        SELECT * FROM conversation_logs 
        WHERE is_summarized = 0 AND timestamp >= :sinceTimestamp
        ORDER BY timestamp ASC
    """)
    suspend fun getUnsummarizedLogs(sinceTimestamp: Long): List<ConversationLogEntity>
    
    /**
     * 获取指定联系人在指定日期的对话记录
     */
    @Query("""
        SELECT * FROM conversation_logs 
        WHERE contact_id = :contactId 
        AND date(timestamp/1000, 'unixepoch', 'localtime') = :date
        ORDER BY timestamp ASC
    """)
    suspend fun getLogsByContactAndDate(
        contactId: String, 
        date: String
    ): List<ConversationLogEntity>
    
    /**
     * 标记对话为已总结
     */
    @Query("UPDATE conversation_logs SET is_summarized = 1 WHERE id IN (:logIds)")
    suspend fun markAsSummarized(logIds: List<Long>)
    
    /**
     * 删除指定联系人的所有对话记录
     */
    @Query("DELETE FROM conversation_logs WHERE contact_id = :contactId")
    suspend fun deleteByContactId(contactId: String): Int
    
    /**
     * 清理过期的已总结对话
     */
    @Query("""
        DELETE FROM conversation_logs 
        WHERE is_summarized = 1 AND timestamp < :beforeTimestamp
    """)
    suspend fun cleanupOldSummarizedLogs(beforeTimestamp: Long): Int
}
```

#### 5.2.2 DailySummaryDao

```kotlin
/**
 * 每日总结DAO
 */
@Dao
interface DailySummaryDao {
    
    /**
     * 插入每日总结（如果已存在则替换）
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(summary: DailySummaryEntity): Long
    
    /**
     * 获取指定联系人的所有总结
     */
    @Query("""
        SELECT * FROM daily_summaries 
        WHERE contact_id = :contactId 
        ORDER BY summary_date DESC
    """)
    suspend fun getSummariesByContact(contactId: String): List<DailySummaryEntity>
    
    /**
     * 获取指定日期的总结
     */
    @Query("""
        SELECT * FROM daily_summaries 
        WHERE contact_id = :contactId AND summary_date = :date
    """)
    suspend fun getSummaryByDate(contactId: String, date: String): DailySummaryEntity?
    
    /**
     * 检查指定日期是否已有总结
     */
    @Query("""
        SELECT EXISTS(
            SELECT 1 FROM daily_summaries 
            WHERE contact_id = :contactId AND summary_date = :date
        )
    """)
    suspend fun hasSummaryForDate(contactId: String, date: String): Boolean
}
```

### 5.3 Entity设计

#### 5.3.1 ConversationLogEntity

```kotlin
/**
 * 对话记录Entity
 */
@Entity(
    tableName = "conversation_logs",
    foreignKeys = [
        ForeignKey(
            entity = ContactProfileEntity::class,
            parentColumns = ["id"],
            childColumns = ["contact_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["contact_id"]),
        Index(value = ["timestamp"]),
        Index(value = ["is_summarized"])
    ]
)
data class ConversationLogEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0,
    
    @ColumnInfo(name = "contact_id")
    val contactId: String,
    
    @ColumnInfo(name = "user_input")
    val userInput: String,
    
    @ColumnInfo(name = "ai_response")
    val aiResponse: String?,
    
    @ColumnInfo(name = "timestamp")
    val timestamp: Long,
    
    @ColumnInfo(name = "is_summarized")
    val isSummarized: Boolean = false
) {
    /**
     * 转换为领域模型
     */
    fun toDomainModel(): ConversationLog {
        return ConversationLog(
            id = id,
            contactId = contactId,
            userInput = userInput,
            aiResponse = aiResponse,
            timestamp = timestamp,
            isSummarized = isSummarized
        )
    }
}
```

#### 5.3.2 DailySummaryEntity

```kotlin
/**
 * 每日总结Entity
 */
@Entity(
    tableName = "daily_summaries",
    foreignKeys = [
        ForeignKey(
            entity = ContactProfileEntity::class,
            parentColumns = ["id"],
            childColumns = ["contact_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["contact_id"]),
        Index(value = ["summary_date"]),
        Index(value = ["contact_id", "summary_date"], unique = true)
    ]
)
data class DailySummaryEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0,
    
    @ColumnInfo(name = "contact_id")
    val contactId: String,
    
    @ColumnInfo(name = "summary_date")
    val summaryDate: String,
    
    @ColumnInfo(name = "content")
    val content: String,
    
    @ColumnInfo(name = "key_events_json")
    val keyEventsJson: String,
    
    @ColumnInfo(name = "relationship_score")
    val relationshipScore: Int,
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long
) {
    /**
     * 转换为领域模型
     */
    fun toDomainModel(moshi: Moshi): DailySummary {
        // 解析JSON字段
        val keyEventsAdapter = moshi.adapter<List<KeyEvent>>(
            Types.newParameterizedType(List::class.java, KeyEvent::class.java)
        )
        val keyEvents = keyEventsAdapter.fromJson(keyEventsJson) ?: emptyList()
        
        return DailySummary(
            id = id,
            contactId = contactId,
            summaryDate = summaryDate,
            content = content,
            keyEvents = keyEvents,
            newFacts = emptyList(),  // 从content中解析
            updatedTags = emptyList(),  // 从content中解析
            relationshipScoreChange = 0,  // 需要计算
            relationshipTrend = RelationshipTrend.STABLE  // 需要计算
        )
    }
}

/**
 * DailySummary扩展方法
 */
fun DailySummary.toEntity(moshi: Moshi): DailySummaryEntity {
    val keyEventsAdapter = moshi.adapter<List<KeyEvent>>(
        Types.newParameterizedType(List::class.java, KeyEvent::class.java)
    )
    val keyEventsJson = keyEventsAdapter.toJson(keyEvents)
    
    return DailySummaryEntity(
        id = id,
        contactId = contactId,
        summaryDate = summaryDate,
        content = content,
        keyEventsJson = keyEventsJson,
        relationshipScore = relationshipScoreChange,
        createdAt = System.currentTimeMillis()
    )
}
```

#### 5.3.3 ContactProfileEntity扩展

```kotlin
/**
 * 联系人画像Entity（扩展版）
 */
@Entity(tableName = "profiles")
data class ContactProfileEntity(
    @PrimaryKey
    @ColumnInfo(name = "id")
    val id: String,
    
    @ColumnInfo(name = "name")
    val name: String,
    
    @ColumnInfo(name = "target_goal")
    val targetGoal: String,
    
    @ColumnInfo(name = "context_depth")
    val contextDepth: Int = 10,
    
    @ColumnInfo(name = "facts_json")
    val factsJson: String = "[]",  // 修改：存储List<Fact>的JSON
    
    @ColumnInfo(name = "relationship_score")
    val relationshipScore: Int = 50,  // 新增
    
    @ColumnInfo(name = "last_interaction_date")
    val lastInteractionDate: String? = null  // 新增
)
```

### 5.4 TypeConverter设计

#### 5.4.1 FactListConverter

```kotlin
/**
 * Fact列表类型转换器
 *
 * 负责List<Fact>与JSON字符串的相互转换
 */
class FactListConverter {
    private val moshi = Moshi.Builder().build()
    
    @TypeConverter
    fun fromFactList(facts: List<Fact>?): String {
        if (facts == null) return "[]"
        val adapter = moshi.adapter<List<Fact>>(
            Types.newParameterizedType(List::class.java, Fact::class.java)
        )
        return adapter.toJson(facts)
    }
    
    @TypeConverter
    fun toFactList(json: String?): List<Fact> {
        if (json.isNullOrBlank()) return emptyList()
        
        return try {
            // 尝试解析为List<Fact>
            val listAdapter = moshi.adapter<List<Fact>>(
                Types.newParameterizedType(List::class.java, Fact::class.java)
            )
            listAdapter.fromJson(json) ?: emptyList()
        } catch (e: Exception) {
            // 降级：尝试解析为旧格式Map<String, String>
            try {
                val mapAdapter = moshi.adapter<Map<String, String>>(
                    Types.newParameterizedType(
                        Map::class.java, 
                        String::class.java, 
                        String::class.java
                    )
                )
                val oldMap = mapAdapter.fromJson(json) ?: emptyMap()
                val now = System.currentTimeMillis()
                oldMap.map { (key, value) ->
                    Fact(
                        key = key, 
                        value = value, 
                        timestamp = now, 
                        source = FactSource.MANUAL
                    )
                }
            } catch (e2: Exception) {
                Log.e("FactListConverter", "解析Facts失败", e2)
                emptyList()
            }
        }
    }
}
```

### 5.5 数据库Migration

#### 5.5.1 Migration 3→4

```kotlin
/**
 * 数据库迁移：v3 → v4
 *
 * 变更内容：
 * 1. 新增conversation_logs表
 * 2. 新增daily_summaries表
 * 3. profiles表添加relationship_score、last_interaction_date字段
 * 4. profiles表的facts_json格式从Map改为List<Fact>
 */
val MIGRATION_3_4 = object : Migration(3, 4) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // 1. 创建conversation_logs表
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS conversation_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                contact_id TEXT NOT NULL,
                user_input TEXT NOT NULL,
                ai_response TEXT,
                timestamp INTEGER NOT NULL,
                is_summarized INTEGER NOT NULL DEFAULT 0,
                FOREIGN KEY(contact_id) REFERENCES profiles(id) ON DELETE CASCADE
            )
        """)
        
        // 2. 创建conversation_logs索引
        database.execSQL(
            "CREATE INDEX idx_conv_contact ON conversation_logs(contact_id)"
        )
        database.execSQL(
            "CREATE INDEX idx_conv_timestamp ON conversation_logs(timestamp)"
        )
        database.execSQL(
            "CREATE INDEX idx_conv_summarized ON conversation_logs(is_summarized)"
        )
        
        // 3. 创建daily_summaries表
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS daily_summaries (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                contact_id TEXT NOT NULL,
                summary_date TEXT NOT NULL,
                content TEXT NOT NULL,
                key_events_json TEXT NOT NULL,
                relationship_score INTEGER NOT NULL,
                created_at INTEGER NOT NULL,
                FOREIGN KEY(contact_id) REFERENCES profiles(id) ON DELETE CASCADE
            )
        """)
        
        // 4. 创建daily_summaries索引
        database.execSQL(
            "CREATE INDEX idx_summary_contact ON daily_summaries(contact_id)"
        )
        database.execSQL(
            "CREATE INDEX idx_summary_date ON daily_summaries(summary_date)"
        )
        database.execSQL(
            "CREATE UNIQUE INDEX idx_summary_contact_date ON daily_summaries(contact_id, summary_date)"
        )
        
        // 5. 添加profiles新字段
        database.execSQL(
            "ALTER TABLE profiles ADD COLUMN relationship_score INTEGER NOT NULL DEFAULT 50"
        )
        database.execSQL(
            "ALTER TABLE profiles ADD COLUMN last_interaction_date TEXT"
        )
        
        // 6. 迁移facts_json格式（Map → List<Fact>）
        migrateFactsFormat(database)
    }
    
    private fun migrateFactsFormat(database: SupportSQLiteDatabase) {
        val cursor = database.query("SELECT id, facts_json FROM profiles")
        cursor.use {
            while (it.moveToNext()) {
                val id = it.getString(0)
                val oldFactsJson = it.getString(1)
                val newFactsJson = convertMapToFactList(oldFactsJson)
                database.execSQL(
                    "UPDATE profiles SET facts_json = ? WHERE id = ?",
                    arrayOf(newFactsJson, id)
                )
            }
        }
    }
    
    private fun convertMapToFactList(oldJson: String): String {
        if (oldJson.isBlank() || oldJson == "{}") return "[]"
        
        return try {
            val moshi = Moshi.Builder().build()
            val mapAdapter = moshi.adapter<Map<String, String>>(
                Types.newParameterizedType(
                    Map::class.java, 
                    String::class.java, 
                    String::class.java
                )
            )
            val oldMap = mapAdapter.fromJson(oldJson) ?: emptyMap()
            
            val now = System.currentTimeMillis()
            val factList = oldMap.map { (key, value) ->
                Fact(
                    key = key, 
                    value = value, 
                    timestamp = now, 
                    source = FactSource.MANUAL
                )
            }
            
            val listAdapter = moshi.adapter<List<Fact>>(
                Types.newParameterizedType(List::class.java, Fact::class.java)
            )
            listAdapter.toJson(factList)
        } catch (e: Exception) {
            Log.e("Migration", "转换Facts格式失败", e)
            "[]"
        }
    }
}
```

### 5.6 本地存储设计

#### 5.6.1 MemoryPreferences

```kotlin
/**
 * 记忆系统配置存储
 *
 * 使用SharedPreferences存储记忆系统的配置信息
 */
@Singleton
class MemoryPreferences @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val prefs = context.getSharedPreferences(
        "memory_settings", 
        Context.MODE_PRIVATE
    )
    
    companion object {
        private const val KEY_LAST_SUMMARY_DATE = "last_summary_date"
        private const val KEY_FAILED_TASKS = "failed_summary_tasks"
    }
    
    /**
     * 获取最后总结日期
     */
    fun getLastSummaryDate(): String? {
        return prefs.getString(KEY_LAST_SUMMARY_DATE, null)
    }
    
    /**
     * 设置最后总结日期
     */
    fun setLastSummaryDate(date: String) {
        prefs.edit().putString(KEY_LAST_SUMMARY_DATE, date).apply()
    }
    
    /**
     * 获取失败的总结任务
     */
    fun getFailedSummaryTasks(): List<FailedSummaryTask> {
        val json = prefs.getString(KEY_FAILED_TASKS, "[]") ?: "[]"
        return try {
            val moshi = Moshi.Builder().build()
            val adapter = moshi.adapter<List<FailedSummaryTask>>(
                Types.newParameterizedType(
                    List::class.java, 
                    FailedSummaryTask::class.java
                )
            )
            adapter.fromJson(json) ?: emptyList()
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * 设置失败的总结任务
     */
    fun setFailedSummaryTasks(tasks: List<FailedSummaryTask>) {
        val moshi = Moshi.Builder().build()
        val adapter = moshi.adapter<List<FailedSummaryTask>>(
            Types.newParameterizedType(
                List::class.java, 
                FailedSummaryTask::class.java
            )
        )
        val json = adapter.toJson(tasks)
        prefs.edit().putString(KEY_FAILED_TASKS, json).apply()
    }
}

/**
 * 失败的总结任务
 */
data class FailedSummaryTask(
    val contactId: String,
    val date: String,
    val timestamp: Long,
    val errorMessage: String?
)
```


## 6. Presentation层设计

### 6.1 ViewModel设计

#### 6.1.1 ChatViewModel扩展

```kotlin
/**
 * 聊天ViewModel（扩展版）
 *
 * 集成对话记录保存功能
 */
@HiltViewModel
class ChatViewModel @Inject constructor(
    private val analyzeChatUseCase: AnalyzeChatUseCase,
    private val checkDraftUseCase: CheckDraftUseCase,
    private val contactRepository: ContactRepository,
    save


## 6. Presentation层设计

### 6.1 ViewModel设计

#### 6.1.1 ChatViewModel扩展

```kotlin
/**
 * 聊天ViewModel（扩展版）
 * 集成对话记录保存功能
 */
@HiltViewModel
class ChatViewModel @Inject constructor(
    private val analyzeChatUseCase: AnalyzeChatUseCase,
    private val checkDraftUseCase: CheckDraftUseCase,
    private val contactRepository: ContactRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ChatUiState())
    val uiState: StateFlow<ChatUiState> = _uiState.asStateFlow()
    
    private val contactId: String = checkNotNull(savedStateHandle["contactId"])
    
    init {
        loadContact()
    }
    
    /**
     * 分析聊天记录
     * 自动保存对话记录
     */
    fun analyzeChat(chatHistory: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }
            
            try {
                // AnalyzeChatUseCase内部会自动保存对话记录
                val result = analyzeChatUseCase(contactId, chatHistory).getOrThrow()
                
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        analysisResult = result,
                        conversationSaved = true
                    )
                }
            } catch (e: Exception) {
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        error = e.message ?: "分析失败"
                    )
                }
            }
        }
    }
    
    private fun loadContact() {
        viewModelScope.launch {
            contactRepository.getProfile(contactId)
                .onSuccess { contact ->
                    _uiState.update { it.copy(contact = contact) }
                }
        }
    }
}
```

#### 6.1.2 ContactDetailViewModel扩展

```kotlin
/**
 * 联系人详情ViewModel（扩展版）
 * 添加关系分数和Facts展示
 */
@HiltViewModel
class ContactDetailViewModel @Inject constructor(
    private val contactRepository: ContactRepository,
    private val brainTagRepository: BrainTagRepository,
    private val dailySummaryRepository: DailySummaryRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ContactDetailUiState())
    val uiState: StateFlow<ContactDetailUiState> = _uiState.asStateFlow()
    
    private val contactId: String = checkNotNull(savedStateHandle["contactId"])
    
    init {
        loadContactDetail()
        loadRecentSummaries()
    }
    
    private fun loadContactDetail() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            
            try {
                val contact = contactRepository.getProfile(contactId).getOrThrow()
                val tags = brainTagRepository.getTagsByContact(contactId).getOrThrow()
                
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        contact = contact,
                        tags = tags,
                        relationshipScore = contact.relationshipScore,
                        lastInteractionDate = contact.lastInteractionDate,
                        facts = contact.facts
                    )
                }
            } catch (e: Exception) {
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        error = e.message ?: "加载失败"
                    )
                }
            }
        }
    }
    
    private fun loadRecentSummaries() {
        viewModelScope.launch {
            dailySummaryRepository.getSummariesByContact(contactId)
                .onSuccess { summaries ->
                    // 根据最近的总结计算趋势
                    val trend = calculateTrend(summaries.take(3))
                    _uiState.update { it.copy(relationshipTrend = trend) }
                }
        }
    }
    
    private fun calculateTrend(recentSummaries: List<DailySummary>): RelationshipTrend {
        if (recentSummaries.isEmpty()) return RelationshipTrend.STABLE
        
        val avgChange = recentSummaries
            .map { it.relationshipScoreChange }
            .average()
        
        return when {
            avgChange >= 3 -> RelationshipTrend.IMPROVING
            avgChange <= -3 -> RelationshipTrend.DECLINING
            else -> RelationshipTrend.STABLE
        }
    }
}
```

### 6.2 UiState设计

#### 6.2.1 ChatUiState扩展

```kotlin
/**
 * 聊天页面UI状态（扩展版）
 */
data class ChatUiState(
    // 现有字段
    val isLoading: Boolean = false,
    val error: String? = null,
    val contact: ContactProfile? = null,
    val messages: List<ChatMessage> = emptyList(),
    val analysisResult: AnalysisResult? = null,
    
    // 新增字段
    val isSavingConversation: Boolean = false,
    val conversationSaved: Boolean = false,
    
    // 上下文信息（用于调试）
    val contextFactsCount: Int = 0,
    val contextTagsCount: Int = 0
)
```

#### 6.2.2 ContactDetailUiState扩展

```kotlin
/**
 * 联系人详情页UI状态（扩展版）
 */
data class ContactDetailUiState(
    // 现有字段
    val isLoading: Boolean = false,
    val error: String? = null,
    val contact: ContactProfile? = null,
    val tags: List<BrainTag> = emptyList(),
    
    // 新增字段
    val relationshipScore: Int = 50,
    val lastInteractionDate: String? = null,
    val relationshipTrend: RelationshipTrend? = null,
    val facts: List<Fact> = emptyList(),
    
    // UI交互状态
    val showAddFactDialog: Boolean = false,
    val showEditFactDialog: Boolean = false,
    val selectedFact: Fact? = null
)
```

### 6.3 Compose组件设计

#### 6.3.1 RelationshipScoreSection

```kotlin
/**
 * 关系分数展示组件
 */
@Composable
fun RelationshipScoreSection(
    score: Int,
    lastInteractionDate: String?,
    trend: RelationshipTrend?,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant
        )
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                text = "关系分数",
                style = MaterialTheme.typography.titleSmall
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(
                    text = "$score/100",
                    style = MaterialTheme.typography.headlineMedium,
                    fontWeight = FontWeight.Bold
                )
                
                Spacer(modifier = Modifier.width(16.dp))
                
                trend?.let { TrendIcon(trend = it) }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            LinearProgressIndicator(
                progress = score / 100f,
                modifier = Modifier
                    .fillMaxWidth()
                    .height(8.dp)
                    .clip(RoundedCornerShape(4.dp)),
                color = getScoreColor(score),
                trackColor = MaterialTheme.colorScheme.surfaceVariant
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            lastInteractionDate?.let {
                Text(
                    text = "最后互动：$it",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

@Composable
private fun getScoreColor(score: Int): Color {
    return when {
        score <= 30 -> MaterialTheme.colorScheme.error
        score <= 60 -> MaterialTheme.colorScheme.tertiary
        else -> MaterialTheme.colorScheme.primary
    }
}
```

#### 6.3.2 FactItem

```kotlin
/**
 * Fact列表项组件
 */
@Composable
fun FactItem(
    fact: Fact,
    modifier: Modifier = Modifier
) {
    Surface(
        modifier = modifier.fillMaxWidth(),
        color = MaterialTheme.colorScheme.surfaceVariant,
        shape = RoundedCornerShape(8.dp)
    ) {
        Column(modifier = Modifier.padding(12.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = fact.key,
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Medium
                )
                Text(
                    text = formatDate(fact.timestamp),
                    style = MaterialTheme.typography.labelSmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            
            Spacer(modifier = Modifier.height(4.dp))
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = fact.value,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.weight(1f)
                )
                
                Text(
                    text = if (fact.source == FactSource.MANUAL) "手动添加" else "AI推断",
                    style = MaterialTheme.typography.labelSmall,
                    color = if (fact.source == FactSource.MANUAL)
                        MaterialTheme.colorScheme.onSurfaceVariant
                    else
                        MaterialTheme.colorScheme.primary
                )
            }
        }
    }
}
```


## 7. 依赖注入设计

### 7.1 Module配置

#### 7.1.1 MemoryModule

```kotlin
/**
 * 记忆系统模块
 * 提供记忆系统相关的依赖
 */
@Module
@InstallIn(SingletonComponent::class)
object MemoryModule {
    
    /**
     * 提供ConversationRepository
     */
    @Provides
    @Singleton
    fun provideConversationRepository(
        conversationLogDao: ConversationLogDao
    ): ConversationRepository {
        return ConversationRepositoryImpl(conversationLogDao)
    }
    
    /**
     * 提供DailySummaryRepository
     */
    @Provides
    @Singleton
    fun provideDailySummaryRepository(
        dailySummaryDao: DailySummaryDao,
        moshi: Moshi
    ): DailySummaryRepository {
        return DailySummaryRepositoryImpl(dailySummaryDao, moshi)
    }
    
    /**
     * 提供MemoryPreferences
     */
    @Provides
    @Singleton
    fun provideMemoryPreferences(
        @ApplicationContext context: Context
    ): MemoryPreferences {
        return MemoryPreferences(context)
    }
    
    /**
     * 提供ContextBuilder
     */
    @Provides
    @Singleton
    fun provideContextBuilder(): ContextBuilder {
        return ContextBuilder()
    }
    
    /**
     * 提供Moshi实例
     */
    @Provides
    @Singleton
    fun provideMoshi(): Moshi {
        return Moshi.Builder()
            .add(KotlinJsonAdapterFactory())
            .build()
    }
}
```

#### 7.1.2 DatabaseModule扩展

```kotlin
/**
 * 数据库模块（扩展版）
 */
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    /**
     * 提供AppDatabase
     */
    @Provides
    @Singleton
    fun provideAppDatabase(
        @ApplicationContext context: Context
    ): AppDatabase {
        return Room.databaseBuilder(
            context.applicationContext,
            AppDatabase::class.java,
            "empathy_database"
        )
        .addMigrations(MIGRATION_3_4)  // 添加新的迁移
        .fallbackToDestructiveMigration()  // MVP阶段降级方案
        .build()
    }
    
    /**
     * 提供ConversationLogDao
     */
    @Provides
    fun provideConversationLogDao(database: AppDatabase): ConversationLogDao {
        return database.conversationLogDao()
    }
    
    /**
     * 提供DailySummaryDao
     */
    @Provides
    fun provideDailySummaryDao(database: AppDatabase): DailySummaryDao {
        return database.dailySummaryDao()
    }
    
    // 现有的DAO提供方法...
}
```

### 7.2 依赖关系图

```
┌─────────────────────────────────────────────────────────────┐
│                    Application层                             │
│  EmpathyApplication                                         │
│    └── SummarizeDailyConversationsUseCase                   │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                    Presentation层                            │
│  ChatViewModel                                              │
│    ├── AnalyzeChatUseCase                                   │
│    ├── CheckDraftUseCase                                    │
│    └── ContactRepository                                    │
│                                                             │
│  ContactDetailViewModel                                     │
│    ├── ContactRepository                                    │
│    ├── BrainTagRepository                                   │
│    └── DailySummaryRepository                               │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                    Domain层                                  │
│  AnalyzeChatUseCase                                         │
│    ├── ContactRepository                                    │
│    ├── BrainTagRepository                                   │
│    ├── AiRepository                                         │
│    ├── ConversationRepository                               │
│    ├── ContextBuilder                                       │
│    └── PrivacyEngine                                        │
│                                                             │
│  SummarizeDailyConversationsUseCase                         │
│    ├── ConversationRepository                               │
│    ├── ContactRepository                                    │
│    ├── BrainTagRepository                                   │
│    ├── DailySummaryRepository                               │
│    ├── AiRepository                                         │
│    └── MemoryPreferences                                    │
│                                                             │
│  ContextBuilder (无依赖)                                    │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                    Data层                                    │
│  ConversationRepositoryImpl                                 │
│    └── ConversationLogDao                                   │
│                                                             │
│  DailySummaryRepositoryImpl                                 │
│    ├── DailySummaryDao                                      │
│    └── Moshi                                                │
│                                                             │
│  ContactRepositoryImpl                                      │
│    └── ContactDao                                           │
│                                                             │
│  MemoryPreferences                                          │
│    └── Context                                              │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                    Storage层                                 │
│  AppDatabase (Room)                                         │
│    ├── ConversationLogDao                                   │
│    ├── DailySummaryDao                                      │
│    ├── ContactDao                                           │
│    └── BrainTagDao                                          │
│                                                             │
│  SharedPreferences                                          │
│    └── MemoryPreferences                                    │
└─────────────────────────────────────────────────────────────┘
```

### 7.3 作用域说明

| 组件 | 作用域 | 生命周期 | 说明 |
|------|--------|---------|------|
| ConversationRepository | Singleton | 应用生命周期 | 全局单例 |
| DailySummaryRepository | Singleton | 应用生命周期 | 全局单例 |
| ContactRepository | Singleton | 应用生命周期 | 全局单例 |
| MemoryPreferences | Singleton | 应用生命周期 | 全局单例 |
| ContextBuilder | Singleton | 应用生命周期 | 全局单例 |
| AnalyzeChatUseCase | Singleton | 应用生命周期 | 全局单例 |
| SummarizeDailyConversationsUseCase | Singleton | 应用生命周期 | 全局单例 |
| ChatViewModel | ViewModelScoped | ViewModel生命周期 | 页面级 |
| ContactDetailViewModel | ViewModelScoped | ViewModel生命周期 | 页面级 |
| AppDatabase | Singleton | 应用生命周期 | 全局单例 |
| Moshi | Singleton | 应用生命周期 | 全局单例 |

## 8. 错误处理设计

### 8.1 错误分类

```kotlin
/**
 * 记忆系统错误类型
 */
sealed class MemoryError : Exception() {
    // 数据库错误
    data class DatabaseError(
        override val message: String,
        override val cause: Throwable? = null
    ) : MemoryError()
    
    // AI服务错误
    data class AiServiceError(
        override val message: String,
        override val cause: Throwable? = null
    ) : MemoryError()
    
    // 数据解析错误
    data class ParseError(
        override val message: String,
        val json: String? = null
    ) : MemoryError()
    
    // 数据验证错误
    data class ValidationError(
        override val message: String,
        val field: String
    ) : MemoryError()
}
```

### 8.2 错误处理策略

| 错误类型 | 处理策略 | 用户反馈 | 日志级别 |
|---------|---------|---------|---------|
| 对话保存失败 | 重试1次 | 无（静默处理） | WARNING |
| AI调用失败 | 重试3次 | Toast提示 | ERROR |
| JSON解析失败 | 使用降级方案 | 无（静默处理） | WARNING |
| 数据库迁移失败 | 破坏性迁移 | 提示数据清空 | ERROR |
| 每日总结失败 | 保留未总结状态 | 无（后台执行） | WARNING |

### 8.3 重试策略

```kotlin
/**
 * 重试策略配置
 */
object RetryPolicy {
    const val MAX_RETRIES = 3
    const val INITIAL_DELAY_MS = 1000L
    const val MAX_DELAY_MS = 10000L
    const val MULTIPLIER = 2.0
    
    /**
     * 计算重试延迟（指数退避）
     */
    fun calculateDelay(retryCount: Int): Long {
        val delay = INITIAL_DELAY_MS * MULTIPLIER.pow(retryCount.toDouble())
        return delay.toLong().coerceAtMost(MAX_DELAY_MS)
    }
    
    /**
     * 判断是否应该重试
     */
    fun shouldRetry(error: Throwable, retryCount: Int): Boolean {
        if (retryCount >= MAX_RETRIES) return false
        
        return when (error) {
            is IOException -> true
            is SocketTimeoutException -> true
            is HttpException -> error.code() in listOf(500, 502, 503, 504)
            is JsonDataException -> true
            else -> false
        }
    }
}
```

## 9. 性能优化设计

### 9.1 缓存策略

```kotlin
/**
 * 记忆系统缓存管理器
 */
@Singleton
class MemoryCacheManager @Inject constructor() {
    private val cache = ConcurrentHashMap<String, CacheEntry>()
    
    data class CacheEntry(
        val value: Any,
        val timestamp: Long,
        val ttl: Long = 5 * 60 * 1000  // 5分钟
    ) {
        fun isExpired(): Boolean {
            return System.currentTimeMillis() - timestamp > ttl
        }
    }
    
    fun get(key: String): Any? {
        val entry = cache[key] ?: return null
        return if (entry.isExpired()) {
            cache.remove(key)
            null
        } else {
            entry.value
        }
    }
    
    fun put(key: String, value: Any, ttl: Long = 5 * 60 * 1000) {
        cache[key] = CacheEntry(value, System.currentTimeMillis(), ttl)
    }
    
    fun clear() {
        cache.clear()
    }
}
```

### 9.2 数据库优化

```kotlin
/**
 * 数据库查询优化
 */
// 1. 使用索引
@Entity(
    indices = [
        Index(value = ["contact_id"]),
        Index(value = ["timestamp"]),
        Index(value = ["is_summarized"])
    ]
)

// 2. 批量操作使用事务
@Transaction
suspend fun batchUpdateSummarized(logIds: List<Long>) {
    logIds.chunked(100).forEach { chunk ->
        markAsSummarized(chunk)
    }
}

// 3. 使用Flow实现响应式查询
@Query("SELECT * FROM profiles WHERE id = :contactId")
fun observeProfile(contactId: String): Flow<ContactProfileEntity?>
```

### 9.3 异步操作优化

```kotlin
/**
 * 异步操作优化策略
 */
// 1. 使用IO调度器执行IO操作
suspend fun saveUserInput(...) = withContext(Dispatchers.IO) {
    // IO操作
}

// 2. 并发执行独立任务
suspend fun loadContactDetail() {
    coroutineScope {
        val contactDeferred = async { contactRepository.getProfile(contactId) }
        val tagsDeferred = async { brainTagRepository.getTagsByContact(contactId) }
        
        val contact = contactDeferred.await()
        val tags = tagsDeferred.await()
    }
}

// 3. 使用Flow避免阻塞
contactRepository.observeProfile(contactId)
    .collect { contact ->
        _uiState.update { it.copy(contact = contact) }
    }
```

## 10. 测试策略

### 10.1 单元测试架构

```
test/
└── com/empathy/ai/
    ├── data/
    │   ├── repository/
    │   │   ├── ConversationRepositoryImplTest.kt
    │   │   └── DailySummaryRepositoryImplTest.kt
    │   └── local/
    │       └── converter/
    │           └── FactListConverterTest.kt
    ├── domain/
    │   ├── usecase/
    │   │   ├── AnalyzeChatUseCaseTest.kt
    │   │   └── SummarizeDailyConversationsUseCaseTest.kt
    │   └── util/
    │       └── ContextBuilderTest.kt
    └── presentation/
        └── viewmodel/
            ├── ChatViewModelTest.kt
            └── ContactDetailViewModelTest.kt
```

### 10.2 测试覆盖率要求

| 层级 | 覆盖率要求 | 重点测试内容 |
|------|-----------|-------------|
| Repository | > 90% | 数据读写、错误处理、事务 |
| UseCase | > 85% | 业务逻辑、数据转换、错误处理 |
| ViewModel | > 80% | 状态管理、事件处理 |
| Util | > 95% | 算法逻辑、数据筛选 |
| DAO | > 85% | SQL查询、数据映射 |

### 10.3 Mock策略

```kotlin
/**
 * 测试用的Mock Repository
 */
class MockConversationRepository : ConversationRepository {
    private val logs = mutableListOf<ConversationLog>()
    private var nextId = 1L
    
    override suspend fun saveUserInput(
        contactId: String,
        userInput: String,
        timestamp: Long
    ): Result<Long> {
        val log = ConversationLog(
            id = nextId++,
            contactId = contactId,
            userInput = userInput,
            aiResponse = null,
            timestamp = timestamp
        )
        logs.add(log)
        return Result.success(log.id)
    }
    
    override suspend fun updateAiResponse(
        logId: Long,
        aiResponse: String
    ): Result<Unit> {
        val index = logs.indexOfFirst { it.id == logId }
        if (index >= 0) {
            logs[index] = logs[index].copy(aiResponse = aiResponse)
            return Result.success(Unit)
        }
        return Result.failure(Exception("Log not found"))
    }
    
    // 其他方法...
}
```

## 11. 部署配置

### 11.1 ProGuard规则

```proguard
# 保留记忆系统相关的类
-keep class com.empathy.ai.domain.model.Fact { *; }
-keep class com.empathy.ai.domain.model.ConversationLog { *; }
-keep class com.empathy.ai.domain.model.DailySummary { *; }
-keep class com.empathy.ai.data.local.entity.** { *; }

# 保留Moshi相关
-keep class com.squareup.moshi.** { *; }
-keep @com.squareup.moshi.JsonQualifier interface *

# 保留Room相关
-keep class * extends androidx.room.RoomDatabase
-keep @androidx.room.Entity class *
-dontwarn androidx.room.paging.**
```

### 11.2 混淆配置

```gradle
buildTypes {
    release {
        minifyEnabled true
        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        
        // 保留记忆系统相关的类名
        keepAttributes 'Signature', 'InnerClasses', 'EnclosingMethod'
    }
}
```

## 12. 监控和日志

### 12.1 日志策略

```kotlin
/**
 * 记忆系统日志管理器
 */
object MemoryLogger {
    private const val TAG = "Memory"
    
    fun logConversationSaved(contactId: String, logId: Long) {
        Log.i(TAG, "对话记录已保存: contactId=$contactId, logId=$logId")
    }
    
    fun logSummaryGenerated(contactId: String, date: String) {
        Log.i(TAG, "每日总结已生成: contactId=$contactId, date=$date")
    }
    
    fun logError(operation: String, error: Throwable) {
        Log.e(TAG, "操作失败: $operation", error)
    }
    
    fun logPerformance(operation: String, duration: Long) {
        if (duration > 1000) {
            Log.w(TAG, "性能警告: $operation 耗时 ${duration}ms")
        }
    }
}
```

### 12.2 性能监控

```kotlin
/**
 * 记忆系统性能监控器
 */
object MemoryPerformanceMonitor {
    fun <T> measureTime(operation: String, block: () -> T): T {
        val startTime = System.currentTimeMillis()
        val result = block()
        val duration = System.currentTimeMillis() - startTime
        
        MemoryLogger.logPerformance(operation, duration)
        return result
    }
}
```

## 13. 附录

### 13.1 相关文档

- [PRD-00003-联系人画像记忆系统需求](../PRD/PRD-00003-联系人画像记忆系统需求.md)
- [FD-00003-联系人画像记忆系统设计](../FD/FD-00003-联系人画像记忆系统设计.md)

### 13.2 变更记录

| 版本 | 日期 | 变更内容 | 变更人 |
|------|------|----------|--------|
| v1.0 | 2025-12-14 | 初始版本 | Claude |
