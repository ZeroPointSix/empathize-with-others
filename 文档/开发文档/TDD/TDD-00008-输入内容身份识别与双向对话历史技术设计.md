# TDD-00008 输入内容身份识别与双向对话历史技术设计

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档编号 | TDD-00008 |
| 创建日期 | 2025-12-17 |
| 更新日期 | 2025-12-17 |
| 状态 | 草稿 |
| 关联PRD | PRD-00008 |
| 关联FD | FD-00008 |

---

## 1. 技术概述

### 1.1 设计目标

实现输入内容的自动身份识别系统，包括：
- 身份前缀工具类（添加、解析、清理）
- UseCase 层集成
- 系统提示词增强
- UI 渲染优化

### 1.2 技术栈

- Kotlin 2.0.21
- Clean Architecture + MVVM
- Jetpack Compose
- Hilt 依赖注入

---

## 2. 架构设计

### 2.1 模块依赖关系

```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer                        │
│  ┌─────────────────┐  ┌─────────────────┐                   │
│  │ ConversationCard │  │EditConversation │                   │
│  │    (UI渲染)      │  │   Dialog        │                   │
│  └────────┬────────┘  └────────┬────────┘                   │
└───────────┼─────────────────────┼───────────────────────────┘
            │                     │
            ▼                     ▼
┌─────────────────────────────────────────────────────────────┐
│                      Domain Layer                            │
│  ┌─────────────────┐  ┌─────────────────┐                   │
│  │AnalyzeChatUseCase│  │CheckDraftUseCase│                   │
│  └────────┬────────┘  └────────┬────────┘                   │
│           │                    │                             │
│           ▼                    ▼                             │
│  ┌─────────────────────────────────────────┐                │
│  │         IdentityPrefixHelper            │ ◄── 新增       │
│  │  - addIdentityPrefix()                  │                │
│  │  - parseIdentityPrefix()                │                │
│  │  - stripAllPrefixes()                   │                │
│  └─────────────────────────────────────────┘                │
│           │                                                  │
│           ▼                                                  │
│  ┌─────────────────────────────────────────┐                │
│  │    ConversationContextBuilder           │ ◄── 修改       │
│  └─────────────────────────────────────────┘                │
└─────────────────────────────────────────────────────────────┘
```


### 2.2 文件变更清单

| 文件路径 | 变更类型 | 说明 |
|---------|---------|------|
| `domain/util/IdentityPrefixHelper.kt` | 新增 | 身份前缀工具类 |
| `domain/usecase/AnalyzeChatUseCase.kt` | 修改 | 集成身份前缀 |
| `domain/usecase/CheckDraftUseCase.kt` | 修改 | 集成身份前缀 |
| `domain/util/SystemPrompts.kt` | 修改 | 增强提示词 |
| `domain/util/ConversationContextBuilder.kt` | 修改 | 支持身份前缀解析 |
| `presentation/ui/component/card/ConversationBubble.kt` | 新增 | 对话气泡组件 |
| `presentation/ui/component/dialog/EditConversationDialog.kt` | 修改 | 支持身份保留 |

---

## 3. 详细设计

### 3.1 IdentityPrefixHelper（新增）

**文件路径**: `app/src/main/java/com/empathy/ai/domain/util/IdentityPrefixHelper.kt`

```kotlin
package com.empathy.ai.domain.util

import com.empathy.ai.domain.model.ActionType

/**
 * 身份前缀工具类
 *
 * 负责处理对话内容的身份标识，包括添加、解析和清理前缀
 */
object IdentityPrefixHelper {

    /** 对方说的内容前缀 */
    const val PREFIX_CONTACT = "【对方说】："

    /** 我正在回复的内容前缀 */
    const val PREFIX_USER = "【我正在回复】："

    /**
     * 身份类型枚举
     */
    enum class IdentityRole(val displayName: String) {
        CONTACT("对方"),
        USER("我"),
        LEGACY("历史")  // 旧数据兼容
    }

    /**
     * 解析结果数据类
     */
    data class ParseResult(
        val role: IdentityRole,
        val content: String
    )

    /**
     * 安全地添加身份前缀
     *
     * 防御性编程：如果用户输入已经包含前缀，先清理再添加
     *
     * @param content 用户输入内容
     * @param actionType 操作类型
     * @return 带前缀的内容
     */
    fun addPrefix(content: String, actionType: ActionType): String {
        if (content.isBlank()) return content

        // 先清理可能存在的前缀（防止双重前缀）
        val cleanContent = stripAllPrefixes(content)

        // 根据操作类型添加对应前缀
        val prefix = when (actionType) {
            ActionType.ANALYZE -> PREFIX_CONTACT
            ActionType.CHECK -> PREFIX_USER
        }

        return "$prefix$cleanContent"
    }

    /**
     * 解析身份前缀
     *
     * @param content 原始内容（可能带前缀）
     * @return 解析结果（身份 + 纯内容）
     */
    fun parse(content: String): ParseResult {
        val cleanContent = stripAllPrefixes(content)

        val role = when {
            content.startsWith(PREFIX_CONTACT) -> IdentityRole.CONTACT
            content.startsWith(PREFIX_USER) -> IdentityRole.USER
            else -> IdentityRole.LEGACY
        }

        return ParseResult(role, cleanContent)
    }

    /**
     * 去除所有身份前缀（递归处理，防止多重前缀）
     *
     * @param content 原始内容
     * @return 纯文本内容
     */
    fun stripAllPrefixes(content: String): String {
        var result = content

        // 循环去除，直到没有前缀为止
        while (true) {
            val stripped = when {
                result.startsWith(PREFIX_CONTACT) ->
                    result.removePrefix(PREFIX_CONTACT)
                result.startsWith(PREFIX_USER) ->
                    result.removePrefix(PREFIX_USER)
                else -> result
            }

            if (stripped == result) break
            result = stripped
        }

        return result
    }

    /**
     * 根据身份类型获取前缀
     *
     * @param role 身份类型
     * @return 对应的前缀，LEGACY 返回空字符串
     */
    fun getPrefixByRole(role: IdentityRole): String {
        return when (role) {
            IdentityRole.CONTACT -> PREFIX_CONTACT
            IdentityRole.USER -> PREFIX_USER
            IdentityRole.LEGACY -> ""
        }
    }

    /**
     * 重新拼接前缀
     *
     * 用于编辑对话后保存
     *
     * @param role 原始身份
     * @param newContent 新内容
     * @return 带前缀的内容
     */
    fun rebuildWithPrefix(role: IdentityRole, newContent: String): String {
        val prefix = getPrefixByRole(role)
        return "$prefix$newContent"
    }
}
```


### 3.2 AnalyzeChatUseCase 修改

**文件路径**: `app/src/main/java/com/empathy/ai/domain/usecase/AnalyzeChatUseCase.kt`

**修改点**：

```kotlin
class AnalyzeChatUseCase @Inject constructor(
    // ... 现有依赖 ...
) {
    companion object {
        private const val TAG = "AnalyzeChatUseCase"
    }

    suspend operator fun invoke(
        contactId: String,
        rawScreenContext: List<String>
    ): Result<AnalysisResult> {
        // ... 现有逻辑 ...

        // 【修改点1】保存时添加身份前缀
        val userInputText = cleanedContext.joinToString("\n")
        val prefixedInput = IdentityPrefixHelper.addPrefix(
            content = userInputText,
            actionType = ActionType.ANALYZE
        )
        conversationLogId = saveUserInput(contactId, prefixedInput)

        // 【修改点2】发送给 AI 时也添加前缀
        val prefixedContext = maskedContext.map { message ->
            IdentityPrefixHelper.addPrefix(message, ActionType.ANALYZE)
        }

        // ... 后续逻辑使用 prefixedContext ...
    }
}
```

### 3.3 CheckDraftUseCase 修改

**文件路径**: `app/src/main/java/com/empathy/ai/domain/usecase/CheckDraftUseCase.kt`

**修改点**：

```kotlin
class CheckDraftUseCase @Inject constructor(
    // ... 现有依赖 ...
) {
    suspend operator fun invoke(
        contactId: String,
        draftSnapshot: String,
        enableDeepCheck: Boolean = false
    ): Result<SafetyCheckResult> {
        // ... 现有逻辑 ...

        // 【修改点】发送给 AI 时添加身份前缀
        val prefixedDraft = IdentityPrefixHelper.addPrefix(
            content = maskedDraft,
            actionType = ActionType.CHECK
        )

        // 【注意】检查功能不保存历史记录

        // 调用 AI 时使用 prefixedDraft
        val deepCheckResult = aiRepository.checkDraftSafety(
            provider = defaultProvider,
            draft = prefixedDraft,  // 使用带前缀的内容
            riskRules = riskRules,
            systemInstruction = systemInstruction
        ).getOrThrow()

        // ... 后续逻辑 ...
    }
}
```

### 3.4 SystemPrompts 修改

**文件路径**: `app/src/main/java/com/empathy/ai/domain/util/SystemPrompts.kt`

**修改点**：

```kotlin
object SystemPrompts {

    // ========== 聊天分析场景 ==========

    private const val ANALYZE_HEADER = """你是一个专业的社交沟通分析助手（AI军师）。

【重要】关于输入内容的身份识别：
- 如果内容以【对方说】开头，表示这是对方发给用户的消息
- 如果内容以【我正在回复】开头，表示这是用户打算发送的内容
- 你需要始终站在用户的角度，帮助用户分析对方的意图并给出回复建议

你的职责是：
1. 分析聊天上下文和联系人画像
2. 识别对方的情绪状态和沟通意图
3. 发现潜在的沟通风险点
4. 提供具体可行的回复建议

重要原则：
- 保持客观中立，不做道德评判
- 建议应该具体可执行，而非泛泛而谈
- 尊重用户的沟通目标和关系定位
- 永远不要模仿对方说话，而是分析对方的话
- 回复时请直接输出分析结果或建议内容，不要重复输入内容，也不要自行添加任何【】格式的角色前缀"""

    // ========== 安全检查场景 ==========

    private const val CHECK_HEADER = """你是一个社交沟通安全检查助手。

【重要】关于输入内容的身份识别：
- 输入内容以【我正在回复】开头，表示这是用户打算发送的草稿
- 你需要帮助用户检查这段草稿是否存在风险

你的职责是：
1. 检查用户草稿是否触及敏感话题
2. 识别可能引起误解的表达
3. 评估语气是否合适
4. 提供修改建议

重要原则：
- 基于已知的雷区信息进行检查
- 宁可多提醒，不可漏检
- 给出具体的修改建议
- 回复时请直接输出检查结果，不要重复输入内容，也不要自行添加任何【】格式的角色前缀"""

    // ... 其他场景保持不变 ...
}
```
