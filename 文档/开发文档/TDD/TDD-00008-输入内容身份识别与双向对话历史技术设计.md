# TDD-00008 输入内容身份识别与双向对话历史技术设计

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档编号 | TDD-00008 |
| 创建日期 | 2025-12-17 |
| 更新日期 | 2025-12-17 |
| 状态 | 草稿 |
| 关联PRD | PRD-00008 |
| 关联FD | FD-00008 |

---

## 1. 技术概述

### 1.1 设计目标

实现输入内容的自动身份识别系统，包括：
- 身份前缀工具类（添加、解析、清理）
- UseCase 层集成
- 系统提示词增强
- UI 渲染优化

### 1.2 技术栈

- Kotlin 2.0.21
- Clean Architecture + MVVM
- Jetpack Compose
- Hilt 依赖注入

---

## 2. 架构设计

### 2.1 模块依赖关系

```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer                        │
│  ┌─────────────────┐  ┌─────────────────┐                   │
│  │ ConversationCard │  │EditConversation │                   │
│  │    (UI渲染)      │  │   Dialog        │                   │
│  └────────┬────────┘  └────────┬────────┘                   │
└───────────┼─────────────────────┼───────────────────────────┘
            │                     │
            ▼                     ▼
┌─────────────────────────────────────────────────────────────┐
│                      Domain Layer                            │
│  ┌─────────────────┐  ┌─────────────────┐                   │
│  │AnalyzeChatUseCase│  │CheckDraftUseCase│                   │
│  └────────┬────────┘  └────────┬────────┘                   │
│           │                    │                             │
│           ▼                    ▼                             │
│  ┌─────────────────────────────────────────┐                │
│  │         IdentityPrefixHelper            │ ◄── 新增       │
│  │  - addIdentityPrefix()                  │                │
│  │  - parseIdentityPrefix()                │                │
│  │  - stripAllPrefixes()                   │                │
│  └─────────────────────────────────────────┘                │
│           │                                                  │
│           ▼                                                  │
│  ┌─────────────────────────────────────────┐                │
│  │    ConversationContextBuilder           │ ◄── 修改       │
│  └─────────────────────────────────────────┘                │
└─────────────────────────────────────────────────────────────┘
```


### 2.2 文件变更清单

| 文件路径 | 变更类型 | 说明 |
|---------|---------|------|
| `domain/util/IdentityPrefixHelper.kt` | 新增 | 身份前缀工具类 |
| `domain/usecase/AnalyzeChatUseCase.kt` | 修改 | 集成身份前缀 |
| `domain/usecase/CheckDraftUseCase.kt` | 修改 | 集成身份前缀 |
| `domain/util/SystemPrompts.kt` | 修改 | 增强提示词 |
| `domain/util/ConversationContextBuilder.kt` | 修改 | 支持身份前缀解析 |
| `presentation/ui/component/card/ConversationBubble.kt` | 新增 | 对话气泡组件 |
| `presentation/ui/component/dialog/EditConversationDialog.kt` | 修改 | 支持身份保留 |

---

## 3. 详细设计

### 3.1 IdentityPrefixHelper（新增）

**文件路径**: `app/src/main/java/com/empathy/ai/domain/util/IdentityPrefixHelper.kt`

```kotlin
package com.empathy.ai.domain.util

import com.empathy.ai.domain.model.ActionType

/**
 * 身份前缀工具类
 *
 * 负责处理对话内容的身份标识，包括添加、解析和清理前缀
 */
object IdentityPrefixHelper {

    /** 对方说的内容前缀 */
    const val PREFIX_CONTACT = "【对方说】："

    /** 我正在回复的内容前缀 */
    const val PREFIX_USER = "【我正在回复】："

    /**
     * 身份类型枚举
     */
    enum class IdentityRole(val displayName: String) {
        CONTACT("对方"),
        USER("我"),
        LEGACY("历史")  // 旧数据兼容
    }

    /**
     * 解析结果数据类
     */
    data class ParseResult(
        val role: IdentityRole,
        val content: String
    )

    /**
     * 安全地添加身份前缀
     *
     * 防御性编程：如果用户输入已经包含前缀，先清理再添加
     *
     * @param content 用户输入内容
     * @param actionType 操作类型
     * @return 带前缀的内容
     */
    fun addPrefix(content: String, actionType: ActionType): String {
        if (content.isBlank()) return content

        // 先清理可能存在的前缀（防止双重前缀）
        val cleanContent = stripAllPrefixes(content)

        // 根据操作类型添加对应前缀
        val prefix = when (actionType) {
            ActionType.ANALYZE -> PREFIX_CONTACT
            ActionType.CHECK -> PREFIX_USER
        }

        return "$prefix$cleanContent"
    }

    /**
     * 解析身份前缀
     *
     * @param content 原始内容（可能带前缀）
     * @return 解析结果（身份 + 纯内容）
     */
    fun parse(content: String): ParseResult {
        val cleanContent = stripAllPrefixes(content)

        val role = when {
            content.startsWith(PREFIX_CONTACT) -> IdentityRole.CONTACT
            content.startsWith(PREFIX_USER) -> IdentityRole.USER
            else -> IdentityRole.LEGACY
        }

        return ParseResult(role, cleanContent)
    }

    /**
     * 去除所有身份前缀（递归处理，防止多重前缀）
     *
     * @param content 原始内容
     * @return 纯文本内容
     */
    fun stripAllPrefixes(content: String): String {
        var result = content

        // 循环去除，直到没有前缀为止
        while (true) {
            val stripped = when {
                result.startsWith(PREFIX_CONTACT) ->
                    result.removePrefix(PREFIX_CONTACT)
                result.startsWith(PREFIX_USER) ->
                    result.removePrefix(PREFIX_USER)
                else -> result
            }

            if (stripped == result) break
            result = stripped
        }

        return result
    }

    /**
     * 根据身份类型获取前缀
     *
     * @param role 身份类型
     * @return 对应的前缀，LEGACY 返回空字符串
     */
    fun getPrefixByRole(role: IdentityRole): String {
        return when (role) {
            IdentityRole.CONTACT -> PREFIX_CONTACT
            IdentityRole.USER -> PREFIX_USER
            IdentityRole.LEGACY -> ""
        }
    }

    /**
     * 重新拼接前缀
     *
     * 用于编辑对话后保存
     *
     * @param role 原始身份
     * @param newContent 新内容
     * @return 带前缀的内容
     */
    fun rebuildWithPrefix(role: IdentityRole, newContent: String): String {
        val prefix = getPrefixByRole(role)
        return "$prefix$newContent"
    }
}
```


### 3.2 AnalyzeChatUseCase 修改

**文件路径**: `app/src/main/java/com/empathy/ai/domain/usecase/AnalyzeChatUseCase.kt`

**修改点**：

```kotlin
class AnalyzeChatUseCase @Inject constructor(
    // ... 现有依赖 ...
) {
    companion object {
        private const val TAG = "AnalyzeChatUseCase"
    }

    suspend operator fun invoke(
        contactId: String,
        rawScreenContext: List<String>
    ): Result<AnalysisResult> {
        // ... 现有逻辑 ...

        // 【修改点1】保存时添加身份前缀
        val userInputText = cleanedContext.joinToString("\n")
        val prefixedInput = IdentityPrefixHelper.addPrefix(
            content = userInputText,
            actionType = ActionType.ANALYZE
        )
        conversationLogId = saveUserInput(contactId, prefixedInput)

        // 【修改点2】发送给 AI 时也添加前缀
        val prefixedContext = maskedContext.map { message ->
            IdentityPrefixHelper.addPrefix(message, ActionType.ANALYZE)
        }

        // ... 后续逻辑使用 prefixedContext ...
    }
}
```

### 3.3 CheckDraftUseCase 修改

**文件路径**: `app/src/main/java/com/empathy/ai/domain/usecase/CheckDraftUseCase.kt`

**修改点**：

```kotlin
class CheckDraftUseCase @Inject constructor(
    // ... 现有依赖 ...
) {
    suspend operator fun invoke(
        contactId: String,
        draftSnapshot: String,
        enableDeepCheck: Boolean = false
    ): Result<SafetyCheckResult> {
        // ... 现有逻辑 ...

        // 【修改点】发送给 AI 时添加身份前缀
        val prefixedDraft = IdentityPrefixHelper.addPrefix(
            content = maskedDraft,
            actionType = ActionType.CHECK
        )

        // 【注意】检查功能不保存历史记录

        // 调用 AI 时使用 prefixedDraft
        val deepCheckResult = aiRepository.checkDraftSafety(
            provider = defaultProvider,
            draft = prefixedDraft,  // 使用带前缀的内容
            riskRules = riskRules,
            systemInstruction = systemInstruction
        ).getOrThrow()

        // ... 后续逻辑 ...
    }
}
```

### 3.4 SystemPrompts 修改

**文件路径**: `app/src/main/java/com/empathy/ai/domain/util/SystemPrompts.kt`

**修改点**：

```kotlin
object SystemPrompts {

    // ========== 聊天分析场景 ==========

    private const val ANALYZE_HEADER = """你是一个专业的社交沟通分析助手（AI军师）。

【重要】关于输入内容的身份识别：
- 如果内容以【对方说】开头，表示这是对方发给用户的消息
- 如果内容以【我正在回复】开头，表示这是用户打算发送的内容
- 你需要始终站在用户的角度，帮助用户分析对方的意图并给出回复建议

你的职责是：
1. 分析聊天上下文和联系人画像
2. 识别对方的情绪状态和沟通意图
3. 发现潜在的沟通风险点
4. 提供具体可行的回复建议

重要原则：
- 保持客观中立，不做道德评判
- 建议应该具体可执行，而非泛泛而谈
- 尊重用户的沟通目标和关系定位
- 永远不要模仿对方说话，而是分析对方的话
- 回复时请直接输出分析结果或建议内容，不要重复输入内容，也不要自行添加任何【】格式的角色前缀"""

    // ========== 安全检查场景 ==========

    private const val CHECK_HEADER = """你是一个社交沟通安全检查助手。

【重要】关于输入内容的身份识别：
- 输入内容以【我正在回复】开头，表示这是用户打算发送的草稿
- 你需要帮助用户检查这段草稿是否存在风险

你的职责是：
1. 检查用户草稿是否触及敏感话题
2. 识别可能引起误解的表达
3. 评估语气是否合适
4. 提供修改建议

重要原则：
- 基于已知的雷区信息进行检查
- 宁可多提醒，不可漏检
- 给出具体的修改建议
- 回复时请直接输出检查结果，不要重复输入内容，也不要自行添加任何【】格式的角色前缀"""

    // ... 其他场景保持不变 ...
}
```


### 3.5 ConversationContextBuilder 修改

**文件路径**: `app/src/main/java/com/empathy/ai/domain/util/ConversationContextBuilder.kt`

**修改点**：

```kotlin
@Singleton
class ConversationContextBuilder @Inject constructor() {

    /**
     * 构建带时间流逝标记的对话历史
     *
     * 【修改】保留身份前缀，不再统一使用 [我] 前缀
     */
    fun buildHistoryContext(
        messages: List<TimestampedMessage>,
        config: ConversationContextConfig = ConversationContextConfig()
    ): String {
        if (messages.isEmpty()) return ""

        return buildString {
            appendLine("【历史对话】(最近${messages.size}条)")

            var previousTimestamp: Long? = null
            var previousDate: String? = null

            messages.forEach { message ->
                // 计算时间标记
                val marker = calculateTimeMarker(
                    previousTimestamp = previousTimestamp,
                    currentTimestamp = message.timestamp,
                    previousDate = previousDate,
                    config = config
                )

                // 插入时间标记（如果有）
                val markerStr = marker.toDisplayString()
                if (markerStr.isNotEmpty()) {
                    appendLine(markerStr)
                }

                // 【修改】直接使用原始内容（已包含身份前缀）
                val timeStr = message.getFormattedTime()
                appendLine("[历史记录 - $timeStr]: ${message.content}")

                previousTimestamp = message.timestamp
                previousDate = message.getFormattedDate()
            }
        }.trimEnd()
    }
}
```

### 3.6 ConversationBubble 组件（新增）

**文件路径**: `app/src/main/java/com/empathy/ai/presentation/ui/component/card/ConversationBubble.kt`

```kotlin
package com.empathy.ai.presentation.ui.component.card

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.empathy.ai.domain.model.ConversationLog
import com.empathy.ai.domain.util.IdentityPrefixHelper
import com.empathy.ai.domain.util.IdentityPrefix


### 3.6 ConversationBubble 组件（新增）

**文件路径**: `app/src/main/java/com/empathy/ai/presentation/ui/component/card/ConversationBubble.kt`

```kotlin
package com.empathy.ai.presentation.ui.component.card

@Composable
fun ConversationBubble(
    log: ConversationLog,
    modifier: Modifier = Modifier,
    onEdit: (() -> Unit)? = null
) {
    val parseResult = remember(log.userInput) {
        IdentityPrefixHelper.parse(log.userInput)
    }

    val alignment = when (parseResult.role) {
        IdentityPrefixHelper.IdentityRole.CONTACT -> Alignment.Start
        IdentityPrefixHelper.IdentityRole.USER -> Alignment.End
        IdentityPrefixHelper.IdentityRole.LEGACY -> Alignment.CenterHorizontally
    }

    val backgroundColor = when (parseResult.role) {
        IdentityPrefixHelper.IdentityRole.CONTACT ->
            MaterialTheme.colorScheme.surfaceVariant
        IdentityPrefixHelper.IdentityRole.USER ->
            MaterialTheme.colorScheme.primaryContainer
        IdentityPrefixHelper.IdentityRole.LEGACY ->
            MaterialTheme.colorScheme.surface
    }

    val bubbleShape = when (parseResult.role) {
        IdentityPrefixHelper.IdentityRole.CONTACT ->
            RoundedCornerShape(4.dp, 16.dp, 16.dp, 16.dp)
        IdentityPrefixHelper.IdentityRole.USER ->
            RoundedCornerShape(16.dp, 4.dp, 16.dp, 16.dp)
        IdentityPrefixHelper.IdentityRole.LEGACY ->
            RoundedCornerShape(16.dp)
    }

    Column(
        modifier = modifier.fillMaxWidth(),
        horizontalAlignment = alignment
    ) {
        // 标签和时间
        Row(
            verticalAlignment = Alignment.CenterVertically,
            modifier = Modifier.padding(bottom = 4.dp)
        ) {
            Text(
                text = parseResult.role.displayName,
                style = MaterialTheme.typography.labelSmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Text(
                text = " · ${formatTime(log.timestamp)}",
                style = MaterialTheme.typography.labelSmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }

        // 气泡
        Surface(
            shape = bubbleShape,
            color = backgroundColor,
            modifier = Modifier
                .widthIn(max = 280.dp)
                .clickable(enabled = onEdit != null) { onEdit?.invoke() }
        ) {
            Text(
                text = parseResult.content,
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.padding(12.dp)
            )
        }
    }
}
```


### 3.7 EditConversationDialog 修改

**文件路径**: `app/src/main/java/com/empathy/ai/presentation/ui/component/dialog/EditConversationDialog.kt`

**修改点**：支持身份保留

```kotlin
@Composable
fun EditConversationDialog(
    log: ConversationLog,
    onDismiss: () -> Unit,
    onSave: (String) -> Unit
) {
    // 解析身份前缀，记住原始身份
    val parseResult = remember(log.userInput) {
        IdentityPrefixHelper.parse(log.userInput)
    }

    var editedContent by remember { mutableStateOf(parseResult.content) }

    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text("编辑对话 (${parseResult.role.displayName})")
        },
        text = {
            OutlinedTextField(
                value = editedContent,
                onValueChange = { editedContent = it },
                modifier = Modifier.fillMaxWidth(),
                label = { Text("对话内容") }
            )
        },
        confirmButton = {
            TextButton(onClick = {
                // 保存时重新拼接前缀
                val finalContent = IdentityPrefixHelper.rebuildWithPrefix(
                    role = parseResult.role,
                    newContent = editedContent
                )
                onSave(finalContent)
            }) {
                Text("保存")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("取消")
            }
        }
    )
}
```

---

## 4. 单元测试设计

### 4.1 IdentityPrefixHelperTest

**文件路径**: `app/src/test/java/com/empathy/ai/domain/util/IdentityPrefixHelperTest.kt`

```kotlin
class IdentityPrefixHelperTest {

    // ========== addPrefix 测试 ==========

    @Test
    fun `addPrefix should add CONTACT prefix for ANALYZE action`() {
        val result = IdentityPrefixHelper.addPrefix("你好", ActionType.ANALYZE)
        assertEquals("【对方说】：你好", result)
    }

    @Test
    fun `addPrefix should add USER prefix for CHECK action`() {
        val result = IdentityPrefixHelper.addPrefix("你好", ActionType.CHECK)
        assertEquals("【我正在回复】：你好", result)
    }

    @Test
    fun `addPrefix should not duplicate prefix`() {
        val result = IdentityPrefixHelper.addPrefix("【对方说】：你好", ActionType.ANALYZE)
        assertEquals("【对方说】：你好", result)
    }

    @Test
    fun `addPrefix should replace different prefix`() {
        val result = IdentityPrefixHelper.addPrefix("【我正在回复】：你好", ActionType.ANALYZE)
        assertEquals("【对方说】：你好", result)
    }

    @Test
    fun `addPrefix should handle empty content`() {
        val result = IdentityPrefixHelper.addPrefix("", ActionType.ANALYZE)
        assertEquals("", result)
    }

    // ========== parse 测试 ==========

    @Test
    fun `parse should identify CONTACT role`() {
        val result = IdentityPrefixHelper.parse("【对方说】：你好")
        assertEquals(IdentityPrefixHelper.IdentityRole.CONTACT, result.role)
        assertEquals("你好", result.content)
    }

    @Test
    fun `parse should identify USER role`() {
        val result = IdentityPrefixHelper.parse("【我正在回复】：你好")
        assertEquals(IdentityPrefixHelper.IdentityRole.USER, result.role)
        assertEquals("你好", result.content)
    }

    @Test
    fun `parse should identify LEGACY role for no prefix`() {
        val result = IdentityPrefixHelper.parse("你好")
        assertEquals(IdentityPrefixHelper.IdentityRole.LEGACY, result.role)
        assertEquals("你好", result.content)
    }

    // ========== stripAllPrefixes 测试 ==========

    @Test
    fun `stripAllPrefixes should remove single prefix`() {
        val result = IdentityPrefixHelper.stripAllPrefixes("【对方说】：你好")
        assertEquals("你好", result)
    }

    @Test
    fun `stripAllPrefixes should remove double prefix`() {
        val result = IdentityPrefixHelper.stripAllPrefixes("【对方说】：【对方说】：你好")
        assertEquals("你好", result)
    }

    @Test
    fun `stripAllPrefixes should remove mixed prefixes`() {
        val result = IdentityPrefixHelper.stripAllPrefixes("【对方说】：【我正在回复】：你好")
        assertEquals("你好", result)
    }

    @Test
    fun `stripAllPrefixes should handle no prefix`() {
        val result = IdentityPrefixHelper.stripAllPrefixes("你好")
        assertEquals("你好", result)
    }

    // ========== rebuildWithPrefix 测试 ==========

    @Test
    fun `rebuildWithPrefix should add CONTACT prefix`() {
        val result = IdentityPrefixHelper.rebuildWithPrefix(
            IdentityPrefixHelper.IdentityRole.CONTACT,
            "再见"
        )
        assertEquals("【对方说】：再见", result)
    }

    @Test
    fun `rebuildWithPrefix should not add prefix for LEGACY`() {
        val result = IdentityPrefixHelper.rebuildWithPrefix(
            IdentityPrefixHelper.IdentityRole.LEGACY,
            "你好"
        )
        assertEquals("你好", result)
    }
}
```


---

## 5. 集成测试设计

### 5.1 AnalyzeChatUseCase 集成测试

**文件路径**: `app/src/test/java/com/empathy/ai/domain/usecase/AnalyzeChatUseCaseIdentityPrefixTest.kt`

```kotlin
class AnalyzeChatUseCaseIdentityPrefixTest {

    @Test
    fun `invoke should save input with CONTACT prefix`() = runTest {
        // Given
        val mockConversationRepository = mockk<ConversationRepository>()
        val savedInput = slot<String>()
        coEvery {
            mockConversationRepository.saveUserInput(any(), capture(savedInput), any())
        } returns Result.success(1L)

        // ... 其他 mock 设置 ...

        // When
        useCase.invoke("contact-1", listOf("你怎么才回消息？"))

        // Then
        assertTrue(savedInput.captured.startsWith("【对方说】："))
    }
}
```

---

## 6. 性能考量

### 6.1 性能指标

| 操作 | 目标耗时 | 实现方式 |
|-----|---------|---------|
| addPrefix | < 1ms | 字符串拼接 |
| parse | < 1ms | startsWith 检查 |
| stripAllPrefixes | < 5ms | 循环去除（最多3次） |
| UI 渲染 | < 16ms | remember 缓存解析结果 |

### 6.2 优化策略

1. **常量内联**：使用 `const val` 定义前缀常量
2. **缓存解析结果**：UI 层使用 `remember` 缓存 `ParseResult`
3. **避免重复解析**：在 ViewModel 层解析一次，传递给 UI

---

## 7. 数据兼容性

### 7.1 旧数据处理

| 数据类型 | 特征 | 处理方式 |
|---------|-----|---------|
| 旧数据 | 不以前缀开头 | `parse()` 返回 `LEGACY` 角色 |
| 新数据 | 以前缀开头 | `parse()` 返回对应角色 |

### 7.2 数据库迁移

**无需数据库迁移**，身份前缀直接存储在 `userInput` 字段中。

---

## 8. 错误处理

### 8.1 异常场景

| 场景 | 处理方式 |
|-----|---------|
| 输入为空 | `addPrefix` 直接返回空字符串 |
| 输入为 null | 调用方需保证非空 |
| 保存失败 | 记录日志，不影响主流程 |

### 8.2 日志记录

```kotlin
companion object {
    private const val TAG = "IdentityPrefixHelper"
}

// 异常情况记录日志
Log.w(TAG, "Unexpected prefix pattern: $content")
```

---

## 9. 相关文档

- [PRD-00008-输入内容身份识别与双向对话历史需求](../PRD/PRD-00008-输入内容身份识别与双向对话历史需求.md)
- [FD-00008-输入内容身份识别与双向对话历史功能设计](../FD/FD-00008-输入内容身份识别与双向对话历史功能设计.md)
- [AnalyzeChatUseCase.kt](../../../app/src/main/java/com/empathy/ai/domain/usecase/AnalyzeChatUseCase.kt)
- [CheckDraftUseCase.kt](../../../app/src/main/java/com/empathy/ai/domain/usecase/CheckDraftUseCase.kt)
- [SystemPrompts.kt](../../../app/src/main/java/com/empathy/ai/domain/util/SystemPrompts.kt)
