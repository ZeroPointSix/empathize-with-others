# TDD-00010: 悬浮球状态指示与拖动技术设计

## 1. 文档信息

| 项目 | 内容 |
|------|------|
| 文档类型 | TDD (Technical Design Document) |
| 文档编号 | TDD-00010 |
| 功能名称 | 悬浮球状态指示与拖动技术设计 |
| 版本 | 1.0 |
| 创建日期 | 2025-12-18 |
| 作者 | Kiro |
| 审核人 | 待定 |
| 关联文档 | PRD-00010, FD-00010, TDD-00009 |

---

## 2. 架构概述

### 2.1 技术栈

| 技术领域 | 技术选择 | 版本 | 用途 |
|---------|----------|------|------|
| UI框架 | Android View | - | 悬浮球视图 |
| 动画 | ObjectAnimator | - | 旋转/弹跳动画 |
| 通知 | NotificationCompat | - | 系统通知 |
| 持久化 | SharedPreferences | - | 位置和状态保存 |
| 依赖注入 | Hilt | 2.52 | 依赖管理 |

### 2.2 模块划分

```
domain/
├── model/
│   └── FloatingBubbleState.kt     # 悬浮球状态枚举（新增）
├── service/
│   └── FloatingWindowService.kt   # 悬浮窗服务（扩展）

data/
├── local/
│   └── FloatingWindowPreferences.kt  # 偏好设置（扩展）

presentation/
├── ui/
│   └── floating/
│       └── FloatingBubbleView.kt  # 悬浮球视图（新增）

notification/
└── AiResultNotificationManager.kt # 通知管理器（新增）
```

---

## 3. ⚠️ 开发注意事项（历史踩坑记录）

> **重要**：以下是过去开发悬浮窗功能时的踩坑记录，务必在开发时注意避免。

### 3.1 核心业务逻辑分流 (State Management)

**这是最容易出错的地方，导致了多次 Bug 修复。**

#### 3.1.1 区分"关闭"与"最小化"

必须根据当前是否有正在处理的 AI 请求来决定按钮行为：

| 场景 | 点击最小化按钮的行为 |
|------|---------------------|
| **无AI请求** | 等同于"取消/关闭"，直接销毁对话框，恢复悬浮球IDLE状态，**绝不能显示加载指示器** |
| **有AI请求** | 执行真正的最小化，显示旋转加载动画，保持后台请求处理 |

```kotlin
// ✅ 正确实现
fun onMinimizeClick() {
    if (hasActiveAiRequest()) {
        // 有请求：真正最小化，显示加载状态
        minimizeWithLoadingState()
    } else {
        // 无请求：直接关闭，显示IDLE状态
        closeAndShowIdleBubble()
    }
}

// ❌ 错误实现
fun onMinimizeClick() {
    minimizeWithLoadingState()  // 错误！无请求时也显示加载
}
```

#### 3.1.2 状态的原子性

状态切换（Mode.BUTTON vs Mode.INPUT）与视图可见性（View.VISIBLE vs View.GONE）的修改**必须是同步且原子的**。

```kotlin
// ✅ 正确：状态和视图同步修改
fun switchToButtonMode() {
    synchronized(stateLock) {
        currentMode = Mode.BUTTON
        inputDialog.visibility = View.GONE
        floatingBubble.visibility = View.VISIBLE
    }
}

// ❌ 错误：只改状态不改视图
fun switchToButtonMode() {
    currentMode = Mode.BUTTON
    // 忘记修改视图可见性，导致界面卡死
}
```

### 3.2 Kotlin 代码作用域陷阱 (Scoping Issues)

**这是一个非常隐蔽且严重的 Bug 源头。**

#### 3.2.1 `this` 指针混淆

在 `apply`、`run` 或 `with` 等作用域函数中，`this` 默认指向接收者对象（如 View）。

如果在 View 的回调中调用 Service 的同名方法，**必须显式使用 `this@ServiceClassName.method()`**。

```kotlin
// ❌ 错误：this指向View，导致递归调用
floatingBubble.apply {
    setOnClickListener {
        minimizeDialog()  // 错误！调用的是View的方法（如果有）
    }
}

// ✅ 正确：显式指定Service
floatingBubble.apply {
    setOnClickListener {
        this@FloatingWindowService.minimizeDialog()  // 正确！
    }
}
```

### 3.3 资源清理与监听器管理 (Resource Cleanup)

**不彻底的清理会导致内存泄漏或逻辑异常。**

#### 3.3.1 监听器解绑

在隐藏或销毁对话框时（`hideInputDialog`），**必须移除所有按钮的 OnClickListener 和输入框的 TextWatcher**。

```kotlin
// ✅ 正确：清理所有监听器
fun hideInputDialog() {
    btnSubmit.setOnClickListener(null)
    btnMinimize.setOnClickListener(null)
    btnCancel.setOnClickListener(null)  // 之前漏掉了这个！
    inputText.removeTextChangedListener(textWatcher)
    // ...
}
```

#### 3.3.2 TextWatcher 的特殊处理

移除 TextWatcher 不能简单传递 null，需要持有引用或通过反射清理。

```kotlin
// ✅ 正确：持有TextWatcher引用
private var textWatcher: TextWatcher? = null

fun setupTextWatcher() {
    textWatcher = object : TextWatcher { ... }
    inputText.addTextChangedListener(textWatcher)
}

fun cleanup() {
    textWatcher?.let { inputText.removeTextChangedListener(it) }
    textWatcher = null
}
```

### 3.4 数据持久化与恢复 (Persistence)

**确保用户体验的连续性。**

#### 3.4.1 重启恢复

应用重启或进程被杀后，需要从 SharedPreferences 恢复最小化状态，**并设定有效期（如10分钟）**，避免恢复过期的上下文。

```kotlin
// ✅ 正确：检查有效期
fun restoreMinimizedState(): Boolean {
    val savedTimestamp = prefs.getLong(KEY_MINIMIZE_TIMESTAMP, 0)
    val currentTime = System.currentTimeMillis()
    val validityPeriod = 10 * 60 * 1000L  // 10分钟
    
    if (currentTime - savedTimestamp > validityPeriod) {
        // 已过期，清除保存的状态
        clearMinimizedState()
        return false
    }
    
    // 未过期，恢复状态
    return restoreState()
}
```

#### 3.4.2 位置记忆

记录悬浮球拖拽后的 X/Y 坐标，确保恢复时在用户预期的位置。

```kotlin
// ✅ 正确：保存和恢复位置
fun saveBubblePosition(x: Int, y: Int) {
    prefs.edit()
        .putInt(KEY_BUBBLE_X, x)
        .putInt(KEY_BUBBLE_Y, y)
        .apply()
}

fun restoreBubblePosition(): Pair<Int, Int> {
    val defaultX = screenWidth - bubbleSize - margin
    val defaultY = screenHeight / 2
    return Pair(
        prefs.getInt(KEY_BUBBLE_X, defaultX),
        prefs.getInt(KEY_BUBBLE_Y, defaultY)
    )
}
```

---

## 4. 详细技术设计

### 4.1 数据模型设计

#### 4.1.1 FloatingBubbleState（悬浮球状态枚举）

**文件位置**：`domain/model/FloatingBubbleState.kt`

```kotlin
/**
 * 悬浮球状态枚举
 */
enum class FloatingBubbleState {
    /**
     * 空闲状态 - 显示静态App图标
     */
    IDLE,
    
    /**
     * 加载中 - 显示旋转动画
     * 注意：只有真正发起AI网络请求后才能进入此状态
     */
    LOADING,
    
    /**
     * 成功 - 显示绿色勾
     */
    SUCCESS,
    
    /**
     * 失败 - 显示红色叹号
     */
    ERROR
}
```


#### 4.1.2 FloatingBubblePosition（悬浮球位置模型）

**文件位置**：`domain/model/FloatingBubblePosition.kt`

```kotlin
/**
 * 悬浮球位置数据类
 */
data class FloatingBubblePosition(
    val x: Int,
    val y: Int
) {
    companion object {
        /**
         * 创建默认位置（屏幕右侧中间）
         */
        fun default(screenWidth: Int, screenHeight: Int, bubbleSize: Int): FloatingBubblePosition {
            val margin = 16.dp
            return FloatingBubblePosition(
                x = screenWidth - bubbleSize - margin,
                y = screenHeight / 2 - bubbleSize / 2
            )
        }
    }
}
```

### 4.2 FloatingWindowPreferences 扩展

**文件位置**：`data/local/FloatingWindowPreferences.kt`

```kotlin
@Singleton
class FloatingWindowPreferences @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val prefs = context.getSharedPreferences(
        "floating_window_prefs", 
        Context.MODE_PRIVATE
    )
    
    companion object {
        // 已有的Key
        private const val KEY_ENABLED = "floating_window_enabled"
        private const val KEY_LAST_CONTACT_ID = "last_contact_id"
        private const val KEY_LAST_TAB = "last_tab"
        
        // 新增的Key - 悬浮球位置
        private const val KEY_BUBBLE_X = "bubble_position_x"
        private const val KEY_BUBBLE_Y = "bubble_position_y"
        
        // 新增的Key - 最小化状态
        private const val KEY_MINIMIZE_TIMESTAMP = "minimize_timestamp"
        private const val KEY_MINIMIZE_REQUEST_INFO = "minimize_request_info"
        private const val KEY_BUBBLE_STATE = "bubble_state"
        
        // 最小化状态有效期：10分钟
        private const val MINIMIZE_VALIDITY_PERIOD = 10 * 60 * 1000L
    }
    
    // ==================== 悬浮球位置 ====================
    
    fun saveBubblePosition(x: Int, y: Int) {
        prefs.edit()
            .putInt(KEY_BUBBLE_X, x)
            .putInt(KEY_BUBBLE_Y, y)
            .apply()
    }
    
    fun getBubblePosition(defaultX: Int, defaultY: Int): Pair<Int, Int> {
        return Pair(
            prefs.getInt(KEY_BUBBLE_X, defaultX),
            prefs.getInt(KEY_BUBBLE_Y, defaultY)
        )
    }
    
    // ==================== 悬浮球状态 ====================
    
    fun saveBubbleState(state: FloatingBubbleState) {
        prefs.edit()
            .putString(KEY_BUBBLE_STATE, state.name)
            .apply()
    }
    
    fun getBubbleState(): FloatingBubbleState {
        val stateName = prefs.getString(KEY_BUBBLE_STATE, FloatingBubbleState.IDLE.name)
        return try {
            FloatingBubbleState.valueOf(stateName ?: FloatingBubbleState.IDLE.name)
        } catch (e: Exception) {
            FloatingBubbleState.IDLE
        }
    }
    
    // ==================== 最小化状态恢复 ====================
    
    fun saveMinimizeState(requestInfo: String) {
        prefs.edit()
            .putLong(KEY_MINIMIZE_TIMESTAMP, System.currentTimeMillis())
            .putString(KEY_MINIMIZE_REQUEST_INFO, requestInfo)
            .apply()
    }
    
    fun getMinimizeStateIfValid(): String? {
        val timestamp = prefs.getLong(KEY_MINIMIZE_TIMESTAMP, 0)
        val currentTime = System.currentTimeMillis()
        
        if (currentTime - timestamp > MINIMIZE_VALIDITY_PERIOD) {
            // 已过期，清除
            clearMinimizeState()
            return null
        }
        
        return prefs.getString(KEY_MINIMIZE_REQUEST_INFO, null)
    }
    
    fun clearMinimizeState() {
        prefs.edit()
            .remove(KEY_MINIMIZE_TIMESTAMP)
            .remove(KEY_MINIMIZE_REQUEST_INFO)
            .apply()
    }
}
```

### 4.3 FloatingBubbleView 设计

**文件位置**：`presentation/ui/floating/FloatingBubbleView.kt`

```kotlin
/**
 * 悬浮球视图
 * 
 * 支持：
 * - 拖动到屏幕任意位置
 * - 四种状态显示（IDLE/LOADING/SUCCESS/ERROR）
 * - 点击展开悬浮窗
 */
class FloatingBubbleView(
    context: Context,
    private val windowManager: WindowManager
) : FrameLayout(context) {
    
    // 状态
    private var currentState = FloatingBubbleState.IDLE
    
    // 拖动相关
    private var initialX = 0
    private var initialY = 0
    private var initialTouchX = 0f
    private var initialTouchY = 0f
    private var touchStartTime = 0L
    private var isDragging = false
    
    // 阈值
    private val clickThreshold = 10.dp  // 移动距离小于此值视为点击
    private val clickTimeThreshold = 200L  // 触摸时长小于此值视为点击
    
    // 动画
    private var rotationAnimator: ObjectAnimator? = null
    private var bounceAnimator: ObjectAnimator? = null
    
    // 回调
    private var onClickListener: (() -> Unit)? = null
    private var onPositionChangedListener: ((Int, Int) -> Unit)? = null
    
    // 视图组件
    private lateinit var iconView: ImageView
    private lateinit var progressView: CircularProgressIndicator
    
    init {
        initViews()
        setupTouchListener()
    }
    
    private fun initViews() {
        // 设置悬浮球大小
        val size = 56.dp
        layoutParams = LayoutParams(size, size)
        
        // 背景
        background = GradientDrawable().apply {
            shape = GradientDrawable.OVAL
            setColor(Color.WHITE)
        }
        elevation = 8f.dp
        
        // 图标
        iconView = ImageView(context).apply {
            layoutParams = LayoutParams(32.dp, 32.dp, Gravity.CENTER)
            setImageResource(R.drawable.ic_app_logo)
        }
        addView(iconView)
        
        // 进度指示器（默认隐藏）
        progressView = CircularProgressIndicator(context).apply {
            layoutParams = LayoutParams(32.dp, 32.dp, Gravity.CENTER)
            isIndeterminate = true
            visibility = View.GONE
        }
        addView(progressView)
    }
    
    private fun setupTouchListener() {
        setOnTouchListener { _, event ->
            val layoutParams = this.layoutParams as WindowManager.LayoutParams
            
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    initialX = layoutParams.x
                    initialY = layoutParams.y
                    initialTouchX = event.rawX
                    initialTouchY = event.rawY
                    touchStartTime = System.currentTimeMillis()
                    isDragging = false
                    true
                }
                
                MotionEvent.ACTION_MOVE -> {
                    val deltaX = event.rawX - initialTouchX
                    val deltaY = event.rawY - initialTouchY
                    val distance = sqrt(deltaX * deltaX + deltaY * deltaY)
                    
                    if (distance > clickThreshold) {
                        isDragging = true
                        layoutParams.x = initialX + deltaX.toInt()
                        layoutParams.y = initialY + deltaY.toInt()
                        
                        // 边界保护：至少50%在屏幕内
                        val screenWidth = context.resources.displayMetrics.widthPixels
                        val screenHeight = context.resources.displayMetrics.heightPixels
                        val halfSize = width / 2
                        
                        layoutParams.x = layoutParams.x.coerceIn(-halfSize, screenWidth - halfSize)
                        layoutParams.y = layoutParams.y.coerceIn(-halfSize, screenHeight - halfSize)
                        
                        windowManager.updateViewLayout(this, layoutParams)
                    }
                    true
                }
                
                MotionEvent.ACTION_UP -> {
                    val touchDuration = System.currentTimeMillis() - touchStartTime
                    
                    if (!isDragging && touchDuration < clickTimeThreshold) {
                        // 视为点击
                        onClickListener?.invoke()
                    } else if (isDragging) {
                        // 拖动结束，保存位置
                        onPositionChangedListener?.invoke(layoutParams.x, layoutParams.y)
                    }
                    true
                }
                
                else -> false
            }
        }
    }
    
    // ==================== 状态切换 ====================
    
    fun setState(state: FloatingBubbleState) {
        if (currentState == state) return
        currentState = state
        
        // 停止所有动画
        stopAllAnimations()
        
        when (state) {
            FloatingBubbleState.IDLE -> showIdleState()
            FloatingBubbleState.LOADING -> showLoadingState()
            FloatingBubbleState.SUCCESS -> showSuccessState()
            FloatingBubbleState.ERROR -> showErrorState()
        }
    }
    
    private fun showIdleState() {
        iconView.visibility = View.VISIBLE
        progressView.visibility = View.GONE
        iconView.setImageResource(R.drawable.ic_app_logo)
        setBackgroundColor(Color.WHITE)
    }
    
    private fun showLoadingState() {
        iconView.visibility = View.GONE
        progressView.visibility = View.VISIBLE
        setBackgroundColor(Color.WHITE)
    }
    
    private fun showSuccessState() {
        iconView.visibility = View.VISIBLE
        progressView.visibility = View.GONE
        iconView.setImageResource(R.drawable.ic_check)
        iconView.setColorFilter(Color.parseColor("#4CAF50"))
        setBackgroundColor(Color.parseColor("#E8F5E9"))
        
        // 弹跳动画
        bounceAnimator = ObjectAnimator.ofFloat(this, "scaleX", 1f, 1.2f, 1f).apply {
            duration = 300
            interpolator = OvershootInterpolator()
            start()
        }
        ObjectAnimator.ofFloat(this, "scaleY", 1f, 1.2f, 1f).apply {
            duration = 300
            interpolator = OvershootInterpolator()
            start()
        }
    }
    
    private fun showErrorState() {
        iconView.visibility = View.VISIBLE
        progressView.visibility = View.GONE
        iconView.setImageResource(R.drawable.ic_error)
        iconView.setColorFilter(Color.parseColor("#F44336"))
        setBackgroundColor(Color.parseColor("#FFEBEE"))
    }
    
    private fun stopAllAnimations() {
        rotationAnimator?.cancel()
        bounceAnimator?.cancel()
    }
    
    // ==================== 回调设置 ====================
    
    fun setOnBubbleClickListener(listener: () -> Unit) {
        onClickListener = listener
    }
    
    fun setOnPositionChangedListener(listener: (Int, Int) -> Unit) {
        onPositionChangedListener = listener
    }
    
    // ==================== 清理 ====================
    
    fun cleanup() {
        stopAllAnimations()
        onClickListener = null
        onPositionChangedListener = null
    }
}
```


### 4.4 通知管理器设计

**文件位置**：`notification/AiResultNotificationManager.kt`

```kotlin
/**
 * AI结果通知管理器
 */
@Singleton
class AiResultNotificationManager @Inject constructor(
    @ApplicationContext private val context: Context
) {
    companion object {
        private const val CHANNEL_ID = "empathy_ai_result"
        private const val CHANNEL_NAME = "AI处理结果"
        private const val NOTIFICATION_ID = 1001
    }
    
    init {
        createNotificationChannel()
    }
    
    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                CHANNEL_NAME,
                NotificationManager.IMPORTANCE_DEFAULT
            ).apply {
                description = "AI分析、润色、回复的处理结果通知"
            }
            
            val notificationManager = context.getSystemService(NotificationManager::class.java)
            notificationManager.createNotificationChannel(channel)
        }
    }
    
    /**
     * 发送成功通知
     */
    fun notifySuccess(taskType: ActionType) {
        val content = when (taskType) {
            ActionType.ANALYZE -> "分析完成，点击查看结果"
            ActionType.POLISH -> "润色完成，点击查看结果"
            ActionType.REPLY -> "回复已生成，点击查看"
            else -> "处理完成，点击查看结果"
        }
        
        showNotification("共情AI", content)
    }
    
    /**
     * 发送失败通知
     */
    fun notifyError(errorMessage: String? = null) {
        val content = errorMessage ?: "处理失败，点击重试"
        showNotification("共情AI", content)
    }
    
    private fun showNotification(title: String, content: String) {
        // 创建点击Intent
        val intent = Intent(context, FloatingWindowService::class.java).apply {
            action = FloatingWindowService.ACTION_EXPAND_FROM_NOTIFICATION
        }
        
        val pendingIntent = PendingIntent.getService(
            context,
            0,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        val notification = NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle(title)
            .setContentText(content)
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .build()
        
        val notificationManager = context.getSystemService(NotificationManager::class.java)
        notificationManager.notify(NOTIFICATION_ID, notification)
    }
    
    /**
     * 取消通知
     */
    fun cancelNotification() {
        val notificationManager = context.getSystemService(NotificationManager::class.java)
        notificationManager.cancel(NOTIFICATION_ID)
    }
}
```

### 4.5 FloatingWindowService 扩展

**文件位置**：`domain/service/FloatingWindowService.kt`

需要在现有的 FloatingWindowService 中添加以下逻辑：

```kotlin
// 新增常量
companion object {
    const val ACTION_EXPAND_FROM_NOTIFICATION = "expand_from_notification"
}

// 新增依赖注入
@Inject lateinit var notificationManager: AiResultNotificationManager
@Inject lateinit var floatingWindowPreferences: FloatingWindowPreferences

// 悬浮球视图
private var floatingBubbleView: FloatingBubbleView? = null

// 当前是否有活跃的AI请求
private var hasActiveAiRequest = false

// ==================== 悬浮球管理 ====================

/**
 * 显示悬浮球
 */
private fun showFloatingBubble(state: FloatingBubbleState = FloatingBubbleState.IDLE) {
    if (floatingBubbleView != null) {
        floatingBubbleView?.setState(state)
        return
    }
    
    floatingBubbleView = FloatingBubbleView(this, windowManager).apply {
        // 恢复保存的位置
        val (savedX, savedY) = floatingWindowPreferences.getBubblePosition(
            defaultX = getDefaultBubbleX(),
            defaultY = getDefaultBubbleY()
        )
        
        // 设置点击监听
        setOnBubbleClickListener {
            expandFromBubble()
        }
        
        // 设置位置变化监听
        setOnPositionChangedListener { x, y ->
            floatingWindowPreferences.saveBubblePosition(x, y)
        }
        
        setState(state)
    }
    
    val params = WindowManager.LayoutParams(
        56.dp,
        56.dp,
        getWindowType(),
        WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,
        PixelFormat.TRANSLUCENT
    ).apply {
        gravity = Gravity.TOP or Gravity.START
        val (savedX, savedY) = floatingWindowPreferences.getBubblePosition(
            defaultX = getDefaultBubbleX(),
            defaultY = getDefaultBubbleY()
        )
        x = savedX
        y = savedY
    }
    
    windowManager.addView(floatingBubbleView, params)
}

/**
 * 最小化到悬浮球
 * 
 * 注意：必须根据是否有活跃AI请求来决定状态
 */
fun minimizeToFloatingBubble() {
    // 隐藏悬浮窗
    hideFloatingWindow()
    
    // 根据是否有活跃请求决定状态
    val bubbleState = if (hasActiveAiRequest) {
        FloatingBubbleState.LOADING
    } else {
        FloatingBubbleState.IDLE
    }
    
    showFloatingBubble(bubbleState)
    
    // 保存最小化状态（如果有活跃请求）
    if (hasActiveAiRequest) {
        floatingWindowPreferences.saveMinimizeState(
            buildMinimizeRequestInfo()
        )
    }
}

/**
 * 从悬浮球展开
 */
private fun expandFromBubble() {
    // 隐藏悬浮球
    floatingBubbleView?.let {
        windowManager.removeView(it)
        it.cleanup()
    }
    floatingBubbleView = null
    
    // 显示悬浮窗
    showFloatingWindow()
    
    // 如果有结果，显示结果
    // 如果有错误，显示错误
    // 重置悬浮球状态
    floatingWindowPreferences.saveBubbleState(FloatingBubbleState.IDLE)
}

// ==================== AI请求状态管理 ====================

/**
 * 标记AI请求开始
 * 
 * 注意：只有在这里才能将悬浮球设置为LOADING状态
 */
fun onAiRequestStarted() {
    hasActiveAiRequest = true
    
    // 如果当前是最小化状态，更新悬浮球为加载状态
    floatingBubbleView?.setState(FloatingBubbleState.LOADING)
}

/**
 * 标记AI请求完成
 */
fun onAiRequestCompleted(result: AiResult) {
    hasActiveAiRequest = false
    
    // 更新悬浮球状态
    floatingBubbleView?.setState(FloatingBubbleState.SUCCESS)
    
    // 如果是最小化状态，发送通知
    if (floatingBubbleView != null) {
        notificationManager.notifySuccess(getCurrentActionType())
    }
    
    // 清除最小化状态
    floatingWindowPreferences.clearMinimizeState()
}

/**
 * 标记AI请求失败
 */
fun onAiRequestFailed(error: Throwable) {
    hasActiveAiRequest = false
    
    // 更新悬浮球状态
    floatingBubbleView?.setState(FloatingBubbleState.ERROR)
    
    // 如果是最小化状态，发送通知
    if (floatingBubbleView != null) {
        notificationManager.notifyError(error.message)
    }
    
    // 清除最小化状态
    floatingWindowPreferences.clearMinimizeState()
}
```

---

## 5. 状态流转时序图

```
┌─────────┐     ┌─────────────┐     ┌──────────────┐     ┌─────────────┐
│  用户   │     │FloatingWindow│     │FloatingBubble│     │AiRepository │
└────┬────┘     └──────┬──────┘     └──────┬───────┘     └──────┬──────┘
     │                 │                   │                    │
     │ 输入内容        │                   │                    │
     │────────────────>│                   │                    │
     │                 │                   │                    │
     │ 点击发送        │                   │                    │
     │────────────────>│                   │                    │
     │                 │                   │                    │
     │                 │ 本地校验          │                    │
     │                 │──────────┐        │                    │
     │                 │          │        │                    │
     │                 │<─────────┘        │                    │
     │                 │                   │                    │
     │ 点击最小化      │                   │                    │
     │────────────────>│                   │                    │
     │                 │                   │                    │
     │                 │ 显示悬浮球(IDLE)  │                    │
     │                 │──────────────────>│                    │
     │                 │                   │                    │
     │                 │ 调用AI API        │                    │
     │                 │───────────────────│───────────────────>│
     │                 │                   │                    │
     │                 │ onAiRequestStarted│                    │
     │                 │──────────────────>│                    │
     │                 │                   │                    │
     │                 │                   │ setState(LOADING)  │
     │                 │                   │──────────┐         │
     │                 │                   │          │         │
     │                 │                   │<─────────┘         │
     │                 │                   │                    │
     │                 │                   │    AI处理中...     │
     │                 │                   │                    │
     │                 │                   │         返回结果   │
     │                 │<──────────────────│───────────────────│
     │                 │                   │                    │
     │                 │ onAiRequestCompleted                   │
     │                 │──────────────────>│                    │
     │                 │                   │                    │
     │                 │                   │ setState(SUCCESS)  │
     │                 │                   │──────────┐         │
     │                 │                   │          │         │
     │                 │                   │<─────────┘         │
     │                 │                   │                    │
     │                 │ 发送系统通知      │                    │
     │                 │──────────────────>│                    │
     │                 │                   │                    │
     │ 点击悬浮球      │                   │                    │
     │────────────────>│                   │                    │
     │                 │                   │                    │
     │                 │ 展开悬浮窗        │                    │
     │                 │ 显示结果          │                    │
     │<────────────────│                   │                    │
     │                 │                   │                    │
```

---

## 6. 测试要点

### 6.1 单元测试

| 测试类 | 测试内容 |
|--------|----------|
| FloatingBubbleStateTest | 状态枚举值正确 |
| FloatingBubblePositionTest | 默认位置计算正确 |
| FloatingWindowPreferencesTest | 位置保存和恢复正确 |
| AiResultNotificationManagerTest | 通知内容正确 |

### 6.2 集成测试

| 测试场景 | 验证点 |
|----------|--------|
| 无请求时最小化 | 悬浮球显示IDLE状态 |
| 有请求时最小化 | 悬浮球显示LOADING状态 |
| AI成功返回 | 悬浮球变为SUCCESS + 发送通知 |
| AI失败返回 | 悬浮球变为ERROR + 发送通知 |
| 点击悬浮球 | 展开悬浮窗，状态重置为IDLE |
| 拖动悬浮球 | 位置更新，保存到Preferences |
| 应用重启 | 恢复保存的位置 |

### 6.3 边界测试

| 测试场景 | 验证点 |
|----------|--------|
| 拖动到屏幕边缘 | 至少50%在屏幕内 |
| 快速点击 | 正确识别为点击而非拖动 |
| 长按不移动 | 不触发点击事件 |
| 最小化状态过期 | 10分钟后不恢复LOADING状态 |

---

## 7. 相关文档

- [PRD-00010-悬浮球状态指示与拖动功能需求](../PRD/PRD-00010-悬浮球状态指示与拖动功能需求.md)
- [FD-00010-悬浮球状态指示与拖动功能设计](../FD/FD-00010-悬浮球状态指示与拖动功能设计.md)
- [TDD-00009-悬浮窗功能重构技术设计](TDD-00009-悬浮窗功能重构技术设计.md)
