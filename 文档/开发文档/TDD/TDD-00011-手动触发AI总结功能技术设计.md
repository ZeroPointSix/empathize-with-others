    # TDD-00011: æ‰‹åŠ¨è§¦å‘AIæ€»ç»“åŠŸèƒ½æŠ€æœ¯è®¾è®¡

---
**æ–‡æ¡£ç±»å‹**: TDD (Technical Design Document) - å¼€å‘è¿‡ç¨‹æ–‡æ¡£  
**å­˜æ”¾è§„èŒƒ**: ç¬¦åˆé¡¹ç›®å®ªæ³•ç¬¬IVæ¡ - æ–‡æ¡£è§„èŒƒ  
**ç‰ˆæœ¬æ§åˆ¶**: Gitç®¡ç†ï¼Œè§.commité’©å­  
---

## 1. æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| æ–‡æ¡£ç±»å‹ | TDD (Technical Design Document) |
| æ–‡æ¡£ç¼–å· | TDD-00011 |
| åŠŸèƒ½åç§° | æ‰‹åŠ¨è§¦å‘AIæ€»ç»“åŠŸèƒ½ |
| ç‰ˆæœ¬ | 1.1 |
| åˆ›å»ºæ—¥æœŸ | 2025-12-19 |
| æœ€åæ›´æ–° | 2025-12-19 |
| ä½œè€… | Kiro |
| å®¡æ ¸äºº | å¾…å®¡æ ¸ |
| å®¡æ ¸çŠ¶æ€ | ğŸ“ å¾…å®¡æ ¸ |
| å…³è”æ–‡æ¡£ | PRD-00011, FD-00011, Q&A-00011 |

### 1.1 ç‰ˆæœ¬å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | ä½œè€… | å˜æ›´è¯´æ˜ |
|------|------|------|----------|
| 1.0 | 2025-12-19 | Kiro | åˆå§‹ç‰ˆæœ¬ |
| 1.1 | 2025-12-19 | Kiro | æ ¹æ®DR-00011å®¡æŸ¥æŠ¥å‘Šä¼˜åŒ–ï¼šè¡¥å……æŠ€æœ¯æ–‡æ¡£äº¤å‰å¼•ç”¨ã€æ˜ç¡®é”™è¯¯å¤„ç†ç»†èŠ‚ã€ç®€åŒ–V1ç‰ˆæœ¬è®¾è®¡ |

### 1.2 å‚è€ƒæ ‡å‡†

| æ ‡å‡†æ–‡æ¡£ | ç‰ˆæœ¬ | è¯´æ˜ |
|---------|------|------|
| Clean Architecture | - | æ¶æ„æ¨¡å¼æ ‡å‡† |
| MVVM Pattern | - | UIæ¶æ„æ¨¡å¼ |
| Kotlin Coding Conventions | 2.0.21 | ä»£ç è§„èŒƒ |
| Material Design 3 | 1.3.1 | UIè®¾è®¡è§„èŒƒ |

### 1.3 æŠ€æœ¯å€ºåŠ¡è¯„ä¼°

| å€ºåŠ¡ID | æè¿° | å½±å“ | ä¼˜å…ˆçº§ | è®¡åˆ’è§£å†³æ—¶é—´ |
|--------|------|------|--------|-------------|
| TD-011-01 | DailySummaryEntityéœ€æ‰©å±•å­—æ®µæ”¯æŒèŒƒå›´æ€»ç»“ | ä¸­ | ğŸŸ¡ ä¸­ | æœ¬æ¬¡è¿­ä»£ |
| TD-011-02 | ç°æœ‰SummarizeDailyConversationsUseCaseéœ€é‡æ„å¤ç”¨ | ä½ | ğŸŸ¢ ä½ | åç»­ç‰ˆæœ¬ï¼ˆV1.1ï¼‰ |

> **TD-011-02è§£å†³è®¡åˆ’**ï¼šV1ç‰ˆæœ¬ä¼˜å…ˆå®ç°ç‹¬ç«‹çš„ManualSummaryUseCaseï¼ŒV1.1ç‰ˆæœ¬å†è€ƒè™‘ä¸SummarizeDailyConversationsUseCaseçš„ä»£ç å¤ç”¨é‡æ„ï¼Œé¿å…å½±å“ç°æœ‰è‡ªåŠ¨æ€»ç»“åŠŸèƒ½çš„ç¨³å®šæ€§ã€‚

### 1.4 ç›¸å…³æŠ€æœ¯æ–‡æ¡£

| æ–‡æ¡£ç¼–å· | æ–‡æ¡£åç§° | å…³è”è¯´æ˜ |
|---------|---------|---------|
| TDD-00003 | è”ç³»äººç”»åƒè®°å¿†ç³»ç»ŸæŠ€æœ¯è®¾è®¡ | å¤ç”¨DailySummaryæ¨¡å‹å’ŒConversationLogæ¨¡å‹ |
| TDD-00004 | è”ç³»äººç”»åƒè®°å¿†ç³»ç»ŸUIæ¶æ„è®¾è®¡ | å¤ç”¨æ—¶å…‰è½´ç»„ä»¶å±•ç¤ºæ‰‹åŠ¨æ€»ç»“ç»“æœ |
| TDD-00007 | å¯¹è¯ä¸Šä¸‹æ–‡è¿ç»­æ€§å¢å¼ºæŠ€æœ¯è®¾è®¡ | å¤ç”¨ConversationContextBuilderæ„å»ºAIä¸Šä¸‹æ–‡ |
| FD-00011 | æ‰‹åŠ¨è§¦å‘AIæ€»ç»“åŠŸèƒ½è®¾è®¡ | åŠŸèƒ½è®¾è®¡æ–‡æ¡£ï¼Œå®šä¹‰äº¤äº’æµç¨‹å’ŒUIè§„èŒƒ |
| PRD-00011 | æ‰‹åŠ¨è§¦å‘AIæ€»ç»“åŠŸèƒ½äº§å“éœ€æ±‚ | äº§å“éœ€æ±‚æ–‡æ¡£ï¼Œå®šä¹‰åŠŸèƒ½èŒƒå›´å’ŒéªŒæ”¶æ ‡å‡† |

---

## 2. æ¶æ„æ¦‚è¿°

### 2.1 æ¶æ„ç›®æ ‡

æ‰‹åŠ¨è§¦å‘AIæ€»ç»“åŠŸèƒ½é‡‡ç”¨ Clean Architecture åˆ†å±‚æ¶æ„ï¼Œå¤ç”¨ç°æœ‰çš„æ€»ç»“ç³»ç»Ÿç»„ä»¶ã€‚

**æ ¸å¿ƒç›®æ ‡**ï¼š
- å¤ç”¨ç°æœ‰AiSummaryProcessorå’ŒLocalSummaryProcessor
- æ‰©å±•DailySummaryæ¨¡å‹æ”¯æŒè‡ªå®šä¹‰æ—¥æœŸèŒƒå›´
- å®ç°å†²çªæ£€æµ‹å’Œå¤„ç†æœºåˆ¶
- æä¾›å®Œæ•´çš„è¿›åº¦åé¦ˆå’Œå–æ¶ˆæ”¯æŒ

### 2.2 æŠ€æœ¯æ ˆ

| æŠ€æœ¯é¢†åŸŸ | æŠ€æœ¯é€‰æ‹© | ç‰ˆæœ¬ | ç”¨é€” |
|---------|----------|------|------|
| UIæ¡†æ¶ | Jetpack Compose | BOM 2024.12.01 | å¯¹è¯æ¡†å’Œç»„ä»¶ |
| ç»„ä»¶åº“ | Material 3 | 1.3.1 | DatePickerã€Dialog |
| å¼‚æ­¥å¤„ç† | Kotlin Coroutines | 1.9.0 | å¼‚æ­¥æ€»ç»“å¤„ç† |
| ä¾èµ–æ³¨å…¥ | Hilt | 2.52 | ä¾èµ–ç®¡ç† |
| æ•°æ®åº“ | Room | 2.6.1 | æ•°æ®æŒä¹…åŒ– |
| JSONè§£æ | Moshi | 1.15.1 | AIå“åº”è§£æ |

### 2.3 è®¾è®¡åŸåˆ™

- **å¤ç”¨ä¼˜å…ˆ**ï¼šæœ€å¤§åŒ–å¤ç”¨ç°æœ‰AiSummaryProcessorç­‰ç»„ä»¶
- **å•ä¸€èŒè´£**ï¼šManualSummaryUseCaseåªè´Ÿè´£æ‰‹åŠ¨æ€»ç»“çš„ç¼–æ’é€»è¾‘
- **çŠ¶æ€ä¸å¯å˜**ï¼šä½¿ç”¨data classå’ŒStateFlowç®¡ç†çŠ¶æ€
- **å¯å–æ¶ˆæ€§**ï¼šæ‰€æœ‰é•¿æ—¶é—´æ“ä½œæ”¯æŒåç¨‹å–æ¶ˆ
- **å‘åå…¼å®¹**ï¼šæ‰©å±•ç°æœ‰æ¨¡å‹ï¼Œä¸ç ´åå·²æœ‰åŠŸèƒ½


---

## 3. æ•´ä½“æ¶æ„è®¾è®¡

### 3.1 åˆ†å±‚æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Presentation Layer                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚           ManualSummaryViewModel                      â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚ManualSummaryFabâ”‚ â”‚DateRangePickerDialog       â”‚   â”‚  â”‚
â”‚  â”‚  â”‚  (å…¥å£æŒ‰é’®)    â”‚ â”‚ (æ—¥æœŸé€‰æ‹©)                 â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚ConflictDialog  â”‚ â”‚SummaryProgressDialog       â”‚   â”‚  â”‚
â”‚  â”‚  â”‚ (å†²çªå¤„ç†)     â”‚ â”‚ (è¿›åº¦æ˜¾ç¤º)                 â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚SummaryResult   â”‚ â”‚MissingSummaryCard          â”‚   â”‚  â”‚
â”‚  â”‚  â”‚Dialog(ç»“æœ)    â”‚ â”‚ (ç¼ºå¤±æç¤º)                 â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Domain Layer                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ManualSummary     â”‚ â”‚SummaryConflictChecker            â”‚ â”‚
â”‚  â”‚  UseCase         â”‚ â”‚  (å†²çªæ£€æµ‹)                      â”‚ â”‚
â”‚  â”‚  (æ ¸å¿ƒç”¨ä¾‹)      â”‚ â”‚                                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚DateRangeValidatorâ”‚ â”‚SummaryTaskManager                â”‚ â”‚
â”‚  â”‚  (æ—¥æœŸéªŒè¯)      â”‚ â”‚  (ä»»åŠ¡ç®¡ç†)                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚AiSummaryProcessorâ”‚ â”‚LocalSummaryProcessor             â”‚ â”‚
â”‚  â”‚  (å·²æœ‰-å¤ç”¨)     â”‚ â”‚  (å·²æœ‰-å¤ç”¨)                     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Data Layer                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚DailySummary      â”‚ â”‚Conversation                      â”‚ â”‚
â”‚  â”‚  Repository      â”‚ â”‚  Repository                      â”‚ â”‚
â”‚  â”‚  (æ‰©å±•)          â”‚ â”‚  (å·²æœ‰)                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚AiRepository      â”‚ â”‚Contact                           â”‚ â”‚
â”‚  â”‚  (å·²æœ‰)          â”‚ â”‚  Repository                      â”‚ â”‚
â”‚  â”‚                  â”‚ â”‚  (å·²æœ‰)                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 æ•°æ®æµå›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ‰‹åŠ¨æ€»ç»“æ•°æ®æµ                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  ç”¨æˆ·ç‚¹å‡»FAB
         â”‚
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ æ˜¾ç¤ºæ—¥æœŸé€‰æ‹© â”‚ â† DateRangePickerDialog
  â”‚    å¯¹è¯æ¡†    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ ç”¨æˆ·é€‰æ‹©æ—¥æœŸèŒƒå›´
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚DateRange     â”‚ â† éªŒè¯æ—¥æœŸèŒƒå›´æœ‰æ•ˆæ€§
  â”‚  Validator   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚SummaryConflictâ”‚ â† æ£€æµ‹å·²æœ‰æ€»ç»“
  â”‚  Checker     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ æœ‰å†²çª?
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     æ˜¯      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ å†²çªåˆ¤æ–­     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ æ˜¾ç¤ºå†²çªå¯¹è¯æ¡†â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚ ç”¨æˆ·é€‰æ‹©å¤„ç† â”‚
         â”‚                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ å¦                        â”‚
         â–¼                           â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚ManualSummary â”‚
  â”‚  UseCase     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ æ‰§è¡Œæ€»ç»“æµç¨‹
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 1.è·å–å¯¹è¯   â”‚ â† ConversationRepository
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 2.AIåˆ†æ     â”‚ â† AiSummaryProcessor
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 3.ä¿å­˜ç»“æœ   â”‚ â† DailySummaryRepository
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 4.æ˜¾ç¤ºç»“æœ   â”‚ â† SummaryResultDialog
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.3 æ¨¡å—åˆ’åˆ†

```
domain/
â”œâ”€â”€ model/
â”‚   â”œâ”€â”€ SummaryTask.kt                 # æ€»ç»“ä»»åŠ¡æ¨¡å‹ï¼ˆæ–°å¢ï¼‰
â”‚   â”œâ”€â”€ SummaryTaskStatus.kt           # ä»»åŠ¡çŠ¶æ€æšä¸¾ï¼ˆæ–°å¢ï¼‰
â”‚   â”œâ”€â”€ SummaryType.kt                 # æ€»ç»“ç±»å‹æšä¸¾ï¼ˆæ–°å¢ï¼‰
â”‚   â”œâ”€â”€ GenerationSource.kt            # ç”Ÿæˆæ¥æºæšä¸¾ï¼ˆæ–°å¢ï¼‰
â”‚   â”œâ”€â”€ SummaryError.kt                # é”™è¯¯å¯†å°ç±»ï¼ˆæ–°å¢ï¼‰
â”‚   â”œâ”€â”€ ConflictResult.kt              # å†²çªç»“æœæ¨¡å‹ï¼ˆæ–°å¢ï¼‰
â”‚   â”œâ”€â”€ ConflictResolution.kt          # å†²çªå¤„ç†æšä¸¾ï¼ˆæ–°å¢ï¼‰
â”‚   â”œâ”€â”€ DateRange.kt                   # æ—¥æœŸèŒƒå›´æ¨¡å‹ï¼ˆæ–°å¢ï¼‰
â”‚   â””â”€â”€ DailySummary.kt                # æ¯æ—¥æ€»ç»“ï¼ˆæ‰©å±•ï¼‰
â”œâ”€â”€ usecase/
â”‚   â”œâ”€â”€ ManualSummaryUseCase.kt        # æ‰‹åŠ¨æ€»ç»“ç”¨ä¾‹ï¼ˆæ–°å¢ï¼‰
â”‚   â””â”€â”€ SummarizeDailyConversationsUseCase.kt  # å·²æœ‰
â”œâ”€â”€ util/
â”‚   â”œâ”€â”€ DateRangeValidator.kt          # æ—¥æœŸèŒƒå›´éªŒè¯ï¼ˆæ–°å¢ï¼‰
â”‚   â”œâ”€â”€ SummaryConflictChecker.kt      # å†²çªæ£€æµ‹ï¼ˆæ–°å¢ï¼‰
â”‚   â”œâ”€â”€ AiSummaryProcessor.kt          # å·²æœ‰
â”‚   â””â”€â”€ LocalSummaryProcessor.kt       # å·²æœ‰

> **V1ç®€åŒ–è¯´æ˜**ï¼šSummaryTaskManageråœ¨V1ç‰ˆæœ¬ä¸­ä¸å•ç‹¬å®ç°ï¼Œä»»åŠ¡çŠ¶æ€ç®¡ç†ç›´æ¥åœ¨ManualSummaryViewModelä¸­å¤„ç†ã€‚V1.1ç‰ˆæœ¬å†è€ƒè™‘æŠ½å–ç‹¬ç«‹çš„ä»»åŠ¡ç®¡ç†å™¨ä»¥æ”¯æŒä»»åŠ¡é˜Ÿåˆ—ã€å¹¶å‘æ§åˆ¶ç­‰é«˜çº§åŠŸèƒ½ã€‚

data/
â”œâ”€â”€ local/
â”‚   â”œâ”€â”€ entity/
â”‚   â”‚   â””â”€â”€ DailySummaryEntity.kt      # æ‰©å±•å­—æ®µ
â”‚   â””â”€â”€ dao/
â”‚       â””â”€â”€ DailySummaryDao.kt         # æ‰©å±•æŸ¥è¯¢æ–¹æ³•
â”œâ”€â”€ repository/
â”‚   â””â”€â”€ DailySummaryRepositoryImpl.kt  # æ‰©å±•æ–¹æ³•

presentation/
â”œâ”€â”€ ui/
â”‚   â””â”€â”€ screen/
â”‚       â””â”€â”€ contact/
â”‚           â””â”€â”€ summary/               # æ–°å¢ç›®å½•
â”‚               â”œâ”€â”€ ManualSummaryFab.kt
â”‚               â”œâ”€â”€ DateRangePickerDialog.kt
â”‚               â”œâ”€â”€ QuickDateOptions.kt
â”‚               â”œâ”€â”€ ConflictResolutionDialog.kt
â”‚               â”œâ”€â”€ SummaryProgressDialog.kt
â”‚               â”œâ”€â”€ SummaryResultDialog.kt
â”‚               â””â”€â”€ MissingSummaryCard.kt
â”œâ”€â”€ viewmodel/
â”‚   â””â”€â”€ ManualSummaryViewModel.kt      # æ–°å¢

di/
â””â”€â”€ SummaryModule.kt                   # æ–°å¢ä¾èµ–æ³¨å…¥æ¨¡å—
```


---

## 4. è¯¦ç»†æŠ€æœ¯è®¾è®¡

### 4.1 æ•°æ®æ¨¡å‹è®¾è®¡

#### 4.1.1 SummaryTaskStatusï¼ˆä»»åŠ¡çŠ¶æ€æšä¸¾ - æ–°å¢ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`domain/model/SummaryTaskStatus.kt`

```kotlin
/**
 * æ€»ç»“ä»»åŠ¡çŠ¶æ€æšä¸¾
 */
enum class SummaryTaskStatus(
    val displayName: String,
    val progressRange: ClosedFloatingPointRange<Float>
) {
    IDLE("ç©ºé—²", 0f..0f),
    FETCHING_DATA("è·å–æ•°æ®", 0f..0.2f),
    ANALYZING("AIåˆ†æä¸­", 0.2f..0.7f),
    GENERATING("ç”Ÿæˆæ€»ç»“", 0.7f..0.9f),
    SAVING("ä¿å­˜ç»“æœ", 0.9f..1f),
    SUCCESS("å®Œæˆ", 1f..1f),
    FAILED("å¤±è´¥", 0f..0f),
    CANCELLED("å·²å–æ¶ˆ", 0f..0f);
    
    /**
     * æ˜¯å¦ä¸ºç»ˆæ€
     */
    fun isTerminal(): Boolean = this in listOf(SUCCESS, FAILED, CANCELLED)
    
    /**
     * æ˜¯å¦å¯å–æ¶ˆ
     */
    fun isCancellable(): Boolean = this in listOf(FETCHING_DATA, ANALYZING, GENERATING)
}
```

#### 4.1.2 SummaryTypeï¼ˆæ€»ç»“ç±»å‹æšä¸¾ - æ–°å¢ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`domain/model/SummaryType.kt`

```kotlin
/**
 * æ€»ç»“ç±»å‹æšä¸¾
 */
enum class SummaryType(val displayName: String) {
    /**
     * å•æ—¥æ€»ç»“ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰
     */
    DAILY("å•æ—¥æ€»ç»“"),
    
    /**
     * è‡ªå®šä¹‰èŒƒå›´æ€»ç»“ï¼ˆæ‰‹åŠ¨è§¦å‘ï¼‰
     */
    CUSTOM_RANGE("èŒƒå›´æ€»ç»“")
}
```

#### 4.1.3 GenerationSourceï¼ˆç”Ÿæˆæ¥æºæšä¸¾ - æ–°å¢ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`domain/model/GenerationSource.kt`

```kotlin
/**
 * æ€»ç»“ç”Ÿæˆæ¥æºæšä¸¾
 */
enum class GenerationSource(
    val displayName: String,
    val icon: String
) {
    /**
     * è‡ªåŠ¨ç”Ÿæˆï¼ˆæ¯æ—¥å®šæ—¶ä»»åŠ¡ï¼‰
     */
    AUTO("è‡ªåŠ¨", "ğŸ¤–"),
    
    /**
     * æ‰‹åŠ¨è§¦å‘
     */
    MANUAL("æ‰‹åŠ¨", "ğŸ‘¤")
}
```

#### 4.1.4 SummaryTaskï¼ˆæ€»ç»“ä»»åŠ¡æ¨¡å‹ - æ–°å¢ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`domain/model/SummaryTask.kt`

```kotlin
import java.util.UUID

/**
 * æ€»ç»“ä»»åŠ¡æ¨¡å‹
 *
 * è¡¨ç¤ºä¸€ä¸ªæ‰‹åŠ¨è§¦å‘çš„æ€»ç»“ä»»åŠ¡
 */
data class SummaryTask(
    val id: String = UUID.randomUUID().toString(),
    val contactId: String,
    val startDate: String,
    val endDate: String,
    val status: SummaryTaskStatus = SummaryTaskStatus.IDLE,
    val progress: Float = 0f,
    val currentStep: String = "",
    val createdAt: Long = System.currentTimeMillis(),
    val startedAt: Long? = null,
    val completedAt: Long? = null,
    val error: SummaryError? = null,
    val conflictResolution: ConflictResolution? = null
) {
    init {
        require(contactId.isNotBlank()) { "contactIdä¸èƒ½ä¸ºç©º" }
        require(startDate.matches(Regex("\\d{4}-\\d{2}-\\d{2}"))) {
            "startDateæ ¼å¼å¿…é¡»ä¸ºyyyy-MM-dd"
        }
        require(endDate.matches(Regex("\\d{4}-\\d{2}-\\d{2}"))) {
            "endDateæ ¼å¼å¿…é¡»ä¸ºyyyy-MM-dd"
        }
        require(progress in 0f..1f) { "progresså¿…é¡»åœ¨0åˆ°1ä¹‹é—´" }
    }
    
    /**
     * è®¡ç®—æ—¥æœŸèŒƒå›´å¤©æ•°
     */
    fun getDayCount(): Int {
        val start = java.time.LocalDate.parse(startDate)
        val end = java.time.LocalDate.parse(endDate)
        return java.time.temporal.ChronoUnit.DAYS.between(start, end).toInt() + 1
    }
    
    /**
     * æ›´æ–°è¿›åº¦
     */
    fun withProgress(newProgress: Float, step: String): SummaryTask {
        return copy(
            progress = newProgress.coerceIn(0f, 1f),
            currentStep = step
        )
    }
    
    /**
     * æ ‡è®°ä¸ºå¼€å§‹
     */
    fun markStarted(): SummaryTask {
        return copy(
            status = SummaryTaskStatus.FETCHING_DATA,
            startedAt = System.currentTimeMillis()
        )
    }
    
    /**
     * æ ‡è®°ä¸ºæˆåŠŸ
     */
    fun markSuccess(): SummaryTask {
        return copy(
            status = SummaryTaskStatus.SUCCESS,
            progress = 1f,
            completedAt = System.currentTimeMillis()
        )
    }
    
    /**
     * æ ‡è®°ä¸ºå¤±è´¥
     */
    fun markFailed(error: SummaryError): SummaryTask {
        return copy(
            status = SummaryTaskStatus.FAILED,
            error = error,
            completedAt = System.currentTimeMillis()
        )
    }
    
    /**
     * æ ‡è®°ä¸ºå–æ¶ˆ
     */
    fun markCancelled(): SummaryTask {
        return copy(
            status = SummaryTaskStatus.CANCELLED,
            completedAt = System.currentTimeMillis()
        )
    }
}
```

#### 4.1.5 SummaryErrorï¼ˆé”™è¯¯å¯†å°ç±» - æ–°å¢ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`domain/model/SummaryError.kt`

```kotlin
/**
 * æ€»ç»“é”™è¯¯å¯†å°ç±»
 */
sealed class SummaryError(
    val code: String,
    val userMessage: String
) {
    /**
     * æ— å¯¹è¯æ•°æ®
     */
    object NoConversations : SummaryError(
        code = "E001",
        userMessage = "é€‰å®šæ—¶é—´æ®µå†…æ²¡æœ‰å¯¹è¯è®°å½•"
    )
    
    /**
     * ç½‘ç»œé”™è¯¯
     */
    object NetworkError : SummaryError(
        code = "E002",
        userMessage = "ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ"
    )
    
    /**
     * AIæœåŠ¡ä¸å¯ç”¨
     */
    object ApiError : SummaryError(
        code = "E003",
        userMessage = "AIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨"
    )
    
    /**
     * APIé…é¢ä¸è¶³
     */
    object QuotaExceeded : SummaryError(
        code = "E004",
        userMessage = "APIè°ƒç”¨æ¬¡æ•°å·²ç”¨å®Œ"
    )
    
    /**
     * è¯·æ±‚è¶…æ—¶
     */
    object Timeout : SummaryError(
        code = "E005",
        userMessage = "å¤„ç†è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•"
    )
    
    /**
     * æ•°æ®åº“é”™è¯¯
     */
    object DatabaseError : SummaryError(
        code = "E006",
        userMessage = "ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•"
    )
    
    /**
     * ç”¨æˆ·å–æ¶ˆ
     */
    object Cancelled : SummaryError(
        code = "E007",
        userMessage = "å·²å–æ¶ˆ"
    )
    
    /**
     * æœªçŸ¥é”™è¯¯
     * 
     * ä½¿ç”¨åœºæ™¯ï¼š
     * 1. æ•è·åˆ°æœªé¢„æœŸçš„å¼‚å¸¸ç±»å‹æ—¶ï¼Œå°†å¼‚å¸¸ä¿¡æ¯åŒ…è£…ä¸ºUnknowné”™è¯¯
     * 2. ç¬¬ä¸‰æ–¹åº“æŠ›å‡ºçš„éæ ‡å‡†å¼‚å¸¸
     * 3. ç³»ç»Ÿçº§é”™è¯¯ï¼ˆå¦‚OOMã€SecurityExceptionç­‰ï¼‰
     * 
     * å¤„ç†æ–¹å¼ï¼š
     * - è®°å½•è¯¦ç»†æ—¥å¿—ç”¨äºé—®é¢˜æ’æŸ¥
     * - å‘ç”¨æˆ·æ˜¾ç¤ºé€šç”¨é”™è¯¯æç¤º
     * - é»˜è®¤ä¸å¯é‡è¯•ï¼Œéœ€è¦ç”¨æˆ·æ‰‹åŠ¨æ“ä½œ
     * 
     * @param message åŸå§‹å¼‚å¸¸ä¿¡æ¯ï¼Œç”¨äºæ—¥å¿—è®°å½•å’Œè°ƒè¯•
     */
    data class Unknown(val message: String) : SummaryError(
        code = "E999",
        userMessage = "æ“ä½œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•"  // å¯¹ç”¨æˆ·æ˜¾ç¤ºé€šç”¨æç¤ºï¼Œé¿å…æš´éœ²æŠ€æœ¯ç»†èŠ‚
    ) {
        /**
         * è·å–è°ƒè¯•ä¿¡æ¯ï¼ˆä»…ç”¨äºæ—¥å¿—ï¼‰
         */
        fun getDebugMessage(): String = "Unknown error: $message"
    }
    
    /**
     * æ˜¯å¦å¯é‡è¯•
     */
    fun isRetryable(): Boolean = this in listOf(NetworkError, Timeout, ApiError)
    
    /**
     * è·å–å»ºè®®æ“ä½œ
     */
    fun getSuggestedAction(): String = when (this) {
        is NoConversations -> "è¯·é€‰æ‹©åŒ…å«å¯¹è¯è®°å½•çš„æ—¥æœŸèŒƒå›´"
        is NetworkError -> "è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•"
        is ApiError -> "è¯·ç¨åé‡è¯•ï¼Œæˆ–æ£€æŸ¥AIæœåŠ¡é…ç½®"
        is QuotaExceeded -> "è¯·æ£€æŸ¥APIé…é¢æˆ–æ›´æ¢æœåŠ¡å•†"
        is Timeout -> "è¯·ç¨åé‡è¯•"
        is DatabaseError -> "è¯·é‡è¯•ï¼Œå¦‚é—®é¢˜æŒç»­è¯·é‡å¯åº”ç”¨"
        is Cancelled -> "æ“ä½œå·²å–æ¶ˆ"
        is Unknown -> "è¯·é‡è¯•ï¼Œå¦‚é—®é¢˜æŒç»­è¯·è”ç³»æ”¯æŒ"
    }
}
```

#### 4.1.6 ConflictResultï¼ˆå†²çªç»“æœæ¨¡å‹ - æ–°å¢ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`domain/model/ConflictResult.kt`

```kotlin
/**
 * å†²çªæ£€æµ‹ç»“æœ
 */
sealed class ConflictResult {
    /**
     * æ— å†²çª
     */
    object NoConflict : ConflictResult()
    
    /**
     * å­˜åœ¨å†²çª
     */
    data class HasConflict(
        val existingSummaries: List<DailySummary>,
        val conflictDates: List<String>
    ) : ConflictResult() {
        /**
         * å†²çªæ•°é‡
         */
        val conflictCount: Int get() = conflictDates.size
    }
}

/**
 * å†²çªå¤„ç†æ–¹å¼
 */
enum class ConflictResolution(val displayName: String) {
    /**
     * è¦†ç›–ç°æœ‰æ€»ç»“
     */
    OVERWRITE("è¦†ç›–ç°æœ‰æ€»ç»“"),
    
    /**
     * ä»…è¡¥å……ç¼ºå¤±æ—¥æœŸ
     */
    FILL_GAPS("ä»…è¡¥å……ç¼ºå¤±æ—¥æœŸ"),
    
    /**
     * å–æ¶ˆæ“ä½œ
     */
    CANCEL("å–æ¶ˆ")
}
```

#### 4.1.7 DateRangeï¼ˆæ—¥æœŸèŒƒå›´æ¨¡å‹ - æ–°å¢ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`domain/model/DateRange.kt`

```kotlin
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import java.time.temporal.ChronoUnit

/**
 * æ—¥æœŸèŒƒå›´æ¨¡å‹
 */
data class DateRange(
    val startDate: String,
    val endDate: String
) {
    private val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
    
    init {
        require(startDate.matches(Regex("\\d{4}-\\d{2}-\\d{2}"))) {
            "startDateæ ¼å¼å¿…é¡»ä¸ºyyyy-MM-dd"
        }
        require(endDate.matches(Regex("\\d{4}-\\d{2}-\\d{2}"))) {
            "endDateæ ¼å¼å¿…é¡»ä¸ºyyyy-MM-dd"
        }
    }
    
    /**
     * è·å–å¼€å§‹æ—¥æœŸ
     */
    fun getStartLocalDate(): LocalDate = LocalDate.parse(startDate, formatter)
    
    /**
     * è·å–ç»“æŸæ—¥æœŸ
     */
    fun getEndLocalDate(): LocalDate = LocalDate.parse(endDate, formatter)
    
    /**
     * è®¡ç®—å¤©æ•°
     */
    fun getDayCount(): Int {
        return ChronoUnit.DAYS.between(getStartLocalDate(), getEndLocalDate()).toInt() + 1
    }
    
    /**
     * è·å–èŒƒå›´å†…æ‰€æœ‰æ—¥æœŸ
     */
    fun getAllDates(): List<String> {
        val start = getStartLocalDate()
        val end = getEndLocalDate()
        return generateSequence(start) { it.plusDays(1) }
            .takeWhile { !it.isAfter(end) }
            .map { it.format(formatter) }
            .toList()
    }
    
    /**
     * æ˜¯å¦åŒ…å«æŒ‡å®šæ—¥æœŸ
     */
    fun contains(date: String): Boolean {
        val target = LocalDate.parse(date, formatter)
        return !target.isBefore(getStartLocalDate()) && !target.isAfter(getEndLocalDate())
    }
    
    companion object {
        /**
         * æœ€è¿‘7å¤©
         */
        fun lastSevenDays(): DateRange {
            val today = LocalDate.now()
            val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
            return DateRange(
                startDate = today.minusDays(6).format(formatter),
                endDate = today.format(formatter)
            )
        }
        
        /**
         * æœ¬æœˆ
         */
        fun thisMonth(): DateRange {
            val today = LocalDate.now()
            val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
            return DateRange(
                startDate = today.withDayOfMonth(1).format(formatter),
                endDate = today.format(formatter)
            )
        }
        
        /**
         * ä¸Šæœˆ
         */
        fun lastMonth(): DateRange {
            val today = LocalDate.now()
            val lastMonth = today.minusMonths(1)
            val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
            return DateRange(
                startDate = lastMonth.withDayOfMonth(1).format(formatter),
                endDate = lastMonth.withDayOfMonth(lastMonth.lengthOfMonth()).format(formatter)
            )
        }
        
        /**
         * æœ€è¿‘30å¤©
         */
        fun lastThirtyDays(): DateRange {
            val today = LocalDate.now()
            val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
            return DateRange(
                startDate = today.minusDays(29).format(formatter),
                endDate = today.format(formatter)
            )
        }
    }
}
```


#### 4.1.8 DailySummaryæ‰©å±•ï¼ˆæ¨¡å‹æ‰©å±•ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`domain/model/DailySummary.kt`

```kotlin
/**
 * æ¯æ—¥æ€»ç»“é¢†åŸŸæ¨¡å‹ï¼ˆæ‰©å±•ç‰ˆï¼‰
 *
 * æ–°å¢å­—æ®µæ”¯æŒè‡ªå®šä¹‰èŒƒå›´æ€»ç»“
 */
data class DailySummary(
    val id: Long = 0,
    val contactId: String,
    val summaryDate: String,
    val content: String,
    val keyEvents: List<KeyEvent>,
    val newFacts: List<Fact>,
    val updatedTags: List<TagUpdate>,
    val relationshipScoreChange: Int,
    val relationshipTrend: RelationshipTrend,
    // ==================== æ–°å¢å­—æ®µ ====================
    val startDate: String? = null,           // èŒƒå›´æ€»ç»“å¼€å§‹æ—¥æœŸ
    val endDate: String? = null,             // èŒƒå›´æ€»ç»“ç»“æŸæ—¥æœŸ
    val summaryType: SummaryType = SummaryType.DAILY,
    val generationSource: GenerationSource = GenerationSource.AUTO,
    val conversationCount: Int = 0,          // åˆ†æçš„å¯¹è¯æ•°é‡
    val generatedAt: Long = System.currentTimeMillis()
) {
    init {
        require(contactId.isNotBlank()) { "contactIdä¸èƒ½ä¸ºç©º" }
        require(summaryDate.matches(Regex("\\d{4}-\\d{2}-\\d{2}"))) {
            "summaryDateæ ¼å¼å¿…é¡»ä¸ºyyyy-MM-dd"
        }
        require(relationshipScoreChange in -10..10) {
            "relationshipScoreChangeå¿…é¡»åœ¨-10åˆ°10ä¹‹é—´"
        }
    }
    
    /**
     * æ˜¯å¦ä¸ºèŒƒå›´æ€»ç»“
     */
    fun isRangeSummary(): Boolean = summaryType == SummaryType.CUSTOM_RANGE
    
    /**
     * æ˜¯å¦ä¸ºæ‰‹åŠ¨ç”Ÿæˆ
     */
    fun isManualGenerated(): Boolean = generationSource == GenerationSource.MANUAL
    
    /**
     * è·å–æ˜¾ç¤ºæ—¥æœŸèŒƒå›´
     */
    fun getDisplayDateRange(): String {
        return if (isRangeSummary() && startDate != null && endDate != null) {
            "$startDate è‡³ $endDate"
        } else {
            summaryDate
        }
    }
    
    /**
     * åˆ¤æ–­æ˜¯å¦æœ‰å®è´¨æ€§å†…å®¹
     */
    fun hasSubstantialContent(): Boolean {
        return keyEvents.isNotEmpty() || newFacts.isNotEmpty() || updatedTags.isNotEmpty()
    }
}
```

### 4.2 æ•°æ®åº“æ‰©å±•è®¾è®¡

#### 4.2.1 DailySummaryEntityæ‰©å±•

**æ–‡ä»¶ä½ç½®**ï¼š`data/local/entity/DailySummaryEntity.kt`

```kotlin
@Entity(
    tableName = "daily_summaries",
    foreignKeys = [
        ForeignKey(
            entity = ContactProfileEntity::class,
            parentColumns = ["id"],
            childColumns = ["contact_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["contact_id"]),
        Index(value = ["summary_date"]),
        Index(value = ["contact_id", "summary_date"], unique = true),
        Index(value = ["summary_type"]),           // æ–°å¢ç´¢å¼•
        Index(value = ["generation_source"])       // æ–°å¢ç´¢å¼•
    ]
)
data class DailySummaryEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0,

    @ColumnInfo(name = "contact_id")
    val contactId: String,

    @ColumnInfo(name = "summary_date")
    val summaryDate: String,

    @ColumnInfo(name = "content")
    val content: String,

    @ColumnInfo(name = "key_events_json")
    val keyEventsJson: String,

    @ColumnInfo(name = "relationship_score")
    val relationshipScore: Int,

    @ColumnInfo(name = "created_at")
    val createdAt: Long,
    
    // ==================== æ–°å¢å­—æ®µ ====================
    
    @ColumnInfo(name = "start_date", defaultValue = "NULL")
    val startDate: String? = null,
    
    @ColumnInfo(name = "end_date", defaultValue = "NULL")
    val endDate: String? = null,
    
    @ColumnInfo(name = "summary_type", defaultValue = "'DAILY'")
    val summaryType: String = "DAILY",
    
    @ColumnInfo(name = "generation_source", defaultValue = "'AUTO'")
    val generationSource: String = "AUTO",
    
    @ColumnInfo(name = "conversation_count", defaultValue = "0")
    val conversationCount: Int = 0,
    
    @ColumnInfo(name = "generated_at", defaultValue = "0")
    val generatedAt: Long = 0
)
```

#### 4.2.2 æ•°æ®åº“è¿ç§»è„šæœ¬

**æ–‡ä»¶ä½ç½®**ï¼š`data/local/AppDatabase.kt`

```kotlin
/**
 * Migration 8 -> 9: æ‰©å±•daily_summariesè¡¨æ”¯æŒæ‰‹åŠ¨æ€»ç»“
 */
val MIGRATION_8_9 = object : Migration(8, 9) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // æ·»åŠ æ–°å­—æ®µ
        database.execSQL(
            "ALTER TABLE daily_summaries ADD COLUMN start_date TEXT DEFAULT NULL"
        )
        database.execSQL(
            "ALTER TABLE daily_summaries ADD COLUMN end_date TEXT DEFAULT NULL"
        )
        database.execSQL(
            "ALTER TABLE daily_summaries ADD COLUMN summary_type TEXT NOT NULL DEFAULT 'DAILY'"
        )
        database.execSQL(
            "ALTER TABLE daily_summaries ADD COLUMN generation_source TEXT NOT NULL DEFAULT 'AUTO'"
        )
        database.execSQL(
            "ALTER TABLE daily_summaries ADD COLUMN conversation_count INTEGER NOT NULL DEFAULT 0"
        )
        database.execSQL(
            "ALTER TABLE daily_summaries ADD COLUMN generated_at INTEGER NOT NULL DEFAULT 0"
        )
        
        // åˆ›å»ºæ–°ç´¢å¼•
        database.execSQL(
            "CREATE INDEX IF NOT EXISTS index_daily_summaries_summary_type ON daily_summaries(summary_type)"
        )
        database.execSQL(
            "CREATE INDEX IF NOT EXISTS index_daily_summaries_generation_source ON daily_summaries(generation_source)"
        )
    }
}
```

#### 4.2.3 DailySummaryDaoæ‰©å±•

**æ–‡ä»¶ä½ç½®**ï¼š`data/local/dao/DailySummaryDao.kt`

```kotlin
@Dao
interface DailySummaryDao {
    // ==================== å·²æœ‰æ–¹æ³• ====================
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(summary: DailySummaryEntity): Long
    
    @Query("SELECT * FROM daily_summaries WHERE contact_id = :contactId ORDER BY summary_date DESC")
    suspend fun getSummariesByContact(contactId: String): List<DailySummaryEntity>
    
    @Query("SELECT * FROM daily_summaries WHERE contact_id = :contactId AND summary_date = :date")
    suspend fun getSummaryByDate(contactId: String, date: String): DailySummaryEntity?
    
    @Query("SELECT EXISTS(SELECT 1 FROM daily_summaries WHERE contact_id = :contactId AND summary_date = :date)")
    suspend fun hasSummaryForDate(contactId: String, date: String): Boolean
    
    // ==================== æ–°å¢æ–¹æ³• ====================
    
    /**
     * è·å–æŒ‡å®šæ—¥æœŸèŒƒå›´å†…çš„æ€»ç»“
     */
    @Query("""
        SELECT * FROM daily_summaries 
        WHERE contact_id = :contactId 
        AND summary_date >= :startDate 
        AND summary_date <= :endDate 
        ORDER BY summary_date ASC
    """)
    suspend fun getSummariesInRange(
        contactId: String,
        startDate: String,
        endDate: String
    ): List<DailySummaryEntity>
    
    /**
     * è·å–æŒ‡å®šæ—¥æœŸèŒƒå›´å†…å·²æœ‰æ€»ç»“çš„æ—¥æœŸåˆ—è¡¨
     */
    @Query("""
        SELECT summary_date FROM daily_summaries 
        WHERE contact_id = :contactId 
        AND summary_date >= :startDate 
        AND summary_date <= :endDate
    """)
    suspend fun getSummarizedDatesInRange(
        contactId: String,
        startDate: String,
        endDate: String
    ): List<String>
    
    /**
     * åˆ é™¤æŒ‡å®šæ—¥æœŸèŒƒå›´å†…çš„æ€»ç»“
     */
    @Query("""
        DELETE FROM daily_summaries 
        WHERE contact_id = :contactId 
        AND summary_date >= :startDate 
        AND summary_date <= :endDate
    """)
    suspend fun deleteSummariesInRange(
        contactId: String,
        startDate: String,
        endDate: String
    ): Int
    
    /**
     * è·å–æ‰‹åŠ¨ç”Ÿæˆçš„æ€»ç»“
     */
    @Query("""
        SELECT * FROM daily_summaries 
        WHERE contact_id = :contactId 
        AND generation_source = 'MANUAL' 
        ORDER BY generated_at DESC
    """)
    suspend fun getManualSummaries(contactId: String): List<DailySummaryEntity>
    
    /**
     * æ£€æµ‹æŒ‡å®šèŒƒå›´å†…æ˜¯å¦æœ‰æœªæ€»ç»“çš„æ—¥æœŸ
     * è¿”å›èŒƒå›´å†…æ²¡æœ‰æ€»ç»“çš„æ—¥æœŸæ•°é‡
     */
    @Query("""
        SELECT COUNT(*) FROM (
            WITH RECURSIVE dates(date) AS (
                SELECT :startDate
                UNION ALL
                SELECT date(date, '+1 day') FROM dates WHERE date < :endDate
            )
            SELECT date FROM dates
            WHERE date NOT IN (
                SELECT summary_date FROM daily_summaries 
                WHERE contact_id = :contactId
            )
        )
    """)
    suspend fun countMissingDatesInRange(
        contactId: String,
        startDate: String,
        endDate: String
    ): Int
}
```


### 4.3 UseCaseè®¾è®¡

#### 4.3.1 ManualSummaryUseCaseï¼ˆæ ¸å¿ƒç”¨ä¾‹ - æ–°å¢ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`domain/usecase/ManualSummaryUseCase.kt`

```kotlin
/**
 * æ‰‹åŠ¨è§¦å‘AIæ€»ç»“ç”¨ä¾‹
 *
 * è´Ÿè´£ç¼–æ’æ‰‹åŠ¨æ€»ç»“çš„å®Œæ•´æµç¨‹ï¼š
 * 1. éªŒè¯æ—¥æœŸèŒƒå›´
 * 2. æ£€æµ‹å†²çª
 * 3. è·å–å¯¹è¯æ•°æ®
 * 4. è°ƒç”¨AIç”Ÿæˆæ€»ç»“
 * 5. ä¿å­˜ç»“æœ
 */
@Singleton
class ManualSummaryUseCase @Inject constructor(
    private val conversationRepository: ConversationRepository,
    private val dailySummaryRepository: DailySummaryRepository,
    private val contactRepository: ContactRepository,
    private val aiSummaryProcessor: AiSummaryProcessor,
    private val localSummaryProcessor: LocalSummaryProcessor,
    private val dateRangeValidator: DateRangeValidator,
    private val conflictChecker: SummaryConflictChecker,
    @IoDispatcher private val ioDispatcher: CoroutineDispatcher
) {
    companion object {
        private const val TAG = "ManualSummaryUseCase"
        private const val BATCH_SIZE = 50
    }
    
    /**
     * æ€»ç»“ç»“æœ
     */
    data class SummaryResult(
        val summary: DailySummary,
        val conversationCount: Int,
        val keyEventCount: Int,
        val factCount: Int,
        val relationshipChange: Int
    )
    
    /**
     * è¿›åº¦å›è°ƒ
     */
    fun interface ProgressCallback {
        fun onProgress(progress: Float, step: String)
    }
    
    /**
     * æ‰§è¡Œæ‰‹åŠ¨æ€»ç»“
     *
     * @param contactId è”ç³»äººID
     * @param dateRange æ—¥æœŸèŒƒå›´
     * @param conflictResolution å†²çªå¤„ç†æ–¹å¼ï¼ˆå¦‚æœæœ‰å†²çªï¼‰
     * @param progressCallback è¿›åº¦å›è°ƒ
     * @return æ€»ç»“ç»“æœ
     */
    suspend operator fun invoke(
        contactId: String,
        dateRange: DateRange,
        conflictResolution: ConflictResolution? = null,
        progressCallback: ProgressCallback? = null
    ): Result<SummaryResult> = withContext(ioDispatcher) {
        try {
            // 1. éªŒè¯æ—¥æœŸèŒƒå›´
            progressCallback?.onProgress(0.05f, "éªŒè¯æ—¥æœŸèŒƒå›´...")
            val validationResult = dateRangeValidator.validate(dateRange, contactId)
            if (validationResult.isFailure) {
                return@withContext Result.failure(validationResult.exceptionOrNull()!!)
            }
            
            // 2. è·å–è”ç³»äººä¿¡æ¯
            progressCallback?.onProgress(0.1f, "è·å–è”ç³»äººä¿¡æ¯...")
            val profile = contactRepository.getProfile(contactId).getOrNull()
                ?: return@withContext Result.failure(
                    IllegalStateException("è”ç³»äººä¸å­˜åœ¨")
                )
            
            // 3. å¤„ç†å†²çªï¼ˆå¦‚æœéœ€è¦è¦†ç›–ï¼‰
            if (conflictResolution == ConflictResolution.OVERWRITE) {
                progressCallback?.onProgress(0.15f, "æ¸…ç†å·²æœ‰æ€»ç»“...")
                dailySummaryRepository.deleteSummariesInRange(
                    contactId,
                    dateRange.startDate,
                    dateRange.endDate
                )
            }
            
            // 4. è·å–å¯¹è¯æ•°æ®
            progressCallback?.onProgress(0.2f, "è·å–å¯¹è¯è®°å½•...")
            val conversations = loadConversations(
                contactId,
                dateRange,
                conflictResolution
            )
            
            if (conversations.isEmpty()) {
                return@withContext Result.failure(
                    SummaryException(SummaryError.NoConversations)
                )
            }
            
            // 5. AIåˆ†æ
            progressCallback?.onProgress(0.4f, "AIæ­£åœ¨åˆ†æå¯¹è¯å†…å®¹...")
            val aiResult = aiSummaryProcessor.processForRange(
                profile = profile,
                conversations = conversations,
                startDate = dateRange.startDate,
                endDate = dateRange.endDate
            ) { subProgress ->
                // æ˜ å°„AIè¿›åº¦åˆ°0.4-0.8
                val mappedProgress = 0.4f + subProgress * 0.4f
                progressCallback?.onProgress(mappedProgress, "AIæ­£åœ¨åˆ†æå¯¹è¯å†…å®¹...")
            }
            
            val summary = if (aiResult.isSuccess) {
                aiResult.getOrThrow()
            } else {
                // AIå¤±è´¥ï¼Œä½¿ç”¨é™çº§æ–¹æ¡ˆ
                Log.w(TAG, "AIæ€»ç»“å¤±è´¥ï¼Œä½¿ç”¨é™çº§æ–¹æ¡ˆ", aiResult.exceptionOrNull())
                progressCallback?.onProgress(0.7f, "ä½¿ç”¨æœ¬åœ°åˆ†æ...")
                localSummaryProcessor.processForRange(
                    profile = profile,
                    conversations = conversations,
                    startDate = dateRange.startDate,
                    endDate = dateRange.endDate
                )
            }
            
            // 6. æ„å»ºæœ€ç»ˆæ€»ç»“å¯¹è±¡
            progressCallback?.onProgress(0.85f, "ç”Ÿæˆæ€»ç»“...")
            val finalSummary = summary.copy(
                summaryType = SummaryType.CUSTOM_RANGE,
                generationSource = GenerationSource.MANUAL,
                startDate = dateRange.startDate,
                endDate = dateRange.endDate,
                conversationCount = conversations.size,
                generatedAt = System.currentTimeMillis()
            )
            
            // 7. ä¿å­˜ç»“æœ
            progressCallback?.onProgress(0.95f, "ä¿å­˜ç»“æœ...")
            val savedId = dailySummaryRepository.saveSummary(finalSummary).getOrThrow()
            
            // 8. æ ‡è®°å¯¹è¯ä¸ºå·²æ€»ç»“
            val logIds = conversations.map { it.id }
            conversationRepository.markAsSummarized(logIds)
            
            progressCallback?.onProgress(1f, "å®Œæˆ")
            
            Result.success(
                SummaryResult(
                    summary = finalSummary.copy(id = savedId),
                    conversationCount = conversations.size,
                    keyEventCount = finalSummary.keyEvents.size,
                    factCount = finalSummary.newFacts.size,
                    relationshipChange = finalSummary.relationshipScoreChange
                )
            )
        } catch (e: CancellationException) {
            Result.failure(SummaryException(SummaryError.Cancelled))
        } catch (e: SummaryException) {
            Result.failure(e)
        } catch (e: Exception) {
            Log.e(TAG, "æ‰‹åŠ¨æ€»ç»“å¤±è´¥", e)
            Result.failure(SummaryException(SummaryError.Unknown(e.message ?: "æœªçŸ¥é”™è¯¯")))
        }
    }
    
    /**
     * åŠ è½½å¯¹è¯æ•°æ®
     */
    private suspend fun loadConversations(
        contactId: String,
        dateRange: DateRange,
        conflictResolution: ConflictResolution?
    ): List<ConversationLog> {
        val allDates = dateRange.getAllDates()
        
        // å¦‚æœæ˜¯ä»…è¡¥å……æ¨¡å¼ï¼Œè¿‡æ»¤æ‰å·²æœ‰æ€»ç»“çš„æ—¥æœŸ
        val targetDates = if (conflictResolution == ConflictResolution.FILL_GAPS) {
            val summarizedDates = dailySummaryRepository
                .getSummarizedDatesInRange(contactId, dateRange.startDate, dateRange.endDate)
                .getOrNull() ?: emptyList()
            allDates.filter { it !in summarizedDates }
        } else {
            allDates
        }
        
        // åˆ†æ‰¹åŠ è½½å¯¹è¯
        return targetDates.flatMap { date ->
            conversationRepository.getLogsByContactAndDate(contactId, date)
                .getOrNull() ?: emptyList()
        }
    }
}

/**
 * æ€»ç»“å¼‚å¸¸
 */
class SummaryException(val error: SummaryError) : Exception(error.userMessage)
```

#### 4.3.2 DateRangeValidatorï¼ˆæ—¥æœŸéªŒè¯å·¥å…· - æ–°å¢ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`domain/util/DateRangeValidator.kt`

```kotlin
/**
 * æ—¥æœŸèŒƒå›´éªŒè¯å™¨
 */
@Singleton
class DateRangeValidator @Inject constructor(
    private val contactRepository: ContactRepository
) {
    companion object {
        const val DEFAULT_MAX_DAYS = 30
        const val EXTENDED_MAX_DAYS = 90
    }
    
    /**
     * éªŒè¯ç»“æœ
     */
    sealed class ValidationResult {
        object Valid : ValidationResult()
        data class Warning(val message: String) : ValidationResult()
        data class Invalid(val message: String) : ValidationResult()
    }
    
    /**
     * éªŒè¯æ—¥æœŸèŒƒå›´
     */
    suspend fun validate(
        dateRange: DateRange,
        contactId: String
    ): Result<ValidationResult> {
        return try {
            val start = dateRange.getStartLocalDate()
            val end = dateRange.getEndLocalDate()
            val today = java.time.LocalDate.now()
            
            // è§„åˆ™1: å¼€å§‹æ—¥æœŸä¸èƒ½æ™šäºç»“æŸæ—¥æœŸ
            if (start.isAfter(end)) {
                return Result.success(
                    ValidationResult.Invalid("å¼€å§‹æ—¥æœŸä¸èƒ½æ™šäºç»“æŸæ—¥æœŸ")
                )
            }
            
            // è§„åˆ™2: ç»“æŸæ—¥æœŸä¸èƒ½æ™šäºä»Šå¤©
            if (end.isAfter(today)) {
                return Result.success(
                    ValidationResult.Invalid("ç»“æŸæ—¥æœŸä¸èƒ½æ™šäºä»Šå¤©")
                )
            }
            
            // è§„åˆ™3: æ£€æŸ¥è”ç³»äººåˆ›å»ºæ—¥æœŸ
            val profile = contactRepository.getProfile(contactId).getOrNull()
            if (profile != null) {
                val createdDate = java.time.Instant.ofEpochMilli(profile.createdAt)
                    .atZone(java.time.ZoneId.systemDefault())
                    .toLocalDate()
                if (start.isBefore(createdDate)) {
                    return Result.success(
                        ValidationResult.Invalid("å¼€å§‹æ—¥æœŸä¸èƒ½æ—©äºè”ç³»äººåˆ›å»ºæ—¥æœŸ")
                    )
                }
            }
            
            // è§„åˆ™4: æ£€æŸ¥èŒƒå›´å¤©æ•°
            val dayCount = dateRange.getDayCount()
            when {
                dayCount > EXTENDED_MAX_DAYS -> {
                    return Result.success(
                        ValidationResult.Invalid("æ—¥æœŸèŒƒå›´ä¸èƒ½è¶…è¿‡${EXTENDED_MAX_DAYS}å¤©")
                    )
                }
                dayCount > DEFAULT_MAX_DAYS -> {
                    return Result.success(
                        ValidationResult.Warning(
                            "æ‚¨é€‰æ‹©äº†${dayCount}å¤©çš„æ—¶é—´èŒƒå›´ï¼Œè¿™å¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´å¤„ç†"
                        )
                    )
                }
            }
            
            Result.success(ValidationResult.Valid)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

#### 4.3.3 SummaryConflictCheckerï¼ˆå†²çªæ£€æµ‹å·¥å…· - æ–°å¢ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`domain/util/SummaryConflictChecker.kt`

```kotlin
/**
 * æ€»ç»“å†²çªæ£€æµ‹å™¨
 */
@Singleton
class SummaryConflictChecker @Inject constructor(
    private val dailySummaryRepository: DailySummaryRepository
) {
    /**
     * æ£€æµ‹å†²çª
     */
    suspend fun checkConflict(
        contactId: String,
        dateRange: DateRange
    ): Result<ConflictResult> {
        return try {
            val existingSummaries = dailySummaryRepository.getSummariesInRange(
                contactId,
                dateRange.startDate,
                dateRange.endDate
            ).getOrNull() ?: emptyList()
            
            if (existingSummaries.isEmpty()) {
                Result.success(ConflictResult.NoConflict)
            } else {
                val conflictDates = existingSummaries.map { it.summaryDate }
                Result.success(
                    ConflictResult.HasConflict(
                        existingSummaries = existingSummaries,
                        conflictDates = conflictDates
                    )
                )
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * æ£€æµ‹ç¼ºå¤±çš„æ€»ç»“æ—¥æœŸ
     */
    suspend fun findMissingDates(
        contactId: String,
        dateRange: DateRange
    ): Result<List<String>> {
        return try {
            val allDates = dateRange.getAllDates()
            val summarizedDates = dailySummaryRepository
                .getSummarizedDatesInRange(contactId, dateRange.startDate, dateRange.endDate)
                .getOrNull() ?: emptyList()
            
            val missingDates = allDates.filter { it !in summarizedDates }
            Result.success(missingDates)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```


### 4.4 ViewModelè®¾è®¡

#### 4.4.1 ManualSummaryViewModelï¼ˆæ–°å¢ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`presentation/viewmodel/ManualSummaryViewModel.kt`

```kotlin
/**
 * æ‰‹åŠ¨æ€»ç»“ViewModel
 */
@HiltViewModel
class ManualSummaryViewModel @Inject constructor(
    private val manualSummaryUseCase: ManualSummaryUseCase,
    private val conflictChecker: SummaryConflictChecker,
    private val dateRangeValidator: DateRangeValidator,
    private val conversationRepository: ConversationRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ManualSummaryUiState())
    val uiState: StateFlow<ManualSummaryUiState> = _uiState.asStateFlow()
    
    private var currentJob: Job? = null
    
    /**
     * å¤„ç†UIäº‹ä»¶
     */
    fun onEvent(event: ManualSummaryUiEvent) {
        when (event) {
            is ManualSummaryUiEvent.ShowDatePicker -> showDatePicker(event.contactId)
            is ManualSummaryUiEvent.SelectQuickOption -> selectQuickOption(event.option)
            is ManualSummaryUiEvent.SelectCustomRange -> selectCustomRange(event.start, event.end)
            is ManualSummaryUiEvent.ConfirmDateRange -> confirmDateRange()
            is ManualSummaryUiEvent.DismissDatePicker -> dismissDatePicker()
            is ManualSummaryUiEvent.SelectConflictResolution -> selectConflictResolution(event.resolution)
            is ManualSummaryUiEvent.ConfirmConflictResolution -> confirmConflictResolution()
            is ManualSummaryUiEvent.DismissConflictDialog -> dismissConflictDialog()
            is ManualSummaryUiEvent.CancelSummary -> cancelSummary()
            is ManualSummaryUiEvent.RetryFailed -> retryFailed()
            is ManualSummaryUiEvent.ViewResult -> viewResult()
            is ManualSummaryUiEvent.DismissResult -> dismissResult()
            is ManualSummaryUiEvent.Reset -> reset()
        }
    }
    
    /**
     * æ˜¾ç¤ºæ—¥æœŸé€‰æ‹©å™¨
     */
    private fun showDatePicker(contactId: String) {
        _uiState.update {
            it.copy(
                contactId = contactId,
                showDatePicker = true,
                selectedDateRange = DateRange.lastSevenDays()
            )
        }
    }
    
    /**
     * é€‰æ‹©å¿«æ·é€‰é¡¹
     */
    private fun selectQuickOption(option: QuickDateOption) {
        val dateRange = when (option) {
            QuickDateOption.LAST_7_DAYS -> DateRange.lastSevenDays()
            QuickDateOption.THIS_MONTH -> DateRange.thisMonth()
            QuickDateOption.LAST_MONTH -> DateRange.lastMonth()
            QuickDateOption.LAST_30_DAYS -> DateRange.lastThirtyDays()
            QuickDateOption.MISSING_DATES -> findMissingDatesRange()
        }
        _uiState.update {
            it.copy(
                selectedQuickOption = option,
                selectedDateRange = dateRange
            )
        }
    }
    
    /**
     * é€‰æ‹©è‡ªå®šä¹‰èŒƒå›´
     */
    private fun selectCustomRange(start: String, end: String) {
        _uiState.update {
            it.copy(
                selectedQuickOption = null,
                selectedDateRange = DateRange(start, end)
            )
        }
    }
    
    /**
     * ç¡®è®¤æ—¥æœŸèŒƒå›´
     */
    private fun confirmDateRange() {
        val state = _uiState.value
        val contactId = state.contactId ?: return
        val dateRange = state.selectedDateRange ?: return
        
        viewModelScope.launch {
            // éªŒè¯æ—¥æœŸèŒƒå›´
            val validationResult = dateRangeValidator.validate(dateRange, contactId)
            when (val result = validationResult.getOrNull()) {
                is DateRangeValidator.ValidationResult.Invalid -> {
                    _uiState.update {
                        it.copy(validationError = result.message)
                    }
                    return@launch
                }
                is DateRangeValidator.ValidationResult.Warning -> {
                    _uiState.update {
                        it.copy(
                            showRangeWarning = true,
                            rangeWarningMessage = result.message
                        )
                    }
                    return@launch
                }
                else -> {}
            }
            
            // æ£€æµ‹å†²çª
            val conflictResult = conflictChecker.checkConflict(contactId, dateRange)
            when (val conflict = conflictResult.getOrNull()) {
                is ConflictResult.HasConflict -> {
                    _uiState.update {
                        it.copy(
                            showDatePicker = false,
                            showConflictDialog = true,
                            conflictResult = conflict
                        )
                    }
                }
                else -> {
                    // æ— å†²çªï¼Œç›´æ¥å¼€å§‹æ€»ç»“
                    _uiState.update { it.copy(showDatePicker = false) }
                    startSummary(contactId, dateRange, null)
                }
            }
        }
    }
    
    /**
     * é€‰æ‹©å†²çªå¤„ç†æ–¹å¼
     */
    private fun selectConflictResolution(resolution: ConflictResolution) {
        _uiState.update {
            it.copy(selectedConflictResolution = resolution)
        }
    }
    
    /**
     * ç¡®è®¤å†²çªå¤„ç†
     */
    private fun confirmConflictResolution() {
        val state = _uiState.value
        val contactId = state.contactId ?: return
        val dateRange = state.selectedDateRange ?: return
        val resolution = state.selectedConflictResolution ?: return
        
        if (resolution == ConflictResolution.CANCEL) {
            dismissConflictDialog()
            return
        }
        
        _uiState.update { it.copy(showConflictDialog = false) }
        startSummary(contactId, dateRange, resolution)
    }
    
    /**
     * å¼€å§‹æ€»ç»“
     */
    private fun startSummary(
        contactId: String,
        dateRange: DateRange,
        conflictResolution: ConflictResolution?
    ) {
        currentJob?.cancel()
        currentJob = viewModelScope.launch {
            _uiState.update {
                it.copy(
                    showProgressDialog = true,
                    task = SummaryTask(
                        contactId = contactId,
                        startDate = dateRange.startDate,
                        endDate = dateRange.endDate,
                        conflictResolution = conflictResolution
                    ).markStarted()
                )
            }
            
            val result = manualSummaryUseCase(
                contactId = contactId,
                dateRange = dateRange,
                conflictResolution = conflictResolution
            ) { progress, step ->
                _uiState.update {
                    it.copy(
                        task = it.task?.withProgress(progress, step)
                    )
                }
            }
            
            result.fold(
                onSuccess = { summaryResult ->
                    _uiState.update {
                        it.copy(
                            showProgressDialog = false,
                            showResultDialog = true,
                            task = it.task?.markSuccess(),
                            summaryResult = summaryResult
                        )
                    }
                },
                onFailure = { error ->
                    val summaryError = when (error) {
                        is SummaryException -> error.error
                        else -> SummaryError.Unknown(error.message ?: "æœªçŸ¥é”™è¯¯")
                    }
                    _uiState.update {
                        it.copy(
                            showProgressDialog = false,
                            showErrorDialog = true,
                            task = it.task?.markFailed(summaryError)
                        )
                    }
                }
            )
        }
    }
    
    /**
     * å–æ¶ˆæ€»ç»“
     */
    private fun cancelSummary() {
        currentJob?.cancel()
        _uiState.update {
            it.copy(
                showProgressDialog = false,
                task = it.task?.markCancelled()
            )
        }
    }
    
    /**
     * é‡è¯•å¤±è´¥çš„ä»»åŠ¡
     */
    private fun retryFailed() {
        val state = _uiState.value
        val task = state.task ?: return
        
        _uiState.update { it.copy(showErrorDialog = false) }
        startSummary(
            task.contactId,
            DateRange(task.startDate, task.endDate),
            task.conflictResolution
        )
    }
    
    /**
     * æŸ¥æ‰¾ç¼ºå¤±æ€»ç»“çš„æ—¥æœŸèŒƒå›´
     */
    private fun findMissingDatesRange(): DateRange {
        // é»˜è®¤è¿”å›æœ€è¿‘30å¤©ï¼Œå®é™…å®ç°éœ€è¦æŸ¥è¯¢æ•°æ®åº“
        return DateRange.lastThirtyDays()
    }
    
    // ... å…¶ä»–è¾…åŠ©æ–¹æ³•
    
    private fun dismissDatePicker() {
        _uiState.update { it.copy(showDatePicker = false) }
    }
    
    private fun dismissConflictDialog() {
        _uiState.update { it.copy(showConflictDialog = false) }
    }
    
    private fun viewResult() {
        // å¯¼èˆªåˆ°æ—¶å…‰è½´é¡µé¢
        _uiState.update { it.copy(navigateToTimeline = true) }
    }
    
    private fun dismissResult() {
        _uiState.update { it.copy(showResultDialog = false) }
    }
    
    private fun reset() {
        _uiState.value = ManualSummaryUiState()
    }
}
```

#### 4.4.2 ManualSummaryUiStateï¼ˆUIçŠ¶æ€ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`presentation/viewmodel/ManualSummaryUiState.kt`

```kotlin
/**
 * æ‰‹åŠ¨æ€»ç»“UIçŠ¶æ€
 */
data class ManualSummaryUiState(
    val contactId: String? = null,
    
    // æ—¥æœŸé€‰æ‹©
    val showDatePicker: Boolean = false,
    val selectedQuickOption: QuickDateOption? = QuickDateOption.LAST_7_DAYS,
    val selectedDateRange: DateRange? = null,
    val validationError: String? = null,
    val showRangeWarning: Boolean = false,
    val rangeWarningMessage: String? = null,
    
    // å†²çªå¤„ç†
    val showConflictDialog: Boolean = false,
    val conflictResult: ConflictResult.HasConflict? = null,
    val selectedConflictResolution: ConflictResolution? = null,
    
    // è¿›åº¦
    val showProgressDialog: Boolean = false,
    val task: SummaryTask? = null,
    
    // ç»“æœ
    val showResultDialog: Boolean = false,
    val summaryResult: ManualSummaryUseCase.SummaryResult? = null,
    
    // é”™è¯¯
    val showErrorDialog: Boolean = false,
    
    // å¯¼èˆª
    val navigateToTimeline: Boolean = false
)

/**
 * å¿«æ·æ—¥æœŸé€‰é¡¹
 */
enum class QuickDateOption(val displayName: String) {
    LAST_7_DAYS("æœ€è¿‘7å¤©"),
    THIS_MONTH("æœ¬æœˆ"),
    LAST_MONTH("ä¸Šæœˆ"),
    LAST_30_DAYS("æœ€è¿‘30å¤©"),
    MISSING_DATES("æœªæ€»ç»“æ—¶æ®µ")
}
```

#### 4.4.3 ManualSummaryUiEventï¼ˆUIäº‹ä»¶ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`presentation/viewmodel/ManualSummaryUiEvent.kt`

```kotlin
/**
 * æ‰‹åŠ¨æ€»ç»“UIäº‹ä»¶
 */
sealed class ManualSummaryUiEvent {
    data class ShowDatePicker(val contactId: String) : ManualSummaryUiEvent()
    data class SelectQuickOption(val option: QuickDateOption) : ManualSummaryUiEvent()
    data class SelectCustomRange(val start: String, val end: String) : ManualSummaryUiEvent()
    object ConfirmDateRange : ManualSummaryUiEvent()
    object DismissDatePicker : ManualSummaryUiEvent()
    data class SelectConflictResolution(val resolution: ConflictResolution) : ManualSummaryUiEvent()
    object ConfirmConflictResolution : ManualSummaryUiEvent()
    object DismissConflictDialog : ManualSummaryUiEvent()
    object CancelSummary : ManualSummaryUiEvent()
    object RetryFailed : ManualSummaryUiEvent()
    object ViewResult : ManualSummaryUiEvent()
    object DismissResult : ManualSummaryUiEvent()
    object Reset : ManualSummaryUiEvent()
}
```


### 4.5 UIç»„ä»¶è®¾è®¡

#### 4.5.1 DateRangePickerDialogï¼ˆæ—¥æœŸé€‰æ‹©å¯¹è¯æ¡†ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`presentation/ui/screen/contact/summary/DateRangePickerDialog.kt`

```kotlin
/**
 * æ—¥æœŸèŒƒå›´é€‰æ‹©å¯¹è¯æ¡†
 */
@Composable
fun DateRangePickerDialog(
    selectedOption: QuickDateOption?,
    selectedRange: DateRange?,
    existingSummaryDates: List<String>,
    validationError: String?,
    onQuickOptionSelected: (QuickDateOption) -> Unit,
    onCustomRangeSelected: (String, String) -> Unit,
    onConfirm: () -> Unit,
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("é€‰æ‹©æ—¥æœŸèŒƒå›´") },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // å¿«æ·é€‰é¡¹
                QuickDateOptions(
                    selectedOption = selectedOption,
                    onOptionSelected = onQuickOptionSelected
                )
                
                HorizontalDivider()
                
                // è‡ªå®šä¹‰æ—¥æœŸ
                CustomDateRangeSection(
                    selectedRange = selectedRange,
                    onRangeChanged = onCustomRangeSelected
                )
                
                // å·²æœ‰æ€»ç»“æç¤º
                if (existingSummaryDates.isNotEmpty()) {
                    ExistingSummaryHint(dates = existingSummaryDates)
                }
                
                // éªŒè¯é”™è¯¯
                validationError?.let {
                    Text(
                        text = it,
                        color = MaterialTheme.colorScheme.error,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            }
        },
        confirmButton = {
            TextButton(onClick = onConfirm) {
                Text("ç¡®è®¤")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("å–æ¶ˆ")
            }
        }
    )
}

/**
 * å¿«æ·æ—¥æœŸé€‰é¡¹ç»„ä»¶
 */
@Composable
private fun QuickDateOptions(
    selectedOption: QuickDateOption?,
    onOptionSelected: (QuickDateOption) -> Unit
) {
    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
        Text(
            text = "å¿«æ·é€‰é¡¹",
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        
        FlowRow(
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            QuickDateOption.entries.forEach { option ->
                FilterChip(
                    selected = selectedOption == option,
                    onClick = { onOptionSelected(option) },
                    label = { Text(option.displayName) }
                )
            }
        }
    }
}

/**
 * è‡ªå®šä¹‰æ—¥æœŸèŒƒå›´åŒºåŸŸ
 */
@Composable
private fun CustomDateRangeSection(
    selectedRange: DateRange?,
    onRangeChanged: (String, String) -> Unit
) {
    var showStartPicker by remember { mutableStateOf(false) }
    var showEndPicker by remember { mutableStateOf(false) }
    
    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
        Text(
            text = "è‡ªå®šä¹‰æ—¥æœŸ",
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            // å¼€å§‹æ—¥æœŸ
            OutlinedButton(
                onClick = { showStartPicker = true },
                modifier = Modifier.weight(1f)
            ) {
                Text(selectedRange?.startDate ?: "å¼€å§‹æ—¥æœŸ")
            }
            
            Text("è‡³", modifier = Modifier.align(Alignment.CenterVertically))
            
            // ç»“æŸæ—¥æœŸ
            OutlinedButton(
                onClick = { showEndPicker = true },
                modifier = Modifier.weight(1f)
            ) {
                Text(selectedRange?.endDate ?: "ç»“æŸæ—¥æœŸ")
            }
        }
    }
    
    // æ—¥æœŸé€‰æ‹©å™¨å¯¹è¯æ¡†
    if (showStartPicker) {
        DatePickerDialog(
            onDateSelected = { date ->
                selectedRange?.let {
                    onRangeChanged(date, it.endDate)
                }
                showStartPicker = false
            },
            onDismiss = { showStartPicker = false }
        )
    }
    
    if (showEndPicker) {
        DatePickerDialog(
            onDateSelected = { date ->
                selectedRange?.let {
                    onRangeChanged(it.startDate, date)
                }
                showEndPicker = false
            },
            onDismiss = { showEndPicker = false }
        )
    }
}
```

#### 4.5.2 SummaryProgressDialogï¼ˆè¿›åº¦å¯¹è¯æ¡†ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`presentation/ui/screen/contact/summary/SummaryProgressDialog.kt`

```kotlin
/**
 * æ€»ç»“è¿›åº¦å¯¹è¯æ¡†
 */
@Composable
fun SummaryProgressDialog(
    task: SummaryTask,
    onCancel: () -> Unit
) {
    AlertDialog(
        onDismissRequest = { /* ä¸å…è®¸ç‚¹å‡»å¤–éƒ¨å…³é—­ */ },
        title = { Text("æ­£åœ¨ç”Ÿæˆæ€»ç»“") },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                // è¿›åº¦æ¡
                LinearProgressIndicator(
                    progress = { task.progress },
                    modifier = Modifier.fillMaxWidth()
                )
                
                // è¿›åº¦ç™¾åˆ†æ¯”
                Text(
                    text = "${(task.progress * 100).toInt()}%",
                    style = MaterialTheme.typography.titleMedium
                )
                
                // å½“å‰æ­¥éª¤
                Text(
                    text = task.currentStep,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                
                // é˜¶æ®µå›¾æ ‡åŠ¨ç”»
                ProgressStageIndicator(status = task.status)
            }
        },
        confirmButton = {},
        dismissButton = {
            if (task.status.isCancellable()) {
                TextButton(onClick = onCancel) {
                    Text("å–æ¶ˆ")
                }
            }
        }
    )
}

/**
 * è¿›åº¦é˜¶æ®µæŒ‡ç¤ºå™¨
 */
@Composable
private fun ProgressStageIndicator(status: SummaryTaskStatus) {
    val icon = when (status) {
        SummaryTaskStatus.FETCHING_DATA -> "ğŸ“¥"
        SummaryTaskStatus.ANALYZING -> "ğŸ¤–"
        SummaryTaskStatus.GENERATING -> "âœï¸"
        SummaryTaskStatus.SAVING -> "ğŸ’¾"
        else -> "â³"
    }
    
    val infiniteTransition = rememberInfiniteTransition(label = "progress")
    val alpha by infiniteTransition.animateFloat(
        initialValue = 0.3f,
        targetValue = 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(500),
            repeatMode = RepeatMode.Reverse
        ),
        label = "alpha"
    )
    
    Text(
        text = icon,
        fontSize = 48.sp,
        modifier = Modifier.alpha(alpha)
    )
}
```

#### 4.5.3 SummaryResultDialogï¼ˆç»“æœå¯¹è¯æ¡†ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`presentation/ui/screen/contact/summary/SummaryResultDialog.kt`

```kotlin
/**
 * æ€»ç»“ç»“æœå¯¹è¯æ¡†
 */
@Composable
fun SummaryResultDialog(
    result: ManualSummaryUseCase.SummaryResult,
    onViewSummary: () -> Unit,
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        icon = {
            Icon(
                imageVector = Icons.Default.CheckCircle,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(48.dp)
            )
        },
        title = { Text("æ€»ç»“ç”ŸæˆæˆåŠŸ") },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                Text(
                    text = "å·²ä¸º ${result.summary.getDisplayDateRange()} ç”Ÿæˆæ€»ç»“",
                    style = MaterialTheme.typography.bodyMedium
                )
                
                HorizontalDivider()
                
                // ç»Ÿè®¡ä¿¡æ¯
                StatisticRow(
                    icon = "ğŸ“Š",
                    label = "åˆ†æå¯¹è¯",
                    value = "${result.conversationCount} æ¡"
                )
                StatisticRow(
                    icon = "ğŸ¯",
                    label = "å…³é”®äº‹ä»¶",
                    value = "${result.keyEventCount} ä¸ª"
                )
                StatisticRow(
                    icon = "ğŸ’¡",
                    label = "æ–°å‘ç°äº‹å®",
                    value = "${result.factCount} ä¸ª"
                )
                StatisticRow(
                    icon = "ğŸ“ˆ",
                    label = "å…³ç³»è¯„åˆ†å˜åŒ–",
                    value = if (result.relationshipChange >= 0) 
                        "+${result.relationshipChange}" 
                    else 
                        "${result.relationshipChange}"
                )
            }
        },
        confirmButton = {
            Button(onClick = onViewSummary) {
                Text("æŸ¥çœ‹æ€»ç»“")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("è¿”å›")
            }
        }
    )
}

@Composable
private fun StatisticRow(
    icon: String,
    label: String,
    value: String
) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
            Text(icon)
            Text(label, color = MaterialTheme.colorScheme.onSurfaceVariant)
        }
        Text(value, fontWeight = FontWeight.Medium)
    }
}
```


### 4.6 ä¾èµ–æ³¨å…¥è®¾è®¡

#### 4.6.1 SummaryModuleï¼ˆæ–°å¢ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š`di/SummaryModule.kt`

```kotlin
/**
 * æ€»ç»“åŠŸèƒ½ä¾èµ–æ³¨å…¥æ¨¡å—
 */
@Module
@InstallIn(SingletonComponent::class)
object SummaryModule {
    
    @Provides
    @Singleton
    fun provideDateRangeValidator(
        contactRepository: ContactRepository
    ): DateRangeValidator {
        return DateRangeValidator(contactRepository)
    }
    
    @Provides
    @Singleton
    fun provideSummaryConflictChecker(
        dailySummaryRepository: DailySummaryRepository
    ): SummaryConflictChecker {
        return SummaryConflictChecker(dailySummaryRepository)
    }
    
    @Provides
    @Singleton
    fun provideManualSummaryUseCase(
        conversationRepository: ConversationRepository,
        dailySummaryRepository: DailySummaryRepository,
        contactRepository: ContactRepository,
        aiSummaryProcessor: AiSummaryProcessor,
        localSummaryProcessor: LocalSummaryProcessor,
        dateRangeValidator: DateRangeValidator,
        conflictChecker: SummaryConflictChecker,
        @IoDispatcher ioDispatcher: CoroutineDispatcher
    ): ManualSummaryUseCase {
        return ManualSummaryUseCase(
            conversationRepository = conversationRepository,
            dailySummaryRepository = dailySummaryRepository,
            contactRepository = contactRepository,
            aiSummaryProcessor = aiSummaryProcessor,
            localSummaryProcessor = localSummaryProcessor,
            dateRangeValidator = dateRangeValidator,
            conflictChecker = conflictChecker,
            ioDispatcher = ioDispatcher
        )
    }
}
```

---

## 5. Repositoryæ‰©å±•è®¾è®¡

### 5.1 DailySummaryRepositoryæ¥å£æ‰©å±•

**æ–‡ä»¶ä½ç½®**ï¼š`domain/repository/DailySummaryRepository.kt`

```kotlin
interface DailySummaryRepository {
    // ==================== å·²æœ‰æ–¹æ³• ====================
    
    suspend fun saveSummary(summary: DailySummary): Result<Long>
    suspend fun getSummariesByContact(contactId: String): Result<List<DailySummary>>
    suspend fun getSummaryByDate(contactId: String, date: String): Result<DailySummary?>
    suspend fun hasSummaryForDate(contactId: String, date: String): Result<Boolean>
    suspend fun deleteByContactId(contactId: String): Result<Int>
    suspend fun cleanupOldSummaries(beforeTimestamp: Long): Result<Int>
    suspend fun getRecentSummaries(contactId: String, days: Int): List<DailySummary>
    
    // ==================== æ–°å¢æ–¹æ³• ====================
    
    /**
     * è·å–æŒ‡å®šæ—¥æœŸèŒƒå›´å†…çš„æ€»ç»“
     */
    suspend fun getSummariesInRange(
        contactId: String,
        startDate: String,
        endDate: String
    ): Result<List<DailySummary>>
    
    /**
     * è·å–æŒ‡å®šæ—¥æœŸèŒƒå›´å†…å·²æœ‰æ€»ç»“çš„æ—¥æœŸåˆ—è¡¨
     */
    suspend fun getSummarizedDatesInRange(
        contactId: String,
        startDate: String,
        endDate: String
    ): Result<List<String>>
    
    /**
     * åˆ é™¤æŒ‡å®šæ—¥æœŸèŒƒå›´å†…çš„æ€»ç»“
     */
    suspend fun deleteSummariesInRange(
        contactId: String,
        startDate: String,
        endDate: String
    ): Result<Int>
    
    /**
     * è·å–æ‰‹åŠ¨ç”Ÿæˆçš„æ€»ç»“
     */
    suspend fun getManualSummaries(contactId: String): Result<List<DailySummary>>
}
```

### 5.2 DailySummaryRepositoryImplæ‰©å±•

**æ–‡ä»¶ä½ç½®**ï¼š`data/repository/DailySummaryRepositoryImpl.kt`

```kotlin
@Singleton
class DailySummaryRepositoryImpl @Inject constructor(
    private val dao: DailySummaryDao,
    private val moshi: Moshi
) : DailySummaryRepository {
    
    // ... å·²æœ‰å®ç° ...
    
    // ==================== æ–°å¢å®ç° ====================
    
    override suspend fun getSummariesInRange(
        contactId: String,
        startDate: String,
        endDate: String
    ): Result<List<DailySummary>> = withContext(Dispatchers.IO) {
        try {
            val entities = dao.getSummariesInRange(contactId, startDate, endDate)
            Result.success(entities.map { it.toDomain() })
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun getSummarizedDatesInRange(
        contactId: String,
        startDate: String,
        endDate: String
    ): Result<List<String>> = withContext(Dispatchers.IO) {
        try {
            val dates = dao.getSummarizedDatesInRange(contactId, startDate, endDate)
            Result.success(dates)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun deleteSummariesInRange(
        contactId: String,
        startDate: String,
        endDate: String
    ): Result<Int> = withContext(Dispatchers.IO) {
        try {
            val count = dao.deleteSummariesInRange(contactId, startDate, endDate)
            Result.success(count)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun getManualSummaries(
        contactId: String
    ): Result<List<DailySummary>> = withContext(Dispatchers.IO) {
        try {
            val entities = dao.getManualSummaries(contactId)
            Result.success(entities.map { it.toDomain() })
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    // ==================== æ˜ å°„å‡½æ•°æ‰©å±• ====================
    
    private fun DailySummary.toEntity(): DailySummaryEntity {
        return DailySummaryEntity(
            id = id,
            contactId = contactId,
            summaryDate = summaryDate,
            content = content,
            keyEventsJson = keyEventsAdapter.toJson(keyEvents),
            relationshipScore = relationshipScoreChange,
            createdAt = System.currentTimeMillis(),
            // æ–°å¢å­—æ®µ
            startDate = startDate,
            endDate = endDate,
            summaryType = summaryType.name,
            generationSource = generationSource.name,
            conversationCount = conversationCount,
            generatedAt = generatedAt
        )
    }
    
    private fun DailySummaryEntity.toDomain(): DailySummary {
        val keyEventsList = try {
            keyEventsAdapter.fromJson(keyEventsJson) ?: emptyList()
        } catch (e: Exception) {
            emptyList()
        }
        
        return DailySummary(
            id = id,
            contactId = contactId,
            summaryDate = summaryDate,
            content = content,
            keyEvents = keyEventsList,
            newFacts = emptyList(),
            updatedTags = emptyList(),
            relationshipScoreChange = relationshipScore,
            relationshipTrend = RelationshipTrend.STABLE,
            // æ–°å¢å­—æ®µ
            startDate = startDate,
            endDate = endDate,
            summaryType = SummaryType.valueOf(summaryType),
            generationSource = GenerationSource.valueOf(generationSource),
            conversationCount = conversationCount,
            generatedAt = generatedAt
        )
    }
}
```

---

## 6. AiSummaryProcessoræ‰©å±•

### 6.1 èŒƒå›´æ€»ç»“æ–¹æ³•æ‰©å±•

**æ–‡ä»¶ä½ç½®**ï¼š`domain/util/AiSummaryProcessor.kt`

```kotlin
@Singleton
class AiSummaryProcessor @Inject constructor(
    private val aiRepository: AiRepository,
    private val aiProviderRepository: AiProviderRepository,
    private val brainTagRepository: BrainTagRepository,
    private val promptBuilder: PromptBuilder
) {
    // ... å·²æœ‰å®ç° ...
    
    /**
     * å¤„ç†èŒƒå›´æ€»ç»“ï¼ˆæ‰‹åŠ¨è§¦å‘ï¼‰
     *
     * @param profile è”ç³»äººç”»åƒ
     * @param conversations å¯¹è¯åˆ—è¡¨
     * @param startDate å¼€å§‹æ—¥æœŸ
     * @param endDate ç»“æŸæ—¥æœŸ
     * @param progressCallback è¿›åº¦å›è°ƒ
     * @return æ€»ç»“ç»“æœ
     */
    suspend fun processForRange(
        profile: ContactProfile,
        conversations: List<ConversationLog>,
        startDate: String,
        endDate: String,
        progressCallback: ((Float) -> Unit)? = null
    ): Result<DailySummary> {
        return try {
            progressCallback?.invoke(0.1f)
            
            // è·å–é»˜è®¤AIæœåŠ¡å•†
            val provider = aiProviderRepository.getDefaultProvider().getOrNull()
                ?: return Result.failure(IllegalStateException("æœªé…ç½®é»˜è®¤AIæœåŠ¡å•†"))
            
            progressCallback?.invoke(0.2f)
            
            // è·å–è”ç³»äººæ ‡ç­¾
            val brainTags = brainTagRepository.getTagsForContact(profile.id).first()
            
            progressCallback?.invoke(0.3f)
            
            // æ„å»ºæç¤ºè¯ä¸Šä¸‹æ–‡
            val promptContext = PromptContext.fromContact(profile)
            val runtimeData = buildRangeSummaryRuntimeData(
                conversations = conversations,
                brainTags = brainTags,
                startDate = startDate,
                endDate = endDate
            )
            
            val systemInstruction = promptBuilder.buildSystemInstruction(
                scene = PromptScene.SUMMARY,
                contactId = profile.id,
                context = promptContext,
                runtimeData = runtimeData
            )
            
            progressCallback?.invoke(0.5f)
            
            // è°ƒç”¨AIç”Ÿæˆæ€»ç»“
            val aiResult = aiRepository.generateSummary(
                provider = provider,
                systemInstruction = systemInstruction,
                conversationContext = formatConversationsForAi(conversations)
            )
            
            progressCallback?.invoke(0.9f)
            
            aiResult.map { response ->
                parseSummaryResponse(
                    response = response,
                    contactId = profile.id,
                    summaryDate = endDate  // ä½¿ç”¨ç»“æŸæ—¥æœŸä½œä¸ºæ€»ç»“æ—¥æœŸ
                )
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * æ„å»ºèŒƒå›´æ€»ç»“çš„è¿è¡Œæ—¶æ•°æ®
     */
    private fun buildRangeSummaryRuntimeData(
        conversations: List<ConversationLog>,
        brainTags: List<BrainTag>,
        startDate: String,
        endDate: String
    ): String {
        return buildString {
            appendLine("ã€æ€»ç»“èŒƒå›´ã€‘")
            appendLine("$startDate è‡³ $endDate")
            appendLine()
            appendLine("ã€å¯¹è¯æ•°é‡ã€‘")
            appendLine("${conversations.size} æ¡å¯¹è¯")
            appendLine()
            appendLine("ã€å·²çŸ¥æ ‡ç­¾ã€‘")
            brainTags.forEach { tag ->
                val typeIcon = if (tag.type == TagType.RISK_RED) "ğŸ”´" else "ğŸŸ¢"
                appendLine("$typeIcon ${tag.content}")
            }
        }
    }
    
    /**
     * æ ¼å¼åŒ–å¯¹è¯è®°å½•ä¾›AIåˆ†æ
     */
    private fun formatConversationsForAi(conversations: List<ConversationLog>): String {
        return conversations.joinToString("\n\n") { log ->
            val timestamp = DateUtils.formatTimestamp(log.timestamp)
            "[$timestamp]\n${log.userInput}"
        }
    }
}
```


---

## 7. æµ‹è¯•ç­–ç•¥

### 7.1 å•å…ƒæµ‹è¯•

#### 7.1.1 DateRangeValidatoræµ‹è¯•

```kotlin
@Test
fun `éªŒè¯æœ‰æ•ˆæ—¥æœŸèŒƒå›´è¿”å›Valid`() = runTest {
    val validator = DateRangeValidator(mockContactRepository)
    val dateRange = DateRange.lastSevenDays()
    
    val result = validator.validate(dateRange, "contact-1")
    
    assertTrue(result.isSuccess)
    assertEquals(DateRangeValidator.ValidationResult.Valid, result.getOrNull())
}

@Test
fun `å¼€å§‹æ—¥æœŸæ™šäºç»“æŸæ—¥æœŸè¿”å›Invalid`() = runTest {
    val validator = DateRangeValidator(mockContactRepository)
    val dateRange = DateRange("2025-12-20", "2025-12-10")
    
    val result = validator.validate(dateRange, "contact-1")
    
    assertTrue(result.isSuccess)
    assertTrue(result.getOrNull() is DateRangeValidator.ValidationResult.Invalid)
}

@Test
fun `è¶…è¿‡30å¤©è¿”å›Warning`() = runTest {
    val validator = DateRangeValidator(mockContactRepository)
    val dateRange = DateRange("2025-11-01", "2025-12-15")
    
    val result = validator.validate(dateRange, "contact-1")
    
    assertTrue(result.isSuccess)
    assertTrue(result.getOrNull() is DateRangeValidator.ValidationResult.Warning)
}
```

#### 7.1.2 SummaryConflictCheckeræµ‹è¯•

```kotlin
@Test
fun `æ— å·²æœ‰æ€»ç»“è¿”å›NoConflict`() = runTest {
    coEvery { 
        mockRepository.getSummariesInRange(any(), any(), any()) 
    } returns Result.success(emptyList())
    
    val checker = SummaryConflictChecker(mockRepository)
    val result = checker.checkConflict("contact-1", DateRange.lastSevenDays())
    
    assertTrue(result.isSuccess)
    assertEquals(ConflictResult.NoConflict, result.getOrNull())
}

@Test
fun `æœ‰å·²æœ‰æ€»ç»“è¿”å›HasConflict`() = runTest {
    val existingSummaries = listOf(createTestSummary("2025-12-15"))
    coEvery { 
        mockRepository.getSummariesInRange(any(), any(), any()) 
    } returns Result.success(existingSummaries)
    
    val checker = SummaryConflictChecker(mockRepository)
    val result = checker.checkConflict("contact-1", DateRange.lastSevenDays())
    
    assertTrue(result.isSuccess)
    assertTrue(result.getOrNull() is ConflictResult.HasConflict)
}
```

#### 7.1.3 ManualSummaryUseCaseæµ‹è¯•

```kotlin
@Test
fun `æˆåŠŸç”Ÿæˆæ‰‹åŠ¨æ€»ç»“`() = runTest {
    // å‡†å¤‡æµ‹è¯•æ•°æ®
    coEvery { mockDateValidator.validate(any(), any()) } returns 
        Result.success(DateRangeValidator.ValidationResult.Valid)
    coEvery { mockContactRepository.getProfile(any()) } returns 
        Result.success(createTestProfile())
    coEvery { mockConversationRepository.getLogsByContactAndDate(any(), any()) } returns 
        Result.success(listOf(createTestConversation()))
    coEvery { mockAiProcessor.processForRange(any(), any(), any(), any(), any()) } returns 
        Result.success(createTestSummary())
    coEvery { mockSummaryRepository.saveSummary(any()) } returns Result.success(1L)
    coEvery { mockConversationRepository.markAsSummarized(any()) } returns Result.success(Unit)
    
    val useCase = ManualSummaryUseCase(...)
    val result = useCase(
        contactId = "contact-1",
        dateRange = DateRange.lastSevenDays()
    )
    
    assertTrue(result.isSuccess)
    assertNotNull(result.getOrNull())
}

@Test
fun `æ— å¯¹è¯æ•°æ®è¿”å›NoConversationsé”™è¯¯`() = runTest {
    coEvery { mockDateValidator.validate(any(), any()) } returns 
        Result.success(DateRangeValidator.ValidationResult.Valid)
    coEvery { mockContactRepository.getProfile(any()) } returns 
        Result.success(createTestProfile())
    coEvery { mockConversationRepository.getLogsByContactAndDate(any(), any()) } returns 
        Result.success(emptyList())
    
    val useCase = ManualSummaryUseCase(...)
    val result = useCase(
        contactId = "contact-1",
        dateRange = DateRange.lastSevenDays()
    )
    
    assertTrue(result.isFailure)
    assertTrue(result.exceptionOrNull() is SummaryException)
    assertEquals(
        SummaryError.NoConversations,
        (result.exceptionOrNull() as SummaryException).error
    )
}
```

### 7.2 é›†æˆæµ‹è¯•

#### 7.2.1 æ•°æ®åº“è¿ç§»æµ‹è¯•

```kotlin
@Test
fun `Migration_8_9_æ·»åŠ æ‰‹åŠ¨æ€»ç»“å­—æ®µ`() {
    helper.createDatabase(TEST_DB, 8).apply {
        execSQL("""
            INSERT INTO daily_summaries (id, contact_id, summary_date, content, key_events_json, relationship_score, created_at)
            VALUES (1, 'contact-1', '2025-12-15', 'test content', '[]', 5, 1734220800000)
        """)
        close()
    }
    
    helper.runMigrationsAndValidate(TEST_DB, 9, true, MIGRATION_8_9)
    
    val db = helper.openDatabase(TEST_DB, 9)
    val cursor = db.query("SELECT * FROM daily_summaries WHERE id = 1")
    cursor.moveToFirst()
    
    // éªŒè¯æ–°å­—æ®µæœ‰é»˜è®¤å€¼
    assertNull(cursor.getString(cursor.getColumnIndex("start_date")))
    assertNull(cursor.getString(cursor.getColumnIndex("end_date")))
    assertEquals("DAILY", cursor.getString(cursor.getColumnIndex("summary_type")))
    assertEquals("AUTO", cursor.getString(cursor.getColumnIndex("generation_source")))
    assertEquals(0, cursor.getInt(cursor.getColumnIndex("conversation_count")))
}
```

#### 7.2.2 UIé›†æˆæµ‹è¯•

```kotlin
@Test
fun `æ—¥æœŸé€‰æ‹©å™¨æ˜¾ç¤ºå¿«æ·é€‰é¡¹`() {
    composeTestRule.setContent {
        DateRangePickerDialog(
            selectedOption = QuickDateOption.LAST_7_DAYS,
            selectedRange = DateRange.lastSevenDays(),
            existingSummaryDates = emptyList(),
            validationError = null,
            onQuickOptionSelected = {},
            onCustomRangeSelected = { _, _ -> },
            onConfirm = {},
            onDismiss = {}
        )
    }
    
    composeTestRule.onNodeWithText("æœ€è¿‘7å¤©").assertIsDisplayed()
    composeTestRule.onNodeWithText("æœ¬æœˆ").assertIsDisplayed()
    composeTestRule.onNodeWithText("ä¸Šæœˆ").assertIsDisplayed()
    composeTestRule.onNodeWithText("æœ€è¿‘30å¤©").assertIsDisplayed()
}

@Test
fun `è¿›åº¦å¯¹è¯æ¡†æ˜¾ç¤ºæ­£ç¡®è¿›åº¦`() {
    val task = SummaryTask(
        contactId = "contact-1",
        startDate = "2025-12-10",
        endDate = "2025-12-15",
        status = SummaryTaskStatus.ANALYZING,
        progress = 0.5f,
        currentStep = "AIæ­£åœ¨åˆ†æå¯¹è¯å†…å®¹..."
    )
    
    composeTestRule.setContent {
        SummaryProgressDialog(
            task = task,
            onCancel = {}
        )
    }
    
    composeTestRule.onNodeWithText("50%").assertIsDisplayed()
    composeTestRule.onNodeWithText("AIæ­£åœ¨åˆ†æå¯¹è¯å†…å®¹...").assertIsDisplayed()
    composeTestRule.onNodeWithText("å–æ¶ˆ").assertIsDisplayed()
}
```

### 7.3 æµ‹è¯•è¦†ç›–è¦æ±‚

| æ¨¡å— | è¦†ç›–ç‡è¦æ±‚ | é‡ç‚¹æµ‹è¯•é¡¹ |
|------|-----------|-----------|
| DateRangeValidator | â‰¥ 90% | æ‰€æœ‰éªŒè¯è§„åˆ™ |
| SummaryConflictChecker | â‰¥ 90% | å†²çªæ£€æµ‹é€»è¾‘ |
| ManualSummaryUseCase | â‰¥ 85% | å®Œæ•´æµç¨‹ã€é”™è¯¯å¤„ç† |
| ManualSummaryViewModel | â‰¥ 80% | çŠ¶æ€è½¬æ¢ã€äº‹ä»¶å¤„ç† |
| UIç»„ä»¶ | â‰¥ 70% | äº¤äº’é€»è¾‘ã€æ˜¾ç¤ºæ­£ç¡®æ€§ |


---

## 8. æ€§èƒ½ä¼˜åŒ–è®¾è®¡

### 8.1 æ•°æ®åŠ è½½ä¼˜åŒ–

#### 8.1.1 åˆ†æ‰¹åŠ è½½ç­–ç•¥

```kotlin
/**
 * åˆ†æ‰¹åŠ è½½å¯¹è¯æ•°æ®
 */
suspend fun loadConversationsInBatches(
    contactId: String,
    dates: List<String>,
    batchSize: Int = 50,
    onProgress: (Float) -> Unit
): List<ConversationLog> {
    val allConversations = mutableListOf<ConversationLog>()
    val totalDates = dates.size
    
    dates.forEachIndexed { index, date ->
        val conversations = conversationRepository
            .getLogsByContactAndDate(contactId, date)
            .getOrNull() ?: emptyList()
        
        allConversations.addAll(conversations)
        
        // æ›´æ–°è¿›åº¦
        val progress = (index + 1).toFloat() / totalDates
        onProgress(progress)
        
        // è®©å‡ºCPUï¼Œé¿å…é˜»å¡
        yield()
    }
    
    return allConversations
}
```

#### 8.1.2 å†…å­˜ç®¡ç†

```kotlin
/**
 * å¤§æ•°æ®é‡å¤„ç†æ—¶çš„å†…å­˜ç®¡ç†
 */
private suspend fun processLargeDataset(
    conversations: List<ConversationLog>
): DailySummary {
    // åˆ†æ‰¹å¤„ç†ï¼Œæ¯æ‰¹æœ€å¤š100æ¡
    val batches = conversations.chunked(100)
    val partialResults = mutableListOf<PartialSummary>()
    
    batches.forEach { batch ->
        val partial = processBatch(batch)
        partialResults.add(partial)
        
        // ä¸»åŠ¨è§¦å‘GCï¼ˆä»…åœ¨å¤§æ•°æ®é‡æ—¶ï¼‰
        if (partialResults.size % 5 == 0) {
            System.gc()
        }
    }
    
    // åˆå¹¶ç»“æœ
    return mergePartialResults(partialResults)
}
```

### 8.2 UIæ€§èƒ½ä¼˜åŒ–

#### 8.2.1 è¿›åº¦æ›´æ–°èŠ‚æµ

```kotlin
/**
 * èŠ‚æµè¿›åº¦æ›´æ–°
 */
class ProgressThrottler(
    private val intervalMs: Long = 100
) {
    private var lastUpdateTime = 0L
    
    fun throttle(action: () -> Unit) {
        val now = System.currentTimeMillis()
        if (now - lastUpdateTime >= intervalMs) {
            action()
            lastUpdateTime = now
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
private val progressThrottler = ProgressThrottler(100)

fun updateProgress(progress: Float, step: String) {
    progressThrottler.throttle {
        _uiState.update {
            it.copy(
                task = it.task?.withProgress(progress, step)
            )
        }
    }
}
```

#### 8.2.2 Composeæ€§èƒ½ä¼˜åŒ–

```kotlin
/**
 * ä½¿ç”¨rememberä¼˜åŒ–é‡ç»„
 */
@Composable
fun SummaryProgressDialog(
    task: SummaryTask,
    onCancel: () -> Unit
) {
    // ç¼“å­˜è¿›åº¦ç™¾åˆ†æ¯”è®¡ç®—
    val progressPercent = remember(task.progress) {
        (task.progress * 100).toInt()
    }
    
    // ç¼“å­˜åŠ¨ç”»çŠ¶æ€
    val infiniteTransition = rememberInfiniteTransition(label = "progress")
    
    // ä½¿ç”¨derivedStateOfé¿å…ä¸å¿…è¦çš„é‡ç»„
    val canCancel by remember {
        derivedStateOf { task.status.isCancellable() }
    }
    
    // ... UIå®ç°
}
```

### 8.3 æ€§èƒ½æŒ‡æ ‡ç›‘æ§

```kotlin
/**
 * æ€§èƒ½ç›‘æ§å·¥å…·
 */
object SummaryPerformanceMonitor {
    private val metrics = mutableMapOf<String, Long>()
    
    fun startMeasure(tag: String) {
        metrics[tag] = System.currentTimeMillis()
    }
    
    fun endMeasure(tag: String): Long {
        val startTime = metrics.remove(tag) ?: return -1
        val duration = System.currentTimeMillis() - startTime
        Log.d("SummaryPerf", "$tag: ${duration}ms")
        return duration
    }
    
    inline fun <T> measure(tag: String, block: () -> T): T {
        startMeasure(tag)
        return try {
            block()
        } finally {
            endMeasure(tag)
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
val result = SummaryPerformanceMonitor.measure("AIåˆ†æ") {
    aiSummaryProcessor.processForRange(...)
}
```

---

## 9. é”™è¯¯å¤„ç†è®¾è®¡

### 9.1 é”™è¯¯æ¢å¤ç­–ç•¥

```kotlin
/**
 * é‡è¯•é…ç½®
 */
data class RetryConfig(
    val maxRetries: Int = 3,
    val initialDelayMs: Long = 1000,
    val maxDelayMs: Long = 10000,
    val multiplier: Double = 2.0
)

/**
 * å¸¦é‡è¯•çš„æ‰§è¡Œå™¨
 */
suspend fun <T> withRetry(
    config: RetryConfig = RetryConfig(),
    isRetryable: (Throwable) -> Boolean = { it is IOException },
    block: suspend () -> T
): T {
    var currentDelay = config.initialDelayMs
    var lastException: Throwable? = null
    
    repeat(config.maxRetries) { attempt ->
        try {
            return block()
        } catch (e: Throwable) {
            lastException = e
            if (!isRetryable(e) || attempt == config.maxRetries - 1) {
                throw e
            }
            
            Log.w("Retry", "å°è¯• ${attempt + 1} å¤±è´¥ï¼Œ${currentDelay}msåé‡è¯•", e)
            delay(currentDelay)
            currentDelay = (currentDelay * config.multiplier)
                .toLong()
                .coerceAtMost(config.maxDelayMs)
        }
    }
    
    throw lastException ?: IllegalStateException("é‡è¯•å¤±è´¥")
}
```

### 9.2 é™çº§å¤„ç†

```kotlin
/**
 * AIå¤±è´¥æ—¶çš„é™çº§å¤„ç†
 */
suspend fun processWithFallback(
    profile: ContactProfile,
    conversations: List<ConversationLog>,
    startDate: String,
    endDate: String
): DailySummary {
    // å°è¯•AIå¤„ç†
    val aiResult = try {
        withRetry(
            config = RetryConfig(maxRetries = 2),
            isRetryable = { it is IOException || it is SocketTimeoutException }
        ) {
            aiSummaryProcessor.processForRange(profile, conversations, startDate, endDate)
        }
    } catch (e: Exception) {
        Log.w(TAG, "AIå¤„ç†å¤±è´¥ï¼Œä½¿ç”¨é™çº§æ–¹æ¡ˆ", e)
        null
    }
    
    return aiResult?.getOrNull() ?: run {
        // é™çº§åˆ°æœ¬åœ°å¤„ç†
        localSummaryProcessor.processForRange(profile, conversations, startDate, endDate)
    }
}
```

---

## 10. å®‰å…¨è®¾è®¡

### 10.1 æ•°æ®å®‰å…¨

- **æ•æ„Ÿæ•°æ®è„±æ•**ï¼šå¯¹è¯å†…å®¹åœ¨å‘é€ç»™AIå‰ç»è¿‡PrivacyEngineè„±æ•
- **æœ¬åœ°å­˜å‚¨åŠ å¯†**ï¼šæ€»ç»“æ•°æ®å­˜å‚¨åœ¨Roomæ•°æ®åº“ï¼Œæ”¯æŒSQLCipheråŠ å¯†
- **APIå¯†é’¥ä¿æŠ¤**ï¼šä½¿ç”¨EncryptedSharedPreferenceså­˜å‚¨APIå¯†é’¥

### 10.2 å¹¶å‘å®‰å…¨

```kotlin
/**
 * ä»»åŠ¡å¹¶å‘æ§åˆ¶
 */
@Singleton
class SummaryTaskManager @Inject constructor() {
    private val activeTasks = ConcurrentHashMap<String, SummaryTask>()
    private val maxConcurrentTasks = 3
    
    /**
     * å°è¯•å¼€å§‹ä»»åŠ¡
     */
    fun tryStartTask(contactId: String, task: SummaryTask): Boolean {
        // æ£€æŸ¥åŒä¸€è”ç³»äººæ˜¯å¦æœ‰è¿›è¡Œä¸­çš„ä»»åŠ¡
        if (activeTasks.containsKey(contactId)) {
            return false
        }
        
        // æ£€æŸ¥å…¨å±€å¹¶å‘æ•°
        if (activeTasks.size >= maxConcurrentTasks) {
            return false
        }
        
        activeTasks[contactId] = task
        return true
    }
    
    /**
     * å®Œæˆä»»åŠ¡
     */
    fun completeTask(contactId: String) {
        activeTasks.remove(contactId)
    }
    
    /**
     * è·å–æ´»è·ƒä»»åŠ¡æ•°
     */
    fun getActiveTaskCount(): Int = activeTasks.size
}
```

---

## 11. ç›¸å…³æ–‡æ¡£

- [PRD-00011-æ‰‹åŠ¨è§¦å‘AIæ€»ç»“åŠŸèƒ½äº§å“éœ€æ±‚æ–‡æ¡£](../PRD/PRD-00011-æ‰‹åŠ¨è§¦å‘AIæ€»ç»“åŠŸèƒ½äº§å“éœ€æ±‚æ–‡æ¡£.md)
- [FD-00011-æ‰‹åŠ¨è§¦å‘AIæ€»ç»“åŠŸèƒ½è®¾è®¡](../FD/FD-00011-æ‰‹åŠ¨è§¦å‘AIæ€»ç»“åŠŸèƒ½è®¾è®¡.md)
- [Q&A-00011-æ‰‹åŠ¨è§¦å‘AIæ€»ç»“åŠŸèƒ½è®¨è®ºé—®é¢˜æ¸…å•](../Q&A/Q&A-00011-æ‰‹åŠ¨è§¦å‘AIæ€»ç»“åŠŸèƒ½è®¨è®ºé—®é¢˜æ¸…å•.md)
- [TDD-00003-è”ç³»äººç”»åƒè®°å¿†ç³»ç»ŸæŠ€æœ¯è®¾è®¡](./TDD-00003-è”ç³»äººç”»åƒè®°å¿†ç³»ç»ŸæŠ€æœ¯è®¾è®¡.md)

---

## 12. ä¿®è®¢å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | ä½œè€… | ä¿®æ”¹å†…å®¹ |
|------|------|------|----------|
| 1.0 | 2025-12-19 | Kiro | åˆå§‹ç‰ˆæœ¬ |

AIæ€»ç»“åŠŸèƒ½è®¨è®ºé—®é¢˜æ¸…å•.md)
- [TDD-00003-è”ç³»äººç”»åƒè®°å¿†ç³»ç»ŸæŠ€æœ¯è®¾è®¡](../TDD/TDD-00003-è”ç³»äººç”»åƒè®°å¿†ç³»ç»ŸæŠ€æœ¯è®¾è®¡.md)
- [TDD-00004-è”ç³»äººç”»åƒè®°å¿†ç³»ç»ŸUIæ¶æ„è®¾è®¡](../TDD/TDD-00004-è”ç³»äººç”»åƒè®°å¿†ç³»ç»ŸUIæ¶æ„è®¾è®¡.md)
- [TDD-00007-å¯¹è¯ä¸Šä¸‹æ–‡è¿ç»­æ€§å¢å¼ºæŠ€æœ¯è®¾è®¡](../TDD/TDD-00007-å¯¹è¯ä¸Šä¸‹æ–‡è¿ç»­æ€§å¢å¼ºæŠ€æœ¯è®¾è®¡.md)

---

## 12. å†…å­˜ç®¡ç†æœ€ä½³å®è·µ

### 12.1 å¼±å¼•ç”¨ä½¿ç”¨åœºæ™¯

åœ¨æ‰‹åŠ¨æ€»ç»“åŠŸèƒ½ä¸­ï¼Œä»¥ä¸‹åœºæ™¯å»ºè®®ä½¿ç”¨å¼±å¼•ç”¨ï¼š

#### 12.1.1 å¤§å¯¹è±¡ç¼“å­˜

```kotlin
/**
 * å¯¹è¯æ•°æ®ç¼“å­˜ï¼ˆä½¿ç”¨å¼±å¼•ç”¨é¿å…å†…å­˜æ³„æ¼ï¼‰
 */
class ConversationCache {
    // ä½¿ç”¨WeakReferenceç¼“å­˜å¤§é‡å¯¹è¯æ•°æ®
    private val cache = WeakHashMap<String, List<ConversationLog>>()
    
    fun get(key: String): List<ConversationLog>? = cache[key]
    
    fun put(key: String, conversations: List<ConversationLog>) {
        cache[key] = conversations
    }
    
    fun clear() {
        cache.clear()
    }
}
```

#### 12.1.2 å›è°ƒå¼•ç”¨

```kotlin
/**
 * è¿›åº¦å›è°ƒæŒæœ‰è€…ï¼ˆé¿å…Activity/Fragmentæ³„æ¼ï¼‰
 */
class ProgressCallbackHolder {
    private var callbackRef: WeakReference<ManualSummaryUseCase.ProgressCallback>? = null
    
    fun setCallback(callback: ManualSummaryUseCase.ProgressCallback) {
        callbackRef = WeakReference(callback)
    }
    
    fun notifyProgress(progress: Float, step: String) {
        callbackRef?.get()?.onProgress(progress, step)
    }
    
    fun clear() {
        callbackRef?.clear()
        callbackRef = null
    }
}
```

### 12.2 å†…å­˜ç›‘æ§

```kotlin
/**
 * å†…å­˜ä½¿ç”¨ç›‘æ§
 */
object MemoryMonitor {
    private const val TAG = "MemoryMonitor"
    private const val WARNING_THRESHOLD_MB = 50
    
    fun checkMemoryUsage(): MemoryStatus {
        val runtime = Runtime.getRuntime()
        val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024
        val maxMemory = runtime.maxMemory() / 1024 / 1024
        val availableMemory = maxMemory - usedMemory
        
        return when {
            availableMemory < WARNING_THRESHOLD_MB -> {
                Log.w(TAG, "å†…å­˜ä¸è¶³è­¦å‘Š: å¯ç”¨${availableMemory}MB")
                MemoryStatus.LOW
            }
            else -> MemoryStatus.NORMAL
        }
    }
    
    enum class MemoryStatus { NORMAL, LOW, CRITICAL }
}

// åœ¨å¤„ç†å¤§æ•°æ®å‰æ£€æŸ¥å†…å­˜
suspend fun processWithMemoryCheck(
    conversations: List<ConversationLog>
): Result<DailySummary> {
    if (MemoryMonitor.checkMemoryUsage() == MemoryMonitor.MemoryStatus.LOW) {
        // è§¦å‘GCå¹¶ç­‰å¾…
        System.gc()
        delay(100)
        
        // å†æ¬¡æ£€æŸ¥
        if (MemoryMonitor.checkMemoryUsage() == MemoryMonitor.MemoryStatus.LOW) {
            return Result.failure(
                SummaryException(SummaryError.Unknown("å†…å­˜ä¸è¶³ï¼Œè¯·å…³é—­å…¶ä»–åº”ç”¨åé‡è¯•"))
            )
        }
    }
    
    return processConversations(conversations)
}
```

### 12.3 èµ„æºé‡Šæ”¾

```kotlin
/**
 * ç¡®ä¿èµ„æºæ­£ç¡®é‡Šæ”¾
 */
class SummaryResourceManager : Closeable {
    private val resources = mutableListOf<Closeable>()
    
    fun <T : Closeable> register(resource: T): T {
        resources.add(resource)
        return resource
    }
    
    override fun close() {
        resources.forEach { resource ->
            try {
                resource.close()
            } catch (e: Exception) {
                Log.w("ResourceManager", "å…³é—­èµ„æºå¤±è´¥", e)
            }
        }
        resources.clear()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
suspend fun processWithResourceManagement(): Result<DailySummary> {
    return SummaryResourceManager().use { manager ->
        val cache = manager.register(ConversationCache())
        // ... å¤„ç†é€»è¾‘
    }
}
```

---

## 13. ä¿®è®¢å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | ä½œè€… | å˜æ›´è¯´æ˜ |
|------|------|------|----------|
| 1.0 | 2025-12-19 | Kiro | åˆå§‹ç‰ˆæœ¬ |
| 1.1 | 2025-12-19 | Kiro | æ ¹æ®DR-00011å®¡æŸ¥æŠ¥å‘Šä¼˜åŒ–ï¼šè¡¥å……æŠ€æœ¯æ–‡æ¡£äº¤å‰å¼•ç”¨ã€æ˜ç¡®Unknowné”™è¯¯ç±»å‹ä½¿ç”¨åœºæ™¯å’Œå¤„ç†æ–¹å¼ã€ç®€åŒ–V1ç‰ˆæœ¬SummaryTaskManagerè®¾è®¡ã€æ·»åŠ å†…å­˜ç®¡ç†æœ€ä½³å®è·µç« èŠ‚ |
