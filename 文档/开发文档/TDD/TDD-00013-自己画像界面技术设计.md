# TDD-00013: 自己画像界面技术设计

---
**文档类型**: TDD (Technical Design Document) - 开发过程文档  
**存放规范**: 符合项目宪法第IV条 - 文档规范  
**版本控制**: Git管理，见.commit钩子  
---

## 1. 文档信息

| 项目 | 内容 |
|------|------|
| 文档类型 | TDD (Technical Design Document) |
| 文档编号 | TDD-00013 |
| 功能名称 | 自己画像界面 |
| 版本 | 1.1 |
| 创建日期 | 2025-12-21 |
| 最后更新 | 2025-12-21 |
| 作者 | Kiro |
| 审核人 | 待定 |
| 关联文档 | PRD-00013, FD-00013 |

---

## 2. 技术概述

### 2.1 设计目标

为用户提供自我画像管理功能，并将画像信息集成到AI分析上下文中，实现个性化的AI建议。

### 2.2 技术约束

- 遵循Clean Architecture + MVVM架构
- 使用Jetpack Compose构建UI
- 使用Hilt进行依赖注入
- 数据本地加密存储，使用EncryptedSharedPreferences
- 与现有联系人画像系统保持一致性
- 遵循项目宪法隐私优先原则

### 2.3 架构概览

```
┌─────────────────────────────────────────────────────────────┐
│                     Presentation Layer                       │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ UserProfileScreen                                    │   │
│  │ ├── ProfileCompletenessCard                         │   │
│  │ ├── DimensionCard (基础维度)                        │   │
│  │ ├── CustomDimensionCard (自定义维度)                │   │
│  │ └── ExportProfileDialog (导出功能)                │   │
│  └─────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ UserProfileViewModel                                 │   │
│  │ ├── UserProfileUiState                              │   │
│  │ └── UserProfileUiEvent                              │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                       Domain Layer                           │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ UserProfile (领域模型) - 参考PRD-00013第7.1.1节   │   │
│  │ UserProfileDimension (枚举)                          │   │
│  └─────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ UserProfileRepository (接口)                         │   │
│  └─────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ GetUserProfileUseCase                                │   │
│  │ UpdateUserProfileUseCase                             │   │
│  │ UserProfileContextBuilder                            │   │
│  │ ExportProfileUseCase                                 │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                        Data Layer                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ UserProfileRepositoryImpl                            │   │
│  └─────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ UserProfilePreferences (EncryptedSharedPreferences) │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 数据层设计

### 3.1 领域模型

UserProfile领域模型定义请参考 PRD-00013-自己画像界面产品需求文档.md 第7.1.1节

### 3.2 存储设计

使用EncryptedSharedPreferences进行加密存储，确保用户隐私数据安全。具体实现请参考FD-00013第4.3节。

### 3.3 数据访问接口

```kotlin
/**
 * 用户画像仓库接口
 */
interface UserProfileRepository {
    suspend fun getUserProfile(): Result<UserProfile>
    suspend fun updateUserProfile(profile: UserProfile): Result<Unit>
    suspend fun clearUserProfile(): Result<Unit>
    suspend fun exportUserProfile(): Result<String>
    suspend fun importUserProfile(json: String): Result<Unit>
}
```

---

## 4. 业务层设计

### 4.1 用例设计

#### 4.1.1 获取用户画像用例

```kotlin
/**
 * 获取用户画像用例
 */
class GetUserProfileUseCase @Inject constructor(
    private val userProfileRepository: UserProfileRepository,
    private val userProfileCache: UserProfileCache
) {
    suspend operator fun invoke(forceRefresh: Boolean = false): Result<UserProfile> {
        // 1. 检查缓存
        if (!forceRefresh && userProfileCache.isValid()) {
            userProfileCache.get()?.let { return Result.success(it) }
        }
        
        // 2. 从存储加载
        val result = userProfileRepository.getUserProfile()
        
        // 3. 更新缓存
        if (result.isSuccess) {
            result.getOrNull()?.let { userProfileCache.set(it) }
        }
        
        return result
    }
}
```

#### 4.1.2 更新用户画像用例

```kotlin
/**
 * 更新用户画像用例
 */
class UpdateUserProfileUseCase @Inject constructor(
    private val userProfileRepository: UserProfileRepository,
    private val userProfileCache: UserProfileCache
) {
    suspend operator fun invoke(
        profile: UserProfile
    ): Result<UserProfile> {
        // 1. 更新存储
        val result = userProfileRepository.updateUserProfile(profile)
        
        // 2. 更新缓存
        if (result.isSuccess) {
            userProfileCache.set(profile)
        }
        
        return result.map { profile }
    }
}
```

#### 4.1.3 用户画像上下文构建器

```kotlin
/**
 * 用户画像上下文构建器
 * 增强算法，支持更复杂的匹配逻辑
 */
class UserProfileContextBuilder @Inject constructor(
    private val userProfileRepository: UserProfileRepository
) {
    /**
     * 构建包含用户画像的分析上下文
     * 添加错误处理确保上下文构建的稳定性
     */
    suspend fun buildAnalysisContext(
        contact: ContactProfile,
        userInput: String
    ): Result<String> {
        return try {
            val userProfileResult = userProfileRepository.getUserProfile()
            if (userProfileResult.isFailure) {
                return Result.failure(Exception("获取用户画像失败: ${userProfileResult.exceptionOrNull()?.message}"))
            }
            
            val userProfile = userProfileResult.getOrThrow()
            
            // 智能筛选相关信息
            val filteredProfile = filterRelevantProfileInfo(userProfile, userInput)
            
            val context = buildString {
                // 1. 用户画像信息（优先级最高）
                if (!filteredProfile.isEmpty()) {
                    appendLine("【用户画像（你的特点）】")
                    appendUserProfileSection(filteredProfile)
                    appendLine()
                }
                
                // 2. 联系人信息
                appendLine("【联系人信息】")
                appendContactSection(contact)
                appendLine()
                
                // 3. 用户输入的聊天记录
                appendLine("【用户提供的聊天记录】")
                appendLine(userInput)
            }
            
            Result.success(context)
        } catch (e: Exception) {
            Result.failure(Exception("构建分析上下文失败: ${e.message}", e))
        }
    }
    
    /**
     * 根据对话内容智能筛选相关的用户画像信息
     * 增强算法，支持更复杂的匹配逻辑
     */
    private fun filterRelevantProfileInfo(
        profile: UserProfile,
        chatContent: String
    ): UserProfile {
        // 1. 关键词匹配规则（基础匹配）
        val keywordRelevanceRules = mapOf(
            "工作" to listOf("values", "communicationStyle"),
            "职场" to listOf("values", "communicationStyle"),
            "同事" to listOf("values", "communicationStyle"),
            "朋友" to listOf("socialPreferences", "interests"),
            "聚会" to listOf("socialPreferences", "interests"),
            "家人" to listOf("values", "personalityTraits"),
            "父母" to listOf("values", "personalityTraits"),
            "约会" to listOf("interests", "communicationStyle", "personalityTraits"),
            "恋爱" to listOf("interests", "communicationStyle", "personalityTraits"),
            "学习" to listOf("interests", "personalityTraits"),
            "运动" to listOf("interests", "socialPreferences"),
            "旅行" to listOf("interests", "socialPreferences")
        )
        
        // 2. 情感分析匹配
        val emotionKeywords = mapOf(
            "开心" to listOf("personalityTraits", "interests"),
            "难过" to listOf("personalityTraits", "values"),
            "生气" to listOf("personalityTraits", "communicationStyle"),
            "焦虑" to listOf("personalityTraits", "socialPreferences"),
            "兴奋" to listOf("interests", "communicationStyle")
        )
        
        // 3. 场景匹配
        val scenarioKeywords = mapOf(
            "会议" to listOf("communicationStyle", "values"),
            "演讲" to listOf("communicationStyle", "personalityTraits"),
            "谈判" to listOf("communicationStyle", "values"),
            "面试" to listOf("communicationStyle", "values", "personalityTraits"),
            "聚餐" to listOf("socialPreferences", "interests"),
            "旅行" to listOf("interests", "socialPreferences"),
            "看电影" to listOf("interests", "socialPreferences")
        )
        
        // 合并所有匹配规则
        val allRelevanceRules = keywordRelevanceRules + emotionKeywords + scenarioKeywords
        
        // 4. 根据聊天内容匹配相关维度
        val relevantDimensions = mutableSetOf<String>()
        val chatContentLower = chatContent.lowercase()
        
        allRelevanceRules.forEach { (keyword, dimensions) ->
            if (chatContentLower.contains(keyword.lowercase())) {
                relevantDimensions.addAll(dimensions)
            }
        }
        
        // 5. 如果没有匹配到特定维度，返回完整画像
        if (relevantDimensions.isEmpty()) {
            return profile
        }
        
        // 6. 返回筛选后的画像
        return profile.copy(
            personalityTraits = if ("personalityTraits" in relevantDimensions) 
                profile.personalityTraits else emptyList(),
            values = if ("values" in relevantDimensions) 
                profile.values else emptyList(),
            interests = if ("interests" in relevantDimensions) 
                profile.interests else emptyList(),
            communicationStyle = if ("communicationStyle" in relevantDimensions) 
                profile.communicationStyle else emptyList(),
            socialPreferences = if ("socialPreferences" in relevantDimensions) 
                profile.socialPreferences else emptyList()
        )
    }
    
    private fun StringBuilder.appendUserProfileSection(profile: UserProfile) {
        if (profile.personalityTraits.isNotEmpty()) {
            appendLine("- 性格特点: ${profile.personalityTraits.joinToString("、")}")
        }
        if (profile.values.isNotEmpty()) {
            appendLine("- 价值观: ${profile.values.joinToString("、")}")
        }
        if (profile.interests.isNotEmpty()) {
            appendLine("- 兴趣爱好: ${profile.interests.joinToString("、")}")
        }
        if (profile.communicationStyle.isNotEmpty()) {
            appendLine("- 沟通风格: ${profile.communicationStyle.joinToString("、")}")
        }
        if (profile.socialPreferences.isNotEmpty()) {
            appendLine("- 社交偏好: ${profile.socialPreferences.joinToString("、")}")
        }
        // 自定义维度
        profile.customDimensions.forEach { (dimension, tags) ->
            if (tags.isNotEmpty()) {
                appendLine("- $dimension: ${tags.joinToString("、")}")
            }
        }
    }
    
    private fun StringBuilder.appendContactSection(contact: ContactProfile) {
        // 实现联系人信息展示逻辑
        appendLine("- 联系人: ${contact.name}")
        if (contact.facts.isNotEmpty()) {
            appendLine("- 联系人特点:")
            contact.facts.forEach { fact ->
                appendLine("  - ${fact.key}: ${fact.value}")
            }
        }
    }
}
```

---

## 5. 表现层设计

### 5.1 MVVM架构

使用Jetpack Compose + ViewModel构建UI，遵循单一数据源原则。

### 5.2 状态管理

使用StateFlow管理UI状态，确保UI响应式更新。

### 5.3 组件设计

采用组合式UI设计，将界面拆分为多个可复用组件。

---

## 6. 测试策略

### 6.1 测试范围

#### 6.1.1 单元测试

| 测试模块 | 测试重点 | 测试用例数 | 覆盖率目标 |
|---------|---------|-----------|-----------|
| UserProfileRepository | 数据存储、读取、加密 | 12 | 95% |
| UseCase类 | 业务逻辑、错误处理 | 15 | 95% |
| UserProfileContextBuilder | 上下文构建、智能筛选 | 10 | 95% |
| ViewModel | 状态管理、事件处理 | 8 | 95% |
| 领域模型 | 数据验证、业务规则 | 10 | 100% |

#### 6.1.2 集成测试

| 测试模块 | 测试重点 | 测试用例数 |
|---------|---------|-----------|
| AI上下文集成 | 上下文构建、筛选逻辑 | 15 |
| 数据持久化 | 存储、读取、迁移 | 12 |
| 设置页面集成 | 入口导航、状态同步 | 8 |
| 悬浮窗集成 | 画像信息传递 | 10 |
| Repository与存储 | 数据持久化、加密 | 6 |
| UseCase与Repository | 业务流程 | 8 |
| ViewModel与UseCase | UI交互 | 5 |

##### 集成测试重点
- **AI上下文集成测试**：验证用户画像与AI分析系统的集成效果，测试智能筛选算法的准确性
- **数据持久化测试**：验证加密存储的可靠性，测试数据迁移和恢复功能
- **系统集成测试**：确保用户画像功能与现有系统组件的无缝集成

#### 6.1.3 UI测试

| 测试模块 | 测试重点 | 测试用例数 |
|---------|---------|-----------|
| 用户画像界面 | 界面渲染、交互 | 10 |
| 标签操作 | 添加、编辑、删除 | 8 |
| 维度管理 | 添加、删除自定义维度 | 6 |
| 导出功能 | 导出流程、格式验证 | 4 |

### 6.2 测试工具

| 测试类型 | 工具 | 版本 |
|---------|------|------|
| 单元测试 | JUnit | 4.13.2 |
| Mock框架 | MockK | 1.13.13 |
| 协程测试 | kotlinx-coroutines-test | 1.7.3 |
| UI测试 | Compose UI Test | 1.5.4 |
| 集成测试 | AndroidX Test | 1.5.0 |

### 6.3 测试数据管理

使用测试专用的EncryptedSharedPreferences实例，确保测试数据隔离。

### 6.4 性能测试

| 测试指标 | 目标值 | 测量方法 |
|---------|--------|----------|
| 界面加载时间 | < 300ms | Compose测试计时 |
| 标签操作响应 | < 100ms | UI测试计时 |
| 数据保存时间 | < 200ms | 单元测试计时 |
| 内存占用 | < 5MB | 内存分析工具 |

### 6.5 测试自动化

配置CI/CD流水线，实现：
- 每次提交自动运行单元测试
- 每日构建运行集成测试
- 每周运行完整UI测试套件

---

## 7. 安全设计

### 7.1 数据加密

使用EncryptedSharedPreferences确保敏感数据安全，符合项目宪法隐私优先原则。

### 7.2 异常处理

所有数据操作添加异常处理，确保应用稳定性。

### 7.3 权限控制

仅使用必要的系统权限，最小化权限申请。

---

## 8. 性能优化

### 8.1 内存优化策略

#### 8.1.1 对象池复用
```kotlin
/**
 * 用户画像内存优化策略
 */
@Singleton
class UserProfileMemoryOptimizer @Inject constructor() {
    // 1. 对象池复用
    private val tagPool = mutableMapOf<String, Tag>()

    // 2. 懒加载自定义维度
    private val customDimensionsLazy = lazy {
        loadCustomDimensions()
    }

    // 3. 定期清理缓存
    private val cleanupJob = CoroutineScope(Dispatchers.IO).launch {
        while(isActive) {
            delay(30_000) // 30秒
            cleanupExpiredCache()
        }
    }
}
```

#### 8.1.2 内存监控
- **内存阈值监控**：当内存使用超过80%时自动清理缓存
- **对象生命周期管理**：使用WeakReference避免内存泄漏
- **GC优化**：减少临时对象创建，降低GC压力

### 8.2 数据缓存

#### 8.2.1 多级缓存策略
- **L1缓存**：内存缓存，存储最新画像数据，有效期1分钟
- **L2缓存**：磁盘缓存，存储序列化数据，有效期10分钟
- **L3缓存**：EncryptedSharedPreferences，持久化存储

#### 8.2.2 缓存失效策略
- **时间失效**：基于TTL的自动失效
- **版本失效**：数据版本变更时主动失效
- **内存压力失效**：内存不足时LRU淘汰

### 8.3 懒加载优化

#### 8.3.1 分层加载策略
- **首屏优先**：基础维度数据优先加载
- **渐进加载**：自定义维度数据滚动到可视区域时加载
- **预测加载**：根据用户行为预测可能需要的维度

#### 8.3.2 异步加载机制
- **协程优化**：使用Dispatchers.IO避免阻塞主线程
- **并发控制**：限制并发加载数量，避免资源竞争
- **取消机制**：页面销毁时及时取消加载任务

### 8.4 UI优化

#### 8.4.1 Compose性能优化
- **remember优化**：合理使用remember缓存计算结果
- **derivedStateOf**：使用derivedStateOf避免不必要的重组
- **key参数**：为LazyColumn提供稳定的key，优化重组性能

#### 8.4.2 渲染优化
- **虚拟化列表**：使用LazyColumn处理大量标签数据
- **差异更新**：使用DiffUtil优化列表更新性能
- **动画优化**：使用硬件加速，减少动画卡顿

### 8.5 存储优化

#### 8.5.1 加密存储优化
- **批量操作**：合并多个小操作为单次批量操作
- **压缩存储**：对大量标签数据进行压缩存储
- **增量更新**：只更新变化的数据部分

#### 8.5.2 I/O优化
- **异步I/O**：所有存储操作使用异步执行
- **缓存写入**：采用写入缓存，定期批量持久化
- **错误恢复**：I/O失败时的降级策略

---

## 9. 部署策略

### 9.1 渐进式发布

采用功能开关控制，支持渐进式发布和快速回滚。

### 9.2 兼容性

确保与现有功能完全兼容，不影响现有用户体验。

### 9.3 监控

实现关键指标监控，及时发现问题并优化。

---

## 10. 风险评估

### 10.1 技术风险

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| 加密存储性能影响 | 中 | 中 | 性能测试，优化策略 |
| 智能筛选算法复杂度 | 中 | 中 | 算法优化，性能监控 |
| 与现有系统集成 | 低 | 高 | 充分测试，渐进式发布 |

### 10.2 缓解措施

1. 完善的测试覆盖
2. 渐进式发布策略
3. 实时性能监控
4. 快速回滚机制

---

## 11. 附录

### 11.1 参考文档

- [PRD-00013-自己画像界面产品需求文档](../PRD/PRD-00013-自己画像界面产品需求文档.md)
- [FD-00013-自己画像界面功能设计](../FD/FD-00013-自己画像界面功能设计.md)
- [TDD-00003-联系人画像记忆系统架构设计](../TDD/TDD-00003-联系人画像记忆系统架构设计.md)

### 11.2 变更记录

| 版本 | 日期 | 变更内容 | 变更人 |
|------|------|----------|--------|
| v1.0 | 2025-12-21 | 初始版本 | Kiro |
| v1.1 | 2025-12-21 | 统一架构描述；补充测试策略章节；增强智能筛选算法；修复宪法对齐问题 | Kiro |

---

**文档结束**