# TDD-00024: å›¾æ ‡å’Œç‰ˆæœ¬å·è‡ªåŠ¨æ›´æ–°æŠ€æœ¯è®¾è®¡

## 1. æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| æ–‡æ¡£ç±»å‹ | TDD (Technical Design Document) |
| æ–‡æ¡£ç¼–å· | TDD-00024 |
| åŠŸèƒ½åç§° | å›¾æ ‡å’Œç‰ˆæœ¬å·è‡ªåŠ¨æ›´æ–°æŠ€æœ¯è®¾è®¡ |
| ç‰ˆæœ¬ | 1.1 |
| åˆ›å»ºæ—¥æœŸ | 2025-12-31 |
| æœ€åæ›´æ–° | 2025-12-31 |
| ä½œè€… | Kiro |
| å®¡æ ¸äºº | Roo |
| å®¡æ ¸çŠ¶æ€ | âœ… é€šè¿‡ |
| å…³è”æ–‡æ¡£ | PRD-00024, FD-00024 |

### 1.1 ç‰ˆæœ¬å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | ä½œè€… | å˜æ›´è¯´æ˜ |
|------|------|------|----------|
| 1.0 | 2025-12-31 | Kiro | åˆå§‹ç‰ˆæœ¬ï¼ŒåŒ…å«ç‰ˆæœ¬å·è‡ªåŠ¨æ›´æ–°ã€å›¾æ ‡åˆ‡æ¢ã€Gradleä»»åŠ¡çš„å®Œæ•´æŠ€æœ¯è®¾è®¡ |
| 1.1 | 2025-12-31 | Kiro | æ ¹æ®DR-00024å®¡æŸ¥æŠ¥å‘Šæ”¹è¿›ï¼šæ·»åŠ Gradle Configuration Cacheæ”¯æŒã€å›¾æ ‡èµ„æºåˆå§‹åŒ–æ£€æŸ¥ã€ç‰ˆæœ¬å·åŒæ­¥æ‰©å±•æ€§è®¾è®¡ |

### 1.2 æŠ€æœ¯æ ˆ

| æŠ€æœ¯é¢†åŸŸ | æŠ€æœ¯é€‰æ‹© | ç‰ˆæœ¬ | ç”¨é€” |
|---------|----------|------|------|
| æ„å»ºå·¥å…· | Gradle | 8.13 | æ„å»ºç³»ç»Ÿå’Œä»»åŠ¡ç®¡ç† |
| æ„å»ºè„šæœ¬ | Kotlin DSL | - | æ„å»ºè„šæœ¬è¯­è¨€ |
| AGP | Android Gradle Plugin | 8.7.3 | Androidæ„å»ºæ”¯æŒ |
| ç¼–ç¨‹è¯­è¨€ | Kotlin | 2.0.21 | buildSrcæ¨¡å—å®ç° |
| JSONåºåˆ—åŒ– | kotlinx.serialization | 1.6.0 | é…ç½®æ–‡ä»¶è§£æ |
| ç‰ˆæœ¬æ§åˆ¶ | Git | 2.30+ | æäº¤ä¿¡æ¯åˆ†æ |

---

## 2. æ¶æ„æ¦‚è¿°

### 2.1 è®¾è®¡ç›®æ ‡

å®ç°åŸºäºGradleä»»åŠ¡çš„ç‰ˆæœ¬å·è‡ªåŠ¨é€’å¢å’Œå›¾æ ‡åˆ‡æ¢åŠŸèƒ½ï¼Œæ”¯æŒCI/CDé›†æˆã€‚

**æ ¸å¿ƒç›®æ ‡**ï¼š
- ç‰ˆæœ¬å·è‡ªåŠ¨é€’å¢ï¼šåŸºäºGitæäº¤ä¿¡æ¯è‡ªåŠ¨è®¡ç®—è¯­ä¹‰åŒ–ç‰ˆæœ¬å·
- å›¾æ ‡è‡ªåŠ¨åˆ‡æ¢ï¼šæ ¹æ®å‘å¸ƒé˜¶æ®µï¼ˆdev/test/beta/productionï¼‰åˆ‡æ¢åº”ç”¨å›¾æ ‡
- å¤šæ¨¡å—åŒæ­¥ï¼šç¡®ä¿Clean Architectureå¤šæ¨¡å—æ¶æ„ä¸‹ç‰ˆæœ¬å·ä¸€è‡´æ€§
- å¤‡ä»½ä¸å›æ»šï¼šæä¾›å®Œå–„çš„å¤‡ä»½å’Œå›æ»šæœºåˆ¶

### 2.2 è®¾è®¡åŸåˆ™

- **è‡ªåŠ¨åŒ–ä¼˜å…ˆ**ï¼šå‡å°‘äººå·¥å¹²é¢„ï¼Œé€šè¿‡Gitæäº¤ä¿¡æ¯è‡ªåŠ¨åˆ¤æ–­ç‰ˆæœ¬å˜æ›´
- **å®‰å…¨å¯é **ï¼šæ“ä½œå‰è‡ªåŠ¨å¤‡ä»½ï¼Œå¤±è´¥æ—¶è‡ªåŠ¨å›æ»š
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒè‡ªå®šä¹‰æäº¤ç±»å‹å’Œç‰ˆæœ¬è§„åˆ™
- **CI/CDå‹å¥½**ï¼šæ”¯æŒå‘½ä»¤è¡Œå‚æ•°ï¼Œä¾¿äºé›†æˆåˆ°è‡ªåŠ¨åŒ–æµç¨‹

---

## 3. æ•´ä½“æ¶æ„è®¾è®¡

### 3.1 ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ç‰ˆæœ¬æ›´æ–°ç³»ç»Ÿæ¶æ„                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚   Gitä»“åº“   â”‚â”€â”€â”€â–¶â”‚  æäº¤åˆ†æå™¨  â”‚â”€â”€â”€â–¶â”‚  ç‰ˆæœ¬è®¡ç®—å™¨  â”‚         â”‚
â”‚  â”‚  Commits    â”‚    â”‚ CommitParserâ”‚    â”‚VersionCalc â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                               â”‚                 â”‚
â”‚                                               â–¼                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  é…ç½®æ–‡ä»¶   â”‚â—€â”€â”€â”€â”‚  ç‰ˆæœ¬æ›´æ–°å™¨  â”‚â—€â”€â”€â”€â”‚  å‘å¸ƒé˜¶æ®µ   â”‚         â”‚
â”‚  â”‚ gradle.prop â”‚    â”‚VersionUpdateâ”‚    â”‚ ReleaseStageâ”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                            â”‚                                    â”‚
â”‚                            â–¼                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  å›¾æ ‡èµ„æº   â”‚â—€â”€â”€â”€â”‚  å›¾æ ‡åˆ‡æ¢å™¨  â”‚â”€â”€â”€â–¶â”‚  å¤‡ä»½ç®¡ç†å™¨  â”‚         â”‚
â”‚  â”‚ mipmap-*    â”‚    â”‚ IconSwitcherâ”‚    â”‚ BackupMgr  â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 æ¨¡å—èŒè´£åˆ†é…

| æ¨¡å— | èŒè´£ | è¾“å…¥ | è¾“å‡º |
|------|------|------|------|
| CommitParser | è§£æGitæäº¤ä¿¡æ¯ | Git log | å˜æ›´ç±»å‹åˆ—è¡¨ |
| VersionCalculator | è®¡ç®—æ–°ç‰ˆæœ¬å· | å½“å‰ç‰ˆæœ¬+å˜æ›´ç±»å‹ | æ–°ç‰ˆæœ¬å· |
| VersionManager | æ›´æ–°ç‰ˆæœ¬é…ç½® | æ–°ç‰ˆæœ¬å· | æ›´æ–°åçš„é…ç½®æ–‡ä»¶ |
| IconManager | åˆ‡æ¢åº”ç”¨å›¾æ ‡ | å‘å¸ƒé˜¶æ®µ | æ›´æ–°åçš„å›¾æ ‡èµ„æº |
| BackupManager | ç®¡ç†å¤‡ä»½å’Œå›æ»š | åŸå§‹æ–‡ä»¶ | å¤‡ä»½æ–‡ä»¶ |

### 3.3 æ–‡ä»¶ç»“æ„è®¾è®¡

```
project/
â”œâ”€â”€ buildSrc/                           # Gradleæ„å»ºé€»è¾‘
â”‚   â”œâ”€â”€ build.gradle.kts
â”‚   â””â”€â”€ src/main/kotlin/
â”‚       â””â”€â”€ com/empathy/ai/build/
â”‚           â”œâ”€â”€ VersionManager.kt       # ç‰ˆæœ¬ç®¡ç†æ ¸å¿ƒç±»
â”‚           â”œâ”€â”€ CommitParser.kt         # Gitæäº¤è§£æå™¨
â”‚           â”œâ”€â”€ IconManager.kt          # å›¾æ ‡ç®¡ç†å™¨
â”‚           â”œâ”€â”€ BackupManager.kt        # å¤‡ä»½ç®¡ç†å™¨
â”‚           â”œâ”€â”€ ReleaseStage.kt         # å‘å¸ƒé˜¶æ®µæšä¸¾
â”‚           â”œâ”€â”€ SemanticVersion.kt      # è¯­ä¹‰åŒ–ç‰ˆæœ¬æ•°æ®ç±»
â”‚           â”œâ”€â”€ VersionCalculator.kt    # ç‰ˆæœ¬è®¡ç®—å™¨
â”‚           â””â”€â”€ VersionUpdatePlugin.kt  # Gradleæ’ä»¶å…¥å£
â”œâ”€â”€ config/                             # é…ç½®æ–‡ä»¶ç›®å½•
â”‚   â”œâ”€â”€ version-config.json             # ç‰ˆæœ¬é…ç½®
â”‚   â”œâ”€â”€ version-history.json            # ç‰ˆæœ¬å†å²
â”‚   â””â”€â”€ icon-mapping.json               # å›¾æ ‡æ˜ å°„é…ç½®
â”œâ”€â”€ assets/                             # å›¾æ ‡èµ„æºç›®å½•
â”‚   â””â”€â”€ icons/
â”‚       â”œâ”€â”€ dev/                        # å¼€å‘ç‰ˆå›¾æ ‡
â”‚       â”œâ”€â”€ test/                       # æµ‹è¯•ç‰ˆå›¾æ ‡
â”‚       â”œâ”€â”€ beta/                       # é¢„å‘å¸ƒç‰ˆå›¾æ ‡
â”‚       â””â”€â”€ production/                 # æ­£å¼ç‰ˆå›¾æ ‡
â”œâ”€â”€ backups/                            # å¤‡ä»½ç›®å½•
â”‚   â””â”€â”€ version-update/
â”œâ”€â”€ gradle.properties                   # ç‰ˆæœ¬å·å®šä¹‰ï¼ˆç»Ÿä¸€ç‰ˆæœ¬æºï¼‰
â””â”€â”€ app/
    â””â”€â”€ src/main/res/
        â””â”€â”€ mipmap-*/                   # åº”ç”¨å›¾æ ‡
```

---

## 4. è¯¦ç»†è®¾è®¡

### 4.1 æ•°æ®æ¨¡å‹è®¾è®¡

#### 4.1.1 SemanticVersionæ•°æ®ç±»

**æ–‡ä»¶ä½ç½®**ï¼š`buildSrc/src/main/kotlin/com/empathy/ai/build/SemanticVersion.kt`

```kotlin
/**
 * è¯­ä¹‰åŒ–ç‰ˆæœ¬æ•°æ®ç±»
 * éµå¾ª Semantic Versioning 2.0.0 è§„èŒƒ
 *
 * @property major ä¸»ç‰ˆæœ¬å· - ä¸å…¼å®¹çš„APIä¿®æ”¹
 * @property minor æ¬¡ç‰ˆæœ¬å· - å‘ä¸‹å…¼å®¹çš„åŠŸèƒ½æ€§æ–°å¢
 * @property patch ä¿®è®¢å· - å‘ä¸‹å…¼å®¹çš„é—®é¢˜ä¿®æ­£
 * @property prerelease é¢„å‘å¸ƒæ ‡è¯† - dev/alpha/beta/rc
 * @property build æ„å»ºå…ƒæ•°æ® - æ—¶é—´æˆ³æˆ–Git SHA
 */
data class SemanticVersion(
    val major: Int,
    val minor: Int,
    val patch: Int,
    val prerelease: String? = null,
    val build: String? = null
) {
    /**
     * é€’å¢ä¸»ç‰ˆæœ¬å·ï¼Œé‡ç½®æ¬¡ç‰ˆæœ¬å·å’Œä¿®è®¢å·
     */
    fun bumpMajor() = copy(major = major + 1, minor = 0, patch = 0)
    
    /**
     * é€’å¢æ¬¡ç‰ˆæœ¬å·ï¼Œé‡ç½®ä¿®è®¢å·
     */
    fun bumpMinor() = copy(minor = minor + 1, patch = 0)
    
    /**
     * é€’å¢ä¿®è®¢å·
     */
    fun bumpPatch() = copy(patch = patch + 1)
    
    /**
     * è½¬æ¢ä¸ºå­—ç¬¦ä¸²æ ¼å¼
     */
    override fun toString(): String {
        val base = "$major.$minor.$patch"
        val pre = prerelease?.let { "-$it" } ?: ""
        val bld = build?.let { "+$it" } ?: ""
        return "$base$pre$bld"
    }
    
    /**
     * è®¡ç®—versionCode
     * å…¬å¼: major*10000 + minor*100 + patch
     */
    fun toVersionCode(): Int = major * 10000 + minor * 100 + patch
    
    companion object {
        /**
         * ä»å­—ç¬¦ä¸²è§£æç‰ˆæœ¬å·
         * @param version ç‰ˆæœ¬å­—ç¬¦ä¸²ï¼Œå¦‚ "1.2.3-beta.1+20251231"
         * @return SemanticVersionå®ä¾‹
         * @throws IllegalArgumentException ç‰ˆæœ¬æ ¼å¼æ— æ•ˆæ—¶æŠ›å‡º
         */
        fun parse(version: String): SemanticVersion {
            val regex = """(\d+)\.(\d+)\.(\d+)(?:-([^+]+))?(?:\+(.+))?""".toRegex()
            val match = regex.matchEntire(version)
                ?: throw IllegalArgumentException("Invalid version: $version")
            
            return SemanticVersion(
                major = match.groupValues[1].toInt(),
                minor = match.groupValues[2].toInt(),
                patch = match.groupValues[3].toInt(),
                prerelease = match.groupValues[4].takeIf { it.isNotEmpty() },
                build = match.groupValues[5].takeIf { it.isNotEmpty() }
            )
        }
    }
}
```

#### 4.1.2 ReleaseStageæšä¸¾

**æ–‡ä»¶ä½ç½®**ï¼š`buildSrc/src/main/kotlin/com/empathy/ai/build/ReleaseStage.kt`

```kotlin
/**
 * å‘å¸ƒé˜¶æ®µæšä¸¾
 * å®šä¹‰åº”ç”¨çš„ä¸åŒå‘å¸ƒé˜¶æ®µåŠå…¶å¯¹åº”çš„å›¾æ ‡é…ç½®
 *
 * @property displayName æ˜¾ç¤ºåç§°
 * @property iconSuffix å›¾æ ‡ç›®å½•åç¼€
 * @property badgeText è§’æ ‡æ–‡å­—ï¼ˆæ­£å¼ç‰ˆä¸ºnullï¼‰
 * @property badgeColor è§’æ ‡é¢œè‰²
 */
enum class ReleaseStage(
    val displayName: String,
    val iconSuffix: String,
    val badgeText: String?,
    val badgeColor: String
) {
    DEV(
        displayName = "å¼€å‘ç‰ˆ",
        iconSuffix = "dev",
        badgeText = "DEV",
        badgeColor = "#FF9800"  // æ©™è‰²
    ),
    TEST(
        displayName = "æµ‹è¯•ç‰ˆ",
        iconSuffix = "test",
        badgeText = "TEST",
        badgeColor = "#2196F3"  // è“è‰²
    ),
    BETA(
        displayName = "é¢„å‘å¸ƒç‰ˆ",
        iconSuffix = "beta",
        badgeText = "BETA",
        badgeColor = "#9C27B0"  // ç´«è‰²
    ),
    PRODUCTION(
        displayName = "æ­£å¼ç‰ˆ",
        iconSuffix = "production",
        badgeText = null,       // æ­£å¼ç‰ˆæ— æ ‡è¯†
        badgeColor = "#4CAF50"  // ç»¿è‰²
    );
    
    companion object {
        /**
         * ä»å­—ç¬¦ä¸²è§£æå‘å¸ƒé˜¶æ®µ
         * @param value é˜¶æ®µåç§°æˆ–åç¼€
         * @return å¯¹åº”çš„ReleaseStageï¼Œé»˜è®¤è¿”å›PRODUCTION
         */
        fun fromString(value: String): ReleaseStage {
            return entries.find { 
                it.name.equals(value, ignoreCase = true) ||
                it.iconSuffix.equals(value, ignoreCase = true)
            } ?: PRODUCTION
        }
    }
}
```

#### 4.1.3 CommitTypeæšä¸¾

**æ–‡ä»¶ä½ç½®**ï¼š`buildSrc/src/main/kotlin/com/empathy/ai/build/CommitType.kt`

```kotlin
/**
 * æäº¤ç±»å‹æšä¸¾
 * åŸºäº Conventional Commits è§„èŒƒå®šä¹‰
 *
 * @property prefix æäº¤å‰ç¼€
 * @property versionBump ç‰ˆæœ¬å˜æ›´ç±»å‹
 * @property description ç±»å‹æè¿°
 */
enum class CommitType(
    val prefix: String,
    val versionBump: VersionBump,
    val description: String
) {
    // Majorç‰ˆæœ¬é€’å¢
    BREAKING_CHANGE("feat!", VersionBump.MAJOR, "ç ´åæ€§å˜æ›´"),
    BREAKING_FIX("fix!", VersionBump.MAJOR, "ç ´åæ€§ä¿®å¤"),
    
    // Minorç‰ˆæœ¬é€’å¢
    FEATURE("feat", VersionBump.MINOR, "æ–°åŠŸèƒ½"),
    
    // Patchç‰ˆæœ¬é€’å¢
    FIX("fix", VersionBump.PATCH, "Bugä¿®å¤"),
    PERF("perf", VersionBump.PATCH, "æ€§èƒ½ä¼˜åŒ–"),
    
    // ä¸å½±å“ç‰ˆæœ¬å·
    DOCS("docs", VersionBump.NONE, "æ–‡æ¡£æ›´æ–°"),
    STYLE("style", VersionBump.NONE, "ä»£ç æ ¼å¼"),
    REFACTOR("refactor", VersionBump.NONE, "ä»£ç é‡æ„"),
    TEST("test", VersionBump.NONE, "æµ‹è¯•ç›¸å…³"),
    CHORE("chore", VersionBump.NONE, "æ„å»º/å·¥å…·"),
    CI("ci", VersionBump.NONE, "CIé…ç½®");
    
    companion object {
        /**
         * ä»æäº¤æ¶ˆæ¯è§£ææäº¤ç±»å‹
         */
        fun fromMessage(message: String): CommitType? {
            val lowerMessage = message.lowercase()
            return entries.find { type ->
                lowerMessage.startsWith(type.prefix.lowercase())
            }
        }
    }
}

/**
 * ç‰ˆæœ¬å˜æ›´ç±»å‹
 */
enum class VersionBump {
    MAJOR, MINOR, PATCH, NONE
}
```



---

### 4.2 æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### 4.2.1 CommitParseræäº¤è§£æå™¨

**æ–‡ä»¶ä½ç½®**ï¼š`buildSrc/src/main/kotlin/com/empathy/ai/build/CommitParser.kt`

```kotlin
/**
 * Gitæäº¤ä¿¡æ¯è§£æå™¨
 * è§£æè‡ªä¸Šæ¬¡å‘å¸ƒä»¥æ¥çš„æ‰€æœ‰æäº¤ï¼Œæå–å˜æ›´ç±»å‹
 */
class CommitParser(private val projectDir: File) {
    
    companion object {
        private const val TAG_PREFIX = "v"
    }
    
    /**
     * è§£æè‡ªä¸Šæ¬¡æ ‡ç­¾ä»¥æ¥çš„æ‰€æœ‰æäº¤
     * @return è§£æåçš„æäº¤åˆ—è¡¨
     */
    fun parseCommitsSinceLastTag(): List<ParsedCommit> {
        val lastTag = getLastTag() ?: return emptyList()
        val commits = getCommitsSince(lastTag)
        return commits.mapNotNull { parseCommitMessage(it) }
    }
    
    /**
     * è·å–æœ€è¿‘çš„ç‰ˆæœ¬æ ‡ç­¾
     */
    private fun getLastTag(): String? {
        return try {
            val process = ProcessBuilder("git", "describe", "--tags", "--abbrev=0")
                .directory(projectDir)
                .redirectErrorStream(true)
                .start()
            
            val output = process.inputStream.bufferedReader().readText().trim()
            process.waitFor()
            
            if (process.exitValue() == 0) output else null
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * è·å–æŒ‡å®šæ ‡ç­¾ä¹‹åçš„æ‰€æœ‰æäº¤
     */
    private fun getCommitsSince(tag: String): List<String> {
        return try {
            val process = ProcessBuilder(
                "git", "log", "$tag..HEAD", "--oneline", "--no-merges"
            )
                .directory(projectDir)
                .redirectErrorStream(true)
                .start()
            
            val output = process.inputStream.bufferedReader().readLines()
            process.waitFor()
            
            if (process.exitValue() == 0) output else emptyList()
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * è§£æå•æ¡æäº¤æ¶ˆæ¯
     */
    fun parseCommitMessage(message: String): ParsedCommit? {
        // ç§»é™¤commit hashå‰ç¼€
        val cleanMessage = message.substringAfter(" ").trim()
        
        // åŒ¹é… Conventional Commits æ ¼å¼
        val regex = """^(\w+)(?:\(([^)]+)\))?(!)?: (.+)$""".toRegex()
        val match = regex.find(cleanMessage) ?: return null
        
        val typeStr = match.groupValues[1]
        val scope = match.groupValues[2].takeIf { it.isNotEmpty() }
        val isBreaking = match.groupValues[3] == "!"
        val subject = match.groupValues[4]
        
        val type = if (isBreaking) {
            when (typeStr.lowercase()) {
                "feat" -> CommitType.BREAKING_CHANGE
                "fix" -> CommitType.BREAKING_FIX
                else -> CommitType.fromMessage(typeStr) ?: return null
            }
        } else {
            CommitType.fromMessage(typeStr) ?: return null
        }
        
        return ParsedCommit(
            type = type,
            scope = scope,
            subject = subject,
            isBreaking = isBreaking
        )
    }
}

/**
 * è§£æåçš„æäº¤ä¿¡æ¯
 */
data class ParsedCommit(
    val type: CommitType,
    val scope: String? = null,
    val subject: String,
    val isBreaking: Boolean = false
)
```

#### 4.2.2 VersionCalculatorç‰ˆæœ¬è®¡ç®—å™¨

**æ–‡ä»¶ä½ç½®**ï¼š`buildSrc/src/main/kotlin/com/empathy/ai/build/VersionCalculator.kt`

```kotlin
/**
 * ç‰ˆæœ¬è®¡ç®—å™¨
 * æ ¹æ®Gitæäº¤å†å²è®¡ç®—æ–°ç‰ˆæœ¬å·
 */
class VersionCalculator {
    
    /**
     * è®¡ç®—æ–°ç‰ˆæœ¬å·
     * @param currentVersion å½“å‰ç‰ˆæœ¬
     * @param commits è‡ªä¸Šæ¬¡å‘å¸ƒä»¥æ¥çš„æäº¤åˆ—è¡¨
     * @return æ–°ç‰ˆæœ¬å·
     */
    fun calculateNextVersion(
        currentVersion: SemanticVersion,
        commits: List<ParsedCommit>
    ): SemanticVersion {
        if (commits.isEmpty()) {
            return currentVersion
        }
        
        // ç¡®å®šæœ€é«˜ä¼˜å…ˆçº§çš„ç‰ˆæœ¬å˜æ›´ç±»å‹
        val highestBump = commits
            .map { it.type.versionBump }
            .maxByOrNull { it.ordinal }
            ?: VersionBump.NONE
        
        return when (highestBump) {
            VersionBump.MAJOR -> currentVersion.bumpMajor()
            VersionBump.MINOR -> currentVersion.bumpMinor()
            VersionBump.PATCH -> currentVersion.bumpPatch()
            VersionBump.NONE -> currentVersion
        }
    }
    
    /**
     * ç”Ÿæˆå˜æ›´æ—¥å¿—
     * @param commits æäº¤åˆ—è¡¨
     * @return æ ¼å¼åŒ–çš„å˜æ›´æ—¥å¿—
     */
    fun generateChangelog(commits: List<ParsedCommit>): String {
        val grouped = commits.groupBy { it.type }
        
        return buildString {
            // æ–°åŠŸèƒ½
            grouped[CommitType.FEATURE]?.let { features ->
                appendLine("### âœ¨ æ–°åŠŸèƒ½")
                features.forEach { appendLine("- ${it.subject}") }
                appendLine()
            }
            
            // Bugä¿®å¤
            grouped[CommitType.FIX]?.let { fixes ->
                appendLine("### ğŸ› Bugä¿®å¤")
                fixes.forEach { appendLine("- ${it.subject}") }
                appendLine()
            }
            
            // æ€§èƒ½ä¼˜åŒ–
            grouped[CommitType.PERF]?.let { perfs ->
                appendLine("### âš¡ æ€§èƒ½ä¼˜åŒ–")
                perfs.forEach { appendLine("- ${it.subject}") }
                appendLine()
            }
            
            // ç ´åæ€§å˜æ›´
            val breaking = commits.filter { it.isBreaking }
            if (breaking.isNotEmpty()) {
                appendLine("### âš ï¸ ç ´åæ€§å˜æ›´")
                breaking.forEach { appendLine("- ${it.subject}") }
                appendLine()
            }
        }
    }
}
```

#### 4.2.3 VersionManagerç‰ˆæœ¬ç®¡ç†å™¨

**æ–‡ä»¶ä½ç½®**ï¼š`buildSrc/src/main/kotlin/com/empathy/ai/build/VersionManager.kt`

```kotlin
/**
 * ç‰ˆæœ¬ç®¡ç†å™¨
 * è´Ÿè´£è¯»å–å’Œæ›´æ–°gradle.propertiesä¸­çš„ç‰ˆæœ¬ä¿¡æ¯
 */
class VersionManager(private val projectDir: File) {
    
    private val gradlePropertiesFile = File(projectDir, "gradle.properties")
    private val versionHistoryFile = File(projectDir, "config/version-history.json")
    
    companion object {
        private const val KEY_VERSION_NAME = "APP_VERSION_NAME"
        private const val KEY_VERSION_CODE = "APP_VERSION_CODE"
        private const val KEY_RELEASE_STAGE = "APP_RELEASE_STAGE"
    }
    
    /**
     * è·å–å½“å‰ç‰ˆæœ¬
     */
    fun getCurrentVersion(): SemanticVersion {
        val properties = Properties().apply {
            gradlePropertiesFile.inputStream().use { load(it) }
        }
        val versionName = properties.getProperty(KEY_VERSION_NAME)
            ?: throw IllegalStateException("$KEY_VERSION_NAME not found in gradle.properties")
        return SemanticVersion.parse(versionName)
    }
    
    /**
     * æ›´æ–°ç‰ˆæœ¬å·
     * @param newVersion æ–°ç‰ˆæœ¬å·
     * @param stage å‘å¸ƒé˜¶æ®µ
     */
    fun updateVersion(newVersion: SemanticVersion, stage: ReleaseStage) {
        val content = gradlePropertiesFile.readText()
        val versionCode = newVersion.toVersionCode()
        
        val updatedContent = content
            .replace(
                Regex("""$KEY_VERSION_NAME=.+"""),
                "$KEY_VERSION_NAME=$newVersion"
            )
            .replace(
                Regex("""$KEY_VERSION_CODE=\d+"""),
                "$KEY_VERSION_CODE=$versionCode"
            )
            .replace(
                Regex("""$KEY_RELEASE_STAGE=.+"""),
                "$KEY_RELEASE_STAGE=${stage.name.lowercase()}"
            )
        
        gradlePropertiesFile.writeText(updatedContent)
    }
    
    /**
     * æ›´æ–°ç‰ˆæœ¬å†å²è®°å½•
     */
    fun updateVersionHistory(
        newVersion: SemanticVersion,
        stage: ReleaseStage,
        commits: List<ParsedCommit>
    ) {
        val historyDir = versionHistoryFile.parentFile
        if (!historyDir.exists()) {
            historyDir.mkdirs()
        }
        
        val history = if (versionHistoryFile.exists()) {
            Json.decodeFromString<VersionHistory>(versionHistoryFile.readText())
        } else {
            VersionHistory()
        }
        
        val changelog = VersionCalculator().generateChangelog(commits)
        
        val newEntry = VersionHistoryEntry(
            version = newVersion.toString(),
            versionCode = newVersion.toVersionCode(),
            stage = stage.name.lowercase(),
            date = java.time.Instant.now().toString(),
            commits = commits.map { it.subject },
            changelog = changelog
        )
        
        val updatedHistory = history.copy(
            currentVersion = VersionInfo(
                version = newVersion.toString(),
                versionCode = newVersion.toVersionCode(),
                stage = stage.name.lowercase(),
                updatedAt = java.time.Instant.now().toString()
            ),
            history = listOf(newEntry) + history.history.take(49) // ä¿ç•™æœ€è¿‘50æ¡
        )
        
        versionHistoryFile.writeText(
            Json { prettyPrint = true }.encodeToString(updatedHistory)
        )
    }
}

/**
 * ç‰ˆæœ¬å†å²æ•°æ®ç»“æ„
 */
@Serializable
data class VersionHistory(
    val schemaVersion: Int = 1,
    val currentVersion: VersionInfo? = null,
    val history: List<VersionHistoryEntry> = emptyList()
)

@Serializable
data class VersionInfo(
    val version: String,
    val versionCode: Int,
    val stage: String,
    val updatedAt: String
)

@Serializable
data class VersionHistoryEntry(
    val version: String,
    val versionCode: Int,
    val stage: String,
    val date: String,
    val commits: List<String>,
    val changelog: String
)
```

#### 4.2.4 IconManagerå›¾æ ‡ç®¡ç†å™¨

**æ–‡ä»¶ä½ç½®**ï¼š`buildSrc/src/main/kotlin/com/empathy/ai/build/IconManager.kt`

```kotlin
/**
 * å›¾æ ‡ç®¡ç†å™¨
 * è´Ÿè´£æ ¹æ®å‘å¸ƒé˜¶æ®µåˆ‡æ¢åº”ç”¨å›¾æ ‡
 */
class IconManager(
    private val projectDir: File,
    private val backupManager: BackupManager
) {
    
    private val iconMappingFile = File(projectDir, "config/icon-mapping.json")
    
    /**
     * åˆ‡æ¢åˆ°æŒ‡å®šå‘å¸ƒé˜¶æ®µçš„å›¾æ ‡
     * @param stage ç›®æ ‡å‘å¸ƒé˜¶æ®µ
     * @return åˆ‡æ¢ç»“æœ
     */
    fun switchToStage(stage: ReleaseStage): Result<IconSwitchResult> {
        return try {
            // 1. å¤‡ä»½å½“å‰å›¾æ ‡
            backupManager.backupIcons()
            
            // 2. è·å–å›¾æ ‡é…ç½®
            val iconMapping = loadIconMapping()
            val iconSet = iconMapping.iconSets[stage.iconSuffix]
                ?: return Result.failure(Exception("æœªæ‰¾åˆ°${stage.displayName}çš„å›¾æ ‡é…ç½®"))
            
            // 3. éªŒè¯æºå›¾æ ‡å­˜åœ¨
            val sourceDir = File(projectDir, iconSet.sourceDir)
            if (!sourceDir.exists()) {
                return Result.failure(Exception("æºå›¾æ ‡ç›®å½•ä¸å­˜åœ¨: ${sourceDir.path}"))
            }
            
            // 4. å¤åˆ¶å›¾æ ‡æ–‡ä»¶
            val copiedFiles = mutableListOf<String>()
            val densities = listOf("mdpi", "hdpi", "xhdpi", "xxhdpi", "xxxhdpi")
            
            densities.forEach { density ->
                val targetDir = File(projectDir, "app/src/main/res/mipmap-$density")
                targetDir.mkdirs()
                
                iconSet.files.forEach { fileName ->
                    val source = File(sourceDir, fileName)
                    val target = File(targetDir, fileName)
                    
                    if (source.exists()) {
                        source.copyTo(target, overwrite = true)
                        copiedFiles.add(target.path)
                    }
                }
            }
            
            // 5. æ›´æ–°è‡ªé€‚åº”å›¾æ ‡ï¼ˆAndroid 8.0+ï¼‰
            updateAdaptiveIcon(stage, sourceDir)
            
            Result.success(IconSwitchResult(
                stage = stage,
                copiedFiles = copiedFiles,
                timestamp = System.currentTimeMillis()
            ))
        } catch (e: Exception) {
            // å›æ»š
            backupManager.restoreIcons()
            Result.failure(e)
        }
    }
    
    /**
     * æ›´æ–°è‡ªé€‚åº”å›¾æ ‡
     */
    private fun updateAdaptiveIcon(stage: ReleaseStage, sourceDir: File) {
        val targetDir = File(projectDir, "app/src/main/res/drawable-v26")
        targetDir.mkdirs()
        
        val foregroundFile = File(sourceDir, "ic_launcher_foreground.png")
        if (foregroundFile.exists()) {
            foregroundFile.copyTo(
                File(targetDir, "ic_launcher_foreground.png"),
                overwrite = true
            )
        }
    }
    
    /**
     * åŠ è½½å›¾æ ‡æ˜ å°„é…ç½®
     */
    private fun loadIconMapping(): IconMapping {
        return if (iconMappingFile.exists()) {
            Json.decodeFromString(iconMappingFile.readText())
        } else {
            IconMapping.createDefault()
        }
    }
}

/**
 * å›¾æ ‡åˆ‡æ¢ç»“æœ
 */
data class IconSwitchResult(
    val stage: ReleaseStage,
    val copiedFiles: List<String>,
    val timestamp: Long
)

/**
 * å›¾æ ‡æ˜ å°„é…ç½®
 */
@Serializable
data class IconMapping(
    val version: Int = 1,
    val defaultStage: String = "production",
    val iconSets: Map<String, IconSet> = emptyMap()
) {
    companion object {
        fun createDefault(): IconMapping {
            val stages = listOf("dev", "test", "beta", "production")
            val iconSets = stages.associateWith { stage ->
                IconSet(
                    sourceDir = "assets/icons/$stage",
                    files = listOf(
                        "ic_launcher.png",
                        "ic_launcher_round.png",
                        "ic_launcher_foreground.png"
                    )
                )
            }
            return IconMapping(iconSets = iconSets)
        }
    }
}

@Serializable
data class IconSet(
    val sourceDir: String,
    val files: List<String>
)
```

#### 4.2.5 BackupManagerå¤‡ä»½ç®¡ç†å™¨

**æ–‡ä»¶ä½ç½®**ï¼š`buildSrc/src/main/kotlin/com/empathy/ai/build/BackupManager.kt`

```kotlin
/**
 * å¤‡ä»½ç®¡ç†å™¨
 * è´Ÿè´£æ–‡ä»¶å¤‡ä»½å’Œå›æ»šæ“ä½œ
 */
class BackupManager(private val projectDir: File) {
    
    companion object {
        private const val BACKUP_DIR = "backups/version-update"
        private const val MAX_BACKUPS = 50
        private const val RETENTION_DAYS = 30
    }
    
    private val backupDir = File(projectDir, BACKUP_DIR)
    
    /**
     * åˆ›å»ºå®Œæ•´å¤‡ä»½
     */
    fun createBackup(): BackupResult {
        val timestamp = java.text.SimpleDateFormat("yyyy-MM-dd-HH-mm-ss")
            .format(java.util.Date())
        val backupName = "backup-$timestamp"
        val backupPath = File(backupDir, backupName)
        
        backupPath.mkdirs()
        
        // å¤‡ä»½æ–‡ä»¶åˆ—è¡¨
        val filesToBackup = listOf(
            "gradle.properties",
            "config/version-history.json"
        )
        
        // å¤‡ä»½å›¾æ ‡ç›®å½•
        val iconDirs = listOf("mdpi", "hdpi", "xhdpi", "xxhdpi", "xxxhdpi")
            .map { "app/src/main/res/mipmap-$it" }
        
        var fileCount = 0
        
        // å¤åˆ¶æ–‡ä»¶
        filesToBackup.forEach { relativePath ->
            val source = File(projectDir, relativePath)
            if (source.exists()) {
                val target = File(backupPath, relativePath)
                target.parentFile.mkdirs()
                source.copyTo(target, overwrite = true)
                fileCount++
            }
        }
        
        // å¤åˆ¶å›¾æ ‡ç›®å½•
        iconDirs.forEach { relativePath ->
            val source = File(projectDir, relativePath)
            if (source.exists() && source.isDirectory) {
                val target = File(backupPath, relativePath)
                source.copyRecursively(target, overwrite = true)
                fileCount += source.listFiles()?.size ?: 0
            }
        }
        
        // åˆ›å»ºå¤‡ä»½å…ƒæ•°æ®
        val metadata = BackupMetadata(
            timestamp = timestamp,
            files = filesToBackup + iconDirs,
            createdAt = System.currentTimeMillis()
        )
        File(backupPath, "metadata.json").writeText(
            Json { prettyPrint = true }.encodeToString(metadata)
        )
        
        // æ¸…ç†æ—§å¤‡ä»½
        cleanupOldBackups()
        
        return BackupResult(
            backupPath = backupPath.absolutePath,
            timestamp = timestamp,
            fileCount = fileCount
        )
    }
    
    /**
     * å¤‡ä»½å›¾æ ‡æ–‡ä»¶
     */
    fun backupIcons() {
        val timestamp = System.currentTimeMillis().toString()
        val iconBackupDir = File(backupDir, "icons-$timestamp")
        iconBackupDir.mkdirs()
        
        val densities = listOf("mdpi", "hdpi", "xhdpi", "xxhdpi", "xxxhdpi")
        densities.forEach { density ->
            val source = File(projectDir, "app/src/main/res/mipmap-$density")
            if (source.exists()) {
                val target = File(iconBackupDir, "mipmap-$density")
                source.copyRecursively(target, overwrite = true)
            }
        }
    }
    
    /**
     * æ¢å¤å›¾æ ‡æ–‡ä»¶
     */
    fun restoreIcons() {
        // æŸ¥æ‰¾æœ€è¿‘çš„å›¾æ ‡å¤‡ä»½
        val iconBackups = backupDir.listFiles()
            ?.filter { it.name.startsWith("icons-") }
            ?.sortedByDescending { it.name }
            ?: return
        
        val latestBackup = iconBackups.firstOrNull() ?: return
        
        val densities = listOf("mdpi", "hdpi", "xhdpi", "xxhdpi", "xxxhdpi")
        densities.forEach { density ->
            val source = File(latestBackup, "mipmap-$density")
            if (source.exists()) {
                val target = File(projectDir, "app/src/main/res/mipmap-$density")
                source.copyRecursively(target, overwrite = true)
            }
        }
    }
    
    /**
     * ä»å¤‡ä»½æ¢å¤
     */
    fun restore(backupResult: BackupResult): RestoreResult {
        val backupPath = File(backupResult.backupPath)
        if (!backupPath.exists()) {
            throw IllegalStateException("å¤‡ä»½ç›®å½•ä¸å­˜åœ¨: ${backupResult.backupPath}")
        }
        
        val metadataFile = File(backupPath, "metadata.json")
        val metadata = Json.decodeFromString<BackupMetadata>(metadataFile.readText())
        
        var restoredCount = 0
        metadata.files.forEach { relativePath ->
            val source = File(backupPath, relativePath)
            val target = File(projectDir, relativePath)
            
            if (source.exists()) {
                if (source.isDirectory) {
                    source.copyRecursively(target, overwrite = true)
                } else {
                    target.parentFile.mkdirs()
                    source.copyTo(target, overwrite = true)
                }
                restoredCount++
            }
        }
        
        return RestoreResult(
            restoredFiles = restoredCount,
            timestamp = backupResult.timestamp
        )
    }
    
    /**
     * æ¸…ç†æ—§å¤‡ä»½
     */
    private fun cleanupOldBackups() {
        if (!backupDir.exists()) return
        
        val backups = backupDir.listFiles()
            ?.filter { it.isDirectory && it.name.startsWith("backup-") }
            ?.sortedByDescending { it.name }
            ?: return
        
        // ä¿ç•™æœ€è¿‘Nä¸ªå¤‡ä»½
        if (backups.size > MAX_BACKUPS) {
            backups.drop(MAX_BACKUPS).forEach { it.deleteRecursively() }
        }
        
        // åˆ é™¤è¶…è¿‡ä¿ç•™æœŸé™çš„å¤‡ä»½
        val cutoffTime = System.currentTimeMillis() - RETENTION_DAYS * 24 * 60 * 60 * 1000L
        backups.forEach { backup ->
            val metadataFile = File(backup, "metadata.json")
            if (metadataFile.exists()) {
                try {
                    val metadata = Json.decodeFromString<BackupMetadata>(metadataFile.readText())
                    if (metadata.createdAt < cutoffTime) {
                        backup.deleteRecursively()
                    }
                } catch (e: Exception) {
                    // å¿½ç•¥è§£æé”™è¯¯
                }
            }
        }
    }
}

@Serializable
data class BackupMetadata(
    val timestamp: String,
    val files: List<String>,
    val createdAt: Long
)

data class BackupResult(
    val backupPath: String,
    val timestamp: String,
    val fileCount: Int
)

data class RestoreResult(
    val restoredFiles: Int,
    val timestamp: String
)
```


---

### 4.3 Gradleæ’ä»¶è®¾è®¡

#### 4.3.1 VersionUpdatePluginæ’ä»¶å…¥å£

**æ–‡ä»¶ä½ç½®**ï¼š`buildSrc/src/main/kotlin/com/empathy/ai/build/VersionUpdatePlugin.kt`

> **âš ï¸ Gradle Configuration Cache æ”¯æŒ**
> 
> ä¸ºç¡®ä¿ä¸ Gradle Configuration Cache å…¼å®¹ï¼Œæ‰€æœ‰ Task å¿…é¡»éµå¾ªä»¥ä¸‹è§„åˆ™ï¼š
> - ä½¿ç”¨ `@Input`ã€`@OutputFile`ã€`@OutputDirectory` ç­‰æ³¨è§£æ­£ç¡®æ ‡è®°è¾“å…¥è¾“å‡º
> - é¿å…åœ¨é…ç½®é˜¶æ®µæ‰§è¡Œè€—æ—¶æ“ä½œï¼ˆå¦‚ Git å‘½ä»¤ï¼‰ï¼Œåº”å°†å…¶æ”¾åœ¨æ‰§è¡Œé˜¶æ®µï¼ˆ`@TaskAction`ï¼‰
> - ä½¿ç”¨ `Property<T>` å’Œ `Provider<T>` å»¶è¿Ÿè®¡ç®—å±æ€§å€¼
> - é¿å…åœ¨ Task ä¸­ç›´æ¥å¼•ç”¨ `Project` å¯¹è±¡ï¼Œä½¿ç”¨æ³¨å…¥çš„æœåŠ¡ä»£æ›¿

```kotlin
/**
 * ç‰ˆæœ¬æ›´æ–°Gradleæ’ä»¶
 * æä¾›ç‰ˆæœ¬å·è‡ªåŠ¨æ›´æ–°å’Œå›¾æ ‡åˆ‡æ¢åŠŸèƒ½
 * 
 * æ”¯æŒ Gradle Configuration Cache
 */
class VersionUpdatePlugin : Plugin<Project> {
    
    override fun apply(project: Project) {
        // æ³¨å†Œæ‰©å±•é…ç½®
        val extension = project.extensions.create(
            "versionUpdate",
            VersionUpdateExtension::class.java
        )
        
        // æ³¨å†Œä¸»ä»»åŠ¡
        project.tasks.register(
            "updateVersionAndIcon",
            UpdateVersionAndIconTask::class.java
        ) {
            group = "release"
            description = "æ›´æ–°ç‰ˆæœ¬å·å’Œåº”ç”¨å›¾æ ‡"
            
            // ä½¿ç”¨ Property å»¶è¿Ÿç»‘å®šï¼Œæ”¯æŒ Configuration Cache
            stage.set(extension.stage)
            force.set(extension.force)
            dryRun.set(extension.dryRun)
            
            // å£°æ˜è¾“å…¥è¾“å‡ºä»¥æ”¯æŒå¢é‡æ„å»ºå’Œç¼“å­˜
            projectDir.set(project.rootDir)
        }
        
        // æ³¨å†Œå­ä»»åŠ¡
        registerSubTasks(project, extension)
    }
    
    private fun registerSubTasks(project: Project, extension: VersionUpdateExtension) {
        // ä»…æ›´æ–°ç‰ˆæœ¬å·
        project.tasks.register("updateVersion", UpdateVersionTask::class.java) {
            group = "release"
            description = "ä»…æ›´æ–°ç‰ˆæœ¬å·"
            projectDir.set(project.rootDir)
        }
        
        // ä»…æ›´æ–°å›¾æ ‡
        project.tasks.register("updateIcon", UpdateIconTask::class.java) {
            group = "release"
            description = "ä»…æ›´æ–°åº”ç”¨å›¾æ ‡"
            stage.set(extension.stage)
            projectDir.set(project.rootDir)
        }
        
        // åˆ†ææäº¤ä¿¡æ¯
        project.tasks.register("analyzeCommits", AnalyzeCommitsTask::class.java) {
            group = "release"
            description = "åˆ†æGitæäº¤ä¿¡æ¯"
            projectDir.set(project.rootDir)
        }
        
        // å›æ»šç‰ˆæœ¬
        project.tasks.register("rollbackVersion", RollbackVersionTask::class.java) {
            group = "release"
            description = "å›æ»šåˆ°ä¸Šä¸€ä¸ªç‰ˆæœ¬"
            projectDir.set(project.rootDir)
        }
        
        // æ˜¾ç¤ºå½“å‰ç‰ˆæœ¬
        project.tasks.register("showCurrentVersion", ShowVersionTask::class.java) {
            group = "release"
            description = "æ˜¾ç¤ºå½“å‰ç‰ˆæœ¬ä¿¡æ¯"
            projectDir.set(project.rootDir)
        }
        
        // åˆå§‹åŒ–å›¾æ ‡èµ„æº
        project.tasks.register("initIconResources", InitIconResourcesTask::class.java) {
            group = "release"
            description = "åˆå§‹åŒ–å›¾æ ‡èµ„æºç›®å½•ç»“æ„"
            projectDir.set(project.rootDir)
        }
    }
}

/**
 * æ’ä»¶æ‰©å±•é…ç½®
 */
open class VersionUpdateExtension {
    /** å‘å¸ƒé˜¶æ®µ */
    var stage: Property<String> = ObjectFactory.property(String::class.java)
        .convention("production")
    
    /** å¼ºåˆ¶æ›´æ–°ï¼ˆå³ä½¿ç‰ˆæœ¬å·æ— å˜åŒ–ï¼‰ */
    var force: Property<Boolean> = ObjectFactory.property(Boolean::class.java)
        .convention(false)
    
    /** é¢„æ¼”æ¨¡å¼ï¼ˆåªæ˜¾ç¤ºå°†è¦æ‰§è¡Œçš„æ“ä½œï¼‰ */
    var dryRun: Property<Boolean> = ObjectFactory.property(Boolean::class.java)
        .convention(false)
}
```

#### 4.3.2 UpdateVersionAndIconTaskä¸»ä»»åŠ¡

**æ–‡ä»¶ä½ç½®**ï¼š`buildSrc/src/main/kotlin/com/empathy/ai/build/UpdateVersionAndIconTask.kt`

> **âš ï¸ Configuration Cache å…¼å®¹æ€§è¯´æ˜**
> 
> æ­¤ä»»åŠ¡å®Œå…¨æ”¯æŒ Gradle Configuration Cacheï¼Œéµå¾ªä»¥ä¸‹è®¾è®¡åŸåˆ™ï¼š
> - æ‰€æœ‰è¾“å…¥ä½¿ç”¨ `@Input` æ³¨è§£å£°æ˜
> - æ‰€æœ‰è¾“å‡ºä½¿ç”¨ `@OutputFile` æˆ– `@OutputDirectory` æ³¨è§£å£°æ˜
> - ä½¿ç”¨ `Property<T>` å»¶è¿Ÿè®¡ç®—å±æ€§å€¼
> - é¿å…åœ¨é…ç½®é˜¶æ®µè®¿é—® `project` å¯¹è±¡ï¼Œä½¿ç”¨æ³¨å…¥çš„ `projectDir` ä»£æ›¿
> - Git å‘½ä»¤ç­‰è€—æ—¶æ“ä½œä»…åœ¨ `@TaskAction` æ‰§è¡Œé˜¶æ®µè¿è¡Œ

```kotlin
/**
 * ç‰ˆæœ¬å’Œå›¾æ ‡æ›´æ–°ä¸»ä»»åŠ¡
 * 
 * æ”¯æŒ Gradle Configuration Cache
 * - ä½¿ç”¨ Property<T> å»¶è¿Ÿç»‘å®šæ‰€æœ‰è¾“å…¥
 * - ä½¿ç”¨ @Input/@OutputFile æ³¨è§£å£°æ˜è¾“å…¥è¾“å‡º
 * - é¿å…åœ¨é…ç½®é˜¶æ®µæ‰§è¡Œè€—æ—¶æ“ä½œ
 */
abstract class UpdateVersionAndIconTask : DefaultTask() {
    
    // ========== è¾“å…¥å±æ€§ï¼ˆæ”¯æŒ Configuration Cacheï¼‰==========
    
    /** å‘å¸ƒé˜¶æ®µ */
    @get:Input
    abstract val stage: Property<String>
    
    /** å¼ºåˆ¶æ›´æ–°æ ‡å¿— */
    @get:Input
    abstract val force: Property<Boolean>
    
    /** é¢„æ¼”æ¨¡å¼æ ‡å¿— */
    @get:Input
    abstract val dryRun: Property<Boolean>
    
    /** é¡¹ç›®æ ¹ç›®å½•ï¼ˆé¿å…ç›´æ¥å¼•ç”¨ project å¯¹è±¡ï¼‰*/
    @get:Input
    abstract val projectDir: Property<File>
    
    // ========== è¾“å‡ºæ–‡ä»¶ï¼ˆæ”¯æŒå¢é‡æ„å»ºï¼‰==========
    
    /** gradle.properties è¾“å‡ºæ–‡ä»¶ */
    @get:OutputFile
    val gradlePropertiesFile: Provider<File>
        get() = projectDir.map { File(it, "gradle.properties") }
    
    /** ç‰ˆæœ¬å†å²è¾“å‡ºæ–‡ä»¶ */
    @get:OutputFile
    val versionHistoryFile: Provider<File>
        get() = projectDir.map { File(it, "config/version-history.json") }
    
    // ========== å»¶è¿Ÿåˆå§‹åŒ–çš„ç®¡ç†å™¨ï¼ˆåœ¨æ‰§è¡Œé˜¶æ®µåˆ›å»ºï¼‰==========
    
    private val versionManager by lazy { VersionManager(projectDir.get()) }
    private val backupManager by lazy { BackupManager(projectDir.get()) }
    private val iconManager by lazy { IconManager(projectDir.get(), backupManager) }
    private val commitParser by lazy { CommitParser(projectDir.get()) }
    private val versionCalculator by lazy { VersionCalculator() }
    
    @TaskAction
    fun execute() {
        val releaseStage = ReleaseStage.fromString(stage.get())
        
        logger.lifecycle("========================================")
        logger.lifecycle("å¼€å§‹ç‰ˆæœ¬æ›´æ–°æµç¨‹")
        logger.lifecycle("å‘å¸ƒé˜¶æ®µ: ${releaseStage.displayName}")
        logger.lifecycle("å¼ºåˆ¶æ›´æ–°: ${force.get()}")
        logger.lifecycle("é¢„æ¼”æ¨¡å¼: ${dryRun.get()}")
        logger.lifecycle("========================================")
        
        // 1. åˆ†æGitæäº¤
        logger.lifecycle("\n[1/6] åˆ†æGitæäº¤...")
        val commits = commitParser.parseCommitsSinceLastTag()
        logger.lifecycle("å‘ç° ${commits.size} ä¸ªæ–°æäº¤")
        commits.forEach { commit ->
            logger.lifecycle("  - ${commit.type.prefix}: ${commit.subject}")
        }
        
        // 2. è®¡ç®—æ–°ç‰ˆæœ¬å·
        logger.lifecycle("\n[2/6] è®¡ç®—æ–°ç‰ˆæœ¬å·...")
        val currentVersion = versionManager.getCurrentVersion()
        val newVersion = versionCalculator.calculateNextVersion(currentVersion, commits)
        logger.lifecycle("å½“å‰ç‰ˆæœ¬: $currentVersion")
        logger.lifecycle("æ–°ç‰ˆæœ¬: $newVersion")
        
        if (currentVersion == newVersion && !force.get()) {
            logger.lifecycle("\nç‰ˆæœ¬å·æ— å˜åŒ–ï¼Œè·³è¿‡æ›´æ–°")
            return
        }
        
        // é¢„æ¼”æ¨¡å¼æ£€æŸ¥
        if (dryRun.get()) {
            logger.lifecycle("\n[é¢„æ¼”æ¨¡å¼] å°†æ‰§è¡Œä»¥ä¸‹æ“ä½œ:")
            logger.lifecycle("  - æ›´æ–°ç‰ˆæœ¬å·: $currentVersion -> $newVersion")
            logger.lifecycle("  - åˆ‡æ¢å›¾æ ‡: ${releaseStage.displayName}")
            logger.lifecycle("\né¢„æ¼”å®Œæˆï¼Œæœªæ‰§è¡Œå®é™…æ“ä½œ")
            return
        }
        
        // 3. å¤‡ä»½æ–‡ä»¶
        logger.lifecycle("\n[3/6] å¤‡ä»½åŸå§‹æ–‡ä»¶...")
        val backupResult = backupManager.createBackup()
        logger.lifecycle("å¤‡ä»½å®Œæˆ: ${backupResult.backupPath}")
        
        try {
            // 4. æ›´æ–°ç‰ˆæœ¬å·
            logger.lifecycle("\n[4/6] æ›´æ–°ç‰ˆæœ¬å·...")
            versionManager.updateVersion(newVersion, releaseStage)
            logger.lifecycle("ç‰ˆæœ¬å·æ›´æ–°å®Œæˆ")
            
            // 5. æ›´æ–°å›¾æ ‡
            logger.lifecycle("\n[5/6] æ›´æ–°åº”ç”¨å›¾æ ‡...")
            val iconResult = iconManager.switchToStage(releaseStage)
            iconResult.onSuccess { result ->
                logger.lifecycle("å›¾æ ‡æ›´æ–°å®Œæˆï¼Œå¤åˆ¶äº† ${result.copiedFiles.size} ä¸ªæ–‡ä»¶")
            }.onFailure { error ->
                throw error
            }
            
            // 6. æ›´æ–°ç‰ˆæœ¬å†å²
            logger.lifecycle("\n[6/6] æ›´æ–°ç‰ˆæœ¬å†å²...")
            versionManager.updateVersionHistory(newVersion, releaseStage, commits)
            logger.lifecycle("ç‰ˆæœ¬å†å²æ›´æ–°å®Œæˆ")
            
            logger.lifecycle("\n========================================")
            logger.lifecycle("âœ… ç‰ˆæœ¬æ›´æ–°å®Œæˆ!")
            logger.lifecycle("æ–°ç‰ˆæœ¬: $newVersion")
            logger.lifecycle("å‘å¸ƒé˜¶æ®µ: ${releaseStage.displayName}")
            logger.lifecycle("========================================")
            
        } catch (e: Exception) {
            logger.error("\nâŒ æ›´æ–°å¤±è´¥: ${e.message}")
            logger.lifecycle("æ­£åœ¨å›æ»š...")
            backupManager.restore(backupResult)
            logger.lifecycle("å›æ»šå®Œæˆ")
            throw e
        }
    }
}
```


---

### 4.4 InitIconResourcesTaskå›¾æ ‡èµ„æºåˆå§‹åŒ–ä»»åŠ¡

**æ–‡ä»¶ä½ç½®**ï¼š`buildSrc/src/main/kotlin/com/empathy/ai/build/InitIconResourcesTask.kt`

> **ğŸ“‹ ä»»åŠ¡è¯´æ˜**
> 
> æ­¤ä»»åŠ¡ç”¨äºåˆå§‹åŒ–å›¾æ ‡èµ„æºç›®å½•ç»“æ„ï¼Œç¡®ä¿é¦–æ¬¡è¿è¡Œæ—¶ä¸ä¼šå› èµ„æºç¼ºå¤±è€ŒæŠ¥é”™ã€‚
> æ”¯æŒç”Ÿæˆé»˜è®¤å ä½å›¾æ ‡ï¼Œä¾¿äºå¼€å‘ç¯å¢ƒå¿«é€Ÿå¯åŠ¨ã€‚

```kotlin
/**
 * å›¾æ ‡èµ„æºåˆå§‹åŒ–ä»»åŠ¡
 * 
 * åŠŸèƒ½ï¼š
 * - æ£€æŸ¥å¹¶åˆ›å»ºå›¾æ ‡èµ„æºç›®å½•ç»“æ„
 * - ç”Ÿæˆé»˜è®¤å ä½å›¾æ ‡ï¼ˆå¯é€‰ï¼‰
 * - åˆ›å»º icon-mapping.json é…ç½®æ–‡ä»¶
 * 
 * æ”¯æŒ Gradle Configuration Cache
 */
abstract class InitIconResourcesTask : DefaultTask() {
    
    // ========== è¾“å…¥å±æ€§ ==========
    
    /** é¡¹ç›®æ ¹ç›®å½• */
    @get:Input
    abstract val projectDir: Property<File>
    
    /** æ˜¯å¦ç”Ÿæˆå ä½å›¾æ ‡ */
    @get:Input
    @get:Optional
    abstract val generatePlaceholders: Property<Boolean>
    
    // ========== è¾“å‡ºç›®å½• ==========
    
    /** å›¾æ ‡èµ„æºæ ¹ç›®å½• */
    @get:OutputDirectory
    val iconsDir: Provider<File>
        get() = projectDir.map { File(it, "assets/icons") }
    
    /** é…ç½®æ–‡ä»¶è¾“å‡º */
    @get:OutputFile
    val iconMappingFile: Provider<File>
        get() = projectDir.map { File(it, "config/icon-mapping.json") }
    
    init {
        description = "åˆå§‹åŒ–å›¾æ ‡èµ„æºç›®å½•ç»“æ„"
        group = "release"
    }
    
    @TaskAction
    fun execute() {
        val rootDir = projectDir.get()
        val shouldGeneratePlaceholders = generatePlaceholders.getOrElse(true)
        
        logger.lifecycle("========================================")
        logger.lifecycle("åˆå§‹åŒ–å›¾æ ‡èµ„æºç›®å½•")
        logger.lifecycle("é¡¹ç›®ç›®å½•: ${rootDir.absolutePath}")
        logger.lifecycle("ç”Ÿæˆå ä½å›¾æ ‡: $shouldGeneratePlaceholders")
        logger.lifecycle("========================================")
        
        // 1. åˆ›å»ºå›¾æ ‡èµ„æºç›®å½•ç»“æ„
        logger.lifecycle("\n[1/4] åˆ›å»ºç›®å½•ç»“æ„...")
        val stages = listOf("dev", "test", "beta", "production")
        val createdDirs = mutableListOf<String>()
        
        stages.forEach { stage ->
            val stageDir = File(rootDir, "assets/icons/$stage")
            if (!stageDir.exists()) {
                stageDir.mkdirs()
                createdDirs.add(stageDir.relativeTo(rootDir).path)
                logger.lifecycle("  âœ“ åˆ›å»ºç›®å½•: assets/icons/$stage")
            } else {
                logger.lifecycle("  - ç›®å½•å·²å­˜åœ¨: assets/icons/$stage")
            }
        }
        
        // 2. åˆ›å»ºåº”ç”¨å›¾æ ‡ç›®å½•ï¼ˆmipmap-*ï¼‰
        logger.lifecycle("\n[2/4] æ£€æŸ¥åº”ç”¨å›¾æ ‡ç›®å½•...")
        val densities = listOf("mdpi", "hdpi", "xhdpi", "xxhdpi", "xxxhdpi")
        densities.forEach { density ->
            val mipmapDir = File(rootDir, "app/src/main/res/mipmap-$density")
            if (!mipmapDir.exists()) {
                mipmapDir.mkdirs()
                logger.lifecycle("  âœ“ åˆ›å»ºç›®å½•: app/src/main/res/mipmap-$density")
            }
        }
        
        // 3. ç”Ÿæˆå ä½å›¾æ ‡ï¼ˆå¯é€‰ï¼‰
        if (shouldGeneratePlaceholders) {
            logger.lifecycle("\n[3/4] ç”Ÿæˆå ä½å›¾æ ‡...")
            generatePlaceholderIcons(rootDir, stages)
        } else {
            logger.lifecycle("\n[3/4] è·³è¿‡å ä½å›¾æ ‡ç”Ÿæˆ")
        }
        
        // 4. åˆ›å»º icon-mapping.json é…ç½®æ–‡ä»¶
        logger.lifecycle("\n[4/4] åˆ›å»ºé…ç½®æ–‡ä»¶...")
        createIconMappingConfig(rootDir)
        
        // è¾“å‡ºæ‘˜è¦
        logger.lifecycle("\n========================================")
        logger.lifecycle("âœ… å›¾æ ‡èµ„æºåˆå§‹åŒ–å®Œæˆ!")
        logger.lifecycle("åˆ›å»ºäº† ${createdDirs.size} ä¸ªæ–°ç›®å½•")
        logger.lifecycle("========================================")
    }
    
    /**
     * ç”Ÿæˆå ä½å›¾æ ‡
     * åˆ›å»ºç®€å•çš„PNGå ä½æ–‡ä»¶ï¼Œä¾¿äºå¼€å‘ç¯å¢ƒå¿«é€Ÿå¯åŠ¨
     */
    private fun generatePlaceholderIcons(rootDir: File, stages: List<String>) {
        val iconFiles = listOf(
            "ic_launcher.png",
            "ic_launcher_round.png",
            "ic_launcher_foreground.png"
        )
        
        // ç®€å•çš„1x1åƒç´ PNGå ä½ç¬¦ï¼ˆæœ€å°æœ‰æ•ˆPNGï¼‰
        val placeholderPng = byteArrayOf(
            0x89.toByte(), 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
            0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
            0x08, 0x02, 0x00, 0x00, 0x00, 0x90.toByte(), 0x77, 0x53,
            0xDE.toByte(), 0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41,
            0x54, 0x08, 0xD7.toByte(), 0x63, 0xF8.toByte(), 0xFF.toByte(),
            0xFF.toByte(), 0x3F, 0x00, 0x05, 0xFE.toByte(), 0x02,
            0xFE.toByte(), 0xDC.toByte(), 0xCC.toByte(), 0x59, 0xE7.toByte(),
            0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44,
            0xAE.toByte(), 0x42, 0x60, 0x82.toByte()
        )
        
        var createdCount = 0
        stages.forEach { stage ->
            val stageDir = File(rootDir, "assets/icons/$stage")
            iconFiles.forEach { fileName ->
                val iconFile = File(stageDir, fileName)
                if (!iconFile.exists()) {
                    iconFile.writeBytes(placeholderPng)
                    createdCount++
                    logger.lifecycle("  âœ“ åˆ›å»ºå ä½å›¾æ ‡: assets/icons/$stage/$fileName")
                }
            }
        }
        
        logger.lifecycle("  å…±åˆ›å»º $createdCount ä¸ªå ä½å›¾æ ‡")
    }
    
    /**
     * åˆ›å»º icon-mapping.json é…ç½®æ–‡ä»¶
     */
    private fun createIconMappingConfig(rootDir: File) {
        val configDir = File(rootDir, "config")
        if (!configDir.exists()) {
            configDir.mkdirs()
        }
        
        val configFile = File(configDir, "icon-mapping.json")
        if (configFile.exists()) {
            logger.lifecycle("  - é…ç½®æ–‡ä»¶å·²å­˜åœ¨: config/icon-mapping.json")
            return
        }
        
        val defaultConfig = """
{
  "version": 1,
  "defaultStage": "production",
  "iconSets": {
    "dev": {
      "sourceDir": "assets/icons/dev",
      "files": ["ic_launcher.png", "ic_launcher_round.png", "ic_launcher_foreground.png"]
    },
    "test": {
      "sourceDir": "assets/icons/test",
      "files": ["ic_launcher.png", "ic_launcher_round.png", "ic_launcher_foreground.png"]
    },
    "beta": {
      "sourceDir": "assets/icons/beta",
      "files": ["ic_launcher.png", "ic_launcher_round.png", "ic_launcher_foreground.png"]
    },
    "production": {
      "sourceDir": "assets/icons/production",
      "files": ["ic_launcher.png", "ic_launcher_round.png", "ic_launcher_foreground.png"]
    }
  }
}
        """.trimIndent()
        
        configFile.writeText(defaultConfig)
        logger.lifecycle("  âœ“ åˆ›å»ºé…ç½®æ–‡ä»¶: config/icon-mapping.json")
    }
}
```

---

### 4.5 ç‰ˆæœ¬å·åŒæ­¥æ‰©å±•æ€§è®¾è®¡

> **ğŸ“‹ è®¾è®¡è¯´æ˜**
> 
> ä¸ºæ”¯æŒéAndroidæ¨¡å—ï¼ˆå¦‚çº¯Kotlinåº“ï¼‰çš„ç‰ˆæœ¬å·åŒæ­¥ï¼Œè®¾è®¡äº†å¯æ‰©å±•çš„ç‰ˆæœ¬æ–‡ä»¶æ›´æ–°ç­–ç•¥ã€‚

#### 4.5.1 VersionFileUpdateræ¥å£

```kotlin
/**
 * ç‰ˆæœ¬æ–‡ä»¶æ›´æ–°å™¨æ¥å£
 * æ”¯æŒä¸åŒç±»å‹é¡¹ç›®çš„ç‰ˆæœ¬å·åŒæ­¥
 */
interface VersionFileUpdater {
    /** æ›´æ–°å™¨åç§° */
    val name: String
    
    /** æ”¯æŒçš„æ–‡ä»¶æ¨¡å¼ */
    val supportedFiles: List<String>
    
    /**
     * æ£€æŸ¥æ˜¯å¦æ”¯æŒæŒ‡å®šæ–‡ä»¶
     */
    fun supports(file: File): Boolean
    
    /**
     * æ›´æ–°ç‰ˆæœ¬å·
     * @param file ç›®æ ‡æ–‡ä»¶
     * @param version æ–°ç‰ˆæœ¬å·
     * @return æ˜¯å¦æ›´æ–°æˆåŠŸ
     */
    fun updateVersion(file: File, version: SemanticVersion): Boolean
    
    /**
     * è¯»å–å½“å‰ç‰ˆæœ¬å·
     * @param file ç›®æ ‡æ–‡ä»¶
     * @return å½“å‰ç‰ˆæœ¬å·ï¼Œå¦‚æœæ— æ³•è¯»å–åˆ™è¿”å›null
     */
    fun readVersion(file: File): SemanticVersion?
}
```

#### 4.5.2 GradlePropertiesUpdaterå®ç°

```kotlin
/**
 * gradle.properties ç‰ˆæœ¬æ›´æ–°å™¨
 * ç”¨äºAndroidé¡¹ç›®å’ŒGradleé¡¹ç›®
 */
class GradlePropertiesUpdater : VersionFileUpdater {
    
    override val name = "Gradle Properties"
    override val supportedFiles = listOf("gradle.properties")
    
    companion object {
        private const val KEY_VERSION_NAME = "APP_VERSION_NAME"
        private const val KEY_VERSION_CODE = "APP_VERSION_CODE"
        
        // é€šç”¨ç‰ˆæœ¬é”®ï¼ˆç”¨äºéAndroidæ¨¡å—ï¼‰
        private const val KEY_VERSION = "VERSION"
        private const val KEY_LIB_VERSION = "LIB_VERSION"
    }
    
    override fun supports(file: File): Boolean {
        return file.name == "gradle.properties" && file.exists()
    }
    
    override fun updateVersion(file: File, version: SemanticVersion): Boolean {
        if (!supports(file)) return false
        
        var content = file.readText()
        var updated = false
        
        // æ›´æ–° APP_VERSION_NAMEï¼ˆAndroidé¡¹ç›®ï¼‰
        if (content.contains(KEY_VERSION_NAME)) {
            content = content.replace(
                Regex("""$KEY_VERSION_NAME=.+"""),
                "$KEY_VERSION_NAME=$version"
            )
            updated = true
        }
        
        // æ›´æ–° APP_VERSION_CODEï¼ˆAndroidé¡¹ç›®ï¼‰
        if (content.contains(KEY_VERSION_CODE)) {
            content = content.replace(
                Regex("""$KEY_VERSION_CODE=\d+"""),
                "$KEY_VERSION_CODE=${version.toVersionCode()}"
            )
            updated = true
        }
        
        // æ›´æ–° VERSIONï¼ˆé€šç”¨ï¼‰
        if (content.contains("$KEY_VERSION=")) {
            content = content.replace(
                Regex("""$KEY_VERSION=.+"""),
                "$KEY_VERSION=$version"
            )
            updated = true
        }
        
        // æ›´æ–° LIB_VERSIONï¼ˆåº“æ¨¡å—ï¼‰
        if (content.contains("$KEY_LIB_VERSION=")) {
            content = content.replace(
                Regex("""$KEY_LIB_VERSION=.+"""),
                "$KEY_LIB_VERSION=$version"
            )
            updated = true
        }
        
        if (updated) {
            file.writeText(content)
        }
        
        return updated
    }
    
    override fun readVersion(file: File): SemanticVersion? {
        if (!supports(file)) return null
        
        val properties = java.util.Properties().apply {
            file.inputStream().use { load(it) }
        }
        
        // ä¼˜å…ˆè¯»å– APP_VERSION_NAME
        val versionName = properties.getProperty(KEY_VERSION_NAME)
            ?: properties.getProperty(KEY_VERSION)
            ?: properties.getProperty(KEY_LIB_VERSION)
            ?: return null
        
        return try {
            SemanticVersion.parse(versionName)
        } catch (e: Exception) {
            null
        }
    }
}
```

#### 4.5.3 PackageJsonUpdaterå®ç°ï¼ˆæ‰©å±•ç¤ºä¾‹ï¼‰

```kotlin
/**
 * package.json ç‰ˆæœ¬æ›´æ–°å™¨
 * ç”¨äºåŒ…å«Node.js/å‰ç«¯æ¨¡å—çš„æ··åˆé¡¹ç›®
 */
class PackageJsonUpdater : VersionFileUpdater {
    
    override val name = "Package JSON"
    override val supportedFiles = listOf("package.json")
    
    override fun supports(file: File): Boolean {
        return file.name == "package.json" && file.exists()
    }
    
    override fun updateVersion(file: File, version: SemanticVersion): Boolean {
        if (!supports(file)) return false
        
        val content = file.readText()
        val updatedContent = content.replace(
            Regex(""""version"\s*:\s*"[^"]+""""),
            """"version": "$version""""
        )
        
        if (content != updatedContent) {
            file.writeText(updatedContent)
            return true
        }
        
        return false
    }
    
    override fun readVersion(file: File): SemanticVersion? {
        if (!supports(file)) return null
        
        val content = file.readText()
        val match = Regex(""""version"\s*:\s*"([^"]+)"""").find(content)
        val versionStr = match?.groupValues?.get(1) ?: return null
        
        return try {
            SemanticVersion.parse(versionStr)
        } catch (e: Exception) {
            null
        }
    }
}
```

#### 4.5.4 VersionSyncManagerå¤šæ¨¡å—ç‰ˆæœ¬åŒæ­¥ç®¡ç†å™¨

```kotlin
/**
 * å¤šæ¨¡å—ç‰ˆæœ¬åŒæ­¥ç®¡ç†å™¨
 * æ”¯æŒåœ¨å¤šæ¨¡å—é¡¹ç›®ä¸­åŒæ­¥ç‰ˆæœ¬å·
 */
class VersionSyncManager(
    private val projectDir: File,
    private val updaters: List<VersionFileUpdater> = listOf(
        GradlePropertiesUpdater(),
        PackageJsonUpdater()
    )
) {
    
    /**
     * åŒæ­¥æ‰€æœ‰æ¨¡å—çš„ç‰ˆæœ¬å·
     * @param version ç›®æ ‡ç‰ˆæœ¬å·
     * @param modules è¦åŒæ­¥çš„æ¨¡å—åˆ—è¡¨ï¼ˆç›¸å¯¹è·¯å¾„ï¼‰ï¼Œä¸ºç©ºåˆ™åŒæ­¥æ‰€æœ‰å‘ç°çš„æ¨¡å—
     * @return åŒæ­¥ç»“æœ
     */
    fun syncVersions(
        version: SemanticVersion,
        modules: List<String> = emptyList()
    ): VersionSyncResult {
        val targetDirs = if (modules.isEmpty()) {
            discoverModules()
        } else {
            modules.map { File(projectDir, it) }
        }
        
        val results = mutableListOf<ModuleSyncResult>()
        
        targetDirs.forEach { moduleDir ->
            val moduleResults = syncModuleVersion(moduleDir, version)
            results.addAll(moduleResults)
        }
        
        return VersionSyncResult(
            version = version,
            syncedModules = results.filter { it.success },
            failedModules = results.filter { !it.success }
        )
    }
    
    /**
     * å‘ç°é¡¹ç›®ä¸­çš„æ‰€æœ‰æ¨¡å—
     */
    private fun discoverModules(): List<File> {
        val modules = mutableListOf<File>()
        
        // æ·»åŠ æ ¹ç›®å½•
        modules.add(projectDir)
        
        // æŸ¥æ‰¾å­æ¨¡å—ï¼ˆåŒ…å« build.gradle.kts æˆ– build.gradle çš„ç›®å½•ï¼‰
        projectDir.listFiles()?.forEach { file ->
            if (file.isDirectory && !file.name.startsWith(".")) {
                val hasBuildFile = File(file, "build.gradle.kts").exists() ||
                                   File(file, "build.gradle").exists()
                if (hasBuildFile) {
                    modules.add(file)
                }
            }
        }
        
        return modules
    }
    
    /**
     * åŒæ­¥å•ä¸ªæ¨¡å—çš„ç‰ˆæœ¬å·
     */
    private fun syncModuleVersion(
        moduleDir: File,
        version: SemanticVersion
    ): List<ModuleSyncResult> {
        val results = mutableListOf<ModuleSyncResult>()
        
        updaters.forEach { updater ->
            updater.supportedFiles.forEach { fileName ->
                val file = File(moduleDir, fileName)
                if (file.exists()) {
                    try {
                        val success = updater.updateVersion(file, version)
                        results.add(ModuleSyncResult(
                            modulePath = moduleDir.relativeTo(projectDir).path.ifEmpty { "." },
                            fileName = fileName,
                            updaterName = updater.name,
                            success = success,
                            error = null
                        ))
                    } catch (e: Exception) {
                        results.add(ModuleSyncResult(
                            modulePath = moduleDir.relativeTo(projectDir).path.ifEmpty { "." },
                            fileName = fileName,
                            updaterName = updater.name,
                            success = false,
                            error = e.message
                        ))
                    }
                }
            }
        }
        
        return results
    }
}

/**
 * ç‰ˆæœ¬åŒæ­¥ç»“æœ
 */
data class VersionSyncResult(
    val version: SemanticVersion,
    val syncedModules: List<ModuleSyncResult>,
    val failedModules: List<ModuleSyncResult>
) {
    val isSuccess: Boolean get() = failedModules.isEmpty()
    val totalSynced: Int get() = syncedModules.size
}

/**
 * æ¨¡å—åŒæ­¥ç»“æœ
 */
data class ModuleSyncResult(
    val modulePath: String,
    val fileName: String,
    val updaterName: String,
    val success: Boolean,
    val error: String?
)
```

---

### 5.1 é”™è¯¯ç±»å‹å®šä¹‰

```kotlin
/**
 * ç‰ˆæœ¬æ›´æ–°é”™è¯¯ç±»å‹
 */
sealed class VersionUpdateError : Exception() {
    
    // Gitç›¸å…³é”™è¯¯
    data class GitNotFound(override val message: String = "Gitæœªå®‰è£…æˆ–ä¸åœ¨PATHä¸­") 
        : VersionUpdateError()
    data class GitOperationFailed(val operation: String, val output: String) 
        : VersionUpdateError() {
        override val message = "Gitæ“ä½œå¤±è´¥: $operation\n$output"
    }
    data class NoCommitsFound(override val message: String = "æœªæ‰¾åˆ°æ–°çš„æäº¤") 
        : VersionUpdateError()
    
    // æ–‡ä»¶ç›¸å…³é”™è¯¯
    data class FileNotFound(val path: String) : VersionUpdateError() {
        override val message = "æ–‡ä»¶ä¸å­˜åœ¨: $path"
    }
    data class FileWriteFailed(val path: String, val cause: Throwable) 
        : VersionUpdateError() {
        override val message = "æ–‡ä»¶å†™å…¥å¤±è´¥: $path - ${cause.message}"
    }
    data class IconNotFound(val stage: String) : VersionUpdateError() {
        override val message = "æœªæ‰¾åˆ°${stage}é˜¶æ®µçš„å›¾æ ‡èµ„æº"
    }
    
    // é…ç½®ç›¸å…³é”™è¯¯
    data class ConfigParseError(val file: String, val cause: Throwable) 
        : VersionUpdateError() {
        override val message = "é…ç½®æ–‡ä»¶è§£æå¤±è´¥: $file - ${cause.message}"
    }
    data class InvalidVersion(val version: String) : VersionUpdateError() {
        override val message = "æ— æ•ˆçš„ç‰ˆæœ¬å·æ ¼å¼: $version"
    }
    
    // å¤‡ä»½ç›¸å…³é”™è¯¯
    data class BackupFailed(val cause: Throwable) : VersionUpdateError() {
        override val message = "å¤‡ä»½å¤±è´¥: ${cause.message}"
    }
    data class RestoreFailed(val cause: Throwable) : VersionUpdateError() {
        override val message = "æ¢å¤å¤±è´¥: ${cause.message}"
    }
}
```

### 5.2 é”™è¯¯å¤„ç†ç­–ç•¥

| é”™è¯¯ç±»å‹ | å¤„ç†ç­–ç•¥ | é‡è¯•æ¬¡æ•° | ç”¨æˆ·æç¤º |
|----------|----------|----------|----------|
| GitNotFound | ç»ˆæ­¢æ‰§è¡Œ | 0 | è¯·å®‰è£…Gitå¹¶æ·»åŠ åˆ°PATH |
| GitOperationFailed | é‡è¯•åç»ˆæ­¢ | 3 | æ˜¾ç¤ºGité”™è¯¯è¾“å‡º |
| FileNotFound | ç»ˆæ­¢æ‰§è¡Œ | 0 | æ˜¾ç¤ºç¼ºå¤±æ–‡ä»¶è·¯å¾„ |
| FileWriteFailed | é‡è¯•åå›æ»š | 3 | æ£€æŸ¥æ–‡ä»¶æƒé™ |
| IconNotFound | ç»ˆæ­¢æ‰§è¡Œ | 0 | è¯·å‡†å¤‡å¯¹åº”é˜¶æ®µçš„å›¾æ ‡ |
| ConfigParseError | ä½¿ç”¨é»˜è®¤é…ç½® | 0 | é…ç½®æ–‡ä»¶æ ¼å¼é”™è¯¯ |
| BackupFailed | ç»ˆæ­¢æ‰§è¡Œ | 1 | æ£€æŸ¥ç£ç›˜ç©ºé—´ |

---

## 6. æµ‹è¯•ç­–ç•¥

### 6.1 å•å…ƒæµ‹è¯•

#### 6.1.1 SemanticVersionTest

```kotlin
class SemanticVersionTest {
    
    @Test
    fun `parse valid version string`() {
        val version = SemanticVersion.parse("1.2.3")
        assertEquals(1, version.major)
        assertEquals(2, version.minor)
        assertEquals(3, version.patch)
        assertNull(version.prerelease)
        assertNull(version.build)
    }
    
    @Test
    fun `parse version with prerelease`() {
        val version = SemanticVersion.parse("1.2.3-beta.1")
        assertEquals("beta.1", version.prerelease)
    }
    
    @Test
    fun `parse version with build metadata`() {
        val version = SemanticVersion.parse("1.2.3+20251231")
        assertEquals("20251231", version.build)
    }
    
    @Test
    fun `bump major version`() {
        val version = SemanticVersion(1, 2, 3)
        val bumped = version.bumpMajor()
        assertEquals(SemanticVersion(2, 0, 0), bumped)
    }
    
    @Test
    fun `bump minor version`() {
        val version = SemanticVersion(1, 2, 3)
        val bumped = version.bumpMinor()
        assertEquals(SemanticVersion(1, 3, 0), bumped)
    }
    
    @Test
    fun `bump patch version`() {
        val version = SemanticVersion(1, 2, 3)
        val bumped = version.bumpPatch()
        assertEquals(SemanticVersion(1, 2, 4), bumped)
    }
    
    @Test
    fun `toVersionCode calculates correctly`() {
        val version = SemanticVersion(1, 2, 3)
        assertEquals(10203, version.toVersionCode())
    }
    
    @Test(expected = IllegalArgumentException::class)
    fun `parse invalid version throws exception`() {
        SemanticVersion.parse("invalid")
    }
}
```

#### 6.1.2 CommitParserTest

```kotlin
class CommitParserTest {
    
    @Test
    fun `parse feat commit`() {
        val parser = CommitParser(File("."))
        val commit = parser.parseCommitMessage("abc1234 feat: æ·»åŠ æ–°åŠŸèƒ½")
        
        assertNotNull(commit)
        assertEquals(CommitType.FEATURE, commit!!.type)
        assertEquals("æ·»åŠ æ–°åŠŸèƒ½", commit.subject)
        assertFalse(commit.isBreaking)
    }
    
    @Test
    fun `parse breaking change commit`() {
        val parser = CommitParser(File("."))
        val commit = parser.parseCommitMessage("abc1234 feat!: ç ´åæ€§å˜æ›´")
        
        assertNotNull(commit)
        assertEquals(CommitType.BREAKING_CHANGE, commit!!.type)
        assertTrue(commit.isBreaking)
    }
    
    @Test
    fun `parse fix commit with scope`() {
        val parser = CommitParser(File("."))
        val commit = parser.parseCommitMessage("abc1234 fix(ui): ä¿®å¤æŒ‰é’®æ ·å¼")
        
        assertNotNull(commit)
        assertEquals(CommitType.FIX, commit!!.type)
        assertEquals("ui", commit.scope)
        assertEquals("ä¿®å¤æŒ‰é’®æ ·å¼", commit.subject)
    }
    
    @Test
    fun `parse invalid commit returns null`() {
        val parser = CommitParser(File("."))
        val commit = parser.parseCommitMessage("abc1234 éšä¾¿å†™çš„æäº¤ä¿¡æ¯")
        
        assertNull(commit)
    }
}
```

#### 6.1.3 VersionCalculatorTest

```kotlin
class VersionCalculatorTest {
    
    private val calculator = VersionCalculator()
    
    @Test
    fun `breaking change bumps major`() {
        val current = SemanticVersion(1, 2, 3)
        val commits = listOf(
            ParsedCommit(CommitType.BREAKING_CHANGE, subject = "ç ´åæ€§å˜æ›´", isBreaking = true)
        )
        val next = calculator.calculateNextVersion(current, commits)
        assertEquals(SemanticVersion(2, 0, 0), next)
    }
    
    @Test
    fun `feature bumps minor`() {
        val current = SemanticVersion(1, 2, 3)
        val commits = listOf(
            ParsedCommit(CommitType.FEATURE, subject = "æ–°åŠŸèƒ½")
        )
        val next = calculator.calculateNextVersion(current, commits)
        assertEquals(SemanticVersion(1, 3, 0), next)
    }
    
    @Test
    fun `fix bumps patch`() {
        val current = SemanticVersion(1, 2, 3)
        val commits = listOf(
            ParsedCommit(CommitType.FIX, subject = "ä¿®å¤é—®é¢˜")
        )
        val next = calculator.calculateNextVersion(current, commits)
        assertEquals(SemanticVersion(1, 2, 4), next)
    }
    
    @Test
    fun `highest bump wins`() {
        val current = SemanticVersion(1, 2, 3)
        val commits = listOf(
            ParsedCommit(CommitType.FIX, subject = "ä¿®å¤é—®é¢˜"),
            ParsedCommit(CommitType.FEATURE, subject = "æ–°åŠŸèƒ½"),
            ParsedCommit(CommitType.FIX, subject = "å¦ä¸€ä¸ªä¿®å¤")
        )
        val next = calculator.calculateNextVersion(current, commits)
        assertEquals(SemanticVersion(1, 3, 0), next)  // minor wins
    }
    
    @Test
    fun `empty commits returns same version`() {
        val current = SemanticVersion(1, 2, 3)
        val next = calculator.calculateNextVersion(current, emptyList())
        assertEquals(current, next)
    }
    
    @Test
    fun `docs commit does not bump version`() {
        val current = SemanticVersion(1, 2, 3)
        val commits = listOf(
            ParsedCommit(CommitType.DOCS, subject = "æ›´æ–°æ–‡æ¡£")
        )
        val next = calculator.calculateNextVersion(current, commits)
        assertEquals(current, next)
    }
}
```

### 6.2 é›†æˆæµ‹è¯•

```kotlin
class VersionUpdateIntegrationTest {
    
    @TempDir
    lateinit var tempDir: File
    
    private lateinit var versionManager: VersionManager
    private lateinit var iconManager: IconManager
    private lateinit var backupManager: BackupManager
    
    @BeforeEach
    fun setup() {
        setupTestProject(tempDir)
        
        backupManager = BackupManager(tempDir)
        versionManager = VersionManager(tempDir)
        iconManager = IconManager(tempDir, backupManager)
    }
    
    @Test
    fun `full update flow succeeds`() {
        // Given
        val initialVersion = versionManager.getCurrentVersion()
        assertEquals(SemanticVersion(1, 0, 0), initialVersion)
        
        // When
        versionManager.updateVersion(SemanticVersion(1, 1, 0), ReleaseStage.BETA)
        iconManager.switchToStage(ReleaseStage.BETA)
        
        // Then
        val updatedVersion = versionManager.getCurrentVersion()
        assertEquals(SemanticVersion(1, 1, 0), updatedVersion)
    }
    
    @Test
    fun `rollback restores original state`() {
        // Given
        val initialVersion = versionManager.getCurrentVersion()
        val backup = backupManager.createBackup()
        
        // When
        versionManager.updateVersion(SemanticVersion(2, 0, 0), ReleaseStage.PRODUCTION)
        backupManager.restore(backup)
        
        // Then
        val restoredVersion = versionManager.getCurrentVersion()
        assertEquals(initialVersion, restoredVersion)
    }
    
    private fun setupTestProject(dir: File) {
        // åˆ›å»ºgradle.properties
        File(dir, "gradle.properties").writeText("""
            APP_VERSION_NAME=1.0.0
            APP_VERSION_CODE=10000
            APP_RELEASE_STAGE=dev
        """.trimIndent())
        
        // åˆ›å»ºå›¾æ ‡ç›®å½•å’Œæ–‡ä»¶
        listOf("mdpi", "hdpi", "xhdpi", "xxhdpi", "xxxhdpi").forEach { density ->
            val iconDir = File(dir, "app/src/main/res/mipmap-$density")
            iconDir.mkdirs()
            File(iconDir, "ic_launcher.png").writeBytes(ByteArray(100))
        }
        
        // åˆ›å»ºæºå›¾æ ‡
        ReleaseStage.entries.forEach { stage ->
            val sourceDir = File(dir, "assets/icons/${stage.iconSuffix}")
            sourceDir.mkdirs()
            File(sourceDir, "ic_launcher.png").writeBytes(ByteArray(100))
            File(sourceDir, "ic_launcher_round.png").writeBytes(ByteArray(100))
        }
    }
}
```

### 6.3 æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡

| æ¨¡å— | ç›®æ ‡è¦†ç›–ç‡ | å…³é”®æŒ‡æ ‡ |
|------|------------|----------|
| SemanticVersion | â‰¥ 95% | è¡Œè¦†ç›–ç‡ã€åˆ†æ”¯è¦†ç›–ç‡ |
| CommitParser | â‰¥ 90% | è¡Œè¦†ç›–ç‡ã€åˆ†æ”¯è¦†ç›–ç‡ |
| VersionCalculator | â‰¥ 95% | è¡Œè¦†ç›–ç‡ã€åˆ†æ”¯è¦†ç›–ç‡ |
| VersionManager | â‰¥ 85% | è¡Œè¦†ç›–ç‡ |
| IconManager | â‰¥ 80% | è¡Œè¦†ç›–ç‡ |
| BackupManager | â‰¥ 85% | è¡Œè¦†ç›–ç‡ã€åˆ†æ”¯è¦†ç›–ç‡ |
| **æ•´ä½“ç›®æ ‡** | **â‰¥ 80%** | è¡Œè¦†ç›–ç‡ |


---

## 7. æ€§èƒ½è¦æ±‚

### 7.1 æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | æµ‹é‡æ–¹æ³• |
|------|--------|----------|
| ç‰ˆæœ¬æ›´æ–°æ€»è€—æ—¶ | < 30ç§’ | ä»ä»»åŠ¡å¼€å§‹åˆ°å®Œæˆçš„æ—¶é—´ |
| Gitæäº¤åˆ†æè€—æ—¶ | < 5ç§’ | CommitParseræ‰§è¡Œæ—¶é—´ |
| å›¾æ ‡åˆ‡æ¢è€—æ—¶ | < 10ç§’ | IconManageræ‰§è¡Œæ—¶é—´ |
| å¤‡ä»½åˆ›å»ºè€—æ—¶ | < 5ç§’ | BackupManager.createBackup()æ‰§è¡Œæ—¶é—´ |
| å†…å­˜å³°å€¼ | < 100MB | JVMå †å†…å­˜ä½¿ç”¨å³°å€¼ |

### 7.2 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

1. **å»¶è¿ŸåŠ è½½**ï¼šé…ç½®æ–‡ä»¶æŒ‰éœ€åŠ è½½ï¼Œä¸åœ¨å¯åŠ¨æ—¶å…¨éƒ¨è¯»å–
2. **å¹¶è¡Œå¤„ç†**ï¼šå›¾æ ‡å¤åˆ¶æ“ä½œå¯å¹¶è¡Œæ‰§è¡Œ
3. **å¢é‡å¤‡ä»½**ï¼šåªå¤‡ä»½å˜æ›´çš„æ–‡ä»¶ï¼Œå‡å°‘IOæ“ä½œ
4. **ç¼“å­˜æœºåˆ¶**ï¼šGitæäº¤ä¿¡æ¯ç¼“å­˜ï¼Œé¿å…é‡å¤è§£æ

---

## 8. å®æ–½è®¡åˆ’

### 8.1 ä»»åŠ¡åˆ†è§£

#### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€æ¶æ„æ­å»ºï¼ˆé¢„ä¼°2å¤©ï¼‰

| ä»»åŠ¡ID | ä»»åŠ¡æè¿° | ä¼˜å…ˆçº§ | é¢„ä¼°æ—¶é—´ | ä¾èµ– |
|--------|----------|--------|----------|------|
| T1.1 | åˆ›å»ºbuildSrcæ¨¡å—ç»“æ„ | P0 | 2h | æ—  |
| T1.2 | å®ç°SemanticVersionæ•°æ®ç±» | P0 | 2h | T1.1 |
| T1.3 | å®ç°CommitTypeæšä¸¾ | P0 | 1h | T1.1 |
| T1.4 | å®ç°ReleaseStageæšä¸¾ | P0 | 1h | T1.1 |
| T1.5 | å®ç°CommitParseræäº¤è§£æå™¨ | P0 | 3h | T1.3 |
| T1.6 | å®ç°VersionCalculatorç‰ˆæœ¬è®¡ç®—å™¨ | P0 | 2h | T1.2 |
| T1.7 | ç¼–å†™Phase 1å•å…ƒæµ‹è¯• | P0 | 2h | T1.2-T1.6 |

#### ç¬¬äºŒé˜¶æ®µï¼šç‰ˆæœ¬ç®¡ç†å®ç°ï¼ˆé¢„ä¼°1.5å¤©ï¼‰

| ä»»åŠ¡ID | ä»»åŠ¡æè¿° | ä¼˜å…ˆçº§ | é¢„ä¼°æ—¶é—´ | ä¾èµ– |
|--------|----------|--------|----------|------|
| T2.1 | å®ç°VersionManagerç‰ˆæœ¬ç®¡ç†å™¨ | P0 | 3h | T1.2, T1.4 |
| T2.2 | å®ç°ç‰ˆæœ¬å†å²è®°å½•åŠŸèƒ½ | P1 | 2h | T2.1 |
| T2.3 | åˆ›å»ºversion-config.jsoné…ç½® | P0 | 1h | æ—  |
| T2.4 | ç¼–å†™Phase 2å•å…ƒæµ‹è¯• | P0 | 2h | T2.1-T2.3 |

#### ç¬¬ä¸‰é˜¶æ®µï¼šå›¾æ ‡ç®¡ç†å®ç°ï¼ˆé¢„ä¼°1.5å¤©ï¼‰

| ä»»åŠ¡ID | ä»»åŠ¡æè¿° | ä¼˜å…ˆçº§ | é¢„ä¼°æ—¶é—´ | ä¾èµ– |
|--------|----------|--------|----------|------|
| T3.1 | åˆ›å»ºå›¾æ ‡èµ„æºç›®å½•ç»“æ„ | P0 | 1h | æ—  |
| T3.2 | è®¾è®¡å¹¶å‡†å¤‡4å¥—å›¾æ ‡èµ„æº | P0 | 4h | T3.1 |
| T3.3 | å®ç°IconManagerå›¾æ ‡ç®¡ç†å™¨ | P0 | 3h | T3.1 |
| T3.4 | åˆ›å»ºicon-mapping.jsoné…ç½® | P0 | 1h | T3.1 |
| T3.5 | ç¼–å†™Phase 3å•å…ƒæµ‹è¯• | P0 | 2h | T3.3 |

#### ç¬¬å››é˜¶æ®µï¼šå¤‡ä»½ä¸é”™è¯¯å¤„ç†ï¼ˆé¢„ä¼°1å¤©ï¼‰

| ä»»åŠ¡ID | ä»»åŠ¡æè¿° | ä¼˜å…ˆçº§ | é¢„ä¼°æ—¶é—´ | ä¾èµ– |
|--------|----------|--------|----------|------|
| T4.1 | å®ç°BackupManagerå¤‡ä»½ç®¡ç†å™¨ | P0 | 3h | æ—  |
| T4.2 | å®šä¹‰VersionUpdateErroré”™è¯¯ç±»å‹ | P0 | 1h | æ—  |
| T4.3 | å®ç°é”™è¯¯å¤„ç†å’Œå›æ»šé€»è¾‘ | P0 | 2h | T4.1, T4.2 |
| T4.4 | ç¼–å†™Phase 4å•å…ƒæµ‹è¯• | P0 | 2h | T4.1-T4.3 |

#### ç¬¬äº”é˜¶æ®µï¼šGradleä»»åŠ¡é›†æˆï¼ˆé¢„ä¼°1.5å¤©ï¼‰

| ä»»åŠ¡ID | ä»»åŠ¡æè¿° | ä¼˜å…ˆçº§ | é¢„ä¼°æ—¶é—´ | ä¾èµ– |
|--------|----------|--------|----------|------|
| T5.1 | å®ç°VersionUpdatePluginæ’ä»¶ | P0 | 2h | Phase 1-4 |
| T5.2 | å®ç°UpdateVersionAndIconTaskä¸»ä»»åŠ¡ | P0 | 3h | T5.1 |
| T5.3 | å®ç°å­ä»»åŠ¡ï¼ˆupdateVersion, updateIconç­‰ï¼‰ | P1 | 2h | T5.1 |
| T5.4 | æ·»åŠ å‘½ä»¤è¡Œå‚æ•°æ”¯æŒ | P0 | 1h | T5.2 |
| T5.5 | ç¼–å†™Phase 5é›†æˆæµ‹è¯• | P0 | 2h | T5.1-T5.4 |

#### ç¬¬å…­é˜¶æ®µï¼šCI/CDä¸æ–‡æ¡£ï¼ˆé¢„ä¼°1å¤©ï¼‰

| ä»»åŠ¡ID | ä»»åŠ¡æè¿° | ä¼˜å…ˆçº§ | é¢„ä¼°æ—¶é—´ | ä¾èµ– |
|--------|----------|--------|----------|------|
| T6.1 | åˆ›å»ºGitHub Actionså·¥ä½œæµ | P1 | 2h | Phase 5 |
| T6.2 | åˆ›å»ºæœ¬åœ°å‘å¸ƒè„šæœ¬ | P1 | 1h | Phase 5 |
| T6.3 | ç¼–å†™ä½¿ç”¨æ–‡æ¡£ | P1 | 2h | Phase 5 |
| T6.4 | ç«¯åˆ°ç«¯æµ‹è¯• | P0 | 2h | Phase 5 |

### 8.2 é‡Œç¨‹ç¢‘

```
Day 1-2: åŸºç¡€æ¶æ„æ­å»ºå®Œæˆ
  â”œâ”€â”€ buildSrcæ¨¡å—åˆ›å»º âœ“
  â”œâ”€â”€ æ•°æ®æ¨¡å‹å®ç° âœ“
  â”œâ”€â”€ æäº¤è§£æå™¨å®ç° âœ“
  â””â”€â”€ å•å…ƒæµ‹è¯•é€šè¿‡ âœ“

Day 3-4: ç‰ˆæœ¬å’Œå›¾æ ‡ç®¡ç†å®Œæˆ
  â”œâ”€â”€ ç‰ˆæœ¬ç®¡ç†å™¨å®ç° âœ“
  â”œâ”€â”€ å›¾æ ‡ç®¡ç†å™¨å®ç° âœ“
  â”œâ”€â”€ å¤‡ä»½ç®¡ç†å™¨å®ç° âœ“
  â””â”€â”€ å•å…ƒæµ‹è¯•é€šè¿‡ âœ“

Day 5-6: Gradleä»»åŠ¡é›†æˆå®Œæˆ
  â”œâ”€â”€ æ’ä»¶å…¥å£å®ç° âœ“
  â”œâ”€â”€ ä¸»ä»»åŠ¡å®ç° âœ“
  â”œâ”€â”€ å­ä»»åŠ¡å®ç° âœ“
  â””â”€â”€ é›†æˆæµ‹è¯•é€šè¿‡ âœ“

Day 7: CI/CDå’Œæ–‡æ¡£å®Œæˆ
  â”œâ”€â”€ GitHub Actionsé…ç½® âœ“
  â”œâ”€â”€ æœ¬åœ°è„šæœ¬åˆ›å»º âœ“
  â”œâ”€â”€ ä½¿ç”¨æ–‡æ¡£ç¼–å†™ âœ“
  â””â”€â”€ ç«¯åˆ°ç«¯æµ‹è¯•é€šè¿‡ âœ“
```

### 8.3 æ€»å·¥æœŸä¼°ç®—

| é˜¶æ®µ | å·¥æœŸ | ç´¯è®¡ |
|------|------|------|
| Phase 1: åŸºç¡€æ¶æ„ | 2å¤© | 2å¤© |
| Phase 2: ç‰ˆæœ¬ç®¡ç† | 1.5å¤© | 3.5å¤© |
| Phase 3: å›¾æ ‡ç®¡ç† | 1.5å¤© | 5å¤© |
| Phase 4: å¤‡ä»½ä¸é”™è¯¯å¤„ç† | 1å¤© | 6å¤© |
| Phase 5: Gradleä»»åŠ¡é›†æˆ | 1.5å¤© | 7.5å¤© |
| Phase 6: CI/CDä¸æ–‡æ¡£ | 1å¤© | 8.5å¤© |
| **æ€»è®¡** | **8.5å¤©** | - |

---

## 9. é£é™©è¯„ä¼°

### 9.1 æŠ€æœ¯é£é™©

| é£é™©ID | é£é™©æè¿° | æ¦‚ç‡ | å½±å“ | é£é™©ç­‰çº§ | ç¼“è§£æªæ–½ |
|--------|----------|------|------|----------|----------|
| TR-01 | Gitæäº¤ä¿¡æ¯ä¸è§„èŒƒå¯¼è‡´ç‰ˆæœ¬å·è®¡ç®—é”™è¯¯ | é«˜ | ä¸­ | ğŸŸ¡ ä¸­ | æä¾›æäº¤ä¿¡æ¯æ ¡éªŒé’©å­ |
| TR-02 | å›¾æ ‡æ–‡ä»¶æŸåå¯¼è‡´åº”ç”¨æ— æ³•å¯åŠ¨ | ä½ | é«˜ | ğŸŸ¡ ä¸­ | å¤‡ä»½æœºåˆ¶ + å›¾æ ‡å®Œæ•´æ€§æ ¡éªŒ |
| TR-03 | å¹¶å‘æ‰§è¡Œå¯¼è‡´æ–‡ä»¶å†²çª | ä¸­ | ä¸­ | ğŸŸ¡ ä¸­ | æ–‡ä»¶é”æœºåˆ¶ |
| TR-04 | Gradleç‰ˆæœ¬ä¸å…¼å®¹ | ä½ | é«˜ | ğŸŸ¡ ä¸­ | ç‰ˆæœ¬æ£€æŸ¥ + å…¼å®¹æ€§æµ‹è¯• |
| TR-05 | å¤‡ä»½æ¢å¤å¤±è´¥ | ä½ | é«˜ | ğŸŸ¡ ä¸­ | å¤šçº§å¤‡ä»½ + æ¢å¤æµ‹è¯• |

### 9.2 ä¸šåŠ¡é£é™©

| é£é™©ID | é£é™©æè¿° | æ¦‚ç‡ | å½±å“ | é£é™©ç­‰çº§ | ç¼“è§£æªæ–½ |
|--------|----------|------|------|----------|----------|
| BR-01 | ç‰ˆæœ¬å·è·³è·ƒå¯¼è‡´ç”¨æˆ·å›°æƒ‘ | ä¸­ | ä½ | ğŸŸ¢ ä½ | ç‰ˆæœ¬å·å˜æ›´æ—¥å¿— |
| BR-02 | é”™è¯¯çš„å‘å¸ƒé˜¶æ®µå›¾æ ‡ | ä½ | ä¸­ | ğŸŸ¢ ä½ | å‘å¸ƒå‰é¢„è§ˆ + äººå·¥ç¡®è®¤ |
| BR-03 | è‡ªåŠ¨åŒ–æµç¨‹ä¸­æ–­å½±å“å‘å¸ƒ | ä¸­ | é«˜ | ğŸŸ¡ ä¸­ | æ‰‹åŠ¨å›é€€æ–¹æ¡ˆ |

---

## 10. é™„å½•

### 10.1 æ–‡ä»¶å˜æ›´æ¸…å•

| æ–‡ä»¶è·¯å¾„ | å˜æ›´ç±»å‹ | è¯´æ˜ |
|----------|----------|------|
| `buildSrc/build.gradle.kts` | æ–°å¢ | buildSrcæ¨¡å—æ„å»ºé…ç½® |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/SemanticVersion.kt` | æ–°å¢ | è¯­ä¹‰åŒ–ç‰ˆæœ¬æ•°æ®ç±» |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/ReleaseStage.kt` | æ–°å¢ | å‘å¸ƒé˜¶æ®µæšä¸¾ |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/CommitType.kt` | æ–°å¢ | æäº¤ç±»å‹æšä¸¾ |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/CommitParser.kt` | æ–°å¢ | Gitæäº¤è§£æå™¨ |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/VersionCalculator.kt` | æ–°å¢ | ç‰ˆæœ¬è®¡ç®—å™¨ |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/VersionManager.kt` | æ–°å¢ | ç‰ˆæœ¬ç®¡ç†å™¨ |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/IconManager.kt` | æ–°å¢ | å›¾æ ‡ç®¡ç†å™¨ |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/BackupManager.kt` | æ–°å¢ | å¤‡ä»½ç®¡ç†å™¨ |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/VersionUpdatePlugin.kt` | æ–°å¢ | Gradleæ’ä»¶å…¥å£ |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/UpdateVersionAndIconTask.kt` | æ–°å¢ | ä¸»ä»»åŠ¡å®ç° |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/InitIconResourcesTask.kt` | æ–°å¢ | å›¾æ ‡èµ„æºåˆå§‹åŒ–ä»»åŠ¡ |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/VersionFileUpdater.kt` | æ–°å¢ | ç‰ˆæœ¬æ–‡ä»¶æ›´æ–°å™¨æ¥å£ |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/GradlePropertiesUpdater.kt` | æ–°å¢ | gradle.propertiesæ›´æ–°å™¨ |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/PackageJsonUpdater.kt` | æ–°å¢ | package.jsonæ›´æ–°å™¨ï¼ˆæ‰©å±•ï¼‰ |
| `buildSrc/src/main/kotlin/com/empathy/ai/build/VersionSyncManager.kt` | æ–°å¢ | å¤šæ¨¡å—ç‰ˆæœ¬åŒæ­¥ç®¡ç†å™¨ |
| `config/version-config.json` | æ–°å¢ | ç‰ˆæœ¬é…ç½®æ–‡ä»¶ |
| `config/version-history.json` | æ–°å¢ | ç‰ˆæœ¬å†å²è®°å½• |
| `config/icon-mapping.json` | æ–°å¢ | å›¾æ ‡æ˜ å°„é…ç½® |
| `assets/icons/dev/` | æ–°å¢ | å¼€å‘ç‰ˆå›¾æ ‡èµ„æº |
| `assets/icons/test/` | æ–°å¢ | æµ‹è¯•ç‰ˆå›¾æ ‡èµ„æº |
| `assets/icons/beta/` | æ–°å¢ | é¢„å‘å¸ƒç‰ˆå›¾æ ‡èµ„æº |
| `assets/icons/production/` | æ–°å¢ | æ­£å¼ç‰ˆå›¾æ ‡èµ„æº |
| `gradle.properties` | ä¿®æ”¹ | æ·»åŠ ç‰ˆæœ¬å·å’Œå‘å¸ƒé˜¶æ®µå±æ€§ |

### 10.2 å‘½ä»¤è¡Œå‚æ•°è¯´æ˜

| å‚æ•° | è¯´æ˜ | é»˜è®¤å€¼ | ç¤ºä¾‹ |
|------|------|--------|------|
| `--stage` | å‘å¸ƒé˜¶æ®µ | production | `--stage=beta` |
| `--force` | å¼ºåˆ¶æ›´æ–° | false | `--force` |
| `--dry-run` | é¢„æ¼”æ¨¡å¼ | false | `--dry-run` |
| `--backup` | æŒ‡å®šå¤‡ä»½ | latest | `--backup=backup-2025-12-31-10-00-00` |

### 10.3 ç›¸å…³æ–‡æ¡£

| æ–‡æ¡£ | è·¯å¾„ | è¯´æ˜ |
|------|------|------|
| PRD-00024 | `æ–‡æ¡£/å¼€å‘æ–‡æ¡£/PRD/PRD-00024-å›¾æ ‡å’Œç‰ˆæœ¬å·è‡ªåŠ¨æ›´æ–°.md` | äº§å“éœ€æ±‚æ–‡æ¡£ |
| FD-00024 | `æ–‡æ¡£/å¼€å‘æ–‡æ¡£/FD/FD-00024-å›¾æ ‡å’Œç‰ˆæœ¬å·è‡ªåŠ¨æ›´æ–°åŠŸèƒ½è®¾è®¡.md` | åŠŸèƒ½è®¾è®¡æ–‡æ¡£ |
| TD-00024 | `æ–‡æ¡£/å¼€å‘æ–‡æ¡£/TD/TD-00024-å›¾æ ‡å’Œç‰ˆæœ¬å·è‡ªåŠ¨æ›´æ–°ä»»åŠ¡æ¸…å•.md` | ä»»åŠ¡æ¸…å•ï¼ˆå¾…åˆ›å»ºï¼‰ |

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [Semantic Versioning 2.0.0](https://semver.org/)
- [Conventional Commits](https://www.conventionalcommits.org/)
- [Gradle Custom Plugins](https://docs.gradle.org/current/userguide/custom_plugins.html)
- [Android App Versioning](https://developer.android.com/studio/publish/versioning)

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å®¡æŸ¥é€šè¿‡  
**åˆ›å»ºæ—¥æœŸ**: 2025-12-31  
**æœ€åæ›´æ–°**: 2025-12-31  
**è´Ÿè´£äºº**: Kiro  
**å®¡æ ¸äºº**: Roo  
**å®¡æ ¸çŠ¶æ€**: âœ… é€šè¿‡
