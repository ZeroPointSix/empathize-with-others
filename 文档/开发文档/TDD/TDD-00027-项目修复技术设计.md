# TDD-00027 é¡¹ç›®ä¿®å¤æŠ€æœ¯è®¾è®¡

## æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| æ–‡æ¡£ç¼–å· | TDD-00027 |
| åˆ›å»ºæ—¥æœŸ | 2026-01-01 |
| ä½œè€… | Kiro |
| çŠ¶æ€ | è‰ç¨¿ |
| ç‰ˆæœ¬ | v1.0 |

### å…³è”æ–‡æ¡£

| æ–‡æ¡£ç±»å‹ | æ–‡æ¡£ç¼–å· | æ–‡æ¡£åç§° |
|----------|----------|----------|
| åŠŸèƒ½è®¾è®¡ | FD-00027 | é¡¹ç›®ä¿®å¤åŠŸèƒ½è®¾è®¡ |
| éœ€æ±‚æ–‡æ¡£ | PRD-00027 | é¡¹ç›®ä¿®å¤éœ€æ±‚ |
| æ¶æ„å®¡æŸ¥ | MA-ARCH-0001 | Dataå±‚æ¶æ„å®¡æŸ¥æŠ¥å‘Š |
| æ¶æ„å®¡æŸ¥ | - | domain-layer-architecture-review |
| æ¶æ„å®¡æŸ¥ | - | Presentationæ¶æ„å®¡æŸ¥æŠ¥å‘Š |
| æ¶æ„å®¡æŸ¥ | - | APPå±‚æ¶æ„å®¡æŸ¥æŠ¥å‘Š |
| å®¡æŸ¥æŠ¥å‘Š | DR-00027 | FD-00027æ–‡æ¡£å®¡æŸ¥æŠ¥å‘Š |

---

## 1. æŠ€æœ¯æ¦‚è¿°

### 1.1 ä¿®å¤ç›®æ ‡

åŸºäºMAæ–‡æ¡£åˆ†æç»“æœï¼Œç³»ç»Ÿæ€§åœ°è§£å†³é¡¹ç›®åœ¨ä»£ç è´¨é‡ã€æ¶æ„è®¾è®¡å’Œæµ‹è¯•è¦†ç›–ç‡æ–¹é¢å­˜åœ¨çš„é—®é¢˜ã€‚

### 1.2 æŠ€æœ¯èŒƒå›´

| æ¨¡å— | ä¿®å¤å†…å®¹ | å½±å“èŒƒå›´ |
|------|----------|----------|
| :app | æ„å»ºé…ç½®ã€DIæ¨¡å— | æ„å»ºç³»ç»Ÿ |
| :data | Repositoryå®ç°ã€Parseré‡æ„ | æ•°æ®å±‚ |
| :presentation | ViewModelæ¸…ç†ã€ç»„ä»¶ç›®å½•ä¼˜åŒ– | è¡¨ç°å±‚ |
| :domain | UseCaseæµ‹è¯•ã€Serviceæ‹†åˆ† | é¢†åŸŸå±‚ |

---

## 2. P0ä¸¥é‡é—®é¢˜æŠ€æœ¯æ–¹æ¡ˆ

### 2.1 æ„å»ºé…ç½®é—®é¢˜ä¿®å¤

#### 2.1.1 é—®é¢˜åˆ†æ

**æ ¹å› **ï¼šappæ¨¡å—å®šä¹‰äº†`dev`æ„å»ºå˜ä½“ï¼Œä½†presentationå’Œdataæ¨¡å—æ²¡æœ‰å¯¹åº”å˜ä½“ã€‚

**å½±å“**ï¼š
- `testDevUnitTest`ä»»åŠ¡æ— æ³•æ‰§è¡Œ
- IDEä¸­é€‰æ‹©devå˜ä½“ä¼šå¤±è´¥

#### 2.1.2 æŠ€æœ¯å®ç°

**ä¿®æ”¹æ–‡ä»¶**ï¼š
1. `presentation/build.gradle.kts`
2. `data/build.gradle.kts`

**ä»£ç å®ç°**ï¼š

```kotlin
// presentation/build.gradle.kts
android {
    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
        debug {
            isMinifyEnabled = false
        }
        create("dev") {
            initWith(getByName("debug"))
            matchingFallbacks += listOf("debug")
        }
    }
}
```

```kotlin
// data/build.gradle.kts
android {
    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
        debug {
            isMinifyEnabled = false
        }
        create("dev") {
            initWith(getByName("debug"))
            matchingFallbacks += listOf("debug")
        }
    }
}
```

#### 2.1.3 éªŒè¯å‘½ä»¤

```bash
# éªŒè¯æ„å»ºå˜ä½“é…ç½®
./gradlew :presentation:assembleDevDebug
./gradlew :data:assembleDevDebug

# éªŒè¯æµ‹è¯•ä»»åŠ¡
./gradlew testDevUnitTest

# éªŒè¯IDEåŒæ­¥
# åœ¨Android Studioä¸­é€‰æ‹©devå˜ä½“ï¼Œç¡®è®¤æ— é”™è¯¯
```

---

## 3. P1ä¸­ç­‰é—®é¢˜æŠ€æœ¯æ–¹æ¡ˆ

### 3.1 UseCaseæµ‹è¯•è¦†ç›–æŠ€æœ¯è®¾è®¡

#### 3.1.1 æµ‹è¯•æ¶æ„

```
domain/src/test/kotlin/com/empathy/ai/domain/usecase/
â”œâ”€â”€ PolishDraftUseCaseTest.kt       # è‰ç¨¿æ¶¦è‰²æµ‹è¯•
â”œâ”€â”€ GenerateReplyUseCaseTest.kt     # ç”Ÿæˆå›å¤æµ‹è¯•
â”œâ”€â”€ CheckDraftUseCaseTest.kt        # å®‰å…¨æ£€æŸ¥æµ‹è¯•
â”œâ”€â”€ RefinementUseCaseTest.kt        # ç»†åŒ–ä¼˜åŒ–æµ‹è¯•
â”œâ”€â”€ SummarizeDailyConversationsUseCaseTest.kt  # æ¯æ—¥æ€»ç»“æµ‹è¯•
â”œâ”€â”€ ManualSummaryUseCaseTest.kt     # æ‰‹åŠ¨æ€»ç»“æµ‹è¯•
â”œâ”€â”€ SaveProfileUseCaseTest.kt       # è”ç³»äººä¿å­˜æµ‹è¯•
â”œâ”€â”€ GetContactUseCaseTest.kt        # è”ç³»äººè·å–æµ‹è¯•
â”œâ”€â”€ SaveBrainTagUseCaseTest.kt      # æ ‡ç­¾ä¿å­˜æµ‹è¯•
â””â”€â”€ EditFactUseCaseTest.kt          # äº‹å®ç¼–è¾‘æµ‹è¯•
```

#### 3.1.2 æµ‹è¯•åŸºç±»è®¾è®¡

```kotlin
/**
 * UseCaseæµ‹è¯•åŸºç±»
 * 
 * æä¾›ç»Ÿä¸€çš„æµ‹è¯•ç¯å¢ƒé…ç½®å’Œè¾…åŠ©æ–¹æ³•
 */
@OptIn(ExperimentalCoroutinesApi::class)
abstract class BaseUseCaseTest {

    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()

    @MockK
    protected lateinit var logger: Logger

    @Before
    open fun setup() {
        MockKAnnotations.init(this)
        every { logger.d(any(), any()) } just Runs
        every { logger.e(any(), any(), any()) } just Runs
        every { logger.w(any(), any()) } just Runs
        every { logger.i(any(), any()) } just Runs
    }

    @After
    open fun tearDown() {
        unmockkAll()
    }

    /**
     * åˆ›å»ºæµ‹è¯•ç”¨è”ç³»äººç”»åƒ
     */
    protected fun createTestContactProfile(
        id: String = "test-contact-id",
        name: String = "æµ‹è¯•è”ç³»äºº",
        contextDepth: Int = 5
    ): ContactProfile {
        return ContactProfile(
            id = id,
            name = name,
            contextDepth = contextDepth,
            lastInteractionDate = null,
            originalGoal = null
        )
    }

    /**
     * åˆ›å»ºæµ‹è¯•ç”¨AIæœåŠ¡å•†
     */
    protected fun createTestAiProvider(
        id: String = "test-provider-id",
        name: String = "æµ‹è¯•æœåŠ¡å•†",
        isDefault: Boolean = true
    ): AiProvider {
        return AiProvider(
            id = id,
            name = name,
            baseUrl = "https://api.test.com",
            apiKey = "test-api-key",
            model = "gpt-4",
            isDefault = isDefault
        )
    }
}
```

#### 3.1.3 PolishDraftUseCaseæµ‹è¯•å®ç°

```kotlin
/**
 * PolishDraftUseCaseå•å…ƒæµ‹è¯•
 *
 * æµ‹è¯•è¦†ç›–ï¼š
 * 1. æ­£å¸¸æµç¨‹æµ‹è¯•
 * 2. å‰ç½®æ£€æŸ¥æµ‹è¯•
 * 3. è¾¹ç•Œæƒ…å†µæµ‹è¯•
 * 4. é”™è¯¯å¤„ç†æµ‹è¯•
 */
@OptIn(ExperimentalCoroutinesApi::class)
class PolishDraftUseCaseTest : BaseUseCaseTest() {

    @MockK
    private lateinit var aiRepository: AiRepository

    @MockK
    private lateinit var contactRepository: ContactRepository

    @MockK
    private lateinit var aiProviderRepository: AiProviderRepository

    @MockK
    private lateinit var promptBuilder: PromptBuilder

    @MockK
    private lateinit var sessionContextService: SessionContextService

    private lateinit var useCase: PolishDraftUseCase

    @Before
    override fun setup() {
        super.setup()
        useCase = PolishDraftUseCase(
            aiRepository = aiRepository,
            contactRepository = contactRepository,
            aiProviderRepository = aiProviderRepository,
            promptBuilder = promptBuilder,
            sessionContextService = sessionContextService,
            logger = logger
        )
    }

    // ============================================================================
    // æ­£å¸¸æµç¨‹æµ‹è¯•
    // ============================================================================

    @Test
    fun `should return polished draft when all conditions are met`() = runTest {
        // Given
        val contactId = "test-contact-id"
        val draft = "è¿™æ˜¯ä¸€æ®µéœ€è¦æ¶¦è‰²çš„æ–‡å­—"
        val contact = createTestContactProfile(id = contactId)
        val provider = createTestAiProvider()
        val expectedResult = PolishResult(
            polishedText = "è¿™æ˜¯æ¶¦è‰²åçš„æ–‡å­—",
            suggestions = listOf("å»ºè®®1", "å»ºè®®2")
        )

        coEvery { contactRepository.getContactById(contactId) } returns Result.success(contact)
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(provider)
        coEvery { promptBuilder.buildPolishPrompt(any(), any()) } returns "ç³»ç»Ÿæç¤ºè¯"
        coEvery { sessionContextService.getHistoryContext(contactId) } returns emptyList()
        coEvery { aiRepository.polishDraft(any(), any(), any()) } returns Result.success(expectedResult)

        // When
        val result = useCase(contactId, draft)

        // Then
        assertTrue(result.isSuccess)
        assertEquals(expectedResult.polishedText, result.getOrNull()?.polishedText)
        coVerify { aiRepository.polishDraft(provider, any(), draft) }
    }

    // ============================================================================
    // å‰ç½®æ£€æŸ¥æµ‹è¯•
    // ============================================================================

    @Test
    fun `should return failure when draft is empty`() = runTest {
        // Given
        val contactId = "test-contact-id"
        val draft = ""

        // When
        val result = useCase(contactId, draft)

        // Then
        assertTrue(result.isFailure)
        assertTrue(result.exceptionOrNull() is IllegalArgumentException)
    }

    @Test
    fun `should return failure when draft is whitespace only`() = runTest {
        // Given
        val contactId = "test-contact-id"
        val draft = "   \n\t  "

        // When
        val result = useCase(contactId, draft)

        // Then
        assertTrue(result.isFailure)
    }

    @Test
    fun `should return failure when contact not found`() = runTest {
        // Given
        val contactId = "non-existent-id"
        val draft = "æµ‹è¯•æ–‡å­—"

        coEvery { contactRepository.getContactById(contactId) } returns 
            Result.failure(Exception("Contact not found"))

        // When
        val result = useCase(contactId, draft)

        // Then
        assertTrue(result.isFailure)
    }

    // ============================================================================
    // è¾¹ç•Œæƒ…å†µæµ‹è¯•
    // ============================================================================

    @Test
    fun `should return failure when draft exceeds max length`() = runTest {
        // Given
        val contactId = "test-contact-id"
        val draft = "a".repeat(10001) // è¶…è¿‡æœ€å¤§é•¿åº¦

        // When
        val result = useCase(contactId, draft)

        // Then
        assertTrue(result.isFailure)
    }

    @Test
    fun `should handle special characters correctly`() = runTest {
        // Given
        val contactId = "test-contact-id"
        val draft = "æµ‹è¯•æ–‡å­— ğŸ‰ ç‰¹æ®Šç¬¦å· @#$%"
        val contact = createTestContactProfile(id = contactId)
        val provider = createTestAiProvider()
        val expectedResult = PolishResult(polishedText = "æ¶¦è‰²åçš„æ–‡å­—", suggestions = emptyList())

        coEvery { contactRepository.getContactById(contactId) } returns Result.success(contact)
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(provider)
        coEvery { promptBuilder.buildPolishPrompt(any(), any()) } returns "ç³»ç»Ÿæç¤ºè¯"
        coEvery { sessionContextService.getHistoryContext(contactId) } returns emptyList()
        coEvery { aiRepository.polishDraft(any(), any(), any()) } returns Result.success(expectedResult)

        // When
        val result = useCase(contactId, draft)

        // Then
        assertTrue(result.isSuccess)
    }

    @Test
    fun `should succeed when history context is empty`() = runTest {
        // Given
        val contactId = "test-contact-id"
        val draft = "æµ‹è¯•æ–‡å­—"
        val contact = createTestContactProfile(id = contactId)
        val provider = createTestAiProvider()
        val expectedResult = PolishResult(polishedText = "æ¶¦è‰²åçš„æ–‡å­—", suggestions = emptyList())

        coEvery { contactRepository.getContactById(contactId) } returns Result.success(contact)
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(provider)
        coEvery { promptBuilder.buildPolishPrompt(any(), any()) } returns "ç³»ç»Ÿæç¤ºè¯"
        coEvery { sessionContextService.getHistoryContext(contactId) } returns emptyList()
        coEvery { aiRepository.polishDraft(any(), any(), any()) } returns Result.success(expectedResult)

        // When
        val result = useCase(contactId, draft)

        // Then
        assertTrue(result.isSuccess)
    }

    // ============================================================================
    // é”™è¯¯å¤„ç†æµ‹è¯•
    // ============================================================================

    @Test
    fun `should return failure when AI service unavailable`() = runTest {
        // Given
        val contactId = "test-contact-id"
        val draft = "æµ‹è¯•æ–‡å­—"
        val contact = createTestContactProfile(id = contactId)
        val provider = createTestAiProvider()

        coEvery { contactRepository.getContactById(contactId) } returns Result.success(contact)
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(provider)
        coEvery { promptBuilder.buildPolishPrompt(any(), any()) } returns "ç³»ç»Ÿæç¤ºè¯"
        coEvery { sessionContextService.getHistoryContext(contactId) } returns emptyList()
        coEvery { aiRepository.polishDraft(any(), any(), any()) } returns 
            Result.failure(Exception("Service unavailable"))

        // When
        val result = useCase(contactId, draft)

        // Then
        assertTrue(result.isFailure)
    }

    @Test
    fun `should return failure when no default provider configured`() = runTest {
        // Given
        val contactId = "test-contact-id"
        val draft = "æµ‹è¯•æ–‡å­—"
        val contact = createTestContactProfile(id = contactId)

        coEvery { contactRepository.getContactById(contactId) } returns Result.success(contact)
        coEvery { aiProviderRepository.getDefaultProvider() } returns 
            Result.failure(Exception("No default provider"))

        // When
        val result = useCase(contactId, draft)

        // Then
        assertTrue(result.isFailure)
    }

    @Test
    fun `should handle coroutine cancellation`() = runTest {
        // Given
        val contactId = "test-contact-id"
        val draft = "æµ‹è¯•æ–‡å­—"

        coEvery { contactRepository.getContactById(contactId) } coAnswers {
            delay(1000)
            Result.success(createTestContactProfile())
        }

        // When
        val job = launch {
            useCase(contactId, draft)
        }
        delay(100)
        job.cancel()

        // Then
        assertTrue(job.isCancelled)
    }
}
```


### 3.2 FallbackHandleræ¥å£å®ç°æŠ€æœ¯è®¾è®¡

#### 3.2.1 ç±»å›¾è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    <<interface>>                             â”‚
â”‚                    FallbackHandler                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ + handleFallback<T>(context: FallbackContext<T>):           â”‚
â”‚                     FallbackResult<T>                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–³
                              â”‚ implements
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  DefaultFallbackHandler                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - jsonCleaner: EnhancedJsonCleaner                          â”‚
â”‚ - fieldMapper: FieldMapper                                   â”‚
â”‚ - logger: Logger                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ + handleFallback<T>(context): FallbackResult<T>             â”‚
â”‚ - tryStrategy<T>(strategy, context): FallbackResult<T>      â”‚
â”‚ - extractText<T>(context): FallbackResult<T>                â”‚
â”‚ - mapFields<T>(context): FallbackResult<T>                  â”‚
â”‚ - useDefaultValue<T>(context): FallbackResult<T>            â”‚
â”‚ - partialParse<T>(context): FallbackResult<T>               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.2.2 å®ç°ä»£ç 

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/parser/DefaultFallbackHandler.kt

/**
 * é»˜è®¤é™çº§å¤„ç†å™¨å®ç°
 *
 * èŒè´£ï¼š
 * 1. å¤„ç†AIå“åº”è§£æå¤±è´¥çš„é™çº§é€»è¾‘
 * 2. æŒ‰ç­–ç•¥é¡ºåºå°è¯•æ¢å¤æ•°æ®
 * 3. è®°å½•é™çº§æ—¥å¿—ç”¨äºåˆ†æ
 */
@Singleton
class DefaultFallbackHandler @Inject constructor(
    private val jsonCleaner: EnhancedJsonCleaner,
    private val fieldMapper: FieldMapper,
    private val logger: Logger
) : FallbackHandler {

    companion object {
        private const val TAG = "DefaultFallbackHandler"
    }

    override fun <T> handleFallback(context: FallbackContext<T>): FallbackResult<T> {
        logger.d(TAG, "å¼€å§‹é™çº§å¤„ç†ï¼Œç›®æ ‡ç±»å‹: ${context.targetType.simpleName}")
        
        val strategies = context.fallbackStrategies.ifEmpty {
            listOf(
                FallbackStrategy.FIELD_MAPPING,
                FallbackStrategy.EXTRACT_TEXT,
                FallbackStrategy.DEFAULT_VALUE
            )
        }

        for (strategy in strategies) {
            logger.d(TAG, "å°è¯•é™çº§ç­–ç•¥: $strategy")
            val result = tryStrategy(strategy, context)
            if (result is FallbackResult.Success) {
                logger.i(TAG, "é™çº§ç­–ç•¥ $strategy æˆåŠŸ")
                return result
            }
            logger.d(TAG, "é™çº§ç­–ç•¥ $strategy å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ª")
        }

        logger.e(TAG, "æ‰€æœ‰é™çº§ç­–ç•¥å‡å¤±è´¥", context.parseError)
        return FallbackResult.Failure(context.parseError)
    }

    private fun <T> tryStrategy(
        strategy: FallbackStrategy,
        context: FallbackContext<T>
    ): FallbackResult<T> {
        return try {
            when (strategy) {
                FallbackStrategy.EXTRACT_TEXT -> extractText(context)
                FallbackStrategy.FIELD_MAPPING -> mapFields(context)
                FallbackStrategy.DEFAULT_VALUE -> useDefaultValue(context)
                FallbackStrategy.PARTIAL_PARSE -> partialParse(context)
            }
        } catch (e: Exception) {
            logger.w(TAG, "ç­–ç•¥ $strategy æ‰§è¡Œå¼‚å¸¸", e)
            FallbackResult.Failure(e)
        }
    }

    @Suppress("UNCHECKED_CAST")
    private fun <T> extractText(context: FallbackContext<T>): FallbackResult<T> {
        val cleanedText = jsonCleaner.extractPlainText(context.originalResponse)
        
        // æ ¹æ®ç›®æ ‡ç±»å‹æ„å»ºç»“æœ
        return when (context.targetType) {
            PolishResult::class.java -> {
                val result = PolishResult(
                    polishedText = cleanedText,
                    suggestions = emptyList()
                )
                FallbackResult.Success(result as T)
            }
            ReplyResult::class.java -> {
                val result = ReplyResult(
                    replyText = cleanedText,
                    tone = "neutral"
                )
                FallbackResult.Success(result as T)
            }
            else -> FallbackResult.Failure(
                UnsupportedOperationException("ä¸æ”¯æŒçš„ç›®æ ‡ç±»å‹: ${context.targetType.simpleName}")
            )
        }
    }

    private fun <T> mapFields(context: FallbackContext<T>): FallbackResult<T> {
        return try {
            val mapped = fieldMapper.mapToType(
                context.originalResponse,
                context.targetType
            )
            FallbackResult.Success(mapped)
        } catch (e: Exception) {
            FallbackResult.Failure(e)
        }
    }

    @Suppress("UNCHECKED_CAST")
    private fun <T> useDefaultValue(context: FallbackContext<T>): FallbackResult<T> {
        return when (context.targetType) {
            PolishResult::class.java -> {
                FallbackResult.Success(PolishResult.empty() as T)
            }
            ReplyResult::class.java -> {
                FallbackResult.Success(ReplyResult.empty() as T)
            }
            AnalysisResult::class.java -> {
                FallbackResult.Success(AnalysisResult.empty() as T)
            }
            SafetyCheckResult::class.java -> {
                FallbackResult.Success(SafetyCheckResult.safe() as T)
            }
            else -> FallbackResult.Failure(
                UnsupportedOperationException("ä¸æ”¯æŒçš„ç›®æ ‡ç±»å‹: ${context.targetType.simpleName}")
            )
        }
    }

    private fun <T> partialParse(context: FallbackContext<T>): FallbackResult<T> {
        return try {
            val partial = jsonCleaner.partialParse(
                context.originalResponse,
                context.targetType
            )
            FallbackResult.Success(partial)
        } catch (e: Exception) {
            FallbackResult.Failure(e)
        }
    }
}
```

#### 3.2.3 DIé…ç½®

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/di/ParserModule.kt

@Module
@InstallIn(SingletonComponent::class)
abstract class ParserModule {

    @Binds
    @Singleton
    abstract fun bindFallbackHandler(
        impl: DefaultFallbackHandler
    ): FallbackHandler

    companion object {
        @Provides
        @Singleton
        fun provideEnhancedJsonCleaner(): EnhancedJsonCleaner {
            return EnhancedJsonCleaner()
        }

        @Provides
        @Singleton
        fun provideFieldMapper(moshi: Moshi): FieldMapper {
            return FieldMapper(moshi)
        }
    }
}
```

#### 3.2.4 å•å…ƒæµ‹è¯•

```kotlin
@OptIn(ExperimentalCoroutinesApi::class)
class DefaultFallbackHandlerTest {

    @MockK
    private lateinit var jsonCleaner: EnhancedJsonCleaner

    @MockK
    private lateinit var fieldMapper: FieldMapper

    @MockK
    private lateinit var logger: Logger

    private lateinit var handler: DefaultFallbackHandler

    @Before
    fun setup() {
        MockKAnnotations.init(this)
        every { logger.d(any(), any()) } just Runs
        every { logger.i(any(), any()) } just Runs
        every { logger.w(any(), any(), any()) } just Runs
        every { logger.e(any(), any(), any()) } just Runs
        
        handler = DefaultFallbackHandler(jsonCleaner, fieldMapper, logger)
    }

    @Test
    fun `should extract text when field mapping fails`() {
        // Given
        val response = "è¿™æ˜¯AIè¿”å›çš„çº¯æ–‡æœ¬å†…å®¹"
        val context = FallbackContext(
            originalResponse = response,
            parseError = JsonParseException("Invalid JSON"),
            targetType = PolishResult::class.java
        )
        
        every { fieldMapper.mapToType(any(), any<Class<*>>()) } throws Exception("Mapping failed")
        every { jsonCleaner.extractPlainText(response) } returns response

        // When
        val result = handler.handleFallback(context)

        // Then
        assertTrue(result is FallbackResult.Success)
        val polishResult = (result as FallbackResult.Success).data
        assertEquals(response, polishResult.polishedText)
    }

    @Test
    fun `should use default value when all strategies fail`() {
        // Given
        val context = FallbackContext(
            originalResponse = "",
            parseError = Exception("Parse error"),
            targetType = SafetyCheckResult::class.java,
            fallbackStrategies = listOf(FallbackStrategy.DEFAULT_VALUE)
        )

        // When
        val result = handler.handleFallback(context)

        // Then
        assertTrue(result is FallbackResult.Success)
        val safetyResult = (result as FallbackResult.Success).data
        assertTrue(safetyResult.isSafe)
    }

    @Test
    fun `should return failure for unsupported type`() {
        // Given
        val context = FallbackContext(
            originalResponse = "test",
            parseError = Exception("Parse error"),
            targetType = String::class.java,
            fallbackStrategies = listOf(FallbackStrategy.DEFAULT_VALUE)
        )

        // When
        val result = handler.handleFallback(context)

        // Then
        assertTrue(result is FallbackResult.Failure)
    }
}
```


### 3.3 Parseræ¥å£é‡æ„æŠ€æœ¯è®¾è®¡

#### 3.3.1 æ¥å£æ‹†åˆ†è®¾è®¡

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/parser/

/**
 * åŸºç¡€è§£ææ¥å£ï¼ˆé€šç”¨ï¼‰
 */
interface BaseResponseParser {
    /**
     * æ¸…ç†åŸå§‹å“åº”
     */
    fun cleanResponse(rawResponse: String): String
    
    /**
     * æå–JSONå—
     */
    fun extractJsonBlock(response: String): String?
}

/**
 * åˆ†æç»“æœè§£ææ¥å£
 */
interface AnalysisResultParser {
    fun parseAnalysisResult(response: String): Result<AnalysisResult>
}

/**
 * å®‰å…¨æ£€æŸ¥ç»“æœè§£ææ¥å£
 */
interface SafetyCheckResultParser {
    fun parseSafetyCheckResult(response: String): Result<SafetyCheckResult>
}

/**
 * æ¶¦è‰²ç»“æœè§£ææ¥å£
 */
interface PolishResultParser {
    fun parsePolishResult(response: String): Result<PolishResult>
}

/**
 * å›å¤ç»“æœè§£ææ¥å£
 */
interface ReplyResultParser {
    fun parseReplyResult(response: String): Result<ReplyResult>
}

/**
 * æ€»ç»“ç»“æœè§£ææ¥å£
 */
interface SummaryResultParser {
    fun parseSummaryResult(response: String): Result<AiSummaryResponse>
}
```

#### 3.3.2 ç»Ÿä¸€è§£æå™¨å®ç°

```kotlin
/**
 * AIå“åº”è§£æå™¨ç»Ÿä¸€å®ç°
 *
 * èŒè´£ï¼š
 * 1. å®ç°æ‰€æœ‰è§£ææ¥å£
 * 2. ç»Ÿä¸€é”™è¯¯å¤„ç†å’Œé™çº§é€»è¾‘
 * 3. ä½¿ç”¨FallbackHandlerå¤„ç†è§£æå¤±è´¥
 */
@Singleton
class UnifiedAiResponseParser @Inject constructor(
    private val jsonCleaner: EnhancedJsonCleaner,
    private val fallbackHandler: FallbackHandler,
    private val moshi: Moshi,
    private val logger: Logger
) : BaseResponseParser,
    AnalysisResultParser,
    SafetyCheckResultParser,
    PolishResultParser,
    ReplyResultParser,
    SummaryResultParser {

    companion object {
        private const val TAG = "UnifiedAiResponseParser"
    }

    // ============================================================================
    // BaseResponseParser å®ç°
    // ============================================================================

    override fun cleanResponse(rawResponse: String): String {
        return jsonCleaner.clean(rawResponse)
    }

    override fun extractJsonBlock(response: String): String? {
        return jsonCleaner.extractJsonBlock(response)
    }

    // ============================================================================
    // å„ç±»å‹è§£æå®ç°
    // ============================================================================

    override fun parseAnalysisResult(response: String): Result<AnalysisResult> {
        return parseWithFallback(response, AnalysisResult::class.java)
    }

    override fun parseSafetyCheckResult(response: String): Result<SafetyCheckResult> {
        return parseWithFallback(response, SafetyCheckResult::class.java)
    }

    override fun parsePolishResult(response: String): Result<PolishResult> {
        return parseWithFallback(response, PolishResult::class.java)
    }

    override fun parseReplyResult(response: String): Result<ReplyResult> {
        return parseWithFallback(response, ReplyResult::class.java)
    }

    override fun parseSummaryResult(response: String): Result<AiSummaryResponse> {
        return parseWithFallback(response, AiSummaryResponse::class.java)
    }

    // ============================================================================
    // ç§æœ‰æ–¹æ³•
    // ============================================================================

    private fun <T> parseWithFallback(
        response: String,
        targetType: Class<T>
    ): Result<T> {
        return try {
            val cleaned = cleanResponse(response)
            val jsonBlock = extractJsonBlock(cleaned) ?: cleaned
            
            val adapter = moshi.adapter(targetType)
            val result = adapter.fromJson(jsonBlock)
            
            if (result != null) {
                Result.success(result)
            } else {
                handleParseFailure(response, targetType, NullPointerException("è§£æç»“æœä¸ºç©º"))
            }
        } catch (e: Exception) {
            logger.w(TAG, "æ ‡å‡†è§£æå¤±è´¥ï¼Œå°è¯•é™çº§å¤„ç†: ${e.message}")
            handleParseFailure(response, targetType, e)
        }
    }

    private fun <T> handleParseFailure(
        response: String,
        targetType: Class<T>,
        error: Exception
    ): Result<T> {
        val context = FallbackContext(
            originalResponse = response,
            parseError = error,
            targetType = targetType
        )
        
        return when (val fallbackResult = fallbackHandler.handleFallback(context)) {
            is FallbackResult.Success -> Result.success(fallbackResult.data)
            is FallbackResult.Failure -> Result.failure(fallbackResult.error)
        }
    }
}
```

#### 3.3.3 DIé…ç½®æ›´æ–°

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/di/ParserModule.kt

@Module
@InstallIn(SingletonComponent::class)
abstract class ParserModule {

    @Binds
    @Singleton
    abstract fun bindFallbackHandler(
        impl: DefaultFallbackHandler
    ): FallbackHandler

    @Binds
    @Singleton
    abstract fun bindBaseResponseParser(
        impl: UnifiedAiResponseParser
    ): BaseResponseParser

    @Binds
    @Singleton
    abstract fun bindAnalysisResultParser(
        impl: UnifiedAiResponseParser
    ): AnalysisResultParser

    @Binds
    @Singleton
    abstract fun bindSafetyCheckResultParser(
        impl: UnifiedAiResponseParser
    ): SafetyCheckResultParser

    @Binds
    @Singleton
    abstract fun bindPolishResultParser(
        impl: UnifiedAiResponseParser
    ): PolishResultParser

    @Binds
    @Singleton
    abstract fun bindReplyResultParser(
        impl: UnifiedAiResponseParser
    ): ReplyResultParser

    @Binds
    @Singleton
    abstract fun bindSummaryResultParser(
        impl: UnifiedAiResponseParser
    ): SummaryResultParser
}
```


### 3.4 AiRepositoryImplæ‹†åˆ†æŠ€æœ¯è®¾è®¡

#### 3.4.1 æ‹†åˆ†åæ–‡ä»¶ç»“æ„

```
data/src/main/kotlin/com/empathy/ai/data/repository/ai/
â”œâ”€â”€ AiRepositoryImpl.kt           # ä¸»Repositoryå®ç°ï¼ˆ~250è¡Œï¼‰
â”œâ”€â”€ AiRequestBuilder.kt           # AIè¯·æ±‚æ„å»ºå™¨ï¼ˆ~150è¡Œï¼‰
â”œâ”€â”€ AiResponseHandler.kt          # AIå“åº”å¤„ç†å™¨ï¼ˆ~200è¡Œï¼‰
â””â”€â”€ AiProviderAdapter.kt          # AIæœåŠ¡å•†é€‚é…å™¨ï¼ˆ~150è¡Œï¼‰
```

#### 3.4.2 AiRequestBuilderå®ç°

```kotlin
/**
 * AIè¯·æ±‚æ„å»ºå™¨
 *
 * èŒè´£ï¼š
 * 1. æ„å»ºAIè¯·æ±‚å‚æ•°
 * 2. ç»„è£…ç³»ç»Ÿæç¤ºè¯
 * 3. å¤„ç†è¯·æ±‚æ ¼å¼åŒ–
 */
@Singleton
class AiRequestBuilder @Inject constructor(
    private val logger: Logger
) {
    companion object {
        private const val TAG = "AiRequestBuilder"
        private const val DEFAULT_MAX_TOKENS = 2048
        private const val DEFAULT_TEMPERATURE = 0.7
    }

    /**
     * æ„å»ºèŠå¤©è¯·æ±‚
     */
    fun buildChatRequest(
        provider: AiProvider,
        systemPrompt: String,
        userPrompt: String,
        maxTokens: Int = DEFAULT_MAX_TOKENS,
        temperature: Double = DEFAULT_TEMPERATURE
    ): ChatRequestDto {
        logger.d(TAG, "æ„å»ºèŠå¤©è¯·æ±‚ï¼Œæ¨¡å‹: ${provider.model}")
        
        return ChatRequestDto(
            model = provider.model,
            messages = listOf(
                MessageDto(role = "system", content = systemPrompt),
                MessageDto(role = "user", content = userPrompt)
            ),
            maxTokens = maxTokens,
            temperature = temperature
        )
    }

    /**
     * æ„å»ºå®‰å…¨æ£€æŸ¥è¯·æ±‚
     */
    fun buildSafetyCheckRequest(
        provider: AiProvider,
        systemPrompt: String,
        draft: String
    ): ChatRequestDto {
        logger.d(TAG, "æ„å»ºå®‰å…¨æ£€æŸ¥è¯·æ±‚")
        
        val userPrompt = """
            è¯·æ£€æŸ¥ä»¥ä¸‹æ–‡æœ¬çš„å®‰å…¨æ€§ï¼š
            
            $draft
        """.trimIndent()
        
        return buildChatRequest(
            provider = provider,
            systemPrompt = systemPrompt,
            userPrompt = userPrompt,
            maxTokens = 1024,
            temperature = 0.3
        )
    }

    /**
     * æ„å»ºæ¶¦è‰²è¯·æ±‚
     */
    fun buildPolishRequest(
        provider: AiProvider,
        systemPrompt: String,
        draft: String,
        historyContext: List<String> = emptyList()
    ): ChatRequestDto {
        logger.d(TAG, "æ„å»ºæ¶¦è‰²è¯·æ±‚ï¼Œå†å²ä¸Šä¸‹æ–‡æ•°é‡: ${historyContext.size}")
        
        val contextSection = if (historyContext.isNotEmpty()) {
            """
                
                ã€å†å²ä¸Šä¸‹æ–‡ã€‘
                ${historyContext.joinToString("\n")}
            """.trimIndent()
        } else ""
        
        val userPrompt = """
            è¯·æ¶¦è‰²ä»¥ä¸‹æ–‡æœ¬ï¼š
            
            $draft
            $contextSection
        """.trimIndent()
        
        return buildChatRequest(
            provider = provider,
            systemPrompt = systemPrompt,
            userPrompt = userPrompt
        )
    }

    /**
     * æ„å»ºå›å¤ç”Ÿæˆè¯·æ±‚
     */
    fun buildReplyRequest(
        provider: AiProvider,
        systemPrompt: String,
        message: String,
        historyContext: List<String> = emptyList()
    ): ChatRequestDto {
        logger.d(TAG, "æ„å»ºå›å¤ç”Ÿæˆè¯·æ±‚")
        
        val contextSection = if (historyContext.isNotEmpty()) {
            """
                
                ã€å¯¹è¯å†å²ã€‘
                ${historyContext.joinToString("\n")}
            """.trimIndent()
        } else ""
        
        val userPrompt = """
            è¯·ä¸ºä»¥ä¸‹æ¶ˆæ¯ç”Ÿæˆå›å¤ï¼š
            
            $message
            $contextSection
        """.trimIndent()
        
        return buildChatRequest(
            provider = provider,
            systemPrompt = systemPrompt,
            userPrompt = userPrompt
        )
    }
}
```

#### 3.4.3 AiResponseHandlerå®ç°

```kotlin
/**
 * AIå“åº”å¤„ç†å™¨
 *
 * èŒè´£ï¼š
 * 1. å¤„ç†AIå“åº”
 * 2. è°ƒç”¨Parserè§£æ
 * 3. å¤„ç†è§£æé”™è¯¯
 */
@Singleton
class AiResponseHandler @Inject constructor(
    private val analysisResultParser: AnalysisResultParser,
    private val safetyCheckResultParser: SafetyCheckResultParser,
    private val polishResultParser: PolishResultParser,
    private val replyResultParser: ReplyResultParser,
    private val summaryResultParser: SummaryResultParser,
    private val logger: Logger
) {
    companion object {
        private const val TAG = "AiResponseHandler"
    }

    /**
     * å¤„ç†åˆ†æå“åº”
     */
    fun handleAnalysisResponse(response: ChatResponseDto): Result<AnalysisResult> {
        logger.d(TAG, "å¤„ç†åˆ†æå“åº”")
        val content = extractContent(response) ?: return Result.failure(
            Exception("å“åº”å†…å®¹ä¸ºç©º")
        )
        return analysisResultParser.parseAnalysisResult(content)
    }

    /**
     * å¤„ç†å®‰å…¨æ£€æŸ¥å“åº”
     */
    fun handleSafetyCheckResponse(response: ChatResponseDto): Result<SafetyCheckResult> {
        logger.d(TAG, "å¤„ç†å®‰å…¨æ£€æŸ¥å“åº”")
        val content = extractContent(response) ?: return Result.failure(
            Exception("å“åº”å†…å®¹ä¸ºç©º")
        )
        return safetyCheckResultParser.parseSafetyCheckResult(content)
    }

    /**
     * å¤„ç†æ¶¦è‰²å“åº”
     */
    fun handlePolishResponse(response: ChatResponseDto): Result<PolishResult> {
        logger.d(TAG, "å¤„ç†æ¶¦è‰²å“åº”")
        val content = extractContent(response) ?: return Result.failure(
            Exception("å“åº”å†…å®¹ä¸ºç©º")
        )
        return polishResultParser.parsePolishResult(content)
    }

    /**
     * å¤„ç†å›å¤ç”Ÿæˆå“åº”
     */
    fun handleReplyResponse(response: ChatResponseDto): Result<ReplyResult> {
        logger.d(TAG, "å¤„ç†å›å¤ç”Ÿæˆå“åº”")
        val content = extractContent(response) ?: return Result.failure(
            Exception("å“åº”å†…å®¹ä¸ºç©º")
        )
        return replyResultParser.parseReplyResult(content)
    }

    /**
     * å¤„ç†æ€»ç»“å“åº”
     */
    fun handleSummaryResponse(response: ChatResponseDto): Result<AiSummaryResponse> {
        logger.d(TAG, "å¤„ç†æ€»ç»“å“åº”")
        val content = extractContent(response) ?: return Result.failure(
            Exception("å“åº”å†…å®¹ä¸ºç©º")
        )
        return summaryResultParser.parseSummaryResult(content)
    }

    private fun extractContent(response: ChatResponseDto): String? {
        return response.choices?.firstOrNull()?.message?.content
    }
}
```

#### 3.4.4 AiProviderAdapterå®ç°

```kotlin
/**
 * AIæœåŠ¡å•†é€‚é…å™¨
 *
 * èŒè´£ï¼š
 * 1. é€‚é…ä¸åŒAIæœåŠ¡å•†çš„å·®å¼‚
 * 2. å¤„ç†URLå’Œè®¤è¯
 * 3. æ‰§è¡ŒAPIè¯·æ±‚
 */
@Singleton
class AiProviderAdapter @Inject constructor(
    private val api: OpenAiApi,
    private val logger: Logger
) {
    companion object {
        private const val TAG = "AiProviderAdapter"
    }

    /**
     * æ‰§è¡Œè¯·æ±‚
     */
    suspend fun executeRequest(
        provider: AiProvider,
        request: ChatRequestDto
    ): ChatResponseDto {
        logger.d(TAG, "æ‰§è¡Œè¯·æ±‚ï¼ŒæœåŠ¡å•†: ${provider.name}, URL: ${provider.baseUrl}")
        
        return api.chat(
            url = "${provider.baseUrl}/chat/completions",
            authorization = "Bearer ${provider.apiKey}",
            request = request
        )
    }

    /**
     * æµ‹è¯•è¿æ¥
     */
    suspend fun testConnection(provider: AiProvider): Result<Boolean> {
        return try {
            val response = api.listModels(
                url = "${provider.baseUrl}/models",
                authorization = "Bearer ${provider.apiKey}"
            )
            Result.success(response.data?.isNotEmpty() == true)
        } catch (e: Exception) {
            logger.e(TAG, "è¿æ¥æµ‹è¯•å¤±è´¥", e)
            Result.failure(e)
        }
    }
}
```

#### 3.4.5 é‡æ„åçš„AiRepositoryImpl

```kotlin
/**
 * AIä»“åº“å®ç°
 *
 * èŒè´£ï¼š
 * 1. åè°ƒè¯·æ±‚æ„å»ºã€APIè°ƒç”¨ã€å“åº”å¤„ç†
 * 2. å®ç°AiRepositoryæ¥å£
 * 3. ç®¡ç†é‡è¯•å’Œé”™è¯¯å¤„ç†
 */
@Singleton
class AiRepositoryImpl @Inject constructor(
    private val requestBuilder: AiRequestBuilder,
    private val responseHandler: AiResponseHandler,
    private val providerAdapter: AiProviderAdapter,
    private val logger: Logger
) : AiRepository {

    companion object {
        private const val TAG = "AiRepositoryImpl"
        private const val MAX_RETRIES = 3
        private const val INITIAL_BACKOFF_MS = 1000L
        private const val MAX_BACKOFF_MS = 10000L
    }

    override suspend fun analyzeChat(
        provider: AiProvider,
        systemPrompt: String,
        userPrompt: String
    ): Result<AnalysisResult> = withContext(Dispatchers.IO) {
        executeWithRetry {
            val request = requestBuilder.buildChatRequest(
                provider = provider,
                systemPrompt = systemPrompt,
                userPrompt = userPrompt
            )
            val response = providerAdapter.executeRequest(provider, request)
            responseHandler.handleAnalysisResponse(response)
        }
    }

    override suspend fun checkDraftSafety(
        provider: AiProvider,
        systemPrompt: String,
        draft: String
    ): Result<SafetyCheckResult> = withContext(Dispatchers.IO) {
        executeWithRetry {
            val request = requestBuilder.buildSafetyCheckRequest(
                provider = provider,
                systemPrompt = systemPrompt,
                draft = draft
            )
            val response = providerAdapter.executeRequest(provider, request)
            responseHandler.handleSafetyCheckResponse(response)
        }
    }

    override suspend fun polishDraft(
        provider: AiProvider,
        systemPrompt: String,
        draft: String,
        historyContext: List<String>
    ): Result<PolishResult> = withContext(Dispatchers.IO) {
        executeWithRetry {
            val request = requestBuilder.buildPolishRequest(
                provider = provider,
                systemPrompt = systemPrompt,
                draft = draft,
                historyContext = historyContext
            )
            val response = providerAdapter.executeRequest(provider, request)
            responseHandler.handlePolishResponse(response)
        }
    }

    override suspend fun generateReply(
        provider: AiProvider,
        systemPrompt: String,
        message: String,
        historyContext: List<String>
    ): Result<ReplyResult> = withContext(Dispatchers.IO) {
        executeWithRetry {
            val request = requestBuilder.buildReplyRequest(
                provider = provider,
                systemPrompt = systemPrompt,
                message = message,
                historyContext = historyContext
            )
            val response = providerAdapter.executeRequest(provider, request)
            responseHandler.handleReplyResponse(response)
        }
    }

    private suspend fun <T> executeWithRetry(
        operation: suspend () -> Result<T>
    ): Result<T> {
        var lastException: Exception? = null
        var backoffMs = INITIAL_BACKOFF_MS
        
        repeat(MAX_RETRIES) { attempt ->
            try {
                val result = operation()
                if (result.isSuccess) return result
                lastException = result.exceptionOrNull() as? Exception
            } catch (e: Exception) {
                lastException = e
                logger.w(TAG, "ç¬¬${attempt + 1}æ¬¡å°è¯•å¤±è´¥: ${e.message}")
            }
            
            if (attempt < MAX_RETRIES - 1) {
                delay(backoffMs)
                backoffMs = (backoffMs * 2).coerceAtMost(MAX_BACKOFF_MS)
            }
        }
        
        logger.e(TAG, "æ‰€æœ‰é‡è¯•å‡å¤±è´¥", lastException)
        return Result.failure(lastException ?: Exception("æœªçŸ¥é”™è¯¯"))
    }
}
```


### 3.5 é‡å¤ViewModelåˆå¹¶æŠ€æœ¯è®¾è®¡

#### 3.5.1 é—®é¢˜åˆ†æ

å½“å‰å­˜åœ¨ä¸¤ä¸ªé‡å¤çš„Debugç‰ˆæœ¬ViewModelï¼š
- `ContactDetailTabViewModelDebug.kt`
- `ContactDetailTabViewModelWithDebug.kt`

#### 3.5.2 åˆå¹¶æ–¹æ¡ˆ

ä½¿ç”¨`@VisibleForTesting`æ³¨è§£æš´éœ²æµ‹è¯•æ–¹æ³•ï¼Œåˆå¹¶ä¸ºå•ä¸€ViewModelï¼š

```kotlin
/**
 * è”ç³»äººè¯¦æƒ…æ ‡ç­¾é¡µViewModel
 *
 * èŒè´£ï¼š
 * 1. ç®¡ç†å››ä¸ªæ ‡ç­¾é¡µçš„UIçŠ¶æ€
 * 2. å¤„ç†ç”¨æˆ·äº¤äº’äº‹ä»¶
 * 3. è°ƒç”¨UseCaseæ‰§è¡Œä¸šåŠ¡é€»è¾‘
 */
@HiltViewModel
class ContactDetailTabViewModel @Inject constructor(
    private val getContactUseCase: GetContactUseCase,
    private val getBrainTagsUseCase: GetBrainTagsUseCase,
    private val getFactsUseCase: GetFactsUseCase,
    private val confirmTagUseCase: ConfirmTagUseCase,
    private val rejectTagUseCase: RejectTagUseCase,
    private val logger: Logger
) : ViewModel() {

    private val _uiState = MutableStateFlow(ContactDetailTabUiState())
    val uiState: StateFlow<ContactDetailTabUiState> = _uiState.asStateFlow()

    private val _events = MutableSharedFlow<ContactDetailTabEvent>()
    val events: SharedFlow<ContactDetailTabEvent> = _events.asSharedFlow()

    fun loadContact(contactId: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            
            getContactUseCase(contactId)
                .onSuccess { contact ->
                    _uiState.update { 
                        it.copy(
                            contact = contact,
                            isLoading = false
                        )
                    }
                    loadTags(contactId)
                    loadFacts(contactId)
                }
                .onFailure { error ->
                    _uiState.update { 
                        it.copy(
                            isLoading = false,
                            error = error.message
                        )
                    }
                }
        }
    }

    private fun loadTags(contactId: String) {
        viewModelScope.launch {
            getBrainTagsUseCase(contactId)
                .onSuccess { tags ->
                    _uiState.update { it.copy(tags = tags) }
                }
        }
    }

    private fun loadFacts(contactId: String) {
        viewModelScope.launch {
            getFactsUseCase(contactId)
                .onSuccess { facts ->
                    _uiState.update { it.copy(facts = facts) }
                }
        }
    }

    fun onEvent(event: ContactDetailTabUiEvent) {
        when (event) {
            is ContactDetailTabUiEvent.SelectTab -> selectTab(event.tabIndex)
            is ContactDetailTabUiEvent.ConfirmTag -> confirmTag(event.tagId)
            is ContactDetailTabUiEvent.RejectTag -> rejectTag(event.tagId)
            is ContactDetailTabUiEvent.Refresh -> refresh()
        }
    }

    private fun selectTab(tabIndex: Int) {
        _uiState.update { it.copy(selectedTabIndex = tabIndex) }
    }

    private fun confirmTag(tagId: String) {
        viewModelScope.launch {
            confirmTagUseCase(tagId)
                .onSuccess {
                    _uiState.value.contact?.id?.let { loadTags(it) }
                }
        }
    }

    private fun rejectTag(tagId: String) {
        viewModelScope.launch {
            rejectTagUseCase(tagId)
                .onSuccess {
                    _uiState.value.contact?.id?.let { loadTags(it) }
                }
        }
    }

    private fun refresh() {
        _uiState.value.contact?.id?.let { loadContact(it) }
    }

    // ============================================================================
    // æµ‹è¯•è¾…åŠ©æ–¹æ³•ï¼ˆä»…ç”¨äºæµ‹è¯•ï¼‰
    // ============================================================================

    @VisibleForTesting
    internal fun setStateForTesting(state: ContactDetailTabUiState) {
        _uiState.value = state
    }

    @VisibleForTesting
    internal fun getCurrentStateForTesting(): ContactDetailTabUiState {
        return _uiState.value
    }

    @VisibleForTesting
    internal suspend fun emitEventForTesting(event: ContactDetailTabEvent) {
        _events.emit(event)
    }
}
```

#### 3.5.3 åˆ é™¤å†—ä½™æ–‡ä»¶

```bash
# åˆ é™¤é‡å¤çš„Debugç‰ˆæœ¬æ–‡ä»¶
rm presentation/src/main/kotlin/.../viewmodel/ContactDetailTabViewModelDebug.kt
rm presentation/src/main/kotlin/.../viewmodel/ContactDetailTabViewModelWithDebug.kt
```

---

## 4. P2è½»å¾®é—®é¢˜æŠ€æœ¯æ–¹æ¡ˆ

### 4.1 PrivacyEngineæ‹†åˆ†æŠ€æœ¯è®¾è®¡

#### 4.1.1 æ‹†åˆ†åç»“æ„

```
domain/src/main/kotlin/com/empathy/ai/domain/service/privacy/
â”œâ”€â”€ SensitiveDataDetector.kt    # æ•æ„Ÿä¿¡æ¯æ£€æµ‹å™¨
â”œâ”€â”€ PrivacyMasker.kt            # éšç§æ•°æ®è„±æ•å™¨
â””â”€â”€ PrivacyEngine.kt            # é—¨é¢ç±»ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
```

#### 4.1.2 SensitiveDataDetectorå®ç°

```kotlin
/**
 * æ•æ„Ÿä¿¡æ¯æ£€æµ‹å™¨
 *
 * èŒè´£ï¼šæ£€æµ‹æ–‡æœ¬ä¸­çš„æ•æ„Ÿä¿¡æ¯
 */
object SensitiveDataDetector {
    
    object Patterns {
        val PHONE_NUMBER = "1[3-9]\\d{9}".toRegex()
        val ID_CARD = "\\d{17}[\\dXx]".toRegex()
        val EMAIL = "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}".toRegex()
        val BANK_CARD = "\\d{16,19}".toRegex()
    }

    data class DetectedPattern(
        val type: PatternType,
        val value: String,
        val range: IntRange
    )

    enum class PatternType {
        PHONE_NUMBER,
        ID_CARD,
        EMAIL,
        BANK_CARD
    }

    /**
     * æ£€æµ‹æ–‡æœ¬ä¸­çš„æ•æ„Ÿä¿¡æ¯
     */
    fun detect(text: String): List<DetectedPattern> {
        val results = mutableListOf<DetectedPattern>()
        
        // æ£€æµ‹æ‰‹æœºå·
        Patterns.PHONE_NUMBER.findAll(text).forEach { match ->
            results.add(DetectedPattern(
                type = PatternType.PHONE_NUMBER,
                value = match.value,
                range = match.range
            ))
        }
        
        // æ£€æµ‹èº«ä»½è¯å·
        Patterns.ID_CARD.findAll(text).forEach { match ->
            results.add(DetectedPattern(
                type = PatternType.ID_CARD,
                value = match.value,
                range = match.range
            ))
        }
        
        // æ£€æµ‹é‚®ç®±
        Patterns.EMAIL.findAll(text).forEach { match ->
            results.add(DetectedPattern(
                type = PatternType.EMAIL,
                value = match.value,
                range = match.range
            ))
        }
        
        // æ£€æµ‹é“¶è¡Œå¡å·
        Patterns.BANK_CARD.findAll(text).forEach { match ->
            // æ’é™¤å·²è¯†åˆ«ä¸ºèº«ä»½è¯å·çš„
            if (results.none { it.range.contains(match.range.first) }) {
                results.add(DetectedPattern(
                    type = PatternType.BANK_CARD,
                    value = match.value,
                    range = match.range
                ))
            }
        }
        
        return results.sortedBy { it.range.first }
    }
}
```

#### 4.1.3 PrivacyMaskerå®ç°

```kotlin
/**
 * éšç§æ•°æ®è„±æ•å™¨
 *
 * èŒè´£ï¼šå¯¹æ•æ„Ÿä¿¡æ¯è¿›è¡Œè„±æ•å¤„ç†
 */
object PrivacyMasker {

    /**
     * æ ¹æ®æ£€æµ‹ç»“æœè¿›è¡Œè„±æ•
     */
    fun mask(
        text: String, 
        patterns: List<SensitiveDataDetector.DetectedPattern>
    ): String {
        if (patterns.isEmpty()) return text
        
        // ä»åå‘å‰æ›¿æ¢ï¼Œé¿å…ç´¢å¼•åç§»
        val sortedPatterns = patterns.sortedByDescending { it.range.first }
        var result = text
        
        for (pattern in sortedPatterns) {
            val masked = maskByType(pattern.value, pattern.type)
            result = result.replaceRange(pattern.range, masked)
        }
        
        return result
    }

    /**
     * æ ¹æ®æ˜ å°„è§„åˆ™è¿›è¡Œè„±æ•
     */
    fun maskByMapping(text: String, mapping: Map<String, String>): String {
        var result = text
        for ((original, masked) in mapping) {
            result = result.replace(original, masked)
        }
        return result
    }

    /**
     * æ ¹æ®ç±»å‹è¿›è¡Œè„±æ•
     */
    fun maskByType(
        value: String,
        type: SensitiveDataDetector.PatternType
    ): String {
        return when (type) {
            SensitiveDataDetector.PatternType.PHONE_NUMBER -> {
                // ä¿ç•™å‰3å4ä½ï¼š138****1234
                if (value.length >= 7) {
                    value.take(3) + "****" + value.takeLast(4)
                } else {
                    "****"
                }
            }
            SensitiveDataDetector.PatternType.ID_CARD -> {
                // ä¿ç•™å‰6å4ä½ï¼š110101********1234
                if (value.length >= 10) {
                    value.take(6) + "********" + value.takeLast(4)
                } else {
                    "****"
                }
            }
            SensitiveDataDetector.PatternType.EMAIL -> {
                // ä¿ç•™@å‰2ä½å’ŒåŸŸåï¼šte***@example.com
                val atIndex = value.indexOf('@')
                if (atIndex > 2) {
                    value.take(2) + "***" + value.substring(atIndex)
                } else if (atIndex > 0) {
                    "***" + value.substring(atIndex)
                } else {
                    "***"
                }
            }
            SensitiveDataDetector.PatternType.BANK_CARD -> {
                // ä¿ç•™å4ä½ï¼š************1234
                "************" + value.takeLast(4)
            }
        }
    }
}
```

#### 4.1.4 PrivacyEngineé—¨é¢ç±»

```kotlin
/**
 * éšç§å¼•æ“ï¼ˆé—¨é¢ç±»ï¼‰
 *
 * èŒè´£ï¼šæä¾›ç»Ÿä¸€çš„éšç§å¤„ç†å…¥å£ï¼Œä¿æŒå‘åå…¼å®¹
 */
object PrivacyEngine {
    
    /**
     * è‡ªåŠ¨æ£€æµ‹å¹¶è„±æ•
     */
    fun maskWithAutoDetection(text: String): String {
        val patterns = SensitiveDataDetector.detect(text)
        return PrivacyMasker.mask(text, patterns)
    }

    /**
     * æ ¹æ®æ˜ å°„è§„åˆ™è„±æ•
     */
    fun maskByMapping(text: String, mapping: Map<String, String>): String {
        return PrivacyMasker.maskByMapping(text, mapping)
    }

    /**
     * æ£€æµ‹æ•æ„Ÿä¿¡æ¯
     */
    fun detect(text: String): List<SensitiveDataDetector.DetectedPattern> {
        return SensitiveDataDetector.detect(text)
    }

    /**
     * æ£€æŸ¥æ˜¯å¦åŒ…å«æ•æ„Ÿä¿¡æ¯
     */
    fun containsSensitiveData(text: String): Boolean {
        return SensitiveDataDetector.detect(text).isNotEmpty()
    }
}
```


### 4.2 UseCaseé”™è¯¯å¤„ç†æŠ½è±¡æŠ€æœ¯è®¾è®¡

#### 4.2.1 Resultæ‰©å±•å‡½æ•°

```kotlin
// domain/src/main/kotlin/com/empathy/ai/domain/util/ResultExtensions.kt

/**
 * Resultæ‰©å±•å‡½æ•°
 *
 * æä¾›ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
 */

/**
 * åœ¨å¤±è´¥æ—¶è®°å½•é”™è¯¯æ—¥å¿—
 */
fun <T> Result<T>.logOnError(
    logger: Logger,
    tag: String,
    message: String
): Result<T> {
    return this.onFailure { error ->
        logger.e(tag, message, error)
    }
}

/**
 * åœ¨å¤±è´¥æ—¶æ‰§è¡Œé™çº§æ“ä½œ
 */
suspend fun <T> Result<T>.recoverWith(
    fallback: suspend () -> Result<T>
): Result<T> {
    return if (isFailure) {
        fallback()
    } else {
        this
    }
}

/**
 * å°†å¼‚å¸¸æ˜ å°„ä¸ºAppError
 */
fun <T> Result<T>.mapError(
    mapper: (Throwable) -> AppError
): Result<T> {
    return if (isFailure) {
        Result.failure(mapper(exceptionOrNull()!!))
    } else {
        this
    }
}

/**
 * å®‰å…¨æ‰§è¡ŒæŒ‚èµ·å‡½æ•°å¹¶è¿”å›Result
 */
suspend fun <T> safeCall(
    logger: Logger,
    tag: String,
    errorMessage: String,
    block: suspend () -> T
): Result<T> {
    return try {
        Result.success(block())
    } catch (e: CancellationException) {
        throw e // ä¸æ•è·åç¨‹å–æ¶ˆå¼‚å¸¸
    } catch (e: Exception) {
        logger.e(tag, errorMessage, e)
        Result.failure(e)
    }
}

/**
 * å¸¦é‡è¯•çš„å®‰å…¨æ‰§è¡Œ
 */
suspend fun <T> safeCallWithRetry(
    logger: Logger,
    tag: String,
    errorMessage: String,
    maxRetries: Int = 3,
    initialDelayMs: Long = 1000L,
    block: suspend () -> T
): Result<T> {
    var lastException: Exception? = null
    var delayMs = initialDelayMs
    
    repeat(maxRetries) { attempt ->
        try {
            return Result.success(block())
        } catch (e: CancellationException) {
            throw e
        } catch (e: Exception) {
            lastException = e
            logger.w(tag, "$errorMessage (å°è¯• ${attempt + 1}/$maxRetries)", e)
            if (attempt < maxRetries - 1) {
                delay(delayMs)
                delayMs *= 2
            }
        }
    }
    
    logger.e(tag, "$errorMessage (æ‰€æœ‰é‡è¯•å¤±è´¥)", lastException)
    return Result.failure(lastException!!)
}

/**
 * ç»„åˆå¤šä¸ªResult
 */
fun <T1, T2, R> combineResults(
    result1: Result<T1>,
    result2: Result<T2>,
    transform: (T1, T2) -> R
): Result<R> {
    return when {
        result1.isFailure -> Result.failure(result1.exceptionOrNull()!!)
        result2.isFailure -> Result.failure(result2.exceptionOrNull()!!)
        else -> Result.success(transform(result1.getOrThrow(), result2.getOrThrow()))
    }
}
```

#### 4.2.2 UseCaseä½¿ç”¨ç¤ºä¾‹

```kotlin
class AnalyzeChatUseCase @Inject constructor(
    private val aiRepository: AiRepository,
    private val contactRepository: ContactRepository,
    private val aiProviderRepository: AiProviderRepository,
    private val promptBuilder: PromptBuilder,
    private val logger: Logger
) {
    companion object {
        private const val TAG = "AnalyzeChatUseCase"
    }

    suspend operator fun invoke(
        contactId: String,
        rawScreenContext: List<String>
    ): Result<AnalysisResult> = safeCall(logger, TAG, "åˆ†æèŠå¤©å¤±è´¥") {
        // è·å–è”ç³»äºº
        val contact = contactRepository.getContactById(contactId)
            .logOnError(logger, TAG, "è·å–è”ç³»äººå¤±è´¥")
            .getOrThrow()
        
        // è·å–é»˜è®¤æœåŠ¡å•†
        val provider = aiProviderRepository.getDefaultProvider()
            .logOnError(logger, TAG, "è·å–AIæœåŠ¡å•†å¤±è´¥")
            .getOrThrow()
        
        // æ„å»ºæç¤ºè¯
        val systemPrompt = promptBuilder.buildAnalysisPrompt(contact)
        val userPrompt = rawScreenContext.joinToString("\n")
        
        // è°ƒç”¨AIåˆ†æ
        aiRepository.analyzeChat(provider, systemPrompt, userPrompt)
            .logOnError(logger, TAG, "AIåˆ†æå¤±è´¥")
            .getOrThrow()
    }
}
```

---

## 5. ç»„ä»¶ç›®å½•ä¼˜åŒ–æŠ€æœ¯è®¾è®¡

### 5.1 ç›®å½•ç»“æ„é‡ç»„

#### 5.1.1 å½“å‰ç»“æ„é—®é¢˜

- `ui/component/`ä¸‹æœ‰26ä¸ªå­ç›®å½•
- éƒ¨åˆ†ç›®å½•æ–‡ä»¶æ•°å¾ˆå°‘ï¼ˆå¦‚buttonä»…æœ‰2ä¸ªï¼‰
- éƒ¨åˆ†ç»„ä»¶ç‰¹å®šäºæŸä¸ªscreen

#### 5.1.2 ä¼˜åŒ–åç»“æ„

```
presentation/src/main/kotlin/com/empathy/ai/presentation/ui/
â”œâ”€â”€ component/
â”‚   â”œâ”€â”€ common/           # é€šç”¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ button/       # æŒ‰é’®ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ card/         # å¡ç‰‡ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ chip/         # æ ‡ç­¾ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ control/      # æ§åˆ¶ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ dialog/       # å¯¹è¯æ¡†ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ input/        # è¾“å…¥ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ list/         # åˆ—è¡¨ç»„ä»¶
â”‚   â”‚   â””â”€â”€ state/        # çŠ¶æ€ç»„ä»¶
â”‚   â”œâ”€â”€ domain/           # ä¸šåŠ¡é¢†åŸŸç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ contact/      # è”ç³»äººç›¸å…³
â”‚   â”‚   â”œâ”€â”€ emotion/      # æƒ…æ„Ÿç›¸å…³
â”‚   â”‚   â”œâ”€â”€ message/      # æ¶ˆæ¯ç›¸å…³
â”‚   â”‚   â”œâ”€â”€ relationship/ # å…³ç³»ç›¸å…³
â”‚   â”‚   â”œâ”€â”€ tag/          # æ ‡ç­¾ç›¸å…³
â”‚   â”‚   â”œâ”€â”€ timeline/     # æ—¶é—´çº¿ç›¸å…³
â”‚   â”‚   â””â”€â”€ topic/        # ä¸»é¢˜ç›¸å…³
â”‚   â””â”€â”€ platform/         # å¹³å°ç‰¹å®šç»„ä»¶
â”‚       â”œâ”€â”€ ios/          # iOSé£æ ¼ç»„ä»¶
â”‚       â””â”€â”€ navigation/   # å¯¼èˆªç»„ä»¶
â””â”€â”€ screen/
    â”œâ”€â”€ contact/
    â”‚   â”œâ”€â”€ ContactListScreen.kt
    â”‚   â”œâ”€â”€ ContactDetailScreen.kt
    â”‚   â””â”€â”€ component/    # screenç‰¹å®šç»„ä»¶
    â”‚       â”œâ”€â”€ factstream/
    â”‚       â”œâ”€â”€ overview/
    â”‚       â”œâ”€â”€ persona/
    â”‚       â””â”€â”€ vault/
    â””â”€â”€ ...
```

#### 5.1.3 è¿ç§»è„šæœ¬

```bash
#!/bin/bash
# migrate_components.sh

BASE_DIR="presentation/src/main/kotlin/com/empathy/ai/presentation/ui"

# åˆ›å»ºæ–°ç›®å½•ç»“æ„
mkdir -p "$BASE_DIR/component/common"
mkdir -p "$BASE_DIR/component/domain"
mkdir -p "$BASE_DIR/component/platform"
mkdir -p "$BASE_DIR/screen/contact/component"

# è¿ç§»é€šç”¨ç»„ä»¶
mv "$BASE_DIR/component/button" "$BASE_DIR/component/common/"
mv "$BASE_DIR/component/card" "$BASE_DIR/component/common/"
mv "$BASE_DIR/component/chip" "$BASE_DIR/component/common/"
mv "$BASE_DIR/component/control" "$BASE_DIR/component/common/"
mv "$BASE_DIR/component/dialog" "$BASE_DIR/component/common/"
mv "$BASE_DIR/component/input" "$BASE_DIR/component/common/"
mv "$BASE_DIR/component/list" "$BASE_DIR/component/common/"
mv "$BASE_DIR/component/state" "$BASE_DIR/component/common/"

# è¿ç§»ä¸šåŠ¡é¢†åŸŸç»„ä»¶
mv "$BASE_DIR/component/contact" "$BASE_DIR/component/domain/"
mv "$BASE_DIR/component/emotion" "$BASE_DIR/component/domain/"
mv "$BASE_DIR/component/message" "$BASE_DIR/component/domain/"
mv "$BASE_DIR/component/relationship" "$BASE_DIR/component/domain/"
mv "$BASE_DIR/component/tag" "$BASE_DIR/component/domain/"
mv "$BASE_DIR/component/timeline" "$BASE_DIR/component/domain/"
mv "$BASE_DIR/component/topic" "$BASE_DIR/component/domain/"

# è¿ç§»å¹³å°ç‰¹å®šç»„ä»¶
mv "$BASE_DIR/component/ios" "$BASE_DIR/component/platform/"
mv "$BASE_DIR/component/navigation" "$BASE_DIR/component/platform/"

# è¿ç§»screenç‰¹å®šç»„ä»¶
mv "$BASE_DIR/component/factstream" "$BASE_DIR/screen/contact/component/"
mv "$BASE_DIR/component/overview" "$BASE_DIR/screen/contact/component/"
mv "$BASE_DIR/component/persona" "$BASE_DIR/screen/contact/component/"
mv "$BASE_DIR/component/vault" "$BASE_DIR/screen/contact/component/"

echo "ç»„ä»¶è¿ç§»å®Œæˆ"
```

#### 5.1.4 Importæ›´æ–°è„šæœ¬

```kotlin
// UpdateImports.kts
import java.io.File

val baseDir = File("presentation/src/main/kotlin")
val importMappings = mapOf(
    "com.empathy.ai.presentation.ui.component.button" to 
        "com.empathy.ai.presentation.ui.component.common.button",
    "com.empathy.ai.presentation.ui.component.card" to 
        "com.empathy.ai.presentation.ui.component.common.card",
    "com.empathy.ai.presentation.ui.component.factstream" to 
        "com.empathy.ai.presentation.ui.screen.contact.component.factstream",
    // ... å…¶ä»–æ˜ å°„
)

fun updateImports(file: File) {
    if (!file.name.endsWith(".kt")) return
    
    var content = file.readText()
    var modified = false
    
    for ((oldImport, newImport) in importMappings) {
        if (content.contains(oldImport)) {
            content = content.replace(oldImport, newImport)
            modified = true
        }
    }
    
    if (modified) {
        file.writeText(content)
        println("Updated: ${file.path}")
    }
}

baseDir.walkTopDown().forEach { file ->
    updateImports(file)
}
```

---

## 6. æµ‹è¯•ä¿®å¤æŠ€æœ¯è®¾è®¡

### 6.1 PrivacyEngineæµ‹è¯•ä¿®å¤

#### 6.1.1 é—®é¢˜åˆ†æ

èº«ä»½è¯æœ«å°¾x/Xçš„è„±æ•å¤„ç†ä¸æ­£ç¡®ã€‚

#### 6.1.2 ä¿®å¤ä»£ç 

```kotlin
// ä¿®å¤èº«ä»½è¯è„±æ•é€»è¾‘
fun maskIdCard(value: String): String {
    // å¤„ç†æœ«å°¾X/xçš„æƒ…å†µ
    val normalizedValue = value.uppercase()
    return if (normalizedValue.length >= 10) {
        normalizedValue.take(6) + "********" + normalizedValue.takeLast(4)
    } else {
        "****"
    }
}
```

#### 6.1.3 ä¿®å¤åçš„æµ‹è¯•

```kotlin
@Test
fun `should handle ID card with lowercase x`() {
    // Given
    val text = "èº«ä»½è¯å·ï¼š11010119900101001X"
    
    // When
    val result = PrivacyEngine.maskWithAutoDetection(text)
    
    // Then
    assertThat(result).contains("110101********001X")
}

@Test
fun `should handle ID card with uppercase X`() {
    // Given
    val text = "èº«ä»½è¯å·ï¼š11010119900101001X"
    
    // When
    val result = PrivacyEngine.maskWithAutoDetection(text)
    
    // Then
    assertThat(result).contains("110101********001X")
}
```

### 6.2 ContactRepositoryæµ‹è¯•ä¿®å¤

#### 6.2.1 é—®é¢˜åˆ†æ

æµ‹è¯•è¾…åŠ©å‡½æ•°å‚æ•°ä¸ç¬¦åˆä¸šåŠ¡çº¦æŸã€‚

#### 6.2.2 ä¿®å¤ä»£ç 

```kotlin
// ä¿®å¤æµ‹è¯•è¾…åŠ©å‡½æ•°
private fun createTestContactProfile(
    id: String = "test-id",
    name: String = "æµ‹è¯•è”ç³»äºº",
    contextDepth: Int = 5,  // å¿…é¡» > 0
    lastInteractionDate: String? = null,  // ä½¿ç”¨null
    originalGoal: String? = null  // ä½¿ç”¨null
): ContactProfile {
    return ContactProfile(
        id = id,
        name = name,
        contextDepth = contextDepth,
        lastInteractionDate = lastInteractionDate,
        originalGoal = originalGoal
    )
}
```

---

## 7. å®æ–½è®¡åˆ’

### 7.1 é˜¶æ®µåˆ’åˆ†

| é˜¶æ®µ | å†…å®¹ | å·¥æ—¶ | ä¾èµ– |
|------|------|------|------|
| Phase 1 | P0æ„å»ºé…ç½®ä¿®å¤ | 0.5å¤© | æ—  |
| Phase 2 | æµ‹è¯•ä¿®å¤ | 0.5å¤© | Phase 1 |
| Phase 3 | FallbackHandlerå®ç° | 1å¤© | Phase 2 |
| Phase 4 | Parseræ¥å£é‡æ„ | 2å¤© | Phase 3 |
| Phase 5 | AiRepositoryImplæ‹†åˆ† | 2å¤© | Phase 4 |
| Phase 6 | ViewModelåˆå¹¶ | 0.5å¤© | Phase 2 |
| Phase 7 | ç»„ä»¶ç›®å½•ä¼˜åŒ– | 1å¤© | Phase 2 |
| Phase 8 | UseCaseæµ‹è¯•è¦†ç›– | 5å¤© | Phase 5 |
| Phase 9 | P2é—®é¢˜ä¿®å¤ | 3å¤© | Phase 8 |
| Phase 10 | éªŒè¯å’Œæ–‡æ¡£ | 1å¤© | Phase 9 |

### 7.2 æ€»å·¥æ—¶ä¼°ç®—

| ç±»åˆ« | å·¥æ—¶ |
|------|------|
| P0é—®é¢˜ä¿®å¤ | 0.5å¤© |
| P1é—®é¢˜ä¿®å¤ | 11.5å¤© |
| P2é—®é¢˜ä¿®å¤ | 3å¤© |
| éªŒè¯å’Œæ–‡æ¡£ | 1å¤© |
| **æ€»è®¡** | **16å¤©** |

---

## 8. éªŒæ”¶æ ‡å‡†

### 8.1 æ„å»ºéªŒæ”¶

- [ ] `./gradlew testDevUnitTest` æ‰§è¡ŒæˆåŠŸ
- [ ] IDEä¸­å¯é€‰æ‹©devå˜ä½“ä¸”æ— é”™è¯¯
- [ ] æ‰€æœ‰æ¨¡å—å¯ç‹¬ç«‹ç¼–è¯‘

### 8.2 æµ‹è¯•éªŒæ”¶

- [ ] æ‰€æœ‰ç°æœ‰æµ‹è¯•é€šè¿‡
- [ ] UseCaseæµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°80%
- [ ] æ–°å¢æµ‹è¯•æ— flakyé—®é¢˜

### 8.3 ä»£ç è´¨é‡éªŒæ”¶

- [ ] å•ä¸€æ–‡ä»¶ä¸è¶…è¿‡500è¡Œ
- [ ] æ— é‡å¤ä»£ç 
- [ ] ç¬¦åˆClean ArchitectureåŸåˆ™

---

## ğŸ“‹ å˜æ›´è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ | å˜æ›´å†…å®¹ | å˜æ›´äºº |
|------|------|----------|--------|
| v1.0 | 2026-01-01 | åˆå§‹ç‰ˆæœ¬ | Kiro |

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2026-01-01
**æ–‡æ¡£çŠ¶æ€**: ğŸ“ è‰ç¨¿
