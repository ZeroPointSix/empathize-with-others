# TDD-00028 AIå†›å¸ˆæµå¼å¯¹è¯å‡çº§æŠ€æœ¯è®¾è®¡

## 1. æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| æ–‡æ¡£ç±»å‹ | TDD (Technical Design Document) |
| æ–‡æ¡£ç¼–å· | TDD-00028 |
| åŠŸèƒ½åç§° | AIå†›å¸ˆæµå¼å¯¹è¯å‡çº§ |
| ç‰ˆæœ¬ | 1.1 |
| åˆ›å»ºæ—¥æœŸ | 2026-01-04 |
| æœ€åæ›´æ–° | 2026-01-04 |
| ä½œè€… | AI Assistant |
| çŠ¶æ€ | å®¡æŸ¥é€šè¿‡ |
| å…³è”PRD | PRD-00028 |
| å…³è”è°ƒç ” | RESEARCH-00003ã€RESEARCH-00004 |
| å®¡æŸ¥æŠ¥å‘Š | TDD-00028-å®¡æŸ¥æŠ¥å‘Š.md |

---

## 2. æŠ€æœ¯æ¦‚è¿°

### 2.1 è®¾è®¡ç›®æ ‡

åŸºäºPRD-00028éœ€æ±‚ï¼Œå®ç°AIå†›å¸ˆçš„æµå¼å¯¹è¯åŠŸèƒ½ï¼Œä¸»è¦æŠ€æœ¯ç›®æ ‡ï¼š

1. **SSEæµå¼å“åº”**ï¼šä½¿ç”¨OkHttp EventSourceå®ç°Server-Sent Events
2. **Blockæ¶æ„**ï¼šæ¶ˆæ¯æ‹†åˆ†ä¸ºå¤šä¸ªç‹¬ç«‹Blockï¼Œæ”¯æŒæ€è€ƒè¿‡ç¨‹å±•ç¤º
3. **æ™ºèƒ½èŠ‚æµ**ï¼šå‡å°‘æ•°æ®åº“å†™å…¥é¢‘ç‡ï¼Œæå‡æ€§èƒ½
4. **çŠ¶æ€ç®¡ç†**ï¼šå®Œæ•´çš„æµå¼çŠ¶æ€ç”Ÿå‘½å‘¨æœŸç®¡ç†

### 2.2 æŠ€æœ¯é€‰å‹

| æŠ€æœ¯ç‚¹ | é€‰å‹ | åŸå›  |
|--------|------|------|
| æµå¼åè®® | SSE (Server-Sent Events) | OpenAI/DeepSeekæ ‡å‡†åè®® |
| HTTPå®¢æˆ·ç«¯ | OkHttp + EventSource | é¡¹ç›®å·²æœ‰OkHttpï¼ŒEventSourceæ˜¯å®˜æ–¹SSEæ”¯æŒ |
| æ•°æ®åº“ | Room | é¡¹ç›®å·²æœ‰Roomï¼Œæ”¯æŒFlowå“åº”å¼ |
| çŠ¶æ€ç®¡ç† | StateFlow | Composeæ ‡å‡†çŠ¶æ€ç®¡ç† |
| ä¾èµ–æ³¨å…¥ | Hilt | é¡¹ç›®å·²æœ‰Hilté…ç½® |

### 2.3 æ¶æ„çº¦æŸ

- **Clean Architecture**ï¼šä¸¥æ ¼éµå¾ªæ¨¡å—ä¾èµ–è§„åˆ™
- **:domainæ¨¡å—**ï¼šçº¯Kotlinï¼Œæ— Androidä¾èµ–
- **:dataæ¨¡å—**ï¼šAndroid Libraryï¼ŒåŒ…å«OkHttpã€Room
- **:presentationæ¨¡å—**ï¼šAndroid Libraryï¼ŒåŒ…å«Compose UI


---

## 3. æ•°æ®åº“è®¾è®¡

### 3.1 ç‰ˆæœ¬è¿ç§»

#### å½“å‰çŠ¶æ€
- **å½“å‰ç‰ˆæœ¬**ï¼šv13ï¼ˆPRD-00026 AIå†›å¸ˆåŸºç¡€åŠŸèƒ½å·²å®Œæˆï¼‰
- **ç›®æ ‡ç‰ˆæœ¬**ï¼šv14
- **è¿ç§»æ–‡ä»¶**ï¼š`data/src/main/kotlin/com/empathy/ai/data/local/DatabaseMigrations.kt`

#### è¿ç§»è„šæœ¬

```kotlin
/**
 * æ•°æ®åº“è¿ç§» v13 â†’ v14
 * 
 * å˜æ›´å†…å®¹ï¼š
 * 1. æ–°å¢ai_advisor_message_blocksè¡¨
 * 2. ä¸ºç°æœ‰AIæ¶ˆæ¯åˆ›å»ºé»˜è®¤MAIN_TEXT Block
 */
val MIGRATION_13_14 = object : Migration(13, 14) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // 1. åˆ›å»ºæ¶ˆæ¯å—è¡¨
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS ai_advisor_message_blocks (
                id TEXT PRIMARY KEY NOT NULL,
                message_id TEXT NOT NULL,
                type TEXT NOT NULL,
                status TEXT NOT NULL,
                content TEXT NOT NULL,
                metadata TEXT,
                created_at INTEGER NOT NULL,
                FOREIGN KEY (message_id) 
                    REFERENCES ai_advisor_conversations(id) 
                    ON DELETE CASCADE
            )
        """)
        
        // 2. åˆ›å»ºç´¢å¼•ï¼ˆä¼˜åŒ–æŒ‰æ¶ˆæ¯IDæŸ¥è¯¢ï¼‰
        database.execSQL("""
            CREATE INDEX IF NOT EXISTS idx_blocks_message_id 
            ON ai_advisor_message_blocks(message_id)
        """)
        
        // 3. æ•°æ®è¿ç§»ï¼šä¸ºç°æœ‰AIæ¶ˆæ¯åˆ›å»ºé»˜è®¤Block
        database.execSQL("""
            INSERT INTO ai_advisor_message_blocks 
                (id, message_id, type, status, content, created_at)
            SELECT 
                id || '_main_block',
                id,
                'MAIN_TEXT',
                'SUCCESS',
                content,
                created_at
            FROM ai_advisor_conversations
            WHERE message_type = 'AI'
        """)
    }
}
```

### 3.2 Entityè®¾è®¡

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/local/entity/AiAdvisorMessageBlockEntity.kt

@Entity(
    tableName = "ai_advisor_message_blocks",
    foreignKeys = [
        ForeignKey(
            entity = AiAdvisorConversationEntity::class,
            parentColumns = ["id"],
            childColumns = ["message_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index("message_id")]
)
data class AiAdvisorMessageBlockEntity(
    @PrimaryKey
    @ColumnInfo(name = "id")
    val id: String,

    @ColumnInfo(name = "message_id")
    val messageId: String,

    @ColumnInfo(name = "type")
    val type: String,  // MessageBlockType.name

    @ColumnInfo(name = "status")
    val status: String,  // MessageBlockStatus.name

    @ColumnInfo(name = "content")
    val content: String,

    @ColumnInfo(name = "metadata")
    val metadata: String? = null,  // JSONæ ¼å¼

    @ColumnInfo(name = "created_at")
    val createdAt: Long
) {
    fun toDomain(): AiAdvisorMessageBlock = AiAdvisorMessageBlock(
        id = id,
        messageId = messageId,
        type = MessageBlockType.valueOf(type),
        status = MessageBlockStatus.valueOf(status),
        content = content,
        metadata = metadata?.let { parseMetadata(it) },
        createdAt = createdAt
    )
    
    companion object {
        fun fromDomain(block: AiAdvisorMessageBlock): AiAdvisorMessageBlockEntity =
            AiAdvisorMessageBlockEntity(
                id = block.id,
                messageId = block.messageId,
                type = block.type.name,
                status = block.status.name,
                content = block.content,
                metadata = block.metadata?.toJson(),
                createdAt = block.createdAt
            )
    }
}
```


### 3.3 DAOè®¾è®¡

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/local/dao/AiAdvisorMessageBlockDao.kt

@Dao
interface AiAdvisorMessageBlockDao {
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(block: AiAdvisorMessageBlockEntity)
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(blocks: List<AiAdvisorMessageBlockEntity>)
    
    @Update
    suspend fun update(block: AiAdvisorMessageBlockEntity)
    
    @Query("""
        UPDATE ai_advisor_message_blocks 
        SET content = :content, status = :status 
        WHERE id = :blockId
    """)
    suspend fun updateContentAndStatus(
        blockId: String, 
        content: String, 
        status: String
    )
    
    @Query("SELECT * FROM ai_advisor_message_blocks WHERE message_id = :messageId ORDER BY created_at ASC")
    fun observeByMessageId(messageId: String): Flow<List<AiAdvisorMessageBlockEntity>>
    
    @Query("SELECT * FROM ai_advisor_message_blocks WHERE message_id = :messageId ORDER BY created_at ASC")
    suspend fun getByMessageId(messageId: String): List<AiAdvisorMessageBlockEntity>
    
    @Query("DELETE FROM ai_advisor_message_blocks WHERE message_id = :messageId")
    suspend fun deleteByMessageId(messageId: String)
    
    @Delete
    suspend fun delete(block: AiAdvisorMessageBlockEntity)
}
```

### 3.4 AppDatabaseæ›´æ–°

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/local/AppDatabase.kt

@Database(
    entities = [
        // ... ç°æœ‰å®ä½“
        AiAdvisorSessionEntity::class,
        AiAdvisorConversationEntity::class,
        AiAdvisorMessageBlockEntity::class  // ğŸ†• æ–°å¢
    ],
    version = 14,  // ğŸ†• ç‰ˆæœ¬å‡çº§
    exportSchema = true
)
@TypeConverters(RoomTypeConverters::class, FactListConverter::class)
abstract class AppDatabase : RoomDatabase() {
    // ... ç°æœ‰DAO
    
    abstract fun aiAdvisorMessageBlockDao(): AiAdvisorMessageBlockDao  // ğŸ†• æ–°å¢
}
```

---

## 4. é¢†åŸŸå±‚è®¾è®¡

### 4.1 æµå¼æ•°æ®å—æ¨¡å‹

```kotlin
// domain/src/main/kotlin/com/empathy/ai/domain/model/AiStreamChunk.kt

/**
 * AIæµå¼å“åº”æ•°æ®å—
 * 
 * å‚è€ƒCherry Studioçš„ChunkTypeè®¾è®¡ï¼Œå®šä¹‰ç»Ÿä¸€çš„æµå¼äº‹ä»¶ç±»å‹ã€‚
 * æ³¨æ„ï¼šThrowableæ˜¯Kotlinæ ‡å‡†åº“ç±»ï¼Œåœ¨:domainæ¨¡å—ä¸­å¯ä»¥ä½¿ç”¨ã€‚
 */
sealed class AiStreamChunk {
    
    /** å“åº”å¼€å§‹ */
    data object Started : AiStreamChunk()
    
    /** æ–‡æœ¬å¢é‡ */
    data class TextDelta(val text: String) : AiStreamChunk()
    
    /** æ€è€ƒè¿‡ç¨‹å¢é‡ï¼ˆDeepSeek R1ç­‰æ¨¡å‹ï¼‰ */
    data class ThinkingDelta(
        val text: String,
        val thinkingMs: Long? = null
    ) : AiStreamChunk()
    
    /** æ€è€ƒå®Œæˆ */
    data class ThinkingComplete(
        val fullThinking: String,
        val totalMs: Long
    ) : AiStreamChunk()
    
    /** å“åº”å®Œæˆ */
    data class Complete(
        val fullText: String,
        val usage: TokenUsage? = null
    ) : AiStreamChunk()
    
    /** é”™è¯¯ */
    data class Error(val error: Throwable) : AiStreamChunk()
}

/**
 * Tokenä½¿ç”¨ç»Ÿè®¡
 */
data class TokenUsage(
    val promptTokens: Int,
    val completionTokens: Int,
    val totalTokens: Int
)
```

### 4.2 æ¶ˆæ¯å—æ¨¡å‹

```kotlin
// domain/src/main/kotlin/com/empathy/ai/domain/model/AiAdvisorMessageBlock.kt

/**
 * æ¶ˆæ¯å—ç±»å‹
 * å‚è€ƒCherry Studioçš„MessageBlockTypeè®¾è®¡
 */
enum class MessageBlockType {
    MAIN_TEXT,    // ä¸»æ–‡æœ¬
    THINKING,     // æ€è€ƒè¿‡ç¨‹
    ERROR         // é”™è¯¯ä¿¡æ¯
    // æœªæ¥æ‰©å±•ï¼šCODE, TOOL, CITATION
}

/**
 * æ¶ˆæ¯å—çŠ¶æ€
 * å‚è€ƒCherry Studioçš„MessageBlockStatusè®¾è®¡
 */
enum class MessageBlockStatus {
    PENDING,      // ç­‰å¾…å¤„ç†
    STREAMING,    // æµå¼æ¥æ”¶ä¸­
    SUCCESS,      // æˆåŠŸå®Œæˆ
    ERROR         // å‘ç”Ÿé”™è¯¯
}

/**
 * AIå†›å¸ˆæ¶ˆæ¯å—
 * ä¸€æ¡æ¶ˆæ¯å¯ä»¥åŒ…å«å¤šä¸ªå—ï¼ˆæ€è€ƒ+æ–‡æœ¬ï¼‰
 */
data class AiAdvisorMessageBlock(
    val id: String,
    val messageId: String,
    val type: MessageBlockType,
    val status: MessageBlockStatus,
    val content: String,
    val metadata: BlockMetadata? = null,
    val createdAt: Long = System.currentTimeMillis()
) {
    companion object {
        fun createMainTextBlock(
            messageId: String,
            content: String = "",
            status: MessageBlockStatus = MessageBlockStatus.PENDING
        ): AiAdvisorMessageBlock = AiAdvisorMessageBlock(
            id = UUID.randomUUID().toString(),
            messageId = messageId,
            type = MessageBlockType.MAIN_TEXT,
            status = status,
            content = content
        )
        
        fun createThinkingBlock(
            messageId: String,
            content: String = "",
            status: MessageBlockStatus = MessageBlockStatus.PENDING
        ): AiAdvisorMessageBlock = AiAdvisorMessageBlock(
            id = UUID.randomUUID().toString(),
            messageId = messageId,
            type = MessageBlockType.THINKING,
            status = status,
            content = content
        )
    }
}

/**
 * å—å…ƒæ•°æ®
 */
data class BlockMetadata(
    val thinkingMs: Long? = null,    // æ€è€ƒè€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
    val tokenCount: Int? = null      // Tokenæ•°é‡
)
```


### 4.3 Repositoryæ¥å£æ‰©å±•

```kotlin
// domain/src/main/kotlin/com/empathy/ai/domain/repository/AiRepository.kt

interface AiRepository {
    // ç°æœ‰æ¥å£ï¼ˆä¿ç•™ï¼‰
    suspend fun generateText(
        provider: AiProvider,
        prompt: String,
        systemInstruction: String
    ): Result<String>
    
    // ğŸ†• æ–°å¢æµå¼æ¥å£
    fun generateTextStream(
        provider: AiProvider,
        prompt: String,
        systemInstruction: String
    ): Flow<AiStreamChunk>
}

// domain/src/main/kotlin/com/empathy/ai/domain/repository/AiAdvisorRepository.kt

interface AiAdvisorRepository {
    // ç°æœ‰æ¥å£ï¼ˆä¿ç•™ï¼‰
    suspend fun saveMessage(message: AiAdvisorConversation): Result<Unit>
    fun getConversations(sessionId: String): Flow<List<AiAdvisorConversation>>
    
    // ğŸ†• æ–°å¢Blockç›¸å…³æ¥å£
    suspend fun saveBlock(block: AiAdvisorMessageBlock): Result<Unit>
    suspend fun updateBlockContent(
        blockId: String, 
        content: String, 
        status: MessageBlockStatus
    ): Result<Unit>
    suspend fun getBlocksByMessageId(messageId: String): Result<List<AiAdvisorMessageBlock>>
    fun observeBlocksByMessageId(messageId: String): Flow<List<AiAdvisorMessageBlock>>
}
```

### 4.4 æµå¼UseCaseè®¾è®¡

```kotlin
// domain/src/main/kotlin/com/empathy/ai/domain/usecase/SendAdvisorMessageStreamingUseCase.kt

/**
 * å‘é€AIå†›å¸ˆæ¶ˆæ¯ï¼ˆæµå¼ç‰ˆæœ¬ï¼‰
 * 
 * å‚è€ƒCherry Studioçš„æ¶ˆæ¯å‘é€æµç¨‹ï¼Œå®ç°ï¼š
 * 1. ä¿å­˜ç”¨æˆ·æ¶ˆæ¯
 * 2. åˆ›å»ºAIæ¶ˆæ¯å ä½
 * 3. è°ƒç”¨æµå¼API
 * 4. å®æ—¶æ›´æ–°Blockå†…å®¹
 */
class SendAdvisorMessageStreamingUseCase @Inject constructor(
    private val aiAdvisorRepository: AiAdvisorRepository,
    private val aiRepository: AiRepository,
    private val contactRepository: ContactRepository,
    private val aiProviderRepository: AiProviderRepository,
    private val promptBuilder: AdvisorPromptBuilder
) {
    /**
     * å‘é€æ¶ˆæ¯å¹¶è¿”å›æµå¼å“åº”
     * 
     * @param contactId è”ç³»äººID
     * @param sessionId ä¼šè¯ID
     * @param userMessage ç”¨æˆ·æ¶ˆæ¯å†…å®¹
     * @return æµå¼å“åº”Flow
     */
    operator fun invoke(
        contactId: String,
        sessionId: String,
        userMessage: String
    ): Flow<StreamingState> = flow {
        // 1. ä¿å­˜ç”¨æˆ·æ¶ˆæ¯
        val userConversation = AiAdvisorConversation.createUserMessage(
            sessionId = sessionId,
            contactId = contactId,
            content = userMessage,
            sendStatus = SendStatus.SUCCESS
        )
        aiAdvisorRepository.saveMessage(userConversation)
        
        // 2. åˆ›å»ºAIæ¶ˆæ¯å ä½
        val aiMessageId = UUID.randomUUID().toString()
        val aiMessage = AiAdvisorConversation(
            id = aiMessageId,
            contactId = contactId,
            sessionId = sessionId,
            messageType = MessageType.AI,
            content = "",
            timestamp = System.currentTimeMillis(),
            sendStatus = SendStatus.PENDING
        )
        aiAdvisorRepository.saveMessage(aiMessage)
        
        // 3. åˆ›å»ºåˆå§‹Block
        val mainTextBlock = AiAdvisorMessageBlock.createMainTextBlock(aiMessageId)
        aiAdvisorRepository.saveBlock(mainTextBlock)
        
        emit(StreamingState.Started(aiMessageId))
        
        // 4. è·å–Providerå’Œæ„å»ºæç¤ºè¯
        val provider = aiProviderRepository.getDefaultProvider().getOrThrow()
        val contact = contactRepository.getProfile(contactId).getOrNull()
        val history = aiAdvisorRepository.getRecentConversations(contactId, 10)
        val prompt = promptBuilder.build(contact, history, userMessage)
        
        // 5. è°ƒç”¨æµå¼API
        var thinkingBlockId: String? = null
        val contentBuilder = StringBuilder()
        val thinkingBuilder = StringBuilder()
        var thinkingStartTime = 0L
        
        aiRepository.generateTextStream(provider, prompt, SYSTEM_INSTRUCTION)
            .collect { chunk ->
                when (chunk) {
                    is AiStreamChunk.Started -> {
                        // å·²å¤„ç†
                    }
                    
                    is AiStreamChunk.ThinkingDelta -> {
                        // åˆ›å»ºæˆ–æ›´æ–°æ€è€ƒBlock
                        if (thinkingBlockId == null) {
                            thinkingStartTime = System.currentTimeMillis()
                            val thinkingBlock = AiAdvisorMessageBlock.createThinkingBlock(
                                aiMessageId,
                                status = MessageBlockStatus.STREAMING
                            )
                            thinkingBlockId = thinkingBlock.id
                            aiAdvisorRepository.saveBlock(thinkingBlock)
                        }
                        thinkingBuilder.append(chunk.text)
                        emit(StreamingState.ThinkingUpdate(
                            thinkingBuilder.toString(),
                            System.currentTimeMillis() - thinkingStartTime
                        ))
                    }
                    
                    is AiStreamChunk.ThinkingComplete -> {
                        thinkingBlockId?.let { id ->
                            aiAdvisorRepository.updateBlockContent(
                                id,
                                chunk.fullThinking,
                                MessageBlockStatus.SUCCESS
                            )
                        }
                    }
                    
                    is AiStreamChunk.TextDelta -> {
                        contentBuilder.append(chunk.text)
                        emit(StreamingState.TextUpdate(contentBuilder.toString()))
                    }
                    
                    is AiStreamChunk.Complete -> {
                        // æ›´æ–°ä¸»æ–‡æœ¬Block
                        aiAdvisorRepository.updateBlockContent(
                            mainTextBlock.id,
                            chunk.fullText.ifEmpty { contentBuilder.toString() },
                            MessageBlockStatus.SUCCESS
                        )
                        // æ›´æ–°æ¶ˆæ¯çŠ¶æ€
                        aiAdvisorRepository.updateMessageStatus(
                            aiMessageId,
                            SendStatus.SUCCESS
                        )
                        emit(StreamingState.Completed(
                            contentBuilder.toString(),
                            chunk.usage
                        ))
                    }
                    
                    is AiStreamChunk.Error -> {
                        aiAdvisorRepository.updateMessageStatus(
                            aiMessageId,
                            SendStatus.FAILED
                        )
                        emit(StreamingState.Error(chunk.error))
                    }
                }
            }
    }.catch { e ->
        emit(StreamingState.Error(e))
    }
    
    companion object {
        private const val SYSTEM_INSTRUCTION = """
ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„ç¤¾äº¤æ²Ÿé€šé¡¾é—®ï¼Œå¸®åŠ©ç”¨æˆ·åˆ†æèŠå¤©åœºæ™¯å¹¶æä¾›å»ºè®®ã€‚
è¯·æ ¹æ®è”ç³»äººç”»åƒå’Œå¯¹è¯å†å²ï¼Œç»™å‡ºå…·ä½“ã€å®ç”¨çš„æ²Ÿé€šå»ºè®®ã€‚
"""
    }
}

/**
 * æµå¼çŠ¶æ€
 */
sealed class StreamingState {
    data class Started(val messageId: String) : StreamingState()
    data class ThinkingUpdate(val content: String, val elapsedMs: Long) : StreamingState()
    data class TextUpdate(val content: String) : StreamingState()
    data class Completed(val fullText: String, val usage: TokenUsage?) : StreamingState()
    data class Error(val error: Throwable) : StreamingState()
}
```


---

## 5. æ•°æ®å±‚è®¾è®¡

### 5.1 SSEæµå¼è¯»å–å™¨

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/remote/SseStreamReader.kt

/**
 * SSEæµå¼è¯»å–å™¨
 * 
 * ä½¿ç”¨OkHttp EventSourceå®ç°Server-Sent Eventsæµå¼è¯»å–ã€‚
 * å‚è€ƒCherry Studioçš„AiSdkToChunkAdapterè®¾è®¡ã€‚
 * 
 * æ”¯æŒçš„AIæœåŠ¡å•†ï¼š
 * - OpenAI (GPT-3.5/GPT-4)
 * - DeepSeek (DeepSeek-Chat/DeepSeek-R1)
 * - å…¶ä»–å…¼å®¹OpenAI APIæ ¼å¼çš„æœåŠ¡å•†
 */
class SseStreamReader @Inject constructor(
    private val okHttpClient: OkHttpClient
) {
    
    companion object {
        /** æœ€å¤§é‡è¯•æ¬¡æ•° */
        private const val MAX_RETRY_COUNT = 3
        /** é‡è¯•é—´éš”ï¼ˆæ¯«ç§’ï¼‰ */
        private const val RETRY_DELAY_MS = 1000L
        /** è¿ç»­å¤±è´¥è®¡æ•°é˜ˆå€¼ï¼ˆè§¦å‘é™çº§ï¼‰ */
        private const val FALLBACK_THRESHOLD = 3
    }
    
    /** è¿ç»­å¤±è´¥è®¡æ•° */
    private var consecutiveFailures = 0
    
    /**
     * å‘èµ·SSEæµå¼è¯·æ±‚ï¼ˆå¸¦é‡è¿æœºåˆ¶ï¼‰
     * 
     * @param url APIç«¯ç‚¹URL
     * @param requestBody è¯·æ±‚ä½“
     * @param headers è¯·æ±‚å¤´ï¼ˆåŒ…å«Authorizationï¼‰
     * @return æµå¼å“åº”Flow
     */
    fun stream(
        url: String,
        requestBody: ChatRequestDto,
        headers: Map<String, String>
    ): Flow<AiStreamChunk> = callbackFlow {
        val jsonBody = Moshi.Builder()
            .add(KotlinJsonAdapterFactory())
            .build()
            .adapter(ChatRequestDto::class.java)
            .toJson(requestBody)
        
        val request = Request.Builder()
            .url(url)
            .apply {
                headers.forEach { (key, value) -> addHeader(key, value) }
                addHeader("Accept", "text/event-stream")
                addHeader("Cache-Control", "no-cache")
            }
            .post(jsonBody.toRequestBody("application/json".toMediaType()))
            .build()

        val eventSource = EventSources.createFactory(okHttpClient)
            .newEventSource(request, object : EventSourceListener() {
                
                override fun onOpen(eventSource: EventSource, response: Response) {
                    consecutiveFailures = 0  // é‡ç½®å¤±è´¥è®¡æ•°
                    trySend(AiStreamChunk.Started)
                }

                override fun onEvent(
                    eventSource: EventSource,
                    id: String?,
                    type: String?,
                    data: String
                ) {
                    // OpenAIæ ¼å¼çš„ç»“æŸæ ‡è®°
                    if (data == "[DONE]") {
                        return
                    }

                    try {
                        val chunk = parseChunk(data)
                        chunk?.let { trySend(it) }
                    } catch (e: Exception) {
                        trySend(AiStreamChunk.Error(e))
                    }
                }

                override fun onClosed(eventSource: EventSource) {
                    channel.close()
                }

                override fun onFailure(
                    eventSource: EventSource,
                    t: Throwable?,
                    response: Response?
                ) {
                    consecutiveFailures++
                    
                    val error = when {
                        t != null -> t
                        response != null -> {
                            val errorBody = response.body?.string() ?: "Unknown error"
                            IOException("SSE failed: ${response.code} - $errorBody")
                        }
                        else -> IOException("SSE connection failed")
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦åº”è¯¥é™çº§åˆ°éæµå¼
                    if (consecutiveFailures >= FALLBACK_THRESHOLD) {
                        trySend(AiStreamChunk.Error(
                            SseFallbackException("è¿ç»­${consecutiveFailures}æ¬¡SSEå¤±è´¥ï¼Œå»ºè®®é™çº§åˆ°éæµå¼æ¨¡å¼", error)
                        ))
                    } else {
                        trySend(AiStreamChunk.Error(error))
                    }
                    channel.close()
                }
            })

        awaitClose {
            eventSource.cancel()
        }
    }
    
    /**
     * æ£€æŸ¥æ˜¯å¦åº”è¯¥ä½¿ç”¨éæµå¼æ¨¡å¼
     * 
     * @return trueè¡¨ç¤ºåº”è¯¥é™çº§åˆ°éæµå¼
     */
    fun shouldFallbackToNonStreaming(): Boolean = consecutiveFailures >= FALLBACK_THRESHOLD
    
    /**
     * é‡ç½®å¤±è´¥è®¡æ•°ï¼ˆç”¨äºæ‰‹åŠ¨é‡è¯•ï¼‰
     */
    fun resetFailureCount() {
        consecutiveFailures = 0
    }

    /**
     * è§£æSSEæ•°æ®å—
     * 
     * æ”¯æŒæ ¼å¼ï¼š
     * - OpenAIæ ‡å‡†æ ¼å¼ï¼ˆcontentå­—æ®µï¼‰
     * - DeepSeek R1æ€è€ƒè¿‡ç¨‹æ ¼å¼ï¼ˆreasoning_contentå­—æ®µï¼‰
     * - Claudeæ ¼å¼ï¼ˆå…¼å®¹å¤„ç†ï¼‰
     */
    private fun parseChunk(data: String): AiStreamChunk? {
        return try {
            val json = JSONObject(data)
            
            // æ£€æŸ¥é”™è¯¯å“åº”
            if (json.has("error")) {
                val errorObj = json.getJSONObject("error")
                val message = errorObj.optString("message", "Unknown API error")
                return AiStreamChunk.Error(IOException(message))
            }
            
            val choices = json.optJSONArray("choices") ?: return null
            if (choices.length() == 0) return null

            val choice = choices.getJSONObject(0)
            val delta = choice.optJSONObject("delta") ?: return null

            // æ£€æŸ¥æ€è€ƒå†…å®¹ï¼ˆDeepSeek R1æ ¼å¼ï¼‰
            // DeepSeek R1ä½¿ç”¨ reasoning_content å­—æ®µä¼ é€’æ€è€ƒè¿‡ç¨‹
            val reasoning = delta.optString("reasoning_content", "")
            if (reasoning.isNotEmpty()) {
                return AiStreamChunk.ThinkingDelta(reasoning)
            }

            // æ™®é€šæ–‡æœ¬å†…å®¹ï¼ˆOpenAI/DeepSeeké€šç”¨æ ¼å¼ï¼‰
            val content = delta.optString("content", "")
            if (content.isNotEmpty()) {
                return AiStreamChunk.TextDelta(content)
            }

            // æ£€æŸ¥å®ŒæˆçŠ¶æ€
            val finishReason = choice.optString("finish_reason", "")
            if (finishReason == "stop") {
                val usage = json.optJSONObject("usage")?.let {
                    TokenUsage(
                        promptTokens = it.optInt("prompt_tokens"),
                        completionTokens = it.optInt("completion_tokens"),
                        totalTokens = it.optInt("total_tokens")
                    )
                }
                return AiStreamChunk.Complete("", usage)
            }

            null
        } catch (e: JSONException) {
            AiStreamChunk.Error(e)
        }
    }
}

/**
 * SSEé™çº§å¼‚å¸¸
 * 
 * å½“è¿ç»­å¤šæ¬¡SSEè¿æ¥å¤±è´¥æ—¶æŠ›å‡ºï¼Œæç¤ºè°ƒç”¨æ–¹åº”è¯¥é™çº§åˆ°éæµå¼æ¨¡å¼
 */
class SseFallbackException(
    message: String,
    cause: Throwable? = null
) : IOException(message, cause)
```

### 5.1.1 å¤šæ¨¡å‹å…¼å®¹æ€§è¯´æ˜

ä¸åŒAIæœåŠ¡å•†çš„æµå¼å“åº”æ ¼å¼å­˜åœ¨å·®å¼‚ï¼ŒSseStreamReaderéœ€è¦é€‚é…ä»¥ä¸‹æ ¼å¼ï¼š

| æœåŠ¡å•† | æ–‡æœ¬å­—æ®µ | æ€è€ƒè¿‡ç¨‹å­—æ®µ | ç»“æŸæ ‡è®° | ç‰¹æ®Šå¤„ç† |
|--------|---------|-------------|---------|---------|
| OpenAI | `delta.content` | ä¸æ”¯æŒ | `[DONE]` | æ ‡å‡†æ ¼å¼ |
| DeepSeek Chat | `delta.content` | ä¸æ”¯æŒ | `[DONE]` | å…¼å®¹OpenAI |
| DeepSeek R1 | `delta.content` | `delta.reasoning_content` | `[DONE]` | éœ€è§£ææ€è€ƒè¿‡ç¨‹ |
| Claude | `delta.text` | ä¸æ”¯æŒ | `event: message_stop` | éœ€é€‚é…ï¼ˆP2ï¼‰ |

**å½“å‰æ”¯æŒ**ï¼šOpenAIã€DeepSeek Chatã€DeepSeek R1

**åç»­æ‰©å±•**ï¼šClaudeç­‰å…¶ä»–æœåŠ¡å•†éœ€è¦åœ¨parseChunkæ–¹æ³•ä¸­æ·»åŠ é€‚é…é€»è¾‘

### 5.1.2 é™çº§ç­–ç•¥

å½“SSEè¿æ¥ä¸ç¨³å®šæ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨é™çº§åˆ°éæµå¼æ¨¡å¼ï¼š

```
SSEè¯·æ±‚ â†’ å¤±è´¥ â†’ é‡è¯•(æœ€å¤š3æ¬¡) â†’ è¿ç»­å¤±è´¥3æ¬¡ â†’ é™çº§åˆ°éæµå¼
                    â†“
                  æˆåŠŸ â†’ é‡ç½®å¤±è´¥è®¡æ•°
```

**é™çº§è§¦å‘æ¡ä»¶**ï¼š
1. è¿ç»­3æ¬¡SSEè¿æ¥å¤±è´¥
2. ç½‘ç»œè¶…æ—¶æˆ–æ–­å¼€
3. æœåŠ¡å•†ä¸æ”¯æŒSSE

**é™çº§åè¡Œä¸º**ï¼š
- ä½¿ç”¨`SendAdvisorMessageUseCase`ï¼ˆéæµå¼ç‰ˆæœ¬ï¼‰
- ç”¨æˆ·å¯åœ¨è®¾ç½®ä¸­æ‰‹åŠ¨åˆ‡æ¢å›æµå¼æ¨¡å¼
- æˆåŠŸä¸€æ¬¡åè‡ªåŠ¨æ¢å¤æµå¼æ¨¡å¼

### 5.2 æ™ºèƒ½èŠ‚æµæ›´æ–°ç®¡ç†å™¨

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/util/BlockUpdateManager.kt

/**
 * Blockæ›´æ–°ç®¡ç†å™¨
 * 
 * å‚è€ƒCherry Studioçš„BlockManageræ™ºèƒ½èŠ‚æµç­–ç•¥ï¼š
 * - å—ç±»å‹å˜åŒ–æ—¶ç«‹å³å†™å…¥
 * - åŒç±»å‹å†…å®¹ä½¿ç”¨èŠ‚æµï¼ˆ300msï¼‰
 */
class BlockUpdateManager @Inject constructor(
    private val aiAdvisorMessageBlockDao: AiAdvisorMessageBlockDao,
    @IoDispatcher private val ioDispatcher: CoroutineDispatcher
) {
    private var lastBlockType: MessageBlockType? = null
    private val pendingUpdates = ConcurrentHashMap<String, PendingUpdate>()
    private var throttleJob: Job? = null
    private val scope = CoroutineScope(ioDispatcher + SupervisorJob())
    
    data class PendingUpdate(
        val blockId: String,
        val content: String,
        val status: MessageBlockStatus
    )

    /**
     * æ™ºèƒ½æ›´æ–°Block
     * 
     * @param blockId Block ID
     * @param content æ–°å†…å®¹
     * @param blockType Blockç±»å‹
     * @param status BlockçŠ¶æ€
     * @param isComplete æ˜¯å¦å®Œæˆ
     */
    suspend fun smartUpdate(
        blockId: String,
        content: String,
        blockType: MessageBlockType,
        status: MessageBlockStatus = MessageBlockStatus.STREAMING,
        isComplete: Boolean = false
    ) {
        val isTypeChanged = lastBlockType != null && lastBlockType != blockType

        if (isTypeChanged || isComplete) {
            // ç«‹å³å†™å…¥ï¼šå—ç±»å‹å˜åŒ–æˆ–å®Œæˆæ—¶
            flushPendingUpdates()
            withContext(ioDispatcher) {
                aiAdvisorMessageBlockDao.updateContentAndStatus(
                    blockId, content, status.name
                )
            }
        } else {
            // èŠ‚æµæ›´æ–°ï¼šåŒç±»å‹å†…å®¹ç´¯ç§¯
            pendingUpdates[blockId] = PendingUpdate(blockId, content, status)
            scheduleFlush()
        }

        lastBlockType = blockType
    }

    private fun scheduleFlush() {
        throttleJob?.cancel()
        throttleJob = scope.launch {
            delay(THROTTLE_DELAY_MS)
            flushPendingUpdates()
        }
    }

    private suspend fun flushPendingUpdates() {
        val updates = pendingUpdates.toMap()
        pendingUpdates.clear()
        
        withContext(ioDispatcher) {
            updates.values.forEach { update ->
                aiAdvisorMessageBlockDao.updateContentAndStatus(
                    update.blockId,
                    update.content,
                    update.status.name
                )
            }
        }
    }
    
    /**
     * é‡ç½®çŠ¶æ€ï¼ˆæ–°æ¶ˆæ¯å¼€å§‹æ—¶è°ƒç”¨ï¼‰
     */
    fun reset() {
        lastBlockType = null
        pendingUpdates.clear()
        throttleJob?.cancel()
    }
    
    /**
     * æ¸…ç†èµ„æº
     */
    fun cleanup() {
        scope.cancel()
    }

    companion object {
        private const val THROTTLE_DELAY_MS = 300L
    }
}
```


### 5.3 Repositoryå®ç°æ‰©å±•

```kotlin
// data/src/main/kotlin/com/empathy/ai/data/repository/AiRepositoryImpl.kt æ‰©å±•

class AiRepositoryImpl @Inject constructor(
    private val openAiApi: OpenAiApi,
    private val sseStreamReader: SseStreamReader,
    private val okHttpClient: OkHttpClient
) : AiRepository {

    // ç°æœ‰å®ç°ä¿ç•™...
    
    override fun generateTextStream(
        provider: AiProvider,
        prompt: String,
        systemInstruction: String
    ): Flow<AiStreamChunk> {
        val requestBody = ChatRequestDto(
            model = provider.model,
            messages = listOf(
                MessageDto(role = "system", content = systemInstruction),
                MessageDto(role = "user", content = prompt)
            ),
            stream = true,
            temperature = provider.temperature,
            maxTokens = provider.maxTokens
        )
        
        val headers = mapOf(
            "Authorization" to "Bearer ${provider.apiKey}",
            "Content-Type" to "application/json"
        )
        
        val url = "${provider.baseUrl}/chat/completions"
        
        return sseStreamReader.stream(url, requestBody, headers)
    }
}

// data/src/main/kotlin/com/empathy/ai/data/repository/AiAdvisorRepositoryImpl.kt æ‰©å±•

class AiAdvisorRepositoryImpl @Inject constructor(
    private val aiAdvisorDao: AiAdvisorDao,
    private val aiAdvisorMessageBlockDao: AiAdvisorMessageBlockDao,
    @IoDispatcher private val ioDispatcher: CoroutineDispatcher
) : AiAdvisorRepository {

    // ç°æœ‰å®ç°ä¿ç•™...
    
    override suspend fun saveBlock(block: AiAdvisorMessageBlock): Result<Unit> =
        withContext(ioDispatcher) {
            runCatching {
                aiAdvisorMessageBlockDao.insert(
                    AiAdvisorMessageBlockEntity.fromDomain(block)
                )
            }
        }
    
    override suspend fun updateBlockContent(
        blockId: String,
        content: String,
        status: MessageBlockStatus
    ): Result<Unit> = withContext(ioDispatcher) {
        runCatching {
            aiAdvisorMessageBlockDao.updateContentAndStatus(
                blockId, content, status.name
            )
        }
    }
    
    override suspend fun getBlocksByMessageId(
        messageId: String
    ): Result<List<AiAdvisorMessageBlock>> = withContext(ioDispatcher) {
        runCatching {
            aiAdvisorMessageBlockDao.getByMessageId(messageId)
                .map { it.toDomain() }
        }
    }
    
    override fun observeBlocksByMessageId(
        messageId: String
    ): Flow<List<AiAdvisorMessageBlock>> =
        aiAdvisorMessageBlockDao.observeByMessageId(messageId)
            .map { entities -> entities.map { it.toDomain() } }
            .flowOn(ioDispatcher)
}
```

---

## 6. è¡¨ç°å±‚è®¾è®¡

### 6.1 ViewModelæ‰©å±•

```kotlin
// presentation/src/main/kotlin/com/empathy/ai/presentation/viewmodel/AiAdvisorChatViewModel.kt

@HiltViewModel
class AiAdvisorChatViewModel @Inject constructor(
    savedStateHandle: SavedStateHandle,
    private val getContactUseCase: GetContactUseCase,
    private val getAllContactsUseCase: GetAllContactsUseCase,
    private val createAdvisorSessionUseCase: CreateAdvisorSessionUseCase,
    private val getAdvisorSessionsUseCase: GetAdvisorSessionsUseCase,
    private val getAdvisorConversationsUseCase: GetAdvisorConversationsUseCase,
    private val sendAdvisorMessageUseCase: SendAdvisorMessageUseCase,
    private val sendAdvisorMessageStreamingUseCase: SendAdvisorMessageStreamingUseCase,  // ğŸ†•
    private val deleteAdvisorConversationUseCase: DeleteAdvisorConversationUseCase
) : ViewModel() {

    private val contactId: String = savedStateHandle[NavRoutes.AI_ADVISOR_CHAT_ARG_ID] ?: ""

    private val _uiState = MutableStateFlow(AiAdvisorChatUiState())
    val uiState: StateFlow<AiAdvisorChatUiState> = _uiState.asStateFlow()

    private var streamingJob: Job? = null

    // ç°æœ‰æ–¹æ³•ä¿ç•™...

    /**
     * å‘é€æ¶ˆæ¯ï¼ˆæµå¼ç‰ˆæœ¬ï¼‰
     */
    fun sendMessageStreaming() {
        val currentState = _uiState.value
        val message = currentState.inputText.trim()
        if (message.isEmpty() || currentState.isSending) return

        val sessionId = currentState.currentSessionId ?: return

        // å–æ¶ˆä¹‹å‰çš„æµå¼ä»»åŠ¡
        streamingJob?.cancel()

        streamingJob = viewModelScope.launch {
            _uiState.update {
                it.copy(
                    isSending = true,
                    inputText = "",
                    error = null,
                    streamingContent = "",
                    thinkingContent = "",
                    thinkingTimeMs = 0,
                    canCancel = true,
                    streamingMessageId = null
                )
            }

            sendAdvisorMessageStreamingUseCase(contactId, sessionId, message)
                .catch { error ->
                    _uiState.update {
                        it.copy(
                            isSending = false,
                            canCancel = false,
                            error = error.message ?: "å‘é€å¤±è´¥"
                        )
                    }
                }
                .collect { state ->
                    handleStreamingState(state)
                }
        }
    }

    private fun handleStreamingState(state: StreamingState) {
        when (state) {
            is StreamingState.Started -> {
                _uiState.update { 
                    it.copy(streamingMessageId = state.messageId) 
                }
            }

            is StreamingState.ThinkingUpdate -> {
                _uiState.update { current ->
                    current.copy(
                        thinkingContent = state.content,
                        thinkingTimeMs = state.elapsedMs
                    )
                }
            }

            is StreamingState.TextUpdate -> {
                _uiState.update { current ->
                    current.copy(streamingContent = state.content)
                }
            }

            is StreamingState.Completed -> {
                _uiState.update {
                    it.copy(
                        isSending = false,
                        canCancel = false,
                        streamingContent = "",
                        thinkingContent = "",
                        streamingMessageId = null
                    )
                }
            }

            is StreamingState.Error -> {
                _uiState.update {
                    it.copy(
                        isSending = false,
                        canCancel = false,
                        error = state.error.message ?: "æœªçŸ¥é”™è¯¯"
                    )
                }
            }
        }
    }

    /**
     * å–æ¶ˆæµå¼è¯·æ±‚
     */
    fun cancelStreaming() {
        streamingJob?.cancel()
        _uiState.update {
            it.copy(
                isSending = false,
                canCancel = false,
                streamingContent = "",
                thinkingContent = ""
            )
        }
    }
}

/**
 * AIå†›å¸ˆå¯¹è¯ç•Œé¢UIçŠ¶æ€ï¼ˆæ‰©å±•ï¼‰
 */
data class AiAdvisorChatUiState(
    // ç°æœ‰å­—æ®µä¿ç•™...
    val isLoading: Boolean = false,
    val isSending: Boolean = false,
    val contactName: String = "",
    val inputText: String = "",
    val currentSessionId: String? = null,
    val sessions: List<AiAdvisorSession> = emptyList(),
    val conversations: List<AiAdvisorConversation> = emptyList(),
    val allContacts: List<ContactProfile> = emptyList(),
    val showContactSelector: Boolean = false,
    val showSwitchConfirmDialog: Boolean = false,
    val pendingContactId: String? = null,
    val shouldNavigateToContact: String? = null,
    val error: String? = null,
    
    // ğŸ†• æµå¼ç›¸å…³å­—æ®µ
    val streamingMessageId: String? = null,  // æ­£åœ¨æµå¼æ¥æ”¶çš„æ¶ˆæ¯ID
    val streamingContent: String = "",        // æµå¼æ–‡æœ¬ç¼“å†²
    val thinkingContent: String = "",         // æ€è€ƒè¿‡ç¨‹ç¼“å†²
    val thinkingTimeMs: Long = 0,             // æ€è€ƒè€—æ—¶
    val canCancel: Boolean = false            // æ˜¯å¦å¯å–æ¶ˆ
)
```


### 6.2 UIç»„ä»¶è®¾è®¡

#### æ€è€ƒè¿‡ç¨‹ç»„ä»¶

```kotlin
// presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/advisor/component/ThinkingSection.kt

@Composable
fun ThinkingSection(
    content: String,
    thinkingMs: Long,
    isStreaming: Boolean,
    modifier: Modifier = Modifier
) {
    var expanded by remember { mutableStateOf(true) }
    
    Card(
        modifier = modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(modifier = Modifier.padding(12.dp)) {
            // æ ‡é¢˜æ ï¼ˆå¯ç‚¹å‡»æŠ˜å ï¼‰
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { expanded = !expanded },
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Icon(
                        imageVector = Icons.Default.Psychology,
                        contentDescription = "æ€è€ƒ",
                        tint = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.size(18.dp)
                    )
                    Spacer(modifier = Modifier.width(6.dp))
                    Text(
                        text = "æ€è€ƒè¿‡ç¨‹",
                        style = MaterialTheme.typography.labelLarge,
                        color = MaterialTheme.colorScheme.primary
                    )
                    if (thinkingMs > 0) {
                        Spacer(modifier = Modifier.width(4.dp))
                        Text(
                            text = "(${String.format("%.1f", thinkingMs / 1000.0)}s)",
                            style = MaterialTheme.typography.labelSmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                    if (isStreaming) {
                        Spacer(modifier = Modifier.width(8.dp))
                        CircularProgressIndicator(
                            modifier = Modifier.size(12.dp),
                            strokeWidth = 2.dp
                        )
                    }
                }
                Icon(
                    imageVector = if (expanded) 
                        Icons.Default.ExpandLess 
                    else 
                        Icons.Default.ExpandMore,
                    contentDescription = if (expanded) "æ”¶èµ·" else "å±•å¼€",
                    tint = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            
            // å†…å®¹ï¼ˆå¯æŠ˜å ï¼‰
            AnimatedVisibility(
                visible = expanded,
                enter = expandVertically() + fadeIn(),
                exit = shrinkVertically() + fadeOut()
            ) {
                Text(
                    text = content + if (isStreaming) "â–ˆ" else "",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(top = 8.dp)
                )
            }
        }
    }
}
```

#### æµå¼æ¶ˆæ¯æ°”æ³¡

```kotlin
// presentation/src/main/kotlin/com/empathy/ai/presentation/ui/screen/advisor/component/StreamingMessageBubble.kt

@Composable
fun StreamingMessageBubble(
    streamingContent: String,
    thinkingContent: String,
    thinkingTimeMs: Long,
    isStreaming: Boolean,
    onCancel: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier) {
        // æ€è€ƒè¿‡ç¨‹å±•ç¤ºï¼ˆå¦‚æœæœ‰ï¼‰
        if (thinkingContent.isNotEmpty()) {
            ThinkingSection(
                content = thinkingContent,
                thinkingMs = thinkingTimeMs,
                isStreaming = isStreaming && streamingContent.isEmpty()
            )
            Spacer(modifier = Modifier.height(8.dp))
        }

        // ä¸»æ–‡æœ¬å†…å®¹
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(
                containerColor = MaterialTheme.colorScheme.secondaryContainer
            ),
            shape = RoundedCornerShape(
                topStart = 4.dp,
                topEnd = 16.dp,
                bottomStart = 16.dp,
                bottomEnd = 16.dp
            )
        ) {
            Column(modifier = Modifier.padding(12.dp)) {
                if (streamingContent.isNotEmpty()) {
                    // æ‰“å­—æœºæ•ˆæœæ–‡æœ¬
                    TypewriterText(
                        text = streamingContent,
                        isStreaming = isStreaming
                    )
                } else if (isStreaming) {
                    // ç­‰å¾…ä¸­çš„åŠ¨ç”»
                    LoadingDots()
                }
            }
        }

        // å–æ¶ˆæŒ‰é’®
        if (isStreaming) {
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedButton(
                onClick = onCancel,
                modifier = Modifier.align(Alignment.CenterHorizontally),
                colors = ButtonDefaults.outlinedButtonColors(
                    contentColor = MaterialTheme.colorScheme.error
                )
            ) {
                Icon(
                    imageVector = Icons.Default.Stop,
                    contentDescription = "åœæ­¢",
                    modifier = Modifier.size(16.dp)
                )
                Spacer(modifier = Modifier.width(4.dp))
                Text("åœæ­¢ç”Ÿæˆ")
            }
        }
    }
}

@Composable
private fun TypewriterText(
    text: String,
    isStreaming: Boolean,
    modifier: Modifier = Modifier
) {
    Text(
        text = text + if (isStreaming) "â–ˆ" else "",
        style = MaterialTheme.typography.bodyLarge,
        color = MaterialTheme.colorScheme.onSecondaryContainer,
        modifier = modifier
    )
}

@Composable
private fun LoadingDots() {
    val infiniteTransition = rememberInfiniteTransition(label = "loading")
    val alpha by infiniteTransition.animateFloat(
        initialValue = 0.3f,
        targetValue = 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(500),
            repeatMode = RepeatMode.Reverse
        ),
        label = "alpha"
    )

    Row(
        horizontalArrangement = Arrangement.spacedBy(4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = "AIæ­£åœ¨æ€è€ƒ",
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        repeat(3) {
            Box(
                modifier = Modifier
                    .size(6.dp)
                    .alpha(alpha)
                    .background(
                        MaterialTheme.colorScheme.primary,
                        CircleShape
                    )
            )
        }
    }
}
```


---

## 7. ä¾èµ–æ³¨å…¥é…ç½®

### 7.1 æ•°æ®å±‚DIæ¨¡å—æ›´æ–°

#### 7.1.1 DatabaseModuleæ‰©å±•

**æ–‡ä»¶ä½ç½®**ï¼š`data/src/main/kotlin/com/empathy/ai/data/di/DatabaseModule.kt`

**éœ€è¦æ·»åŠ çš„å¯¼å…¥**ï¼š
```kotlin
import com.empathy.ai.data.local.dao.AiAdvisorMessageBlockDao
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
```

**è¿ç§»è„šæœ¬å®šä¹‰**ï¼ˆINT-001ä¿®å¤ï¼‰ï¼š
```kotlin
/**
 * æ•°æ®åº“è¿ç§»: ç‰ˆæœ¬ 13 -> 14
 * TDD-00028: AIå†›å¸ˆæµå¼å¯¹è¯å‡çº§
 *
 * å˜æ›´å†…å®¹ï¼š
 * 1. æ–°å¢ai_advisor_message_blocksè¡¨
 * 2. ä¸ºç°æœ‰AIæ¶ˆæ¯åˆ›å»ºé»˜è®¤MAIN_TEXT Block
 */
private val MIGRATION_13_14 = object : Migration(13, 14) {
    override fun migrate(db: SupportSQLiteDatabase) {
        // 1. åˆ›å»ºæ¶ˆæ¯å—è¡¨
        db.execSQL("""
            CREATE TABLE IF NOT EXISTS ai_advisor_message_blocks (
                id TEXT PRIMARY KEY NOT NULL,
                message_id TEXT NOT NULL,
                type TEXT NOT NULL,
                status TEXT NOT NULL,
                content TEXT NOT NULL,
                metadata TEXT,
                created_at INTEGER NOT NULL,
                FOREIGN KEY (message_id) 
                    REFERENCES ai_advisor_conversations(id) 
                    ON DELETE CASCADE
            )
        """.trimIndent())
        
        // 2. åˆ›å»ºç´¢å¼•ï¼ˆä¼˜åŒ–æŒ‰æ¶ˆæ¯IDæŸ¥è¯¢ï¼‰
        db.execSQL("""
            CREATE INDEX IF NOT EXISTS idx_blocks_message_id 
            ON ai_advisor_message_blocks(message_id)
        """.trimIndent())
        
        // 3. æ•°æ®è¿ç§»ï¼šä¸ºç°æœ‰AIæ¶ˆæ¯åˆ›å»ºé»˜è®¤Block
        db.execSQL("""
            INSERT INTO ai_advisor_message_blocks 
                (id, message_id, type, status, content, created_at)
            SELECT 
                id || '_main_block',
                id,
                'MAIN_TEXT',
                'SUCCESS',
                content,
                created_at
            FROM ai_advisor_conversations
            WHERE message_type = 'AI'
        """.trimIndent())
    }
}
```

**provideAppDatabaseæ–¹æ³•æ›´æ–°**ï¼š
```kotlin
@Provides
@Singleton
fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {
    return Room.databaseBuilder(
        context,
        AppDatabase::class.java,
        "empathy_ai_database"
    )
    .addMigrations(
        MIGRATION_1_2,
        MIGRATION_2_3,
        MIGRATION_3_4,
        MIGRATION_4_5,
        MIGRATION_5_6,
        MIGRATION_6_7,
        MIGRATION_7_8,
        MIGRATION_8_9,
        MIGRATION_9_10,
        MIGRATION_10_11,
        MIGRATION_11_12,
        MIGRATION_12_13,
        MIGRATION_13_14  // ğŸ†• æ·»åŠ æ­¤è¡Œ
    )
    .build()
}
```

**DAOæä¾›æ–¹æ³•**ï¼ˆINT-002ä¿®å¤ï¼‰ï¼š
```kotlin
/**
 * æä¾›AiAdvisorMessageBlockDaoå®ä¾‹
 *
 * TDD-00028: AIå†›å¸ˆæ¶ˆæ¯å—DAO
 * ç”¨äºç®¡ç†æ¶ˆæ¯å—çš„CRUDæ“ä½œå’ŒFlowè®¢é˜…
 */
@Provides
fun provideAiAdvisorMessageBlockDao(database: AppDatabase): AiAdvisorMessageBlockDao =
    database.aiAdvisorMessageBlockDao()
```

#### 7.1.2 NetworkModuleæ‰©å±•

**æ–‡ä»¶ä½ç½®**ï¼š`data/src/main/kotlin/com/empathy/ai/data/di/NetworkModule.kt`

**éœ€è¦æ·»åŠ çš„å¯¼å…¥**ï¼ˆINT-004ä¿®å¤ï¼‰ï¼š
```kotlin
import com.empathy.ai.data.remote.SseStreamReader
import javax.inject.Named
import okhttp3.OkHttpClient
import java.util.concurrent.TimeUnit
```

**SSEç›¸å…³é…ç½®**ï¼š
```kotlin
/**
 * æä¾›ç”¨äºSSEçš„OkHttpClient
 *
 * TDD-00028: SSEè¿æ¥éœ€è¦ç‰¹æ®Šé…ç½®
 * - readTimeoutè®¾ç½®ä¸º0ä»¥æ”¯æŒé•¿æ—¶é—´è¿æ¥
 * - å¯ç”¨é‡è¿æœºåˆ¶
 */
@Provides
@Singleton
@Named("streaming")
fun provideStreamingOkHttpClient(): OkHttpClient {
    return OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(0, TimeUnit.SECONDS)  // SSEéœ€è¦æ— é™è¯»å–è¶…æ—¶
        .writeTimeout(30, TimeUnit.SECONDS)
        .retryOnConnectionFailure(true)
        .build()
}

/**
 * æä¾›SseStreamReaderå®ä¾‹
 *
 * TDD-00028: SSEæµå¼è¯»å–å™¨
 * ä½¿ç”¨OkHttp EventSourceå®ç°Server-Sent Eventsæµå¼è¯»å–
 */
@Provides
@Singleton
fun provideSseStreamReader(
    @Named("streaming") okHttpClient: OkHttpClient
): SseStreamReader = SseStreamReader(okHttpClient)
```

### 7.2 åº”ç”¨å±‚DIæ¨¡å—æ›´æ–°

**æ–‡ä»¶ä½ç½®**ï¼š`app/src/main/java/com/empathy/ai/di/AiAdvisorModule.kt`

**éœ€è¦æ·»åŠ çš„å¯¼å…¥**ï¼ˆINT-003ä¿®å¤ï¼‰ï¼š
```kotlin
import com.empathy.ai.domain.usecase.SendAdvisorMessageStreamingUseCase
import com.empathy.ai.data.util.BlockUpdateManager
import com.empathy.ai.data.local.dao.AiAdvisorMessageBlockDao
import com.empathy.ai.domain.util.AdvisorPromptBuilder
import com.empathy.ai.domain.repository.AiRepository
import com.empathy.ai.domain.repository.AiAdvisorRepository
import com.empathy.ai.domain.repository.ContactRepository
import com.empathy.ai.domain.repository.AiProviderRepository
import com.empathy.ai.data.di.IoDispatcher
import kotlinx.coroutines.CoroutineDispatcher
```

**æµå¼åŠŸèƒ½DIé…ç½®**ï¼š
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object AiAdvisorModule {
    
    // ç°æœ‰é…ç½®ä¿ç•™...
    
    /**
     * æä¾›BlockUpdateManagerå®ä¾‹
     *
     * TDD-00028: æ™ºèƒ½èŠ‚æµæ›´æ–°ç®¡ç†å™¨
     * ç”¨äºå‡å°‘æ•°æ®åº“å†™å…¥é¢‘ç‡ï¼Œæå‡æµå¼å“åº”æ€§èƒ½
     * 
     * èŠ‚æµç­–ç•¥ï¼š
     * - å—ç±»å‹å˜åŒ–æ—¶ç«‹å³å†™å…¥
     * - åŒç±»å‹å†…å®¹ä½¿ç”¨300msèŠ‚æµ
     */
    @Provides
    @Singleton
    fun provideBlockUpdateManager(
        aiAdvisorMessageBlockDao: AiAdvisorMessageBlockDao,
        @IoDispatcher ioDispatcher: CoroutineDispatcher
    ): BlockUpdateManager = BlockUpdateManager(aiAdvisorMessageBlockDao, ioDispatcher)
    
    /**
     * æä¾›å‘é€AIå†›å¸ˆæ¶ˆæ¯ç”¨ä¾‹ï¼ˆæµå¼ç‰ˆæœ¬ï¼‰
     *
     * TDD-00028: æµå¼å¯¹è¯åŠŸèƒ½æ ¸å¿ƒUseCase
     * ç¼–æ’å®Œæ•´çš„æµå¼å‘é€æµç¨‹ï¼š
     *   1. ä¿å­˜ç”¨æˆ·æ¶ˆæ¯
     *   2. åˆ›å»ºAIæ¶ˆæ¯å ä½å’ŒBlock
     *   3. è°ƒç”¨æµå¼APIå¹¶å¤„ç†å“åº”
     *   4. å®æ—¶æ›´æ–°Blockå†…å®¹å’ŒçŠ¶æ€
     *
     * ä¾èµ–5ä¸ªä»“åº“çš„åä½œï¼Œä½“ç°å…¶æ ¸å¿ƒç¼–æ’è§’è‰²
     */
    @Provides
    @Singleton
    fun provideSendAdvisorMessageStreamingUseCase(
        aiAdvisorRepository: AiAdvisorRepository,
        aiRepository: AiRepository,
        contactRepository: ContactRepository,
        aiProviderRepository: AiProviderRepository,
        promptBuilder: AdvisorPromptBuilder
    ): SendAdvisorMessageStreamingUseCase = SendAdvisorMessageStreamingUseCase(
        aiAdvisorRepository,
        aiRepository,
        contactRepository,
        aiProviderRepository,
        promptBuilder
    )
}
```

### 7.3 AppDatabaseæ›´æ–°

**æ–‡ä»¶ä½ç½®**ï¼š`data/src/main/kotlin/com/empathy/ai/data/local/AppDatabase.kt`

**Entityæ³¨å†Œæ›´æ–°**ï¼š
```kotlin
@Database(
    entities = [
        ContactProfileEntity::class,
        BrainTagEntity::class,
        AiProviderEntity::class,
        ConversationLogEntity::class,
        DailySummaryEntity::class,
        FailedSummaryTaskEntity::class,
        ConversationTopicEntity::class,
        ApiUsageEntity::class,
        AiAdvisorSessionEntity::class,
        AiAdvisorConversationEntity::class,
        AiAdvisorMessageBlockEntity::class  // ğŸ†• æ–°å¢
    ],
    version = 14,  // ğŸ†• ç‰ˆæœ¬å‡çº§ 13 â†’ 14
    exportSchema = true
)
@TypeConverters(RoomTypeConverters::class, FactListConverter::class)
abstract class AppDatabase : RoomDatabase() {
    // ç°æœ‰DAOä¿ç•™...
    
    /**
     * è·å–AIå†›å¸ˆæ¶ˆæ¯å—DAO
     *
     * TDD-00028: æ¶ˆæ¯å—æ•°æ®è®¿é—®
     * - æ”¯æŒBlockçš„CRUDæ“ä½œ
     * - æ”¯æŒæŒ‰æ¶ˆæ¯IDæŸ¥è¯¢å’ŒFlowè®¢é˜…
     */
    abstract fun aiAdvisorMessageBlockDao(): AiAdvisorMessageBlockDao
}
```

### 7.4 é›†æˆæ£€æŸ¥æ¸…å•

æ ¹æ®å®¡æŸ¥æŠ¥å‘ŠINT-001~INT-004ï¼Œå®æ–½å‰éœ€ç¡®è®¤ä»¥ä¸‹é›†æˆç‚¹ï¼š

| æ£€æŸ¥é¡¹ | æ–‡ä»¶ | çŠ¶æ€ | è¯´æ˜ |
|--------|------|------|------|
| MIGRATION_13_14è¿ç§»è„šæœ¬ | DatabaseModule.kt | â¬œ å¾…å®ç° | åŒ…å«è¡¨åˆ›å»ºã€ç´¢å¼•ã€æ•°æ®è¿ç§» |
| provideAiAdvisorMessageBlockDao | DatabaseModule.kt | â¬œ å¾…å®ç° | DAOæä¾›æ–¹æ³• |
| provideStreamingOkHttpClient | NetworkModule.kt | â¬œ å¾…å®ç° | SSEä¸“ç”¨OkHttpClient |
| provideSseStreamReader | NetworkModule.kt | â¬œ å¾…å®ç° | SSEæµå¼è¯»å–å™¨ |
| provideBlockUpdateManager | AiAdvisorModule.kt | â¬œ å¾…å®ç° | æ™ºèƒ½èŠ‚æµç®¡ç†å™¨ |
| provideSendAdvisorMessageStreamingUseCase | AiAdvisorModule.kt | â¬œ å¾…å®ç° | æµå¼UseCase |
| AiAdvisorMessageBlockEntityæ³¨å†Œ | AppDatabase.kt | â¬œ å¾…å®ç° | Entityæ•°ç»„æ·»åŠ  |
| aiAdvisorMessageBlockDao()æ–¹æ³• | AppDatabase.kt | â¬œ å¾…å®ç° | æŠ½è±¡æ–¹æ³•å£°æ˜ |
| ç‰ˆæœ¬å·æ›´æ–° | AppDatabase.kt | â¬œ å¾…å®ç° | version = 14 |

---

## 8. æµ‹è¯•è®¾è®¡

### 8.1 å•å…ƒæµ‹è¯•

#### AiStreamChunkæµ‹è¯•

```kotlin
// domain/src/test/kotlin/com/empathy/ai/domain/model/AiStreamChunkTest.kt

class AiStreamChunkTest {
    
    @Test
    fun `Started chunk should be singleton`() {
        val chunk1 = AiStreamChunk.Started
        val chunk2 = AiStreamChunk.Started
        assertEquals(chunk1, chunk2)
    }
    
    @Test
    fun `TextDelta should contain text`() {
        val chunk = AiStreamChunk.TextDelta("Hello")
        assertEquals("Hello", chunk.text)
    }
    
    @Test
    fun `ThinkingDelta should contain text and optional time`() {
        val chunk = AiStreamChunk.ThinkingDelta("Thinking...", 1000L)
        assertEquals("Thinking...", chunk.text)
        assertEquals(1000L, chunk.thinkingMs)
    }
    
    @Test
    fun `Complete should contain full text and optional usage`() {
        val usage = TokenUsage(100, 50, 150)
        val chunk = AiStreamChunk.Complete("Full response", usage)
        assertEquals("Full response", chunk.fullText)
        assertEquals(150, chunk.usage?.totalTokens)
    }
    
    @Test
    fun `Error should contain throwable`() {
        val error = IOException("Network error")
        val chunk = AiStreamChunk.Error(error)
        assertEquals("Network error", chunk.error.message)
    }
}
```

#### BlockUpdateManageræµ‹è¯•

```kotlin
// data/src/test/kotlin/com/empathy/ai/data/util/BlockUpdateManagerTest.kt

@ExperimentalCoroutinesApi
class BlockUpdateManagerTest {
    
    private lateinit var mockDao: AiAdvisorMessageBlockDao
    private lateinit var manager: BlockUpdateManager
    private val testDispatcher = StandardTestDispatcher()
    
    @Before
    fun setup() {
        mockDao = mockk(relaxed = true)
        manager = BlockUpdateManager(mockDao, testDispatcher)
    }
    
    @Test
    fun `should immediately write when block type changes`() = runTest {
        // First update with THINKING type
        manager.smartUpdate("block1", "content1", MessageBlockType.THINKING)
        advanceUntilIdle()
        
        // Second update with MAIN_TEXT type (type changed)
        manager.smartUpdate("block2", "content2", MessageBlockType.MAIN_TEXT)
        advanceUntilIdle()
        
        // Both should be written immediately
        coVerify(exactly = 2) { 
            mockDao.updateContentAndStatus(any(), any(), any()) 
        }
    }
    
    @Test
    fun `should throttle updates for same block type`() = runTest {
        // Multiple updates with same type
        manager.smartUpdate("block1", "content1", MessageBlockType.MAIN_TEXT)
        manager.smartUpdate("block1", "content2", MessageBlockType.MAIN_TEXT)
        manager.smartUpdate("block1", "content3", MessageBlockType.MAIN_TEXT)
        
        // Before throttle delay, only pending
        advanceTimeBy(100)
        coVerify(exactly = 0) { mockDao.updateContentAndStatus(any(), any(), any()) }
        
        // After throttle delay, should write once with latest content
        advanceTimeBy(300)
        coVerify(exactly = 1) { 
            mockDao.updateContentAndStatus("block1", "content3", any()) 
        }
    }
    
    @Test
    fun `should immediately write when isComplete is true`() = runTest {
        manager.smartUpdate(
            "block1", 
            "final content", 
            MessageBlockType.MAIN_TEXT,
            MessageBlockStatus.SUCCESS,
            isComplete = true
        )
        advanceUntilIdle()
        
        coVerify(exactly = 1) { 
            mockDao.updateContentAndStatus("block1", "final content", "SUCCESS") 
        }
    }
}
```

### 8.2 é›†æˆæµ‹è¯•

#### æ•°æ®åº“è¿ç§»æµ‹è¯•

```kotlin
// data/src/androidTest/kotlin/com/empathy/ai/data/local/Migration13To14Test.kt

@RunWith(AndroidJUnit4::class)
class Migration13To14Test {
    
    private val TEST_DB = "migration-test"
    
    @get:Rule
    val helper: MigrationTestHelper = MigrationTestHelper(
        InstrumentationRegistry.getInstrumentation(),
        AppDatabase::class.java.canonicalName,
        FrameworkSQLiteOpenHelperFactory()
    )
    
    @Test
    fun migrate13To14_createsMessageBlocksTable() {
        // Create database at version 13
        helper.createDatabase(TEST_DB, 13).apply {
            // Insert test data
            execSQL("""
                INSERT INTO ai_advisor_conversations 
                (id, contact_id, session_id, message_type, content, timestamp, created_at, send_status)
                VALUES ('msg1', 'contact1', 'session1', 'AI', 'Test content', 1000, 1000, 'SUCCESS')
            """)
            close()
        }
        
        // Run migration
        val db = helper.runMigrationsAndValidate(TEST_DB, 14, true, MIGRATION_13_14)
        
        // Verify table exists
        val cursor = db.query("SELECT * FROM ai_advisor_message_blocks WHERE message_id = 'msg1'")
        assertTrue(cursor.moveToFirst())
        assertEquals("msg1_main_block", cursor.getString(cursor.getColumnIndex("id")))
        assertEquals("MAIN_TEXT", cursor.getString(cursor.getColumnIndex("type")))
        assertEquals("SUCCESS", cursor.getString(cursor.getColumnIndex("status")))
        assertEquals("Test content", cursor.getString(cursor.getColumnIndex("content")))
        cursor.close()
    }
    
    @Test
    fun migrate13To14_preservesExistingData() {
        helper.createDatabase(TEST_DB, 13).apply {
            execSQL("""
                INSERT INTO ai_advisor_sessions (id, contact_id, title, created_at, updated_at)
                VALUES ('session1', 'contact1', 'Test Session', 1000, 1000)
            """)
            execSQL("""
                INSERT INTO ai_advisor_conversations 
                (id, contact_id, session_id, message_type, content, timestamp, created_at, send_status)
                VALUES ('msg1', 'contact1', 'session1', 'USER', 'User message', 1000, 1000, 'SUCCESS')
            """)
            close()
        }
        
        val db = helper.runMigrationsAndValidate(TEST_DB, 14, true, MIGRATION_13_14)
        
        // Verify existing data preserved
        val sessionCursor = db.query("SELECT * FROM ai_advisor_sessions")
        assertTrue(sessionCursor.moveToFirst())
        assertEquals("session1", sessionCursor.getString(sessionCursor.getColumnIndex("id")))
        sessionCursor.close()
        
        val msgCursor = db.query("SELECT * FROM ai_advisor_conversations")
        assertTrue(msgCursor.moveToFirst())
        assertEquals("msg1", msgCursor.getString(msgCursor.getColumnIndex("id")))
        msgCursor.close()
        
        // USER messages should NOT have blocks created
        val blockCursor = db.query("SELECT * FROM ai_advisor_message_blocks WHERE message_id = 'msg1'")
        assertFalse(blockCursor.moveToFirst())
        blockCursor.close()
    }
}
```

### 8.3 UIæµ‹è¯•

```kotlin
// presentation/src/androidTest/kotlin/com/empathy/ai/presentation/ui/screen/advisor/ThinkingSectionTest.kt

@RunWith(AndroidJUnit4::class)
class ThinkingSectionTest {
    
    @get:Rule
    val composeTestRule = createComposeRule()
    
    @Test
    fun thinkingSection_displaysContent() {
        composeTestRule.setContent {
            ThinkingSection(
                content = "æ­£åœ¨åˆ†æé—®é¢˜...",
                thinkingMs = 2300,
                isStreaming = false
            )
        }
        
        composeTestRule.onNodeWithText("æ€è€ƒè¿‡ç¨‹").assertIsDisplayed()
        composeTestRule.onNodeWithText("(2.3s)").assertIsDisplayed()
        composeTestRule.onNodeWithText("æ­£åœ¨åˆ†æé—®é¢˜...").assertIsDisplayed()
    }
    
    @Test
    fun thinkingSection_canCollapse() {
        composeTestRule.setContent {
            ThinkingSection(
                content = "æ­£åœ¨åˆ†æé—®é¢˜...",
                thinkingMs = 2300,
                isStreaming = false
            )
        }
        
        // Initially expanded
        composeTestRule.onNodeWithText("æ­£åœ¨åˆ†æé—®é¢˜...").assertIsDisplayed()
        
        // Click to collapse
        composeTestRule.onNodeWithText("æ€è€ƒè¿‡ç¨‹").performClick()
        
        // Content should be hidden
        composeTestRule.onNodeWithText("æ­£åœ¨åˆ†æé—®é¢˜...").assertDoesNotExist()
    }
    
    @Test
    fun thinkingSection_showsLoadingWhenStreaming() {
        composeTestRule.setContent {
            ThinkingSection(
                content = "æ­£åœ¨åˆ†æ...",
                thinkingMs = 1000,
                isStreaming = true
            )
        }
        
        // Should show loading indicator
        composeTestRule.onNode(hasProgressBarRangeInfo(ProgressBarRangeInfo.Indeterminate))
            .assertIsDisplayed()
    }
}
```

---

## 9. å®æ–½è®¡åˆ’

### 9.1 Phase 1ï¼šæµå¼å“åº”åŸºç¡€ï¼ˆé¢„è®¡1å‘¨ï¼‰

| åºå· | ä»»åŠ¡ | æ–‡ä»¶ | é¢„ä¼° | ä¾èµ– |
|------|------|------|------|------|
| 1.1 | å®šä¹‰AiStreamChunkå¯†å°ç±» | domain/model/AiStreamChunk.kt | 0.5å¤© | - |
| 1.2 | å®šä¹‰TokenUsageæ¨¡å‹ | domain/model/TokenUsage.kt | 0.5å¤© | - |
| 1.3 | AiRepositoryæ–°å¢æµå¼æ¥å£ | domain/repository/AiRepository.kt | 0.5å¤© | 1.1 |
| 1.4 | å®ç°SseStreamReader | data/remote/SseStreamReader.kt | 2å¤© | 1.1 |
| 1.5 | AiRepositoryImplå®ç°æµå¼ | data/repository/AiRepositoryImpl.kt | 1å¤© | 1.3, 1.4 |
| 1.6 | å®šä¹‰StreamingState | domain/model/StreamingState.kt | 0.5å¤© | 1.1 |
| 1.7 | æ–°å¢æµå¼UseCase | domain/usecase/SendAdvisorMessageStreamingUseCase.kt | 1å¤© | 1.3, 1.6 |
| 1.8 | ViewModelæµå¼çŠ¶æ€ | presentation/viewmodel/AiAdvisorChatViewModel.kt | 1å¤© | 1.7 |

### 9.2 Phase 2ï¼šBlockæ¶æ„ï¼ˆé¢„è®¡1å‘¨ï¼‰

| åºå· | ä»»åŠ¡ | æ–‡ä»¶ | é¢„ä¼° | ä¾èµ– |
|------|------|------|------|------|
| 2.1 | å®šä¹‰MessageBlockTypeæšä¸¾ | domain/model/MessageBlockType.kt | 0.5å¤© | - |
| 2.2 | å®šä¹‰MessageBlockStatusæšä¸¾ | domain/model/MessageBlockStatus.kt | 0.5å¤© | - |
| 2.3 | å®šä¹‰AiAdvisorMessageBlockæ¨¡å‹ | domain/model/AiAdvisorMessageBlock.kt | 0.5å¤© | 2.1, 2.2 |
| 2.4 | æ–°å¢MessageBlockEntity | data/local/entity/AiAdvisorMessageBlockEntity.kt | 0.5å¤© | 2.3 |
| 2.5 | æ–°å¢MessageBlockDao | data/local/dao/AiAdvisorMessageBlockDao.kt | 0.5å¤© | 2.4 |
| 2.6 | æ•°æ®åº“è¿ç§»13â†’14 | data/local/DatabaseMigrations.kt | 1å¤© | 2.4, 2.5 |
| 2.7 | æ›´æ–°AppDatabase | data/local/AppDatabase.kt | 0.5å¤© | 2.5, 2.6 |
| 2.8 | AiAdvisorRepositoryæ‰©å±•Blockæ¥å£ | domain/repository/AiAdvisorRepository.kt | 0.5å¤© | 2.3 |
| 2.9 | AiAdvisorRepositoryImplå®ç°Block | data/repository/AiAdvisorRepositoryImpl.kt | 1å¤© | 2.5, 2.8 |
| 2.10 | æ€è€ƒè¿‡ç¨‹UIç»„ä»¶ | presentation/ui/screen/advisor/component/ThinkingSection.kt | 1å¤© | - |
| 2.11 | æµå¼æ¶ˆæ¯æ°”æ³¡ç»„ä»¶ | presentation/ui/screen/advisor/component/StreamingMessageBubble.kt | 1å¤© | 2.10 |
| 2.12 | è¿ç§»æµ‹è¯• | data/src/androidTest/Migration13To14Test.kt | 0.5å¤© | 2.6 |

### 9.3 Phase 3ï¼šæ€§èƒ½ä¼˜åŒ–ä¸æµ‹è¯•ï¼ˆé¢„è®¡0.5å‘¨ï¼‰

| åºå· | ä»»åŠ¡ | æ–‡ä»¶ | é¢„ä¼° | ä¾èµ– |
|------|------|------|------|------|
| 3.1 | æ™ºèƒ½èŠ‚æµæ›´æ–°ç®¡ç†å™¨ | data/util/BlockUpdateManager.kt | 1å¤© | 2.5 |
| 3.2 | DIæ¨¡å—æ›´æ–° | data/di/*, app/di/* | 0.5å¤© | 3.1 |
| 3.3 | å•å…ƒæµ‹è¯• | domain/src/test/*, data/src/test/* | 1å¤© | å…¨éƒ¨ |
| 3.4 | UIæµ‹è¯• | presentation/src/androidTest/* | 0.5å¤© | 2.10, 2.11 |
| 3.5 | Bugä¿®å¤ä¸ä¼˜åŒ– | - | 0.5å¤© | å…¨éƒ¨ |

---

## 10. é£é™©ä¸ç¼“è§£

| é£é™© | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½ |
|------|------|------|----------|
| AIæœåŠ¡å•†ä¸æ”¯æŒSSE | ä½ | é«˜ | OpenAI/DeepSeekéƒ½æ”¯æŒSSEï¼Œæå‰éªŒè¯ï¼›ä¿ç•™éæµå¼å¤‡é€‰ |
| æ•°æ®åº“è¿ç§»å¤±è´¥ | ä¸­ | é«˜ | ç¼–å†™å®Œæ•´è¿ç§»æµ‹è¯•ï¼›ä¿ç•™å›æ»šæ–¹æ¡ˆï¼›åº”ç”¨å¯åŠ¨æ—¶å¤‡ä»½æ•°æ®åº“ |
| æµå¼è§£æé”™è¯¯ | ä¸­ | ä¸­ | å¢å¼ºé”™è¯¯å¤„ç†ï¼›å‚è€ƒç°æœ‰AiResponseCleanerï¼›æ·»åŠ é™çº§é€»è¾‘ |
| æ€§èƒ½é—®é¢˜ï¼ˆANRï¼‰ | ä½ | é«˜ | æ™ºèƒ½èŠ‚æµï¼›æ•°æ®åº“æ“ä½œåœ¨IOçº¿ç¨‹ï¼›UIæ›´æ–°èŠ‚æµ |
| æ€è€ƒè¿‡ç¨‹æ ¼å¼ä¸ç»Ÿä¸€ | ä¸­ | ä½ | é€‚é…å¤šç§æ¨¡å‹æ ¼å¼ï¼ˆreasoning_contentã€thinkingç­‰ï¼‰ |
| OkHttp SSEè¿æ¥ä¸ç¨³å®š | ä¸­ | ä¸­ | æ·»åŠ é‡è¿é€»è¾‘ï¼›è®¾ç½®åˆç†è¶…æ—¶ï¼›é™çº§åˆ°éæµå¼ |

---

## 11. é™„å½•

### 11.1 ç›¸å…³æ–‡æ¡£

- PRD-00028ï¼šAIå†›å¸ˆæµå¼å¯¹è¯å‡çº§éœ€æ±‚
- PRD-00026ï¼šAIå†›å¸ˆå¯¹è¯åŠŸèƒ½éœ€æ±‚ï¼ˆåŸºç¡€ç‰ˆæœ¬ï¼‰
- RESEARCH-00003ï¼šCherryé¡¹ç›®æ¶æ„å¯¹æ¯”åˆ†ææŠ¥å‘Š
- RESEARCH-00004ï¼šCherryé¡¹ç›®AIå¯¹è¯å®ç°æ·±åº¦åˆ†ææŠ¥å‘Š
- DR-00028ï¼šPRD-00028æ–‡æ¡£å®¡æŸ¥æŠ¥å‘Š

### 11.2 å‚è€ƒèµ„æ–™

- [OkHttp EventSource](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-event-source/)
- [OpenAI Streaming API](https://platform.openai.com/docs/api-reference/streaming)
- [DeepSeek API Documentation](https://platform.deepseek.com/api-docs)
- [Room Database Migration](https://developer.android.com/training/data-storage/room/migrating-db-versions)

### 11.3 æœ¯è¯­è¡¨

| æœ¯è¯­ | è§£é‡Š |
|------|------|
| SSE | Server-Sent Eventsï¼ŒæœåŠ¡å™¨æ¨é€äº‹ä»¶åè®® |
| Block | æ¶ˆæ¯å—ï¼Œä¸€æ¡æ¶ˆæ¯å¯åŒ…å«å¤šä¸ªBlock |
| Chunk | æµå¼å“åº”çš„æ•°æ®ç‰‡æ®µ |
| èŠ‚æµ | Throttleï¼Œé™åˆ¶æ“ä½œé¢‘ç‡ä»¥æå‡æ€§èƒ½ |
| ä¹è§‚æ›´æ–° | å…ˆæ›´æ–°UIï¼ŒåæŒä¹…åŒ–ï¼Œå¤±è´¥å›æ»š |

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.1  
**æœ€åæ›´æ–°**: 2026-01-04  
**ä½œè€…**: AI Assistant  
**æ›´æ–°å†…å®¹**: æ ¹æ®TDD-00028-å®¡æŸ¥æŠ¥å‘Š.mdä¿®å¤INT-001~INT-004é›†æˆç‚¹é—®é¢˜ï¼Œè¡¥å……SSEé‡è¿ç­–ç•¥å’Œå¤šæ¨¡å‹å…¼å®¹æ€§è¯´æ˜
