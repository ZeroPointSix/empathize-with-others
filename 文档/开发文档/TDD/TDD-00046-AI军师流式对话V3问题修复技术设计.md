# TDD-00046: AI军师流式对话V3问题修复技术设计

**创建日期**: 2026-01-05
**关联BUG**: BUG-00046
**关联文档**: BUG-00044, BUG-00045, FD-00028
**状态**: ✅ 实现完成
**最后更新**: 2026-01-05
**修复版本**: v1.0.0-BUG046

---

## 1. 设计目标

修复AI军师流式对话功能在第三次人工测试中发现的问题，确保：
1. 流式响应完成后内容正确保持
2. 会话状态管理正确，不发生意外跳转
3. 重新生成功能正常工作
4. 滚动行为符合用户预期

---

## 2. 技术方案

### 2.1 会话状态管理重构

#### 2.1.1 问题分析

当前问题的根本原因是会话状态管理存在竞态条件：
1. 多个Flow收集器同时运行
2. 流式完成后的延迟清空与conversations更新存在时序问题
3. `loadSessions`方法总是选择第一个会话

#### 2.1.2 解决方案

**方案A: 引入会话锁定机制**

```kotlin
data class AiAdvisorChatUiState(
    // ... 现有字段
    val isSessionLocked: Boolean = false,  // 新增：会话锁定标志
    val lockedSessionId: String? = null    // 新增：锁定的会话ID
)
```

**方案B: 使用单一Flow收集器（推荐）**

```kotlin
class AiAdvisorChatViewModel {
    private var conversationsJob: Job? = null
    
    private fun loadConversations(sessionId: String) {
        // 取消之前的收集器
        conversationsJob?.cancel()
        
        conversationsJob = viewModelScope.launch {
            getAdvisorConversationsUseCase(sessionId).collect { conversations ->
                // 验证sessionId仍然匹配
                if (_uiState.value.currentSessionId == sessionId) {
                    _uiState.update { it.copy(conversations = conversations) }
                }
            }
        }
    }
}
```

### 2.2 流式完成状态处理优化

#### 2.2.1 当前问题

```kotlin
// 当前实现
is StreamingState.Completed -> {
    _uiState.update { ... }
    
    viewModelScope.launch {
        delay(800)  // 问题：这个延迟期间可能发生状态变化
        _uiState.update { ... }
    }
}
```

#### 2.2.2 优化方案

```kotlin
is StreamingState.Completed -> {
    val completedSessionId = _uiState.value.currentSessionId
    val completedMessageId = state.messageId
    
    _uiState.update {
        it.copy(
            isStreaming = false,
            streamingContent = state.fullText,
            thinkingContent = "",
            thinkingElapsedMs = 0,
            lastTokenUsage = state.usage
        )
    }
    
    viewModelScope.launch {
        delay(800)
        // 只有当会话未变化时才清空
        val currentState = _uiState.value
        if (currentState.currentSessionId == completedSessionId &&
            currentState.currentStreamingMessageId == completedMessageId) {
            _uiState.update {
                it.copy(
                    streamingContent = "",
                    currentStreamingMessageId = null
                )
            }
        }
    }
}
```

### 2.3 重新生成逻辑修复

#### 2.3.1 当前问题

删除操作和重新生成操作之间存在竞态条件。

#### 2.3.2 优化方案

```kotlin
fun regenerateLastMessage() {
    val conversations = _uiState.value.conversations
    val lastAiMessage = conversations.lastOrNull { it.messageType == MessageType.AI }
    val lastUserMessage = conversations.lastOrNull { it.messageType == MessageType.USER }
    val sessionId = _uiState.value.currentSessionId ?: return

    if (lastAiMessage != null && lastUserMessage != null) {
        viewModelScope.launch {
            // 1. 设置重新生成状态，防止UI显示旧消息
            _uiState.update { it.copy(isRegenerating = true) }
            
            // 2. 删除最后一条AI消息
            val deleteResult = deleteAdvisorConversationUseCase(lastAiMessage.id)
            
            if (deleteResult.isSuccess) {
                // 3. 等待Flow更新
                delay(100)
                
                // 4. 开始重新生成
                regenerateStreaming(lastUserMessage.content, sessionId)
            } else {
                _uiState.update { 
                    it.copy(
                        isRegenerating = false,
                        error = "删除消息失败，请重试"
                    ) 
                }
            }
        }
    }
}
```

### 2.4 滚动行为优化

#### 2.4.1 当前问题

滚动逻辑依赖`streamingContent`变化，导致频繁触发。

#### 2.4.2 优化方案

```kotlin
// 分离滚动逻辑
@Composable
fun AiAdvisorChatScreen(...) {
    // 用户滚动状态追踪
    var userHasScrolled by remember { mutableStateOf(false) }
    
    // 检测用户滚动
    LaunchedEffect(listState.isScrollInProgress) {
        if (listState.isScrollInProgress) {
            userHasScrolled = true
        }
    }
    
    // 新消息到达时的滚动
    LaunchedEffect(uiState.conversations.size) {
        if (!userHasScrolled && uiState.conversations.isNotEmpty()) {
            listState.animateScrollToItem(uiState.conversations.size - 1)
        }
    }
    
    // 流式开始时重置滚动状态
    LaunchedEffect(uiState.isStreaming) {
        if (uiState.isStreaming) {
            userHasScrolled = false
            listState.animateScrollToItem(uiState.conversations.size)
        }
    }
}
```

---

## 3. 数据流设计

### 3.1 正常对话流程

```
用户发送消息
    ↓
sendMessageStreaming()
    ├── 取消旧的streamingJob
    ├── 更新UI状态(isStreaming=true)
    └── 启动新的streamingJob
        ↓
StreamingState.Started
    └── 更新currentStreamingMessageId
        ↓
StreamingState.TextUpdate (多次)
    └── 更新streamingContent
        ↓
StreamingState.Completed
    ├── 更新isStreaming=false
    ├── 保持streamingContent
    └── 延迟清空(带会话ID验证)
        ↓
conversations Flow更新
    └── UI显示完整消息
```

### 3.2 重新生成流程

```
用户点击重新生成
    ↓
regenerateLastMessage()
    ├── 设置isRegenerating=true
    ├── 删除最后一条AI消息
    ├── 等待删除完成
    └── 调用regenerateStreaming()
        ↓
regenerateStreaming()
    ├── 取消旧的streamingJob
    ├── 更新UI状态
    └── 调用UseCase(skipUserMessage=true)
        ↓
正常流式响应流程
```

### 3.3 会话切换流程

```
用户切换会话
    ↓
switchSession()
    ├── 停止当前流式响应
    ├── 取消conversationsJob
    ├── 更新currentSessionId
    └── 启动新的loadConversations()
        ↓
新会话的conversations Flow
    └── 更新UI
```

---

## 4. 接口变更

### 4.1 AiAdvisorChatUiState

```kotlin
data class AiAdvisorChatUiState(
    // 现有字段...
    
    // 新增字段
    val isRegenerating: Boolean = false,  // 是否正在重新生成
)
```

### 4.2 AiAdvisorRepository

```kotlin
interface AiAdvisorRepository {
    // 现有方法...
    
    // 确保这些方法返回Result
    suspend fun updateMessageContentAndStatus(
        messageId: String,
        content: String,
        status: SendStatus
    ): Result<Unit>
    
    suspend fun deleteMessage(messageId: String): Result<Unit>
}
```

---

## 5. 测试用例设计

### 5.1 单元测试

#### 5.1.1 AiAdvisorChatViewModelTest

```kotlin
class AiAdvisorChatViewModelTest {
    
    @Test
    fun `流式完成后内容保持直到conversations更新`() {
        // Given
        val viewModel = createViewModel()
        
        // When
        viewModel.simulateStreamingCompleted("测试内容")
        
        // Then
        assertEquals("测试内容", viewModel.uiState.value.streamingContent)
        assertFalse(viewModel.uiState.value.isStreaming)
    }
    
    @Test
    fun `会话切换时停止当前流式响应`() {
        // Given
        val viewModel = createViewModel()
        viewModel.startStreaming()
        
        // When
        viewModel.switchSession("new-session-id")
        
        // Then
        assertFalse(viewModel.uiState.value.isStreaming)
        assertEquals("", viewModel.uiState.value.streamingContent)
    }
    
    @Test
    fun `重新生成不创建重复用户消息`() {
        // Given
        val viewModel = createViewModel()
        viewModel.addConversation(userMessage)
        viewModel.addConversation(aiMessage)
        
        // When
        viewModel.regenerateLastMessage()
        
        // Then
        verify(sendAdvisorMessageStreamingUseCase).invoke(
            any(), any(), any(), skipUserMessage = true
        )
    }
    
    @Test
    fun `延迟清空时验证会话ID`() {
        // Given
        val viewModel = createViewModel()
        viewModel.setCurrentSession("session-1")
        
        // When
        viewModel.simulateStreamingCompleted("内容")
        viewModel.switchSession("session-2")
        advanceTimeBy(1000)
        
        // Then
        // streamingContent应该被清空，因为会话已切换
        assertEquals("", viewModel.uiState.value.streamingContent)
    }
}
```

### 5.2 集成测试

```kotlin
class AiAdvisorChatIntegrationTest {
    
    @Test
    fun `完整对话流程测试`() {
        // 1. 发送消息
        // 2. 验证流式响应
        // 3. 验证完成后内容保持
        // 4. 验证conversations更新
    }
    
    @Test
    fun `多会话切换测试`() {
        // 1. 创建多个会话
        // 2. 在会话B发送消息
        // 3. 验证不跳转到会话A
    }
}
```

---

## 6. 实现计划

### 6.1 任务分解

| 任务ID | 任务描述 | 预计工时 | 依赖 |
|--------|----------|----------|------|
| T1 | 重构会话状态管理 | 1.5h | 无 |
| T2 | 优化流式完成处理 | 1h | T1 |
| T3 | 修复重新生成逻辑 | 1h | T1 |
| T4 | 优化滚动行为 | 0.5h | 无 |
| T5 | 修复停止生成逻辑 | 0.5h | T1 |
| T6 | 添加日志和调试 | 0.5h | 无 |
| T7 | 编写单元测试 | 1.5h | T1-T5 |
| T8 | 集成测试验证 | 0.5h | T7 |

### 6.2 实现顺序

1. T1 → T2 → T3 → T5 (核心逻辑修复)
2. T4 (滚动优化)
3. T6 (调试支持)
4. T7 → T8 (测试验证)

---

## 7. 风险评估

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 状态管理改动影响其他功能 | 中 | 高 | 完整回归测试 |
| Flow收集器取消时机不当 | 低 | 中 | 添加日志监控 |
| 延迟清空时间不够 | 低 | 低 | 可配置延迟时间 |

---

## 8. 相关文档

- [BUG-00046-AI军师流式对话V3问题系统性分析](../BUG/BUG-00046-AI军师流式对话V3问题系统性分析.md)
- [FD-00028-AI军师流式对话升级功能设计](../FD/FD-00028-AI军师流式对话升级功能设计.md)
- [TDD-00028-AI军师流式对话升级技术设计](./TDD-00028-AI军师流式对话升级技术设计.md)

---

**文档版本**: v1.0
**创建日期**: 2026-01-05
**最后更新**: 2026-01-05


---

## 9. 实现记录

### 9.1 实现日期
2026-01-05

### 9.2 修改文件清单

| 文件路径 | 修改类型 | 修改内容 |
|----------|----------|----------|
| `presentation/.../AiAdvisorChatViewModel.kt` | 修改 | 会话状态管理重构、流式完成处理优化、重新生成逻辑修复 |
| `presentation/.../AiAdvisorChatScreen.kt` | 修改 | 滚动逻辑优化 |

### 9.3 核心修改点

#### 9.3.1 AiAdvisorChatViewModel.kt

1. **新增字段**:
   - `conversationsJob: Job?` - 管理Flow收集器，避免多个收集器冲突
   - `TAG` 常量 - 用于日志
   - `isRegenerating` 状态 - 标记重新生成中

2. **loadSessions() 方法修改**:
   - 保持当前会话ID，避免自动跳转到第一个会话

3. **loadConversations() 方法修改**:
   - 使用单一Flow收集器
   - 取消之前的收集器
   - 验证sessionId匹配

4. **StreamingState.Completed 处理修改**:
   - 记录完成时的会话ID和消息ID
   - 延迟清空时验证会话未变化

5. **regenerateLastMessage() 方法修改**:
   - 添加 `isRegenerating` 状态
   - 等待删除完成后再重新生成

6. **stopGeneration() 方法修改**:
   - 增强错误处理

7. **switchSession() 方法修改**:
   - 取消conversations收集器
   - 清空当前对话

#### 9.3.2 AiAdvisorChatScreen.kt

1. **滚动逻辑优化**:
   - 分离为两个 `LaunchedEffect`
   - 一个监听 `conversations.size`
   - 一个监听 `isStreaming`

### 9.4 编译验证

```
✅ :presentation:compileDebugKotlin - 成功
✅ assembleDebug - 成功
```

### 9.5 待人工验证

修复完成后需要人工验证以下测试用例：

- [ ] P0-V3-001: AI回复完成后内容保持显示，不消失
- [ ] P0-V3-002: 重新生成时只有一个AI消息框
- [ ] P0-V3-003: 发送消息后停留在当前会话
- [ ] P1-V3-001: 滚动查看历史时不自动跳回
- [ ] P1-V3-002: 停止生成后显示已生成内容或删除空消息
- [ ] P1-V3-003: 重新生成按钮点击有响应

---

**文档版本**: v1.1
**最后更新**: 2026-01-05
