# TE-00028-V7-BUG-00048-V3测试用例

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档编号 | TE-00028-V7 |
| 创建日期 | 2026-01-05 |
| 关联BUG | BUG-00048 V3 |
| 关联任务 | TD-00028 AI军师流式对话功能 |
| 测试类型 | 单元测试 + 人工测试 |

---

## 1. 测试目标

验证BUG-00048 V3修复后，终止AI生成后点击重新生成时：
1. 不会将被停止的内容当作用户消息显示
2. 使用正确的用户输入进行重新生成
3. 各种边界场景下都能正常工作

---

## 2. 单元测试用例

### 2.1 RegenerateLastMessageTest.kt

```kotlin
package com.empathy.ai.presentation.viewmodel

import com.empathy.ai.domain.model.AiAdvisorConversation
import com.empathy.ai.domain.model.MessageType
import com.empathy.ai.domain.model.SendStatus
import io.mockk.*
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

/**
 * BUG-00048 V3 修复验证测试
 * 
 * 测试场景：终止AI生成后点击重新生成
 */
@OptIn(ExperimentalCoroutinesApi::class)
class RegenerateLastMessageTest {

    private lateinit var viewModel: AiAdvisorChatViewModel
    // ... mock dependencies

    @Before
    fun setup() {
        // 初始化mock对象
    }

    /**
     * 测试用例 TC-001: 正常重新生成
     * 
     * 场景：用户发送消息 → AI回复完成 → 点击重新生成
     * 预期：使用原始用户输入重新生成
     */
    @Test
    fun `regenerateLastMessage should use correct user input when lastUserInput is available`() = runTest {
        // Given: 有lastUserInput
        val userInput = "你好，请帮我分析一下"
        val aiMessage = createAiMessage("ai-1", "这是AI的回复", SendStatus.SUCCESS)
        
        // 设置初始状态
        // viewModel._uiState.update { it.copy(lastUserInput = userInput, conversations = listOf(userMessage, aiMessage)) }
        
        // When: 调用重新生成
        // viewModel.regenerateLastMessage()
        
        // Then: 验证使用了正确的用户输入
        // verify { sendAdvisorMessageStreamingUseCase(any(), any(), userInput, skipUserMessage = true) }
    }

    /**
     * 测试用例 TC-002: lastUserInput为空时的回退逻辑
     * 
     * 场景：应用重启后，lastUserInput为空
     * 预期：从conversations中查找最后一条用户消息
     */
    @Test
    fun `regenerateLastMessage should fallback to conversations when lastUserInput is empty`() = runTest {
        // Given: lastUserInput为空，但conversations中有用户消息
        val userMessage = createUserMessage("user-1", "原始用户输入", SendStatus.SUCCESS, timestamp = 1000)
        val aiMessage = createAiMessage("ai-1", "[用户已停止生成]", SendStatus.CANCELLED, timestamp = 2000)
        
        // 设置初始状态：lastUserInput为空
        // viewModel._uiState.update { it.copy(lastUserInput = "", conversations = listOf(userMessage, aiMessage)) }
        
        // When: 调用重新生成
        // viewModel.regenerateLastMessage()
        
        // Then: 验证使用了conversations中的用户消息
        // verify { sendAdvisorMessageStreamingUseCase(any(), any(), "原始用户输入", skipUserMessage = true) }
    }

    /**
     * 测试用例 TC-003: 终止后重新生成（核心场景）
     * 
     * 场景：用户发送消息 → AI开始回复 → 点击停止 → 点击重新生成
     * 预期：
     * 1. 被停止的AI消息被删除
     * 2. 使用原始用户输入重新生成
     * 3. 不出现新的用户消息
     */
    @Test
    fun `regenerateLastMessage after stop should use original user input not cancelled content`() = runTest {
        // Given: 用户消息和被停止的AI消息
        val userMessage = createUserMessage("user-1", "请帮我分析", SendStatus.SUCCESS, timestamp = 1000)
        val cancelledAiMessage = createAiMessage("ai-1", "[用户已停止生成]", SendStatus.CANCELLED, timestamp = 2000)
        
        // 设置初始状态
        // viewModel._uiState.update { 
        //     it.copy(
        //         lastUserInput = "请帮我分析",
        //         conversations = listOf(userMessage, cancelledAiMessage)
        //     ) 
        // }
        
        // When: 调用重新生成
        // viewModel.regenerateLastMessage()
        
        // Then: 
        // 1. 验证删除了被停止的AI消息
        // verify { deleteAdvisorConversationUseCase("ai-1") }
        
        // 2. 验证使用了原始用户输入，而不是"[用户已停止生成]"
        // verify { sendAdvisorMessageStreamingUseCase(any(), any(), "请帮我分析", skipUserMessage = true) }
        
        // 3. 验证没有创建新的用户消息
        // verify(exactly = 0) { aiAdvisorRepository.insertConversation(match { it.messageType == MessageType.USER }) }
    }

    /**
     * 测试用例 TC-004: 多轮对话后重新生成
     * 
     * 场景：消息1 → AI回复1 → 消息2 → AI开始回复2 → 停止 → 重新生成
     * 预期：使用消息2的内容重新生成，而不是消息1
     */
    @Test
    fun `regenerateLastMessage should use the most recent user message before AI message`() = runTest {
        // Given: 多轮对话
        val userMessage1 = createUserMessage("user-1", "第一个问题", SendStatus.SUCCESS, timestamp = 1000)
        val aiMessage1 = createAiMessage("ai-1", "第一个回答", SendStatus.SUCCESS, timestamp = 2000)
        val userMessage2 = createUserMessage("user-2", "第二个问题", SendStatus.SUCCESS, timestamp = 3000)
        val cancelledAiMessage = createAiMessage("ai-2", "[用户已停止生成]", SendStatus.CANCELLED, timestamp = 4000)
        
        // 设置初始状态
        // viewModel._uiState.update { 
        //     it.copy(
        //         lastUserInput = "第二个问题",
        //         conversations = listOf(userMessage1, aiMessage1, userMessage2, cancelledAiMessage)
        //     ) 
        // }
        
        // When: 调用重新生成
        // viewModel.regenerateLastMessage()
        
        // Then: 验证使用了"第二个问题"，而不是"第一个问题"
        // verify { sendAdvisorMessageStreamingUseCase(any(), any(), "第二个问题", skipUserMessage = true) }
    }

    /**
     * 测试用例 TC-005: 时间戳排序验证
     * 
     * 场景：conversations列表顺序与时间戳不一致
     * 预期：按时间戳找到正确的消息
     */
    @Test
    fun `regenerateLastMessage should find messages by timestamp not list order`() = runTest {
        // Given: 列表顺序与时间戳不一致（模拟并发插入场景）
        val aiMessage = createAiMessage("ai-1", "[用户已停止生成]", SendStatus.CANCELLED, timestamp = 2000)
        val userMessage = createUserMessage("user-1", "正确的用户输入", SendStatus.SUCCESS, timestamp = 1000)
        
        // 注意：列表顺序是 [aiMessage, userMessage]，但时间戳顺序是 userMessage 在前
        // viewModel._uiState.update { 
        //     it.copy(
        //         lastUserInput = "",  // 强制使用回退逻辑
        //         conversations = listOf(aiMessage, userMessage)  // 故意打乱顺序
        //     ) 
        // }
        
        // When: 调用重新生成
        // viewModel.regenerateLastMessage()
        
        // Then: 验证使用了正确的用户输入（按时间戳查找）
        // verify { sendAdvisorMessageStreamingUseCase(any(), any(), "正确的用户输入", skipUserMessage = true) }
    }

    /**
     * 测试用例 TC-006: 用户消息必须在AI消息之前
     * 
     * 场景：验证查找用户消息时的时间戳约束
     * 预期：只查找AI消息之前的用户消息
     */
    @Test
    fun `regenerateLastMessage should only find user messages before AI message`() = runTest {
        // Given: 用户消息在AI消息之后（异常场景）
        val aiMessage = createAiMessage("ai-1", "[用户已停止生成]", SendStatus.CANCELLED, timestamp = 1000)
        val userMessage = createUserMessage("user-1", "这是后来的用户消息", SendStatus.SUCCESS, timestamp = 2000)
        val earlierUserMessage = createUserMessage("user-0", "这是正确的用户消息", SendStatus.SUCCESS, timestamp = 500)
        
        // viewModel._uiState.update { 
        //     it.copy(
        //         lastUserInput = "",
        //         conversations = listOf(earlierUserMessage, aiMessage, userMessage)
        //     ) 
        // }
        
        // When: 调用重新生成
        // viewModel.regenerateLastMessage()
        
        // Then: 验证使用了AI消息之前的用户消息
        // verify { sendAdvisorMessageStreamingUseCase(any(), any(), "这是正确的用户消息", skipUserMessage = true) }
    }

    /**
     * 测试用例 TC-007: 没有用户消息时的错误处理
     * 
     * 场景：conversations中没有用户消息
     * 预期：显示错误提示
     */
    @Test
    fun `regenerateLastMessage should show error when no user message found`() = runTest {
        // Given: 只有AI消息，没有用户消息
        val aiMessage = createAiMessage("ai-1", "[用户已停止生成]", SendStatus.CANCELLED)
        
        // viewModel._uiState.update { 
        //     it.copy(
        //         lastUserInput = "",
        //         conversations = listOf(aiMessage)
        //     ) 
        // }
        
        // When: 调用重新生成
        // viewModel.regenerateLastMessage()
        
        // Then: 验证显示错误提示
        // assertEquals("未找到有效的用户消息，无法重新生成", viewModel.uiState.value.error)
    }

    /**
     * 测试用例 TC-008: 没有AI消息时的错误处理
     * 
     * 场景：conversations中没有AI消息
     * 预期：显示错误提示
     */
    @Test
    fun `regenerateLastMessage should show error when no AI message found`() = runTest {
        // Given: 只有用户消息，没有AI消息
        val userMessage = createUserMessage("user-1", "用户输入", SendStatus.SUCCESS)
        
        // viewModel._uiState.update { 
        //     it.copy(
        //         lastUserInput = "用户输入",
        //         conversations = listOf(userMessage)
        //     ) 
        // }
        
        // When: 调用重新生成
        // viewModel.regenerateLastMessage()
        
        // Then: 验证显示错误提示
        // assertEquals("未找到AI消息，无法重新生成", viewModel.uiState.value.error)
    }

    // Helper functions
    private fun createUserMessage(
        id: String, 
        content: String, 
        status: SendStatus,
        timestamp: Long = System.currentTimeMillis()
    ): AiAdvisorConversation {
        return AiAdvisorConversation(
            id = id,
            contactId = "contact-1",
            sessionId = "session-1",
            messageType = MessageType.USER,
            content = content,
            timestamp = timestamp,
            sendStatus = status
        )
    }

    private fun createAiMessage(
        id: String, 
        content: String, 
        status: SendStatus,
        timestamp: Long = System.currentTimeMillis()
    ): AiAdvisorConversation {
        return AiAdvisorConversation(
            id = id,
            contactId = "contact-1",
            sessionId = "session-1",
            messageType = MessageType.AI,
            content = content,
            timestamp = timestamp,
            sendStatus = status
        )
    }
}
```

---

## 3. 人工测试用例

### 3.1 基础功能测试

| 测试ID | 测试场景 | 操作步骤 | 预期结果 | 实际结果 | 状态 |
|--------|----------|----------|----------|----------|------|
| MT-001 | 正常发送和回复 | 1. 打开AI军师对话<br>2. 发送消息"你好"<br>3. 等待AI回复完成 | AI回复显示在左侧（白色气泡） | | ⬜ |
| MT-002 | 正常重新生成 | 1. 完成MT-001<br>2. 点击"重新生成"按钮 | 1. 原AI回复被删除<br>2. 新AI回复正常生成<br>3. 用户消息不变 | | ⬜ |

### 3.2 核心场景测试（BUG-00048 V3）

| 测试ID | 测试场景 | 操作步骤 | 预期结果 | 实际结果 | 状态 |
|--------|----------|----------|----------|----------|------|
| MT-003 | 终止后重新生成 | 1. 发送消息"请帮我分析"<br>2. AI开始回复时点击"停止"<br>3. 确认显示"[用户已停止生成]"<br>4. 点击"重新生成" | 1. 被停止的消息被删除<br>2. 使用"请帮我分析"重新生成<br>3. **不出现新的用户消息**<br>4. 新AI回复正常显示 | | ⬜ |
| MT-004 | 终止后消息类型验证 | 1. 完成MT-003的步骤1-3<br>2. 观察"[用户已停止生成]"消息 | 该消息显示为AI消息（白色气泡，左侧），**不是**用户消息（蓝色气泡，右侧） | | ⬜ |
| MT-005 | 快速停止后重新生成 | 1. 发送消息<br>2. 立即点击"停止"（AI刚开始回复）<br>3. 点击"重新生成" | 1. 不出现状态混乱<br>2. 正常重新生成 | | ⬜ |

### 3.3 边界场景测试

| 测试ID | 测试场景 | 操作步骤 | 预期结果 | 实际结果 | 状态 |
|--------|----------|----------|----------|----------|------|
| MT-006 | 多轮对话后重新生成 | 1. 发送消息1"第一个问题"<br>2. 等待AI回复完成<br>3. 发送消息2"第二个问题"<br>4. AI开始回复时点击"停止"<br>5. 点击"重新生成" | 使用"第二个问题"重新生成，**不是**"第一个问题" | | ⬜ |
| MT-007 | 应用重启后重新生成 | 1. 发送消息<br>2. AI开始回复时点击"停止"<br>3. 关闭应用并重新打开<br>4. 进入同一对话<br>5. 点击"重新生成" | 即使应用重启，也能正确找到用户消息并重新生成 | | ⬜ |
| MT-008 | 连续停止和重新生成 | 1. 发送消息<br>2. 停止 → 重新生成 → 停止 → 重新生成<br>3. 重复3次 | 每次都能正确重新生成，不出现消息角色错误 | | ⬜ |

### 3.4 异常场景测试

| 测试ID | 测试场景 | 操作步骤 | 预期结果 | 实际结果 | 状态 |
|--------|----------|----------|----------|----------|------|
| MT-009 | 网络断开时重新生成 | 1. 发送消息并停止<br>2. 断开网络<br>3. 点击"重新生成" | 显示网络错误提示，不出现消息角色错误 | | ⬜ |
| MT-010 | 切换会话后重新生成 | 1. 在会话A发送消息并停止<br>2. 切换到会话B<br>3. 切换回会话A<br>4. 点击"重新生成" | 正确使用会话A的用户消息重新生成 | | ⬜ |

---

## 4. 测试环境

- **设备**: Android 模拟器 / 真机
- **系统版本**: Android 7.0+ (API 24+)
- **网络**: WiFi / 4G
- **AI服务商**: DeepSeek / OpenAI

---

## 5. 测试结果汇总

| 测试类型 | 总数 | 通过 | 失败 | 阻塞 |
|----------|------|------|------|------|
| 单元测试 | 8 | - | - | - |
| 人工测试 | 10 | - | - | - |
| **总计** | **18** | **-** | **-** | **-** |

---

## 6. 问题记录

| 问题ID | 发现日期 | 测试用例 | 问题描述 | 严重程度 | 状态 |
|--------|----------|----------|----------|----------|------|
| - | - | - | - | - | - |

---

**文档版本**: 1.0
**创建日期**: 2026-01-05
**测试状态**: ⬜ 待执行
