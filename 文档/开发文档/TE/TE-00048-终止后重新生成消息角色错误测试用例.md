# TE-00048-终止后重新生成消息角色错误测试用例

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档编号 | TE-00048 |
| 创建日期 | 2026-01-05 |
| 关联BUG | BUG-00048 |
| 测试类型 | 单元测试 + 集成测试 |
| 状态 | ✅ 已实现 |

---

## 1. 测试范围

### 1.1 测试目标
验证BUG-00048修复后，终止AI回复后重新生成功能正常工作，消息角色显示正确。

### 1.2 测试模块
- `AiAdvisorChatViewModel` - 核心业务逻辑
- `SendAdvisorMessageStreamingUseCase` - 流式消息发送
- `AiAdvisorChatScreen` - UI渲染

---

## 2. 单元测试用例

### 2.1 AiAdvisorChatViewModelTest

#### TC-001: 正常重新生成使用正确的用户输入
```kotlin
@Test
fun `regenerateLastMessage should use correct user message content`() = runTest {
    // Given: 存在用户消息和AI消息
    val userMessage = createConversation(
        id = "user-1",
        messageType = MessageType.USER,
        content = "你好，请帮我分析",
        sendStatus = SendStatus.SUCCESS
    )
    val aiMessage = createConversation(
        id = "ai-1",
        messageType = MessageType.AI,
        content = "您好，我来帮您分析...",
        sendStatus = SendStatus.SUCCESS
    )
    viewModel.setConversations(listOf(userMessage, aiMessage))
    
    // When: 调用重新生成
    viewModel.regenerateLastMessage()
    advanceUntilIdle()
    
    // Then: 验证使用正确的用户输入
    verify(sendAdvisorMessageStreamingUseCase).invoke(
        contactId = any(),
        sessionId = any(),
        userMessage = eq("你好，请帮我分析"),
        skipUserMessage = eq(true)
    )
}
```

#### TC-002: 终止后重新生成使用原始用户输入
```kotlin
@Test
fun `regenerateLastMessage after stop should use original user input`() = runTest {
    // Given: 用户发送消息后AI被终止
    val userMessage = createConversation(
        id = "user-1",
        messageType = MessageType.USER,
        content = "请分析这段对话",
        sendStatus = SendStatus.SUCCESS
    )
    val cancelledAiMessage = createConversation(
        id = "ai-1",
        messageType = MessageType.AI,
        content = "好的，我来分析...[用户已停止生成]",
        sendStatus = SendStatus.CANCELLED
    )
    viewModel.setConversations(listOf(userMessage, cancelledAiMessage))
    
    // When: 调用重新生成
    viewModel.regenerateLastMessage()
    advanceUntilIdle()
    
    // Then: 验证使用原始用户输入，而不是被终止的AI内容
    verify(sendAdvisorMessageStreamingUseCase).invoke(
        contactId = any(),
        sessionId = any(),
        userMessage = eq("请分析这段对话"),
        skipUserMessage = eq(true)
    )
}
```

#### TC-003: lastUserInput状态正确记录
```kotlin
@Test
fun `sendMessage should record lastUserInput`() = runTest {
    // Given: 初始状态
    val initialState = viewModel.uiState.value
    assertEquals("", initialState.lastUserInput)
    
    // When: 发送消息
    viewModel.updateInput("测试消息内容")
    viewModel.sendMessage()
    advanceUntilIdle()
    
    // Then: lastUserInput被正确记录
    val updatedState = viewModel.uiState.value
    assertEquals("测试消息内容", updatedState.lastUserInput)
}
```

#### TC-004: 重新生成优先使用lastUserInput
```kotlin
@Test
fun `regenerateLastMessage should prefer lastUserInput over conversation lookup`() = runTest {
    // Given: lastUserInput已记录，但conversations可能有延迟
    viewModel.setLastUserInput("原始用户输入")
    
    // 模拟conversations列表可能的延迟状态
    val delayedConversations = listOf(
        createConversation(
            id = "ai-1",
            messageType = MessageType.AI,
            content = "AI回复内容",
            sendStatus = SendStatus.CANCELLED
        )
    )
    viewModel.setConversations(delayedConversations)
    
    // When: 调用重新生成
    viewModel.regenerateLastMessage()
    advanceUntilIdle()
    
    // Then: 使用lastUserInput而不是从conversations查找
    verify(sendAdvisorMessageStreamingUseCase).invoke(
        contactId = any(),
        sessionId = any(),
        userMessage = eq("原始用户输入"),
        skipUserMessage = eq(true)
    )
}
```

#### TC-005: 停止生成不影响lastUserInput
```kotlin
@Test
fun `stopGeneration should not modify lastUserInput`() = runTest {
    // Given: 已发送消息并记录lastUserInput
    viewModel.setLastUserInput("用户的问题")
    viewModel.setStreamingState(isStreaming = true, messageId = "ai-1")
    
    // When: 停止生成
    viewModel.stopGeneration()
    advanceUntilIdle()
    
    // Then: lastUserInput保持不变
    assertEquals("用户的问题", viewModel.uiState.value.lastUserInput)
}
```

#### TC-006: 空lastUserInput时的错误处理
```kotlin
@Test
fun `regenerateLastMessage should show error when lastUserInput is empty`() = runTest {
    // Given: lastUserInput为空
    viewModel.setLastUserInput("")
    viewModel.setConversations(emptyList())
    
    // When: 调用重新生成
    viewModel.regenerateLastMessage()
    advanceUntilIdle()
    
    // Then: 显示错误提示
    val state = viewModel.uiState.value
    assertNotNull(state.error)
    assertTrue(state.error!!.contains("未找到") || state.error!!.contains("用户"))
}
```

#### TC-007: 快速连续操作的状态一致性
```kotlin
@Test
fun `rapid stop and regenerate should maintain correct state`() = runTest {
    // Given: 正在流式响应
    viewModel.setLastUserInput("用户问题")
    viewModel.setStreamingState(isStreaming = true, messageId = "ai-1")
    
    // When: 快速停止并重新生成
    viewModel.stopGeneration()
    // 不等待，立即重新生成
    viewModel.regenerateLastMessage()
    advanceUntilIdle()
    
    // Then: 状态正确，使用正确的用户输入
    verify(sendAdvisorMessageStreamingUseCase).invoke(
        contactId = any(),
        sessionId = any(),
        userMessage = eq("用户问题"),
        skipUserMessage = eq(true)
    )
}
```

### 2.2 消息类型验证测试

#### TC-008: 验证消息类型判断逻辑
```kotlin
@Test
fun `findLastUserMessage should correctly identify user messages`() = runTest {
    // Given: 混合的消息列表
    val conversations = listOf(
        createConversation("u1", MessageType.USER, "用户消息1", SendStatus.SUCCESS),
        createConversation("a1", MessageType.AI, "AI回复1", SendStatus.SUCCESS),
        createConversation("u2", MessageType.USER, "用户消息2", SendStatus.SUCCESS),
        createConversation("a2", MessageType.AI, "AI回复2", SendStatus.CANCELLED)
    )
    
    // When: 查找最后一条用户消息
    val lastUserMessage = conversations.lastOrNull { 
        it.messageType == MessageType.USER && 
        it.sendStatus == SendStatus.SUCCESS 
    }
    
    // Then: 正确找到最后一条用户消息
    assertNotNull(lastUserMessage)
    assertEquals("u2", lastUserMessage.id)
    assertEquals("用户消息2", lastUserMessage.content)
}
```

#### TC-009: 验证CANCELLED状态的AI消息不被误判
```kotlin
@Test
fun `cancelled AI message should not be treated as user message`() = runTest {
    // Given: 包含CANCELLED状态AI消息的列表
    val conversations = listOf(
        createConversation("u1", MessageType.USER, "用户问题", SendStatus.SUCCESS),
        createConversation("a1", MessageType.AI, "被终止的内容[用户已停止生成]", SendStatus.CANCELLED)
    )
    viewModel.setConversations(conversations)
    viewModel.setLastUserInput("用户问题")
    
    // When: 重新生成
    viewModel.regenerateLastMessage()
    advanceUntilIdle()
    
    // Then: 使用的是用户消息内容，不是AI消息内容
    verify(sendAdvisorMessageStreamingUseCase).invoke(
        contactId = any(),
        sessionId = any(),
        userMessage = eq("用户问题"),
        skipUserMessage = eq(true)
    )
}
```

---

## 3. 集成测试用例

### 3.1 端到端流程测试

#### TC-010: 完整的终止-重新生成流程
```kotlin
@Test
fun `complete stop and regenerate flow should work correctly`() = runTest {
    // Given: 初始化ViewModel和依赖
    val viewModel = createViewModelWithRealDependencies()
    
    // Step 1: 发送消息
    viewModel.updateInput("请帮我分析这段对话")
    viewModel.sendMessage()
    advanceTimeBy(100)
    
    // Step 2: 等待AI开始回复
    assertTrue(viewModel.uiState.value.isStreaming)
    
    // Step 3: 停止生成
    viewModel.stopGeneration()
    advanceTimeBy(500)
    
    // Step 4: 验证停止后的状态
    assertFalse(viewModel.uiState.value.isStreaming)
    
    // Step 5: 重新生成
    viewModel.regenerateLastMessage()
    advanceTimeBy(500)
    
    // Step 6: 验证重新生成使用正确的输入
    assertTrue(viewModel.uiState.value.isStreaming || viewModel.uiState.value.isRegenerating)
    
    // Step 7: 验证消息角色正确
    val conversations = viewModel.uiState.value.conversations
    val userMessages = conversations.filter { it.messageType == MessageType.USER }
    val aiMessages = conversations.filter { it.messageType == MessageType.AI }
    
    // 用户消息应该只有一条
    assertEquals(1, userMessages.size)
    assertEquals("请帮我分析这段对话", userMessages.first().content)
}
```

### 3.2 UI渲染测试

#### TC-011: 消息气泡角色显示正确
```kotlin
@Test
fun `message bubbles should display correct roles after regenerate`() {
    // Given: 设置测试数据
    val conversations = listOf(
        createConversation("u1", MessageType.USER, "用户问题", SendStatus.SUCCESS),
        createConversation("a1", MessageType.AI, "AI回复", SendStatus.SUCCESS)
    )
    
    composeTestRule.setContent {
        AiAdvisorChatScreenContent(
            uiState = AiAdvisorChatUiState(conversations = conversations),
            // ... 其他参数
        )
    }
    
    // Then: 验证用户消息显示在右侧
    composeTestRule.onNodeWithText("用户问题")
        .assertExists()
    
    // Then: 验证AI消息显示在左侧（带AI头像）
    composeTestRule.onNodeWithText("AI回复")
        .assertExists()
}
```

---

## 4. 边界情况测试

### 4.1 异常情况

#### TC-012: 网络异常时的重新生成
```kotlin
@Test
fun `regenerate should handle network error gracefully`() = runTest {
    // Given: 模拟网络异常
    whenever(sendAdvisorMessageStreamingUseCase.invoke(any(), any(), any(), any()))
        .thenReturn(flowOf(StreamingState.Error(IOException("网络异常"))))
    
    viewModel.setLastUserInput("用户问题")
    
    // When: 重新生成
    viewModel.regenerateLastMessage()
    advanceUntilIdle()
    
    // Then: 显示错误信息
    assertNotNull(viewModel.uiState.value.error)
}
```

#### TC-013: 空会话时的重新生成
```kotlin
@Test
fun `regenerate should handle empty session gracefully`() = runTest {
    // Given: 空会话
    viewModel.setConversations(emptyList())
    viewModel.setLastUserInput("")
    
    // When: 尝试重新生成
    viewModel.regenerateLastMessage()
    advanceUntilIdle()
    
    // Then: 不崩溃，显示适当提示
    // 验证没有调用UseCase
    verify(sendAdvisorMessageStreamingUseCase, never()).invoke(any(), any(), any(), any())
}
```

---

## 5. 测试数据工厂

```kotlin
private fun createConversation(
    id: String,
    messageType: MessageType,
    content: String,
    sendStatus: SendStatus,
    timestamp: Long = System.currentTimeMillis()
) = AiAdvisorConversation(
    id = id,
    contactId = "test-contact",
    sessionId = "test-session",
    messageType = messageType,
    content = content,
    timestamp = timestamp,
    sendStatus = sendStatus
)
```

---

## 6. 测试执行计划

| 阶段 | 测试类型 | 用例数量 | 预计时间 |
|------|----------|----------|----------|
| 1 | 单元测试 | 9 | 30分钟 |
| 2 | 集成测试 | 2 | 20分钟 |
| 3 | 边界测试 | 2 | 10分钟 |
| **总计** | - | **13** | **60分钟** |

---

## 7. 验收标准

- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] 边界情况测试通过
- [ ] 人工验证终止后重新生成功能正常
- [ ] 消息角色显示正确

---

**文档版本**: 1.0
**最后更新**: 2026-01-05
