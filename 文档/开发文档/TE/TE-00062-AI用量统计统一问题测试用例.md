# TE-00062：AI用量统计统一问题测试用例

## 文档信息

| 属性 | 值 |
|------|-----|
| 文档编号 | TE-00062 |
| 关联BUG | BUG-00062 |
| 创建日期 | 2026-01-10 |
| 测试类型 | 单元测试 + 集成测试 |
| 状态 | 待实现 |

---

## 1. 测试范围

### 1.1 测试目标

验证以下功能的用量统计正确性：
- AI总结功能（通过 `generateText` 方法）
- AI军师对话功能（通过 `generateTextStream` 方法）

### 1.2 测试模块

| 模块 | 文件 | 测试内容 |
|------|------|----------|
| Data层 | `AiRepositoryImpl.kt` | generateText 用量统计 |
| Domain层 | `SendAdvisorMessageStreamingUseCase.kt` | 流式对话用量统计 |
| Presentation层 | `UsageStatsScreen.kt` | UI显示验证 |

---

## 2. 单元测试用例

### 2.1 AiRepositoryImpl.generateText 测试

**测试文件**：`data/src/test/kotlin/com/empathy/ai/data/repository/AiRepositoryImplGenerateTextUsageTest.kt`

```kotlin
package com.empathy.ai.data.repository

import com.empathy.ai.data.remote.api.OpenAiApi
import com.empathy.ai.data.remote.model.ChatResponseDto
import com.empathy.ai.data.remote.model.ChoiceDto
import com.empathy.ai.data.remote.model.MessageDto
import com.empathy.ai.domain.model.AiProvider
import com.empathy.ai.domain.model.ApiUsageRecord
import com.empathy.ai.domain.repository.ApiUsageRepository
import io.mockk.*
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue

/**
 * BUG-00062: generateText 用量统计测试
 *
 * 验证 generateText 方法在成功和失败时都正确记录用量
 */
class AiRepositoryImplGenerateTextUsageTest {

    private lateinit var api: OpenAiApi
    private lateinit var apiUsageRepository: ApiUsageRepository
    private lateinit var repository: AiRepositoryImpl

    @Before
    fun setup() {
        api = mockk()
        apiUsageRepository = mockk(relaxed = true)
        repository = AiRepositoryImpl(api, apiUsageRepository, mockk(), mockk())
    }

    // ==================== 成功场景测试 ====================

    @Test
    fun `generateText_成功时应记录用量_isSuccess为true`() = runTest {
        // Given
        val provider = createTestProvider()
        val prompt = "测试提示词"
        val systemInstruction = "系统指令"
        val expectedResponse = "AI响应内容"
        
        coEvery { api.chatCompletion(any(), any(), any()) } returns createMockResponse(expectedResponse)
        
        // When
        val result = repository.generateText(provider, prompt, systemInstruction)
        
        // Then
        assertTrue(result.isSuccess)
        assertEquals(expectedResponse, result.getOrNull())
        
        coVerify { 
            apiUsageRepository.recordUsage(match { record ->
                record.providerId == provider.id &&
                record.providerName == provider.name &&
                record.isSuccess == true &&
                record.promptTokens > 0 &&
                record.completionTokens > 0 &&
                record.errorMessage == null
            })
        }
    }

    @Test
    fun `generateText_成功时Token估算应合理`() = runTest {
        // Given
        val provider = createTestProvider()
        val prompt = "这是一个中文测试提示词，包含一些内容"  // 约20个中文字符
        val systemInstruction = "你是一个AI助手"  // 约8个中文字符
        val response = "这是AI的响应内容"  // 约9个中文字符
        
        coEvery { api.chatCompletion(any(), any(), any()) } returns createMockResponse(response)
        
        // When
        repository.generateText(provider, prompt, systemInstruction)
        
        // Then
        coVerify { 
            apiUsageRepository.recordUsage(match { record ->
                // 中文字符约 1.5 字符/token
                // 输入: (20 + 8) / 1.5 ≈ 18-19 tokens
                // 输出: 9 / 1.5 ≈ 6 tokens
                record.promptTokens in 10..30 &&
                record.completionTokens in 3..15
            })
        }
    }

    @Test
    fun `generateText_成功时应记录请求耗时`() = runTest {
        // Given
        val provider = createTestProvider()
        coEvery { api.chatCompletion(any(), any(), any()) } coAnswers {
            delay(100)  // 模拟100ms延迟
            createMockResponse("响应")
        }
        
        // When
        repository.generateText(provider, "prompt", "system")
        
        // Then
        coVerify { 
            apiUsageRepository.recordUsage(match { record ->
                record.requestTimeMs >= 100
            })
        }
    }

    // ==================== 失败场景测试 ====================

    @Test
    fun `generateText_HTTP错误时应记录失败用量`() = runTest {
        // Given
        val provider = createTestProvider()
        val httpException = retrofit2.HttpException(
            retrofit2.Response.error<Any>(500, okhttp3.ResponseBody.create(null, "Server Error"))
        )
        coEvery { api.chatCompletion(any(), any(), any()) } throws httpException
        
        // When
        val result = repository.generateText(provider, "prompt", "system")
        
        // Then
        assertTrue(result.isFailure)
        
        coVerify { 
            apiUsageRepository.recordUsage(match { record ->
                record.isSuccess == false &&
                record.errorMessage?.contains("HTTP 500") == true &&
                record.completionTokens == 0
            })
        }
    }

    @Test
    fun `generateText_网络异常时应记录失败用量`() = runTest {
        // Given
        val provider = createTestProvider()
        coEvery { api.chatCompletion(any(), any(), any()) } throws java.io.IOException("网络连接失败")
        
        // When
        val result = repository.generateText(provider, "prompt", "system")
        
        // Then
        assertTrue(result.isFailure)
        
        coVerify { 
            apiUsageRepository.recordUsage(match { record ->
                record.isSuccess == false &&
                record.errorMessage == "网络连接失败"
            })
        }
    }

    @Test
    fun `generateText_空响应时应记录失败用量`() = runTest {
        // Given
        val provider = createTestProvider()
        coEvery { api.chatCompletion(any(), any(), any()) } returns ChatResponseDto(
            id = "test",
            choices = emptyList(),  // 空响应
            created = 0,
            model = "test"
        )
        
        // When
        val result = repository.generateText(provider, "prompt", "system")
        
        // Then
        assertTrue(result.isFailure)
        
        coVerify { 
            apiUsageRepository.recordUsage(match { record ->
                record.isSuccess == false &&
                record.errorMessage?.contains("Empty response") == true
            })
        }
    }

    // ==================== 边界条件测试 ====================

    @Test
    fun `generateText_空提示词时应正常记录`() = runTest {
        // Given
        val provider = createTestProvider()
        coEvery { api.chatCompletion(any(), any(), any()) } returns createMockResponse("响应")
        
        // When
        repository.generateText(provider, "", "")
        
        // Then
        coVerify { 
            apiUsageRepository.recordUsage(match { record ->
                record.promptTokens >= 1  // 至少1个token
            })
        }
    }

    @Test
    fun `generateText_超长文本时Token估算应合理`() = runTest {
        // Given
        val provider = createTestProvider()
        val longPrompt = "测试".repeat(1000)  // 2000个中文字符
        coEvery { api.chatCompletion(any(), any(), any()) } returns createMockResponse("响应")
        
        // When
        repository.generateText(provider, longPrompt, "系统指令")
        
        // Then
        coVerify { 
            apiUsageRepository.recordUsage(match { record ->
                // 2000 / 1.5 ≈ 1333 tokens
                record.promptTokens in 1000..2000
            })
        }
    }

    // ==================== 辅助方法 ====================

    private fun createTestProvider() = AiProvider(
        id = "test-provider-id",
        name = "测试服务商",
        baseUrl = "https://api.test.com",
        apiKey = "test-key",
        models = listOf("test-model"),
        isDefault = true
    )

    private fun createMockResponse(content: String) = ChatResponseDto(
        id = "test-response-id",
        choices = listOf(
            ChoiceDto(
                index = 0,
                message = MessageDto(role = "assistant", content = content),
                finishReason = "stop"
            )
        ),
        created = System.currentTimeMillis() / 1000,
        model = "test-model"
    )
}
```

### 2.2 SendAdvisorMessageStreamingUseCase 测试

**测试文件**：`domain/src/test/kotlin/com/empathy/ai/domain/usecase/SendAdvisorMessageStreamingUseCaseUsageTest.kt`

```kotlin
package com.empathy.ai.domain.usecase

import com.empathy.ai.domain.model.*
import com.empathy.ai.domain.repository.*
import com.empathy.ai.domain.util.Logger
import io.mockk.*
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Test
import kotlin.test.assertTrue

/**
 * BUG-00062: SendAdvisorMessageStreamingUseCase 用量统计测试
 *
 * 验证AI军师流式对话在成功和失败时都正确记录用量
 */
class SendAdvisorMessageStreamingUseCaseUsageTest {

    private lateinit var aiAdvisorRepository: AiAdvisorRepository
    private lateinit var aiRepository: AiRepository
    private lateinit var contactRepository: ContactRepository
    private lateinit var aiProviderRepository: AiProviderRepository
    private lateinit var brainTagRepository: BrainTagRepository
    private lateinit var apiUsageRepository: ApiUsageRepository
    private lateinit var logger: Logger
    private lateinit var useCase: SendAdvisorMessageStreamingUseCase

    @Before
    fun setup() {
        aiAdvisorRepository = mockk(relaxed = true)
        aiRepository = mockk()
        contactRepository = mockk()
        aiProviderRepository = mockk()
        brainTagRepository = mockk()
        apiUsageRepository = mockk(relaxed = true)
        logger = mockk(relaxed = true)

        useCase = SendAdvisorMessageStreamingUseCase(
            aiAdvisorRepository,
            aiRepository,
            contactRepository,
            aiProviderRepository,
            brainTagRepository,
            apiUsageRepository,
            logger
        )

        // 默认Mock配置
        coEvery { contactRepository.getProfile(any()) } returns Result.success(createTestContact())
        coEvery { brainTagRepository.getTagsForContact(any()) } returns flowOf(emptyList())
        coEvery { aiAdvisorRepository.getConversationsBySessionWithLimit(any(), any()) } returns Result.success(emptyList())
    }

    // ==================== 成功场景测试 ====================

    @Test
    fun `invoke_流式完成时应记录成功用量`() = runTest {
        // Given
        val provider = createTestProvider()
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(provider)
        coEvery { aiRepository.generateTextStream(any(), any(), any()) } returns flowOf(
            AiStreamChunk.Started,
            AiStreamChunk.TextDelta("你好"),
            AiStreamChunk.TextDelta("，有什么可以帮助你的？"),
            AiStreamChunk.Complete(
                fullText = "你好，有什么可以帮助你的？",
                usage = TokenUsage(promptTokens = 15, completionTokens = 12)
            )
        )

        // When
        useCase("contact-1", "session-1", "你好").toList()

        // Then
        coVerify {
            apiUsageRepository.recordUsage(match { record ->
                record.providerId == provider.id &&
                record.isSuccess == true &&
                record.promptTokens == 15 &&
                record.completionTokens == 12 &&
                record.totalTokens == 27
            })
        }
    }

    @Test
    fun `invoke_流式完成无TokenUsage时应使用估算值`() = runTest {
        // Given
        val provider = createTestProvider()
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(provider)
        coEvery { aiRepository.generateTextStream(any(), any(), any()) } returns flowOf(
            AiStreamChunk.Started,
            AiStreamChunk.TextDelta("响应内容"),
            AiStreamChunk.Complete(fullText = "响应内容", usage = null)  // 无TokenUsage
        )

        // When
        useCase("contact-1", "session-1", "测试消息").toList()

        // Then
        coVerify {
            apiUsageRepository.recordUsage(match { record ->
                record.isSuccess == true &&
                record.promptTokens > 0 &&  // 使用估算值
                record.completionTokens > 0
            })
        }
    }

    @Test
    fun `invoke_包含思考过程时应正确记录用量`() = runTest {
        // Given
        val provider = createTestProvider()
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(provider)
        coEvery { aiRepository.generateTextStream(any(), any(), any()) } returns flowOf(
            AiStreamChunk.Started,
            AiStreamChunk.ThinkingDelta("让我思考一下..."),
            AiStreamChunk.ThinkingComplete("让我思考一下这个问题"),
            AiStreamChunk.TextDelta("这是我的回答"),
            AiStreamChunk.Complete(
                fullText = "这是我的回答",
                usage = TokenUsage(promptTokens = 20, completionTokens = 30)
            )
        )

        // When
        useCase("contact-1", "session-1", "复杂问题").toList()

        // Then
        coVerify {
            apiUsageRepository.recordUsage(match { record ->
                record.isSuccess == true &&
                record.promptTokens == 20 &&
                record.completionTokens == 30
            })
        }
    }

    // ==================== 失败场景测试 ====================

    @Test
    fun `invoke_流式错误时应记录失败用量`() = runTest {
        // Given
        val provider = createTestProvider()
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(provider)
        coEvery { aiRepository.generateTextStream(any(), any(), any()) } returns flowOf(
            AiStreamChunk.Started,
            AiStreamChunk.TextDelta("部分内容"),
            AiStreamChunk.Error(java.io.IOException("网络中断"))
        )

        // When
        useCase("contact-1", "session-1", "你好").toList()

        // Then
        coVerify {
            apiUsageRepository.recordUsage(match { record ->
                record.isSuccess == false &&
                record.errorMessage == "网络中断" &&
                record.completionTokens == 0
            })
        }
    }

    @Test
    fun `invoke_无默认服务商时不应记录用量`() = runTest {
        // Given
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(null)

        // When
        val states = useCase("contact-1", "session-1", "你好").toList()

        // Then
        assertTrue(states.any { it is StreamingState.Error })
        coVerify(exactly = 0) { apiUsageRepository.recordUsage(any()) }
    }

    @Test
    fun `invoke_服务商获取失败时不应记录用量`() = runTest {
        // Given
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.failure(Exception("获取失败"))

        // When
        val states = useCase("contact-1", "session-1", "你好").toList()

        // Then
        assertTrue(states.any { it is StreamingState.Error })
        coVerify(exactly = 0) { apiUsageRepository.recordUsage(any()) }
    }

    // ==================== 重新生成场景测试 ====================

    @Test
    fun `invoke_重新生成时应正确记录用量`() = runTest {
        // Given
        val provider = createTestProvider()
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(provider)
        coEvery { aiRepository.generateTextStream(any(), any(), any()) } returns flowOf(
            AiStreamChunk.Started,
            AiStreamChunk.TextDelta("重新生成的内容"),
            AiStreamChunk.Complete(
                fullText = "重新生成的内容",
                usage = TokenUsage(promptTokens = 10, completionTokens = 8)
            )
        )

        // When - skipUserMessage = true 表示重新生成
        useCase(
            contactId = "contact-1",
            sessionId = "session-1",
            userMessage = "原始问题",
            skipUserMessage = true,
            relatedUserMessageId = "original-msg-id"
        ).toList()

        // Then
        coVerify {
            apiUsageRepository.recordUsage(match { record ->
                record.isSuccess == true
            })
        }
    }

    // ==================== 边界条件测试 ====================

    @Test
    fun `invoke_用量记录失败时不应影响主流程`() = runTest {
        // Given
        val provider = createTestProvider()
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(provider)
        coEvery { aiRepository.generateTextStream(any(), any(), any()) } returns flowOf(
            AiStreamChunk.Started,
            AiStreamChunk.Complete("响应", TokenUsage(10, 10))
        )
        coEvery { apiUsageRepository.recordUsage(any()) } throws Exception("记录失败")

        // When
        val states = useCase("contact-1", "session-1", "你好").toList()

        // Then - 主流程应正常完成
        assertTrue(states.any { it is StreamingState.Completed })
        // 应记录警告日志
        verify { logger.w(any(), match { it.contains("记录") }) }
    }

    // ==================== 辅助方法 ====================

    private fun createTestProvider() = AiProvider(
        id = "test-provider-id",
        name = "测试服务商",
        baseUrl = "https://api.test.com",
        apiKey = "test-key",
        models = listOf("test-model"),
        isDefault = true
    )

    private fun createTestContact() = ContactProfile(
        id = "contact-1",
        name = "测试联系人",
        targetGoal = "测试目标",
        relationshipScore = 50
    )
}
```

---

## 3. 集成测试用例

### 3.1 端到端测试

**测试文件**：`app/src/androidTest/kotlin/com/empathy/ai/integration/BUG00062UsageStatsIntegrationTest.kt`

```kotlin
package com.empathy.ai.integration

import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import com.empathy.ai.presentation.ui.MainActivity
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test

/**
 * BUG-00062: AI用量统计统一问题集成测试
 *
 * 验证AI军师和AI总结的用量统计在UI上正确显示
 */
@HiltAndroidTest
class BUG00062UsageStatsIntegrationTest {

    @get:Rule(order = 0)
    val hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<MainActivity>()

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun AI军师对话后用量统计应显示记录() {
        // 1. 导航到AI军师
        composeTestRule.onNodeWithText("AI军师").performClick()
        composeTestRule.waitForIdle()

        // 2. 发送消息
        composeTestRule.onNodeWithTag("advisor_input").performTextInput("你好")
        composeTestRule.onNodeWithTag("advisor_send_button").performClick()

        // 3. 等待响应完成
        composeTestRule.waitUntil(timeoutMillis = 30000) {
            composeTestRule.onAllNodesWithTag("ai_message").fetchSemanticsNodes().isNotEmpty()
        }

        // 4. 导航到用量统计
        composeTestRule.onNodeWithContentDescription("返回").performClick()
        composeTestRule.onNodeWithText("设置").performClick()
        composeTestRule.onNodeWithText("AI配置").performClick()
        composeTestRule.onNodeWithText("用量统计").performClick()

        // 5. 验证显示了记录
        composeTestRule.onNodeWithText("总请求数").assertExists()
        composeTestRule.onNode(hasText("1") and hasTestTag("total_requests")).assertExists()
    }

    @Test
    fun 用量统计页面应正确显示服务商分类() {
        // 假设已有用量记录
        
        // 1. 导航到用量统计
        composeTestRule.onNodeWithText("设置").performClick()
        composeTestRule.onNodeWithText("AI配置").performClick()
        composeTestRule.onNodeWithText("用量统计").performClick()

        // 2. 验证服务商分类显示
        composeTestRule.onNodeWithText("按服务商").performClick()
        composeTestRule.waitForIdle()
        
        // 应显示服务商列表
        composeTestRule.onAllNodesWithTag("provider_usage_item").assertCountEquals(1)
    }

    @Test
    fun 用量统计页面应正确显示模型分类() {
        // 1. 导航到用量统计
        composeTestRule.onNodeWithText("设置").performClick()
        composeTestRule.onNodeWithText("AI配置").performClick()
        composeTestRule.onNodeWithText("用量统计").performClick()

        // 2. 验证模型分类显示
        composeTestRule.onNodeWithText("按模型").performClick()
        composeTestRule.waitForIdle()
        
        // 应显示模型列表
        composeTestRule.onAllNodesWithTag("model_usage_item").assertCountEquals(1)
    }
}
```

---

## 4. 测试数据准备

### 4.1 Mock数据

```kotlin
object TestDataFactory {
    
    fun createTestProvider(
        id: String = "test-provider",
        name: String = "测试服务商"
    ) = AiProvider(
        id = id,
        name = name,
        baseUrl = "https://api.test.com",
        apiKey = "test-key",
        models = listOf("test-model"),
        isDefault = true,
        temperature = 0.7f,
        maxTokens = 4096
    )
    
    fun createTestUsageRecord(
        isSuccess: Boolean = true,
        promptTokens: Int = 100,
        completionTokens: Int = 50
    ) = ApiUsageRecord(
        id = UUID.randomUUID().toString(),
        providerId = "test-provider",
        providerName = "测试服务商",
        modelId = "test-model",
        modelName = "test-model",
        promptTokens = promptTokens,
        completionTokens = completionTokens,
        totalTokens = promptTokens + completionTokens,
        requestTimeMs = 1000,
        isSuccess = isSuccess,
        errorMessage = if (isSuccess) null else "测试错误",
        createdAt = System.currentTimeMillis()
    )
}
```

---

## 5. 测试执行命令

```bash
# 运行所有BUG-00062相关测试
./gradlew :data:test --tests "*GenerateTextUsage*"
./gradlew :domain:test --tests "*StreamingUseCaseUsage*"
./gradlew :app:connectedAndroidTest --tests "*BUG00062*"

# 运行单个测试类
./gradlew :data:test --tests "com.empathy.ai.data.repository.AiRepositoryImplGenerateTextUsageTest"
./gradlew :domain:test --tests "com.empathy.ai.domain.usecase.SendAdvisorMessageStreamingUseCaseUsageTest"

# 生成测试报告
./gradlew :data:test --tests "*GenerateTextUsage*" --info
```

---

## 6. 验收检查清单

### 6.1 单元测试验收

- [ ] `AiRepositoryImplGenerateTextUsageTest` 全部通过
- [ ] `SendAdvisorMessageStreamingUseCaseUsageTest` 全部通过
- [ ] 测试覆盖率 ≥ 80%

### 6.2 集成测试验收

- [ ] `BUG00062UsageStatsIntegrationTest` 全部通过
- [ ] AI军师对话后用量统计正确显示
- [ ] AI总结执行后用量统计正确显示

### 6.3 手动测试验收

- [ ] 在真机上验证AI军师对话用量统计
- [ ] 在真机上验证AI总结用量统计
- [ ] 验证失败请求也被正确记录
- [ ] 验证Token计数基本准确

---

**文档版本**: 1.0
**最后更新**: 2026-01-10
