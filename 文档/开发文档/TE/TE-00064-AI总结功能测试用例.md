# TE-00064：AI总结功能测试用例

## 文档信息

| 项目 | 内容 |
|------|------|
| **文档编号** | TE-00064 |
| **关联BUG** | BUG-00064 |
| **测试类型** | 单元测试 + 集成测试 |
| **编写者** | Kiro |
| **编写时间** | 2026-01-10 |
| **状态** | 已完成 |

---

## 一、测试范围

### 1.1 测试目标

验证 AI 总结功能的完整性和正确性，包括：
- UI 层事件触发和状态管理
- ViewModel 层业务逻辑
- UseCase 层核心功能
- 错误处理和边界情况

### 1.2 测试文件清单

| 测试文件 | 测试目标 | 优先级 |
|----------|----------|--------|
| `ManualSummaryViewModelTest.kt` | ViewModel 事件处理和状态管理 | P0 |
| `ManualSummaryUseCaseTest.kt` | UseCase 业务逻辑 | P0 |
| `BUG00064ManualSummaryTest.kt` | BUG 回归测试 | P0 |

---

## 二、单元测试用例

### 2.1 ManualSummaryViewModelTest.kt

**文件路径**：`presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/ManualSummaryViewModelTest.kt`

```kotlin
package com.empathy.ai.presentation.viewmodel

import com.empathy.ai.domain.model.AiProvider
import com.empathy.ai.domain.model.ConflictResolution
import com.empathy.ai.domain.model.ConflictResult
import com.empathy.ai.domain.model.DateRange
import com.empathy.ai.domain.model.SummaryError
import com.empathy.ai.domain.repository.AiProviderRepository
import com.empathy.ai.domain.usecase.ManualSummaryUseCase
import com.empathy.ai.domain.usecase.SummaryException
import com.empathy.ai.domain.util.DateRangeValidator
import com.empathy.ai.domain.util.Logger
import com.empathy.ai.domain.util.SummaryConflictChecker
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

/**
 * ManualSummaryViewModel 单元测试
 *
 * 测试范围：
 * - 事件处理
 * - 状态管理
 * - AI服务商检查
 * - 错误处理
 */
@OptIn(ExperimentalCoroutinesApi::class)
class ManualSummaryViewModelTest {

    private val testDispatcher = StandardTestDispatcher()
    
    private lateinit var viewModel: ManualSummaryViewModel
    private lateinit var manualSummaryUseCase: ManualSummaryUseCase
    private lateinit var conflictChecker: SummaryConflictChecker
    private lateinit var dateRangeValidator: DateRangeValidator
    private lateinit var aiProviderRepository: AiProviderRepository
    private lateinit var logger: Logger

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
        
        manualSummaryUseCase = mockk()
        conflictChecker = mockk()
        dateRangeValidator = mockk()
        aiProviderRepository = mockk()
        logger = mockk(relaxed = true)
        
        viewModel = ManualSummaryViewModel(
            manualSummaryUseCase = manualSummaryUseCase,
            conflictChecker = conflictChecker,
            dateRangeValidator = dateRangeValidator,
            aiProviderRepository = aiProviderRepository,
            logger = logger
        )
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }

    // ==================== ShowDatePicker 测试 ====================

    @Test
    fun `ShowDatePicker事件_有AI服务商配置_应该显示日期选择器`() = runTest {
        // Given
        val contactId = "contact_123"
        val mockProvider = mockk<AiProvider>()
        every { mockProvider.name } returns "TestProvider"
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(mockProvider)
        
        // When
        viewModel.onEvent(ManualSummaryUiEvent.ShowDatePicker(contactId))
        advanceUntilIdle()
        
        // Then
        val state = viewModel.uiState.value
        assertTrue("showDatePicker应该为true", state.showDatePicker)
        assertEquals("contactId应该正确设置", contactId, state.contactId)
        assertNotNull("selectedDateRange应该有默认值", state.selectedDateRange)
        assertEquals("selectedQuickOption应该为LAST_7_DAYS", QuickDateOption.LAST_7_DAYS, state.selectedQuickOption)
    }

    @Test
    fun `ShowDatePicker事件_无AI服务商配置_应该显示警告`() = runTest {
        // Given
        val contactId = "contact_123"
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(null)
        
        // When
        viewModel.onEvent(ManualSummaryUiEvent.ShowDatePicker(contactId))
        advanceUntilIdle()
        
        // Then
        val state = viewModel.uiState.value
        assertTrue("showNoProviderWarning应该为true", state.showNoProviderWarning)
        assertFalse("showDatePicker应该为false", state.showDatePicker)
        assertNotNull("noProviderWarningMessage应该有值", state.noProviderWarningMessage)
    }

    // ==================== SelectQuickOption 测试 ====================

    @Test
    fun `SelectQuickOption事件_选择最近7天_应该更新日期范围`() = runTest {
        // Given
        setupShowDatePicker()
        
        // When
        viewModel.onEvent(ManualSummaryUiEvent.SelectQuickOption(QuickDateOption.LAST_7_DAYS))
        advanceUntilIdle()
        
        // Then
        val state = viewModel.uiState.value
        assertEquals(QuickDateOption.LAST_7_DAYS, state.selectedQuickOption)
        assertNotNull(state.selectedDateRange)
        assertEquals(7, state.selectedDateRange?.getDayCount())
    }

    @Test
    fun `SelectQuickOption事件_选择本月_应该更新日期范围`() = runTest {
        // Given
        setupShowDatePicker()
        
        // When
        viewModel.onEvent(ManualSummaryUiEvent.SelectQuickOption(QuickDateOption.THIS_MONTH))
        advanceUntilIdle()
        
        // Then
        val state = viewModel.uiState.value
        assertEquals(QuickDateOption.THIS_MONTH, state.selectedQuickOption)
        assertNotNull(state.selectedDateRange)
    }

    // ==================== ConfirmDateRange 测试 ====================

    @Test
    fun `ConfirmDateRange事件_验证通过无冲突_应该开始总结`() = runTest {
        // Given
        setupShowDatePicker()
        val dateRange = DateRange.lastSevenDays()
        
        coEvery { 
            dateRangeValidator.validate(any(), any()) 
        } returns Result.success(DateRangeValidator.ValidationResult.Valid)
        
        coEvery { 
            conflictChecker.checkConflict(any(), any()) 
        } returns Result.success(ConflictResult.NoConflict)
        
        coEvery { 
            manualSummaryUseCase(any(), any(), any(), any()) 
        } returns Result.success(mockk(relaxed = true))
        
        // When
        viewModel.onEvent(ManualSummaryUiEvent.ConfirmDateRange)
        advanceUntilIdle()
        
        // Then
        coVerify { manualSummaryUseCase(any(), any(), any(), any()) }
    }

    @Test
    fun `ConfirmDateRange事件_验证失败_应该显示错误`() = runTest {
        // Given
        setupShowDatePicker()
        
        coEvery { 
            dateRangeValidator.validate(any(), any()) 
        } returns Result.success(DateRangeValidator.ValidationResult.Invalid("日期范围无效"))
        
        // When
        viewModel.onEvent(ManualSummaryUiEvent.ConfirmDateRange)
        advanceUntilIdle()
        
        // Then
        val state = viewModel.uiState.value
        assertNotNull("validationError应该有值", state.validationError)
        assertEquals("日期范围无效", state.validationError)
    }

    @Test
    fun `ConfirmDateRange事件_有冲突_应该显示冲突对话框`() = runTest {
        // Given
        setupShowDatePicker()
        
        coEvery { 
            dateRangeValidator.validate(any(), any()) 
        } returns Result.success(DateRangeValidator.ValidationResult.Valid)
        
        val conflictResult = ConflictResult.HasConflict(
            existingSummaries = listOf(mockk(relaxed = true)),
            conflictDates = listOf("2026-01-01")
        )
        coEvery { 
            conflictChecker.checkConflict(any(), any()) 
        } returns Result.success(conflictResult)
        
        // When
        viewModel.onEvent(ManualSummaryUiEvent.ConfirmDateRange)
        advanceUntilIdle()
        
        // Then
        val state = viewModel.uiState.value
        assertTrue("showConflictDialog应该为true", state.showConflictDialog)
        assertNotNull("conflictResult应该有值", state.conflictResult)
    }

    // ==================== 错误处理测试 ====================

    @Test
    fun `总结失败_无对话记录_应该显示错误对话框`() = runTest {
        // Given
        setupShowDatePicker()
        setupValidationAndConflictCheck()
        
        coEvery { 
            manualSummaryUseCase(any(), any(), any(), any()) 
        } returns Result.failure(SummaryException(SummaryError.NoConversations))
        
        // When
        viewModel.onEvent(ManualSummaryUiEvent.ConfirmDateRange)
        advanceUntilIdle()
        
        // Then
        val state = viewModel.uiState.value
        assertTrue("showErrorDialog应该为true", state.showErrorDialog)
        assertFalse("showProgressDialog应该为false", state.showProgressDialog)
    }

    @Test
    fun `总结失败_API错误_应该显示错误对话框`() = runTest {
        // Given
        setupShowDatePicker()
        setupValidationAndConflictCheck()
        
        coEvery { 
            manualSummaryUseCase(any(), any(), any(), any()) 
        } returns Result.failure(SummaryException(SummaryError.ApiError))
        
        // When
        viewModel.onEvent(ManualSummaryUiEvent.ConfirmDateRange)
        advanceUntilIdle()
        
        // Then
        val state = viewModel.uiState.value
        assertTrue("showErrorDialog应该为true", state.showErrorDialog)
    }

    // ==================== 辅助方法 ====================

    private suspend fun setupShowDatePicker() {
        val mockProvider = mockk<AiProvider>()
        every { mockProvider.name } returns "TestProvider"
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(mockProvider)
        
        viewModel.onEvent(ManualSummaryUiEvent.ShowDatePicker("contact_123"))
        advanceUntilIdle()
    }

    private fun setupValidationAndConflictCheck() {
        coEvery { 
            dateRangeValidator.validate(any(), any()) 
        } returns Result.success(DateRangeValidator.ValidationResult.Valid)
        
        coEvery { 
            conflictChecker.checkConflict(any(), any()) 
        } returns Result.success(ConflictResult.NoConflict)
    }
}
```

### 2.2 BUG00064ManualSummaryTest.kt（回归测试）

**文件路径**：`presentation/src/test/kotlin/com/empathy/ai/presentation/viewmodel/BUG00064ManualSummaryTest.kt`

```kotlin
package com.empathy.ai.presentation.viewmodel

import com.empathy.ai.domain.model.AiProvider
import com.empathy.ai.domain.model.ConflictResult
import com.empathy.ai.domain.model.DailySummary
import com.empathy.ai.domain.model.DateRange
import com.empathy.ai.domain.model.RelationshipTrend
import com.empathy.ai.domain.repository.AiProviderRepository
import com.empathy.ai.domain.usecase.ManualSummaryUseCase
import com.empathy.ai.domain.util.DateRangeValidator
import com.empathy.ai.domain.util.Logger
import com.empathy.ai.domain.util.SummaryConflictChecker
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

/**
 * BUG-00064 回归测试
 *
 * 验证 AI 总结功能的核心流程是否正常工作
 */
@OptIn(ExperimentalCoroutinesApi::class)
class BUG00064ManualSummaryTest {

    private val testDispatcher = StandardTestDispatcher()
    
    private lateinit var viewModel: ManualSummaryViewModel
    private lateinit var manualSummaryUseCase: ManualSummaryUseCase
    private lateinit var conflictChecker: SummaryConflictChecker
    private lateinit var dateRangeValidator: DateRangeValidator
    private lateinit var aiProviderRepository: AiProviderRepository
    private lateinit var logger: Logger

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
        
        manualSummaryUseCase = mockk()
        conflictChecker = mockk()
        dateRangeValidator = mockk()
        aiProviderRepository = mockk()
        logger = mockk(relaxed = true)
        
        viewModel = ManualSummaryViewModel(
            manualSummaryUseCase = manualSummaryUseCase,
            conflictChecker = conflictChecker,
            dateRangeValidator = dateRangeValidator,
            aiProviderRepository = aiProviderRepository,
            logger = logger
        )
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }

    /**
     * BUG-00064 核心场景：点击FAB按钮后应该显示日期选择器
     */
    @Test
    fun `BUG00064_点击FAB按钮_配置了AI服务商_应该显示日期选择器`() = runTest {
        // Given: 用户已配置AI服务商
        val mockProvider = mockk<AiProvider>()
        every { mockProvider.name } returns "DeepSeek"
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(mockProvider)
        
        // When: 用户点击FAB按钮
        viewModel.onEvent(ManualSummaryUiEvent.ShowDatePicker("contact_123"))
        advanceUntilIdle()
        
        // Then: 日期选择器应该显示
        val state = viewModel.uiState.value
        assertTrue("日期选择器应该显示", state.showDatePicker)
        assertEquals("联系人ID应该正确", "contact_123", state.contactId)
        assertNotNull("应该有默认日期范围", state.selectedDateRange)
    }

    /**
     * BUG-00064 核心场景：未配置AI服务商时应该显示警告
     */
    @Test
    fun `BUG00064_点击FAB按钮_未配置AI服务商_应该显示警告`() = runTest {
        // Given: 用户未配置AI服务商
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(null)
        
        // When: 用户点击FAB按钮
        viewModel.onEvent(ManualSummaryUiEvent.ShowDatePicker("contact_123"))
        advanceUntilIdle()
        
        // Then: 应该显示警告，而不是日期选择器
        val state = viewModel.uiState.value
        assertTrue("应该显示无服务商警告", state.showNoProviderWarning)
        assertFalse("日期选择器不应该显示", state.showDatePicker)
    }

    /**
     * BUG-00064 核心场景：完整的总结流程
     */
    @Test
    fun `BUG00064_完整总结流程_应该成功生成总结`() = runTest {
        // Given: 配置所有必要的mock
        val mockProvider = mockk<AiProvider>()
        every { mockProvider.name } returns "DeepSeek"
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(mockProvider)
        
        coEvery { 
            dateRangeValidator.validate(any(), any()) 
        } returns Result.success(DateRangeValidator.ValidationResult.Valid)
        
        coEvery { 
            conflictChecker.checkConflict(any(), any()) 
        } returns Result.success(ConflictResult.NoConflict)
        
        val mockSummary = DailySummary(
            id = 1,
            contactId = "contact_123",
            summaryDate = "2026-01-10",
            content = "测试总结内容",
            keyEvents = emptyList(),
            newFacts = emptyList(),
            updatedTags = emptyList(),
            relationshipScoreChange = 5,
            relationshipTrend = RelationshipTrend.IMPROVING
        )
        val mockResult = ManualSummaryUseCase.SummaryResult(
            summary = mockSummary,
            conversationCount = 10,
            keyEventCount = 2,
            factCount = 3,
            relationshipChange = 5
        )
        coEvery { 
            manualSummaryUseCase(any(), any(), any(), any()) 
        } returns Result.success(mockResult)
        
        // When: 执行完整流程
        // Step 1: 点击FAB
        viewModel.onEvent(ManualSummaryUiEvent.ShowDatePicker("contact_123"))
        advanceUntilIdle()
        
        // Step 2: 确认日期范围
        viewModel.onEvent(ManualSummaryUiEvent.ConfirmDateRange)
        advanceUntilIdle()
        
        // Then: 应该成功显示结果
        val state = viewModel.uiState.value
        assertTrue("应该显示结果对话框", state.showResultDialog)
        assertNotNull("应该有总结结果", state.summaryResult)
        assertEquals("对话数量应该正确", 10, state.summaryResult?.conversationCount)
        
        // 验证UseCase被调用
        coVerify { manualSummaryUseCase(any(), any(), any(), any()) }
    }

    /**
     * BUG-00064 核心场景：日志输出验证
     */
    @Test
    fun `BUG00064_关键操作_应该输出日志`() = runTest {
        // Given
        val mockProvider = mockk<AiProvider>()
        every { mockProvider.name } returns "DeepSeek"
        coEvery { aiProviderRepository.getDefaultProvider() } returns Result.success(mockProvider)
        
        // When
        viewModel.onEvent(ManualSummaryUiEvent.ShowDatePicker("contact_123"))
        advanceUntilIdle()
        
        // Then: 验证日志被调用
        coVerify { logger.d(any(), match { it.contains("showDatePicker") }) }
    }
}
```

---

## 三、测试执行命令

```bash
# 运行所有 ManualSummary 相关测试
./gradlew :presentation:test --tests "*ManualSummary*"

# 运行 BUG-00064 回归测试
./gradlew :presentation:test --tests "*BUG00064*"

# 运行单个测试类
./gradlew :presentation:test --tests "com.empathy.ai.presentation.viewmodel.ManualSummaryViewModelTest"
./gradlew :presentation:test --tests "com.empathy.ai.presentation.viewmodel.BUG00064ManualSummaryTest"
```

---

## 四、测试覆盖率要求

| 组件 | 最低覆盖率 | 说明 |
|------|------------|------|
| ManualSummaryViewModel | 80% | 核心业务逻辑 |
| ManualSummaryUseCase | 80% | 核心业务逻辑 |
| ManualSummaryUiState | 100% | 数据类 |
| ManualSummaryUiEvent | 100% | 密封类 |

---

## 五、变更日志

| 日期 | 版本 | 变更内容 | 作者 |
|------|------|----------|------|
| 2026-01-10 | v1.0 | 初始版本 | Kiro |
